// FamobiAPI.js
var FamobiApi = pc.createScript('famobiApi');

pc.extend(FamobiApi.prototype, {

    initialize: function () {
        window.famobi = window.famobi || {};
        window.famobi.localStorage = window.famobi.localStorage || window.localStorage;
        window.famobi.sessionStorage = window.famobi.sessionStorage || window.sessionStorage;

        },

    /**
     * After the game is fully loaded and has landed on the title screen or any other potential target screen, the game must indicate that it is ready:
     */
    gameReady: function () {
        try {
            window.famobi.gameReady();
        } catch (e) {
            console.warn(e);
        }
    },
    /**
     * Returns a relative path to the final branding button. For an absolute path use the parameter "true".
     * The size of the image ALWAYS has to be 600 x 253px. Therefore, you have to scale it using your engine/ framework only.
     * Please note: In some cases, the button is transparent or invisible; don't combine it with any GUI elements!
     *
     * @returns {string} Path of the image.
     */
    getBrandingButtonImage: function () {
        return window.famobi.getBrandingButtonImage();
    },

    /**
     * Opens the branding placeholder URL.
     *
     * Important: It does NOT return a URL, so don't use it with window.open or location.href!
     */
    moreGamesLink: function () {
        window.famobi.moreGamesLink();
    },

    /**
     * Important: The game MUST NOT contain rewarded ad features!
     *
     * Regardless of the use of Famobi Analytics trackEvent calls, make sure to use this call
     * at typical breaks (e.g.: Pause, Retry, Continue, Menu...)
     * Important: Ads will only be shown in a given interval controlled by our API (usually every 60 to 90 seconds).
     *
     * @param {Function} callback - Callback called after watching an ad.
     * @param {*} context - Context of the callback.
     */
    showInterstitialAd: function (eventId, callback) {
        return window.famobi.showInterstitialAd(eventId, callback);
    },

    showAd: function () {
        try {
            return window.famobi.showAd();
        } catch (e) {

        }
    },

    /**
     * 
     */
    hasRewardedAd: function () {
        return window.famobi.hasRewardedAd();
    },

    rewardedAd: function (callback, context) {
        window.famobi.rewardedAd(callback.bind(context));
    },

    /**
     * Function that pauses/mutes the game
     *
     * @param {Function} onPauseFunction - Function that is executed before an ad.
     */
    setOnPauseRequested: function (onPauseFunction, context) {
        window.famobi_onPauseRequested = onPauseFunction.bind(context || this);
    },

    /**
     * Function that unpauses/unmutes the game
     *
     * @param {Function} onResumeFunction - Function that is executed after an ad.
     */
    setOnResumeRequested: function (onResumeFunction, context) {
        window.famobi_onResumeRequested = onResumeFunction.bind(context || this);
    },
    // endregion

    // region ------------------ LOCALISATION ------------------
    /**
     * Returns a corresponding value string associated with the famobi.json.
     * If there's no key either in the current language or in the "default" section, null is returned.
     *
     * @param {string} key - Unique key of the text.
     * @returns {string|null} Value of the key.
     */
    get: function (key) {
        return window.famobi.__(key) || key;
    },

    /**
     * Returns the current language code (two letters, lower-case).
     * Important: This function should be used as an exception only.
     * In 99% of the cases window.famobi.__(key) is sufficient.
     * The trick is just to limit your game to one language and use its texts as translation keys.
     *
     * @returns {string} Current language code (two letters, lower-case).
     */
    getCurrentLanguage: function () {
        return window.famobi.getCurrentLanguage();
    },

    /**
     * Set local storage item.
     *
     * @param {string} key - Key of the value.
     * @param {*} value - Value that needs to be saved.
     */
    setLocalStorageItem: function (key, value) {
        window.famobi.localStorage.setItem(key, value);
    },

    /**
     * Get local storage item.
     *
     * @param {string} key - Key of the value.
     */
    getLocalStorageItem: function (key) {
        return window.famobi.localStorage.getItem(key);
    },

    /**
     * Remove the locale storage item.
     *
     * @param {string} key - Key of the value.
     */
    removeLocalStorageItem: function (key) {
        window.famobi.localStorage.removeItem(key);
    },

    /**
     * Remove the whole locale storage.
     */
    clearLocalStorage: function () {
        window.famobi.localStorage.clear();
    },

    /**
     * Set session storage item.
     *
     * @param {string} key - Key of the value.
     * @param {*} value - Value that needs to be saved.
     */
    setSessionStorageItem: function (key, value) {
        window.famobi.sessionStorage.setItem(key, value);
    },

    /**
     * Get session storage item.
     *
     * @param {string} key - Key of the value.
     */
    getSessionStorageItem: function (key) {
        window.famobi.sessionStorage.getItem(key);
    },

    /**
     * Remove the session storage item.
     *
     * @param {string} key - Key of the value.
     */
    removeSessionStorageItem: function (key) {
        window.famobi.sessionStorage.removeItem(key);
    },

    /**
     * Remove the whole session storage.
     */
    clearSessionStorage: function () {
        window.famobi.sessionStorage.clear();
    },

    /**
     * Get the current orientation.
     *
     * @returns {"landscape"|"portrait"|""} Orientation of the device.
     */
    getOrientation: function () {
        return window.famobi.getOrientation();
    },

    /**
     * Set the callback when orientation is changed.
     *
     * @param {Function} callback - Callback called when the orientation is changed.
     * @param {*} context - Context of the callback.
     */
    setOnOrientationChange: function (callback, context) {
        window.famobi.onOrientationChange(callback.bind(context));
    },

    hasFeature: function (feature) {
        return window.famobi.hasFeature(feature);
    },

    onRequest: function (event, callback) {
        window.famobi.onRequest(event, callback);
    },

    getFeatureProperties: function (feature) {
        return window.famobi.getFeatureProperties(feature);
    },

    getVolume: function () {
        return window.famobi.getVolume();
    },

    playerReady: function () {
        window.famobi.playerReady()
    },

    getOffsets() {
        return window.famobi.getOffsets();
    },

    setOffsetCallback(callback) {
        if (typeof window.famobi.onOffsetChange === 'function') {
            window.famobi.onOffsetChange(callback);
        }
    },
});


/**
 * DEPRECATED FUNCTIONS
 */
pc.extend(FamobiApi.prototype, {

    getMoreGamesButtonImage: function () {
        console.warn("GetMoreGamesButtonImage is deprecated, use getBrandingButtonImage instead");

        this.getBrandingButtonImage();
    },

    moreGamesLink: function () {
        console.warn("moreGamesLink is deprecated, use openBrandingLink instead");

        this.openBrandingLink();
    },

    submitHighscore: function () {
        console.warn("submitHighscore is deprecated, use window.famobi_analytics.trackEvent instead");
    },

    levelUp: function () {
        console.warn("levelUp is deprecated, use window.famobi_analytics.trackEvent instead");
    },

    gameOver: function () {
        console.warn("gameOver is deprecated, use window.famobi_analytics.trackEvent instead");
    },

    // showAd: function() {
    //     console.warn("showAd is deprecated, use showInterstitalAd instead");
    // },

    sendGAEvent(type, data) {
        // window.famobi_analytics.trackEvent("EVENT_CUSTOM", { eventName: "GA:$eventType"[, ...] })

        switch (type) {
                case Wrapper.GA_EVENT_TYPE.BUSINESS:
                    break

                case Wrapper.GA_EVENT_TYPE.PROGRESSION:
                    window.famobi_analytics.trackEvent("EVENT_CUSTOM", { eventName: "GA:Progression", ...data });
                    break;

                case Wrapper.GA_EVENT_TYPE.DESIGN:
                    window.famobi_analytics.trackEvent("EVENT_CUSTOM", { eventName: "GA:Design", ...data });
                    break;

                case Wrapper.GA_EVENT_TYPE.RESOURCE:
                    window.famobi_analytics.trackEvent("EVENT_CUSTOM", {
                        eventName: "GA:Resource",
                        flowType: data.flowType,
                        itemType: data.itemType,
                        itemId: data.itemId,
                        amount: data.amount,
                        resourceCurrency: data.resourceCurrency
                    });
                    break;

                default:
                    console.warn(`${type} is not supported`);
                    break;
            }

            }

});


// FakeFamobiAPI.js
// AudioManager.js
var AudioManager = pc.createScript('audioManager');

/**
  * AudioManager
  * Plays audio/music samples. Treats every sample as a separate audio slot
  * Usage:
  * Make use of the following two event to play sounds: Audio:sfx & Audio:bgm
  */
// AudioManager.attributes.add('bgm',              { type: 'asset', array: true });
// AudioManager.attributes.add('sfx',              { type: 'asset', array: true });
AudioManager.attributes.add('bgmVolume', { type: 'number', default: 0.25, min: 0, max: 1 });
AudioManager.attributes.add('maxBGMVolume', { type: 'number', default: 1, min: 0, max: 1 });
AudioManager.attributes.add('sfxVolume', { type: 'number', default: 1, min: 0, max: 1 });
AudioManager.attributes.add('maxSFXVolume', { type: 'number', default: 1, min: 0, max: 1 });
AudioManager.attributes.add('autoPlayBGM', { type: 'string', });
AudioManager.attributes.add('bgmSettingKey', { type: 'string', default: 'music', description: 'This key must be the same as in the default_save_data.json' });
AudioManager.attributes.add('sfxSettingKey', { type: 'string', default: '', description: 'Leave this empty if there is only one setting for all sounds' });
AudioManager.attributes.add('bgmNoLoop', { type: 'string', array: true });
AudioManager.attributes.add('userVolume', { type: 'number', default: 1, });
AudioManager.attributes.add('userBGM', { type: 'number', default: 1, });
AudioManager.attributes.add('userSFX', { type: 'number', default: 1, });

pc.extend(AudioManager.prototype, {

    initialize: function () {
        if (Singleton.instance.canCreateInstance(this)) {
            AudioManager.instance = this;
        }

        this.sfx = this.app.assets.findByTag('sfx');
        this.bgm = this.app.assets.findByTag('bgm');

        this.soundPlayer = this.entity.addComponent("sound");
        this.soundPlayer.positional = false;

        this.activeMusicSlot = null;
        this.activeMusicName = null;

        this.natureSoundSlot = null;
        this.natureSoundName = null;

        this.useBGM = true;
        this.useSFX = true;

        this._bgmSlots = {};
        this._sfxSlots = {};

        this._bgmVolume = this.bgmVolume;
        this._sfxVolume = this.sfxVolume;

        this.externalMute = Wrapper.instance.hasFeature('external_mute');

        this.app.on('Audio:sfx', this._playSFX, this);
        this.app.on('Audio:bgm', this._playBGM, this);

        this.on('attr:bgmVolume', this._setBGMVolume, this);
        this.on('attr:sfxVolume', this._setSFXVolume, this);
        this.on('attr:maxBGMVolume', function () { this._setBGMVolume(this.bgmVolume); }, this);
        this.on('attr:maxSFXVolume', function () { this._setSFXVolume(this.sfxVolume); }, this);
        this.on('attr:userVolume', this._setSFXVolume, this);
        this.on('attr:userVolume', this._setBGMVolume, this);
        this.on('attr:userBGM', this._setBGMVolume, this);
        this.on('attr:userSFX', this._setSFXVolume, this);
        /*** 
                AudioContext OnResume handler (Needed because of browser audio protection)
        ***/
        if (this.app.context._soundManager.context && this.app.context._soundManager.context.state === 'suspended') {
            this.app.on('InputManager:input', this._onResumeContext, this);
        }

        this.app.on('AudioManager:stopBgm', this._stopMusic, this);
    },

    postInitialize: function () {
        this.app.on('PauseManager:valueChanged', this.onPauseManagerValueChanged, this);

        Wrapper.instance.onRequest("enableAudio", () => {
            this.userSFX = 1;
        });

        Wrapper.instance.onRequest("disableAudio", () => {
            this.userSFX = 0;
        });

        Wrapper.instance.onRequest("enableMusic", () => {
            this.userBGM = 1;
        });

        Wrapper.instance.onRequest("disableMusic", () => {
            this.userBGM = 0;
        });

        Wrapper.instance.onRequest("changeVolume", (vol) => {
            this.userVolume = vol;
        });

        this.userVolume = Wrapper.instance.getVolume();

        this.setBGMSetting(StorageManager.instance.get(this.bgmSettingKey), true);
        if (this.sfxSettingKey) {
            this.setSFXSetting(StorageManager.instance.get(this.sfxSettingKey), true);
        }

        this._loadSounds();

        this.app.on("StorageManager:changedStorage", this._onStorageChange, this);
    },

    _onStorageChange: function () {
        this.setBGMSetting(StorageManager.instance.get(this.bgmSettingKey), true);
        if (this.sfxSettingKey) {
            this.setSFXSetting(StorageManager.instance.get(this.sfxSettingKey), true);
        }
    },
    // ------------------------------------------------
    // PRIVATE METHODS
    // ------------------------------------------------

    _loadSounds: function () {
        var assetsToLoad = [];

        for (var i = 0; i < this.bgm.length; i += 1) {
            var bgmAsset = this.bgm[i];

            if (!(bgmAsset instanceof pc.Asset)) {
                console.warn("BGM with index " + i + " is not an asset!");
                continue;
            }
            // Define the slots to zero, which is the loading variable.
            this._bgmSlots[bgmAsset.name] = 0;

            // Download if the resource is undefined
            if (!bgmAsset.resource) {
                // Autoplay it
                if (bgmAsset.name === this.autoPlayBGM) {
                    this.activeMusicName = bgmAsset.name;

                    if (!bgmAsset.tags.has('lazyload')) {
                        continue;
                    }

                    bgmAsset.ready(function (sound) {
                        this._onBGMLoadComplete(sound, true);
                    }, this);

                    assetsToLoad.push(bgmAsset);
                } else {
                    if (!bgmAsset.tags.has('lazyload')) {
                        continue;
                    }

                    bgmAsset.ready(function (sound) {
                        this._onBGMLoadComplete(sound, false);
                    }, this);

                    assetsToLoad.push(bgmAsset);
                }
            } else {
                var slot = this._createBGMSlot(bgmAsset);

                if (bgmAsset.name === this.autoPlayBGM) {
                    this._playBGMSlot(slot);
                }
            }
        }

        for (var j = 0; j < this.sfx.length; j += 1) {
            var sfxAsset = this.sfx[j];

            if (!(sfxAsset instanceof pc.Asset)) {
                console.warn("SFX with index " + j + " is not an asset!");
                continue;
            }

            if (this._sfxSlots[sfxAsset.name] === 0) {
                console.warn(sfxAsset.name, " is already loading. Ignoring", sfxAsset, this._sfxSlots);
                continue;
            }

            // Define the slots to zero, which is the loading variable.
            this._sfxSlots[sfxAsset.name] = 0;

            if (sfxAsset.tags.has('nolazyload')) {
                continue;
            }

            // Download if the resource is undefined
            if (!sfxAsset.resource) {
                LazyLoader.instance.lazyLoad(sfxAsset, this._onSFXLoadComplete, this);

                assetsToLoad.push(sfxAsset);
            } else {
                this._createSFXSlot(sfxAsset);
            }
        }

        LazyLoader.instance.lazyLoadSeries(assetsToLoad);
    },

    _onBGMLoadComplete: function (asset, autoPlay) {
        var slot = this._createBGMSlot(asset);

        // if (autoPlay) {
        //     this._playBGMSlot(slot);
        // }

        if (this.activeMusicName === asset.name) {
            this._playBGMSlot(slot);
        }
    },

    _onSFXLoadComplete: function (asset) {
        this._createSFXSlot(asset);
    },

    _createBGMSlot: function (asset) {
        var slot = this.soundPlayer.addSlot(asset.name, {
            asset: asset.id,
            volume: (typeof this._bgmVolume === 'number' ? this._bgmVolume : 1) * this.maxBGMVolume,
            pitch: 1.00,
            loop: this.bgmNoLoop.indexOf(asset.name) === -1,
            overlap: false,
        });

        this._bgmSlots[asset.name] = slot;

        return slot;
    },

    _createSFXSlot: function (asset) {

        var slot = this.soundPlayer.addSlot(asset.name, {
            asset: asset.id,
            volume: (typeof this._sfxVolume === 'number' ? this._sfxVolume : 1) * this.maxSFXVolume,
            pitch: 1.00,
            loop: false,
            overlap: true,
        });
        this._sfxSlots[asset.name] = slot;

        return slot;
    },

    _onResumeContext: function () {
        this.app.context._soundManager.context.resume();

        this.setTimeout = setTimeout(() => {
            if (this.setTimeout) {
                clearTimeout(this.setTimeout);
                delete this.setTimeout;
            }

            if (this.app.context._soundManager.context.state !== 'suspended') {
                this.app.off('InputManager:input', this._onResumeContext, this);
            }
        }, 100);
    },

    _playSFX: function (name) {
        var slot = this._sfxSlots[name];

        if (!slot) {
            switch (slot) {
                case undefined:
                    console.warn('Sound slot with the name [' + name + '] is not found');
                    return;
                case 0:
                    var asset = this.app.assets.find(name, "audio");

                    if (asset && asset.resource) {
                        this._createSFXSlot(asset);
                        slot = this._sfxSlots[name];
                    } else {
                        console.warn('Sound slot with the name ' + name + ' is still loading');
                        return;
                    }
                    break;

                default:
                    console.warn('Something went wrong with the sound. Value is ' + slot);
                    return;

            }

        }

        return this._playSFXSlot(slot);
    },

    _playBGM: function (name) {
        var slot = this._bgmSlots[name];
        this.activeMusicName = name;

        if (!(slot instanceof pc.SoundSlot)) {
            switch (slot) {
                case undefined:
                    console.warn('Sound slot with the name [' + name + '] is not found');
                    return;
                case 0:
                    var asset = this.app.assets.find(name);

                    if (asset) {
                        if (asset.resource) {
                            this._createBGMSlot(asset);

                            slot = this._bgmSlots[name];
                        } else {
                            return;
                        }
                    } else {
                        return;
                    }
                    break;
                default:
                    console.warn('Something went wrong with the sound. Value is ', slot);
                    return;
            }
        }

        return this._playBGMSlot(slot);
    },

    _playBGMSlot: function (slot) {
        if (this.activeMusicSlot === slot) {
            return;
        }

        if (this.activeMusicName !== slot.name) {
            return;
        }

        if (this.app.context._soundManager.context && this.app.context._soundManager.context.state === 'suspended') {
            this._onResumeContext();
        }

        const success = this._stopMusic();

        if (!success) {
            return null;
        }

        delete this._nextBGM;

        this.activeMusicSlot = slot;
        this.activeMusicSlot.volume = this._bgmVolume * this.maxBGMVolume;

        this.activeMusicInstance = this.activeMusicSlot.play();

        slot.on("end", this.onBGMEnd, this);

        return this.activeMusicSlot;
    },

    onBGMEnd: function () {
        if (this._nextBGM) {
            this._playBGM(this._nextBGM);
            delete this._nextBGM;
        }
    },

    playBGM: function (name) {
        return this._playBGM(name);
    },

    playSFX: function (name) {
        return this._playSFX(name);
    },

    getActiveMusicSlot: function () {
        return this.activeMusicSlot;
    },

    fadeOutMusicSlot: function (duration, delay) {

        if (!this.activeMusicSlot) {
            console.warn("No active music slot");
            return null;
        }

        return this.entity.tween(this.activeMusicSlot).to({ volume: 0 }, duration, pc.Linear, delay || 0).start();
    },

    _playSFXSlot: function (slot) {
        if (!this.useSFX) return;

        return slot.play();
    },

    _stopMusic: function () {
        if (!this.activeMusicSlot) return true;

        if (this.activeMusicSlot.isPlaying) {
            var hasStopped = this.activeMusicSlot.stop();

            if (!hasStopped) {
                return false;
            }
        }

        delete this.activeMusicSlot;

        return true;
    },

    _setBGMVolume: function (volume) {
        var keys = Object.keys(this._bgmSlots);

        this._bgmVolume = volume;

        for (var i = 0; i < keys.length; i += 1) {

            if (typeof this._bgmSlots[keys[i]] === 'object') {
                this._bgmSlots[keys[i]].volume = this._calculateBGMVolume();
            }
        }
    },

    _calculateBGMVolume: function () {
        return this._bgmVolume * this.maxBGMVolume * this.userVolume * this.userBGM;
    },

    _setSFXVolume: function (volume) {
        var keys = Object.keys(this._sfxSlots);

        this._sfxVolume = volume;

        for (var i = 0; i < keys.length; i += 1) {
            if (typeof this._sfxSlots[keys[i]] === 'object') {
                this._sfxSlots[keys[i]].volume = volume * this.maxSFXVolume * this.userVolume * this.userSFX;
            }
        }
    },

    setNextBGM: function (bgm) {
        if (this.activeMusicSlot && !this.activeMusicSlot.isPlaying) {
            this._playBGM(bgm);
        } else {
            this._nextBGM = bgm;
        }
    },

    // ------------------------------------------------
    // PUBLIC METHODS
    // ------------------------------------------------


    /**
     * Set and save the volume of BGM. Will also change volume of SFX if no sfxKey is availabe.
     *
     * @param {number|boolean} volume - Volume of the sound.
     */
    setBGMSetting: function (volume, start) {
        if (this.externalMute) {
            this._setBGMVolume(1);
            return true;
        }
        // Check if volume is valid 
        volume = Number(volume);

        if (isNaN(volume)) {
            console.warn('Volume is NaN!', volume);
            return;
        }

        volume = pc.math.clamp(volume, 0, 1);

        // Save
        if (!start) {
            StorageManager.instance.set(this.bgmSettingKey, volume);
        }

        // Set volume
        this._setBGMVolume(volume);

        // Set sfx setting, if required.
        if (this.bgmSettingKey && !this.sfxSettingKey) {
            this.setSFXSetting(volume);
        }

        this.fire('bgmVolume', this._calculateBGMVolume());

        return this.useBGM;
    },

    /**
     * Set and save the volume of SFX.
     *
     * @param {number|boolean} volume - Volume of the sound effects.
     */
    setSFXSetting: function (volume, start) {
        if (this.externalMute) {
            this._setSFXVolume(1);
            return true;
        }

        // Check if volume is valid 
        volume = Number(volume);

        if (isNaN(volume)) {
            console.warn('Volume is NaN!', volume);
            return;
        }

        volume = pc.math.clamp(volume, 0, 1);

        // Save
        if (this.sfxSettingKey && !start) {
            StorageManager.instance.set(this.sfxSettingKey, volume);
        }

        this.useSFX = !!volume;

        // Set volume
        this._setSFXVolume(volume);

        return this.useSFX;
    },

    onPauseManagerValueChanged(timeScale, gameTimeScale, focusTimeScale, adTimeScale) {
        if (timeScale > 0) {
            this.unmute();
            return;
        }

        if (!this.muteIfPaused && gameTimeScale === 0 && focusTimeScale === 1 && adTimeScale === 1) {
            this.unmute();
            return;
        }

        this.mute();
    },

    /**
     * 
     */
    mute: function (mute) {
        this.app.systems.sound.volume = 0;
    },

    unmute: function (mute) {
        this.app.systems.sound.volume = 1;
    },

    getSFXVolume: function () {
        return this._sfxVolume;
    },

    getBGMVolume: function () {
        return this._bgmVolume;
    },
});


// GameManager.js
var GameManager = pc.createScript('gameManager');

GameManager.attributes.add('levelSelectionEntities', { type: 'entity' });
GameManager.attributes.add('allowAdAfterCoinsSpentMoves', { type: 'boolean' });
GameManager.attributes.add('maxAdsPerSessionMoves', { type: 'number' });
GameManager.attributes.add('addMovesScreen', { type: 'entity' });

GameManager.attributes.add('allowAdAfterCoinsSpentExploderTimer', { type: 'boolean' });
GameManager.attributes.add('maxAdsPerSessionExploderTimer', { type: 'number' });
GameManager.attributes.add('addExploderTimerScreen', { type: 'entity' });
GameManager.attributes.add('swapButton', { type: 'entity' });
GameManager.attributes.add('shovelButton', { type: 'entity' });
GameManager.attributes.add('beehiveButton', { type: 'entity' });

GameManager.attributes.add('backToGardenButton', { type: 'entity' });

GameManager.attributes.add('buyItemEntities', { type: 'entity', array: true });


pc.extend(GameManager, {
    startUp: function () {
        GameManager.instance.init();
    },
});

pc.extend(GameManager.prototype, {

    initialize: function () {
        GameManager.instance = this;

        this.app.on('PauseManager:paused', this.paused, this);
        this.app.on('PauseManager:resumed', this.resumed, this);

        window.addEventListener("message", (event) => {
            if (event.data) {
                try {
                    const data = JSON.parse(event.data);

                    if (data && data.command === 'return') {
                        XPayStationWidget.close();
                    }
                } catch (e) {
                    // console.log(e)
                }
            }
        }, false);

        // Wrapper.instance.onRequest("pauseGameplay", function () {
        //     if (UIManager.instance.getScreen("Game").entity.enabled) {
        //         this.pause();
        //     }
        // });

        // Wrapper.instance.onRequest("resumeGameplay", function () {
        //     if (UIManager.instance.getScreen("Game").entity.enabled) {
        //         this.unpause();
        //     }
        // });

        this.forcedMode = Wrapper.instance.hasFeature("forced_mode");

        this._currentSceneController = null;
        this._init = false;

        this.levelString = "level_";
        this.app.on("StorageManager:changedStorage", this._onStorageChange, this);
        this.app.on('Firebase:invoice', this.onInvoice, this);
        this.setWebGLExtension();

        Wrapper.instance.onRequest('restartGame', this.restart, this);
    },

    restart: function () {
        ObjectiveManager.instance.reset();
        LevelManager.instance.restart();
    },

    update: function () {
    },

    throwOnGLError(a, b, c, d) {
        console.log(a, b, c, d);
    },

    onInvoice: function (invoices, inventory) {
        const invoice = invoices[invoices.length - 1];
        const sku = invoice.sku;
        let selectedScript = null;
        let reward = null;

        for (var i = 0; i < this.buyItemEntities.length; i++) {
            const script = this.buyItemEntities[i].script.buyItem;

            if (script.key === sku) {
                selectedScript = script;
            }
        }

        if (selectedScript) {
            reward = selectedScript.createReward();
        } else {
            console.log("Nothing found", sku);
            reward = { coinsReward: { quantity: 1000 }, boosterReward: [] };
        }

        Inventory.instance.updateInventory(inventory, invoices);

        this.app.fire('UIManager:hideUI', 'IAPClosedWhileProcessing');
        this.app.fire('UIManager:showUI', 'IAPSuccess', reward);

        this.app.fire('CoinInterface:updateCoins');
    },

    compareInvoices: function (invoices) {
        if (StorageManager.instance._hold) {
            console.log("holding");
            return;
        }

        if (!Array.isArray(invoices)) {
            console.log("no invoices found");
            return;
        }
        const inventoryInvoices = Inventory.instance.invoices;

        if (!Array.isArray(inventoryInvoices)) {
            console.log("no invoices found");
            return;
        }

        if (invoices.length === inventoryInvoices.length) {
            return;
        }

        for (var i = 0; i < invoices.length; i++) {
            const invoice = invoices[i];
            let found = false;

            for (var j = 0; j < inventoryInvoices.length; j++) {
                const inventoryInvoice = inventoryInvoices[j];

                if (inventoryInvoice.id === invoice.id) {
                    found = true;
                    break;
                }
            }

            if (!found) {
                Inventory.instance.addInvoice(invoice);
            }
        }

    },

    setWebGLExtension: function () {
        this.app.graphicsDevice.on('devicelost', this.onDeviceLost, this);
        this.app.graphicsDevice.on('devicerestored', this.onDeviceRestored, this);

        try {
            var canvas = this.app.graphicsDevice.canvas;
            var context = canvas.getContext("webgl") || canvas.getContext("webgl2") || canvas.getContext("experimental-webgl");
            this.extension = context.getExtension('WEBGL_lose_context');

            canvas.addEventListener('webglcontextlost', (e) => {
                console.log(e);
                Sentry.captureException(e);
                setTimeout(this.restoreContext.bind(this), 3000);
            }, false);
        } catch (e) {
            Sentry.captureException(e);
        }
    },

    onDeviceLost: function () {
        console.log("Context lost!")
        Sentry.captureMessage("Context lost!");

        setTimeout(() => {
            this.app.graphicsDevice.gl.getExtension("WEBGL_lose_context").restoreContext();
        }, 3000);
    },

    onDeviceRestored: function () {
        console.log("Context restored!")
        Sentry.captureMessage("Context restored!");
    },

    _onStorageChange: function () {
        pc.timer.add(0.01, () => {
            if (!this.forcedMode) {
                WorldManager.instance.setWorldIndexWithCurrentLevel();
                LevelLoader.instance.lazyLoadLevels();
            }

            FirstTimeUserManager.instance.checkEntities();
        }, this);
    },

    loseContext: function () {
        this.canvas.loseContext();
    },

    restoreContext: function () {
        try {
            this.extension.restoreContext();
            this.app.updateCanvasSize();
        } catch (e) {
            console.log(e);
        }
    },

    postInitialize: function () {
        LevelLoader.instance.loadLevel(1);

        try {
        } catch (e) {
            if (firebaseClass.loaded && firebaseClass.loggedIn()) {
                this.compareInvoices(firebaseClass.data.invoices);
            }
        }
    },

    test: function (tag) {
        var assets = this.app.assets.findByTag(tag);

        assets.forEach(asset => {
            if (asset.resource) {
                console.log(asset);
            }
        });
    },

    onSelect: function (script) {
        this.entity.script.swapMode.onSelect(script, script.colorID);
    },

    getLevelName: function () {
        return this.levelString + LevelManager.instance.getCurrentLevelNumber();
    },

    init: function () {
        setTimeout(() => {
            // Go directly to a level;
            if (this.forcedMode) {
                this.forcedModeProperties = Wrapper.instance.getFeatureProperties("forced_mode");
                this.gameMode = this.forcedModeProperties.state.mode;

                const level = this.forcedModeProperties.state.level;
                const world = WorldManager.instance.getCurrentWorld(level);

                WorldManager.instance.switchWorld(world);
                LevelManager.instance.startLevel(level, world);

                // this.startLevel(`level${this.forcedModeProperties.level}`);
            } else {
                this.app.fire('Audio:bgm', 'main_ost.mp3');
                this.checkReady();
                // this.app.fire('UIManager:showUI', 'finalImage')
            }
        }, 100);
    },

    loadSceneDone: function () {
        this.checkReady();
    },

    checkReady: function () {
        if (this.forcedMode && Application.currentScene.includes("World")) {
            LoadingScreen.instance.once('done', this.startForcedMode, this);
        } else if (Application.currentScene.includes("Init")) {
            if (Wrapper.instance.hasFeature("external_start")) {
                PauseManager.instance.pause();
                Wrapper.instance.onRequest("startGame", () => {
                    PauseManager.instance.resume();
                });
            }

            WorldManager.instance.setWorldIndexWithCurrentLevel();

            const menuScreen = UIManager.instance.getScreen("Menu").script.uiEntity;

            if (menuScreen.enabled && Wrapper.instance.hasFeature("skip_title")) {
                this.backToGardenButton.script.backTogardenButton._onClick();
                LoadingScreen.instance.once('done', () => {
                    Wrapper.instance.gameReady();
                    this.app.fire('GameManager:ready');
                });
                // // TODO Refactor if the Garden is in the build.
                // AssetManager.instance.loadBookAssets(WorldManager.instance.getWorldIndex(), function () {
                //     // this.app.fire('UIManager:hideAll');
                //     this.app.fire('UIManager:showUI', 'Book', 'nextLevel');
                //     this.app.fire('GameManager:ready');
                //     Wrapper.instance.gameReady();
                //     AssetManager.instance.loadWorldLevels();

                // }, this);
                return;
            } else {
                this.app.fire('UIManager:showUI', 'Menu');
                this.app.fire('UIManager:showUI', 'Settings');

                if (firebaseClass.active) {
                    if (firebaseClass.initialized) {
                        this.gameReady();
                    } else {
                        this.app.once('Firebase:logchange', this.gameReady, this);
                    }
                } else {
                    this.gameReady();
                }

                WorldManager.instance.setWorldIndexWithCurrentLevel();
                LevelLoader.instance.lazyLoadLevels();
            }
        }
    },

    startForcedMode: function () {
        if (Wrapper.instance.hasFeature("external_start")) {
            PauseManager.instance.pause();
            Wrapper.instance.onRequest("startGame", () => {
                PauseManager.instance.resume();
            });
        }

        this.app.fire('GameManager:ready');
        Wrapper.instance.gameReady();
    },

    gameReady: function () {
        Wrapper.instance.gameReady();
        this.app.fire('GameManager:ready');

    },

    resetGameSession: function () {
        this.amountOfMovesAddedWithCoins = 0;
        this.amountOfMovesAddedWithAds = 0;
        this.amountOfExploderTimerAddedWithCoins = 0;
        this.amountOfExploderTimerAddedWithAds = 0;
    },

    increaseAmountOfMovesAddedWithCoins: function () {
        this.amountOfMovesAddedWithCoins++;
    },

    increaseAmountOfMovesAddedWithAds: function () {
        this.amountOfMovesAddedWithAds++;
    },

    increaseAmountOfExploderTimerAddedWithCoins: function () {
        this.amountOfExploderTimerAddedWithCoins++;
    },

    increaseAmountOfExploderTimerAddedWithAds: function () {
        this.amountOfExploderTimerAddedWithAds++;
    },

    canUseAdsForMoves: function () {
        if (!this.allowAdAfterCoinsSpentMoves && this.amountOfMovesAddedWithCoins > 0) {
            return false;
        }

        // Check if rewarded ad is available.
        if (!Wrapper.instance.hasFeature('rewarded') || !Wrapper.instance.hasRewardedAd()) {
            return false;
        }

        if (this.amountOfMovesAddedWithAds < this.maxAdsPerSessionMoves) {
            return true;
        }

        return false;
    },

    canUseAdsForExploderTimer: function () {
        if (!this.allowAdAfterCoinsSpentExploderTimer && this.amountOfExploderTimerAddedWithCoins > 0) {
            return false;
        }
        // Check if rewarded ad is available.
        if (!Wrapper.instance.hasFeature('rewarded') || !Wrapper.instance.hasRewardedAd()) {
            return false;
        }

        if (this.amountOfExploderTimerAddedWithAds < this.maxAdsPerSessionExploderTimer) {
            return true;
        }

        return false;
    },

    hasAddMovesAttempts: function () {
        // Check if the player has attempts to buy with coins.
        if (this.amountOfMovesAddedWithCoins < this.addMovesScreen.script.outOfMovesScreen.addMovesPrice.length) {
            return true;
        }

        // Check if rewarded ad is available.
        if (!Wrapper.instance.hasRewardedAd()) {
            return false;
        }

        // Check if the player is allowed to watch ads.
        if (!this.allowAdAfterCoinsSpentMoves && this.amountOfMovesAddedWithCoins !== 0) {
            return false;
        }

        // Check if the player has attempts to watch ads.
        if (this.amountOfMovesAddedWithAds < this.maxAdsPerSessionMoves) {
            return true;
        }

        return false;
    },

    hasAddExploderTimerAttempts: function () {
        // Check if the player has attempts to buy with coins.
        if (this.amountOfExploderTimerAddedWithCoins < this.addExploderTimerScreen.script.addExploderTimerScreen.addMovesPrice.length) {
            return true;
        }

        // Check if rewarded ad is available.
        if (!Wrapper.instance.hasRewardedAd()) {
            return false;
        }

        // Check if the player is allowed to watch ads.
        if (!this.allowAdAfterCoinsSpentExploderTimer && this.amountOfExploderTimerAddedWithCoins !== 0) {
            return false;
        }

        // Check if the player has attempts to watch ads.
        if (this.amountOfExploderTimerAddedWithAds < this.maxAdsPerSessionExploderTimer) {
            return true;
        }

        return false;

    },


    applyForcedModeProperties: function () {
        // Apply preboosters
        if (!this.forcedMode || !this.forcedModeProperties) {
            return;
        }

        if (this.forcedModeProperties.state.has_prebooster_bees) {
            BoosterManager.instance.addPreBoosterToQueue([2, 3], 2);
        }

        if (this.forcedModeProperties.state.has_prebooster_ladybugs) {
            BoosterManager.instance.addPreBoosterToQueue(4, 2);
        }

        if (this.forcedModeProperties.state.has_prebooster_butterfly) {
            BoosterManager.instance.addPreBoosterToQueue(5, 1);
        }

        Inventory.instance.setFakeBoosters(
            this.forcedModeProperties.state.booster_swap,
            this.forcedModeProperties.state.booster_shovel,
            this.forcedModeProperties.state.booster_beehive
        );

        if (typeof this.forcedModeProperties.override.maximum_moves === 'number') {
            MovesManager.instance.setMoveAmount(this.forcedModeProperties.override.maximum_moves);
        }
    },

    pause: function () {
        this.app.timeScale = 0;
    },

    unpause: function () {
        this.app.timeScale = 1;
    },

    paused: function () {

    },

    resumed: function () {

    },

    // if (!this._init) {
    //     this.app.fire('UIManager:showUI', 'Menu');
    //     // this.app.fire('UIManager:showUI', 'Garden');
    //     // this.app.fire('UIManager:showUI', 'Settings');
    //     this.app.fire('GameManager:ready'); 
    //     WorldManager.instance.setWorldIndexWithCurrentLevel();
    //     LevelLoader.instance.lazyLoadLevels();
    //     this._init = true;
    // }

    /// tracking events
    trackEventLevelStart: function (restart) {
        var promise1 = window.famobi_analytics.trackEvent(restart ? window.famobi_analytics.EVENT_LEVELRESTART : window.famobi_analytics.EVENT_LEVELSTART, { levelName: this.getLevelName() });

        return Promise.all([promise1]);
    },

    trackEventEnd: function (result) {
        var promise1 = window.famobi_analytics.trackEvent(window.famobi_analytics.EVENT_CUSTOM, { eventName: "LEVELEND", result, score: ScoreManager.instance.getScore() });

        return promise1;
    },

    trackEventLevelSuccess: function (showInterstitial) {
        StatisticsManager.instance.incrementStatistic("level_completed", { level: Number.parseInt(LevelManager.instance.getCurrentLevelNumber()) });

        var levelName = this.getLevelName();

        var promises = [];

        var promise1 = window.famobi_analytics.trackEvent(window.famobi_analytics.EVENT_LEVELSUCCESS, { levelName: levelName });
        var promise2 = window.famobi_analytics.trackEvent(window.famobi_analytics.EVENT_LEVELSCORE, { levelName: levelName, levelScore: ScoreManager.instance.getCurrentLevelScore() });
        var promise3 = window.famobi_analytics.trackEvent(window.famobi_analytics.EVENT_TOTALSCORE, { totalScore: ScoreManager.instance.getScore() });

        promises.push(promise1, promise2, promise3);

        return Promise.all(promises);
    },

    trackEventLevelFail: function (showInterstitial) {
        StatisticsManager.instance.incrementStatistic("level_failed", { level: Number.parseInt(LevelManager.instance.getCurrentLevelNumber()) });

        var levelName = this.getLevelName();

        var promises = [];

        var promise1 = window.famobi_analytics.trackEvent(window.famobi_analytics.EVENT_LEVELFAIL, { levelName: levelName, reason: "dead" });
        var promise2 = window.famobi_analytics.trackEvent(window.famobi_analytics.EVENT_LEVELSCORE, { levelName: levelName, levelScore: ScoreManager.instance.getCurrentLevelScore() });
        var promise3 = window.famobi_analytics.trackEvent(window.famobi_analytics.EVENT_TOTALSCORE, { totalScore: ScoreManager.instance.getScore() });

        promises.push(promise1, promise2, promise3);

        return Promise.all(promises);
    },

    trackEventLevelQuit: function () {
        StatisticsManager.instance.incrementStatistic("level_failed", { level: LevelManager.instance.getCurrentLevelNumber() });

        var promise1 = window.famobi_analytics.trackEvent(window.famobi_analytics.EVENT_LEVELFAIL, { levelName: this.getLevelName(), reason: "quit" });

        this.app.fire('GameManager:quit');
        return Promise.all([promise1]);
    },

    trackEventPause: function () {
        try {
            pauseEvent();
        } catch (e) {

        }
        var promise1 = window.famobi_analytics.trackEvent(window.famobi_analytics.EVENT_PAUSE);

        return Promise.all([promise1]);
    },

    trackEventResume: function () {
        try {
            resumeEvent();
        } catch (e) {

        }
        var promise1 = window.famobi_analytics.trackEvent(window.famobi_analytics.EVENT_RESUME);

        return Promise.all([promise1]);
    },

    trackEventVolumeChange: function () {
        var promise1 = window.famobi_analytics.trackEvent(window.famobi_analytics.EVENT_VOLUMECHANGE, { bgmVolume: AudioManager.instance.getBGMVolume(), sfxVolume: AudioManager.instance.getSFXVolume() });

        return Promise.all([promise1]);
    },

    trackLiveScore: function () {
        window.famobi_analytics.trackEvent("EVENT_LIVESCORE", { liveScore: ScoreManager.instance.getScore() });
    },

    trackCustomEvent: function (category, name, other) {
        const obj = {
            category: category,
            name: name,
            value: 1,
        };

        if (other) {
            Object.assign(obj, other);
        }

        window.famobi_tracking.trackEvent('event/custom', obj);
    },
});


// LocalisationManager.js
var LocalizationManager = pc.createScript('localizationManager');

pc.extend(LocalizationManager.prototype, {

    initialize: function() {
        if (Singleton.instance.canCreateInstance(this)) {
            LocalizationManager.instance = this;
        }
        
//         var self = this;
        
//         // For testing purposes
//         setInterval(function() {
//             LocalizationManager.instance.setLocale(self.app.i18n.locale === 'en-US' ? 'nl-NL' : 'en-US');
//         }, 2000);
        
        this.textInstances = {};
    },
    
    setLocale: function(locale) {
        this.app.i18n.locale = locale;
        this._replaceTextInstances();
    },

    setText: function(textEntity, key, variables) {
        this._logText(textEntity, key, variables); 
        this._displayText(textEntity, key, variables);
    },
    
    _getTextByKey: function(key) {
       return this.app.i18n.getText(key);
    },

    _parseText: function(text, variables) {
        if (!Array.isArray(variables) || variables.length === 0) {
            if(variables) 
                variables = [variables];
            else 
                return text;
        }

        var newText = text;

        for (var i = 0; i < variables.length; i += 1) {
            newText = newText.replace('{' + i + '}', variables[i]);
        }

        return newText;
    },

    _displayText: function(textEntity, key, variables) {
        textEntity.element.text = this._parseText(this.app.i18n.getText(key), variables);
    },
    
    _logText: function(textEntity, key, variables) {
        if(!this.textInstances[textEntity._guid]) {
            this.textInstances[textEntity._guid] = {};
            this.textInstances[textEntity._guid].textEntity = textEntity;
            this.textInstances[textEntity._guid].key = key;  
        }
        this.textInstances[textEntity._guid].variables = variables;
    },
    
    _replaceTextInstances: function() {
        for (var key in this.textInstances) {
            if(this.textInstances[key].textEntity.element === undefined)
                delete this.textInstances[key]; 
            else
                this._displayText(this.textInstances[key].textEntity, this.textInstances[key].key, this.textInstances[key].variables);
        }
    },

    get: function(key, variables) {
        return this._parseText(this._getTextByKey(key), variables);
    },

    priceToText: function(price, currency) {
        if (typeof price !== 'number') {
            price = Number.parseFloat(price);
        }

        return price.toLocaleString(pc.app.i18n.locale, {style:"currency", currency: currency});
    },
});



// TweenAlpha.js
var TweenAlpha = pc.createScript('tweenAlpha');

TweenAlpha.attributes.add('initFrom',           { type: 'number', default: 1, title: 'From' });
TweenAlpha.attributes.add('initTo',             { type: 'number', default: 0, title: 'To' });
TweenAlpha.attributes.add('playStyle', { 
    type: 'number',
    enum: [
        { 'Once': 0 },
        { 'Loop': 1 },
        { 'PingPong': 2 }
    ],
    title: 'Play Style'
});

TweenAlpha.attributes.add('duration',           { type: 'number', default: 1, title: 'duration' });
TweenAlpha.attributes.add('curve',              { type: 'curve', title: 'Animation Curve' });
TweenAlpha.attributes.add('ignoreTimeScale',    { type: 'boolean', default: true, title: 'Ignore Time Scale' });
TweenAlpha.attributes.add('startDelay',         { type: 'number', default: 0, title: 'Start Delay' });
TweenAlpha.attributes.add('debug',              { type: 'boolean', default: false, title: 'Show Debug' });
TweenAlpha.attributes.add('startOnEnable',      { type: 'boolean', default: true, title: 'Start on Enable'});
TweenAlpha.attributes.add('startOnInitialize',  { type: 'boolean', default: true, title: 'Start on Initialize'});

pc.extend(TweenAlpha.prototype, {

    initialize: function() {
        this._currentOpacity = 1;
        
        this._time = this.startOnInitialize ? 0 : this.duration + this.startDelay;
        this._oldTime = this.app._time || 0;
        this._from = this.initFrom;
        this._to = this.initTo;

        // List of all elements
        this._elements = this._elements || [];
    }, 

    postInitialize: function() {
        this._getAllElementComponents(this.entity);

        if (this.startOnInitialize) {
            this.startTween();
        }

        this.on('state', function(enabled) {
            if (enabled && this.startOnEnable) {
                this.startTween();
            }
        });
    },

    update: function(dt) {
        // Only execute code if this.time is between 0 and this.duration + this.startDelay
        if (this.isActive()) {
            // Update time
            this.updateTime(dt);

            // Only update opacity after the start delay.
            if (this._time > this.startDelay) {
                // Update opacity
                var opacity = this._from - this.curve.value((this._time - this.startDelay) / this.duration) * (this._from - this._to);
                this._currentOpacity = opacity;
                
                this.setAllElementOpacity(opacity);

                if (this.debug) {
                    console.log(this.entity.name, this._time, opacity);
                }
            }

            // Set new old time
            this._oldTime = this.app._time;
        }

        // Execute if this.time is higher than this.duration + this.startDelay
        if (this._time >= this.duration + this.startDelay) {
            switch(this.playStyle) {
                case 0: 
                    this.fire('finish');
                    break;
        
                case 1: this._time -= this.duration + this.startDelay;
                    break;
                    
                case 2: this._time -= this.duration + this.startDelay;
                    var temp = this._from;
                    this._from = this._to;
                    this._to = temp;
                    break;
            }
        }
    },

    updateTime: function(dt) {
        this._time += this.ignoreTimeScale ? (this.app._time - this._oldTime) / 1000 : dt;
    },

    /*
     * Recursive method to get all elements
     */
    _getAllElementComponents: function(entity) {
        var element = entity.element;

        if (element !== undefined && element.opacity !== null && element.opacity !== undefined) {
            this._elements.push(entity.element);
        }

        var self = this;
        entity.children.forEach(function(child) {
            self._getAllElementComponents(child); 
        });
    },
    
    /*
     * Set the correct value for starting a tween
     * This method can also be called to start a new tween
     */
    startTween: function(from = this.initFrom, to = this.initTo) {
        this.initFrom = from;
        this.initTo = to;
        
        this._time = 0;
        this._from = this.initFrom;
        this._to = this.initTo;
        this.setAllElementOpacity(this._from);   
        this._oldTime = this.app._time;
        
        return this;
    },

    setAllElementOpacity: function(opacity) {
        if (!this._elements) {
            this._elements = [];
            this._getAllElementComponents(this.entity);
        }

        this._elements.forEach(function(element) {
            if (!element.mask) {
                element.opacity = opacity;
            }
            
            if (element.type === pc.ELEMENTTYPE_TEXT) {
                if (!element.shadowOffset.equals(pc.Vec2.ZERO)) {
                    TweenAlpha.COLOR.set(element.shadowColor.r, element.shadowColor.g, element.shadowColor.b, opacity);
                    element.shadowColor = TweenAlpha.COLOR;
                }
                
                if (element.outlineThickness > 0) {
                    TweenAlpha.COLOR_1.set(element.outlineColor.r, element.outlineColor.g, element.outlineColor.b, opacity);
                    element.outlineColor = TweenAlpha.COLOR_1;

                }
            }
        });
    },
    
    getCurrentOpacity: function() {
        return this._currentOpacity;
    },
    
    isActive: function() {
        return this._time >= 0 && this._time <= this.duration + this.startDelay;
    },
});

TweenAlpha.COLOR = new pc.Color();
TweenAlpha.COLOR_1 = new pc.Color();

// TweenPosition.js
var TweenPosition = pc.createScript('tweenPosition');

TweenPosition.attributes.add('initFrom',        { type: 'vec3', default: [0, 0, 0], title: 'From' });
TweenPosition.attributes.add('initTo',          { type: 'vec3', default: [0, 0, 0], title: 'To' });
TweenPosition.attributes.add('playStyle', {
    type: 'number',
    enum: [
        { 'Once': 0 },
        { 'Loop': 1 },
        { 'PingPong': 2 }
    ],
    title: 'Play Style'
});

TweenPosition.attributes.add('duration',        { type: 'number', default: 1, title: 'duration' });
TweenPosition.attributes.add('curve',           { type: 'curve', title: 'Animation Curve' });
TweenPosition.attributes.add('ignoreTimeScale', { type: 'boolean', default: true, title: 'Ignore Time Scale' });
TweenPosition.attributes.add('startDelay',      { type: 'number', default: 0, title: 'Start Delay' });
TweenPosition.attributes.add('debug',           { type: 'boolean', default: false, title: 'Show Debug' });
TweenPosition.attributes.add('startAtEnable',   { type: 'boolean', default: true, title: 'Start on Initialize' });
TweenPosition.attributes.add('startOnEnable',   { type: 'boolean', default: true, title: 'Start on Enable'});

pc.extend(TweenPosition.prototype, {
    initialize: function() {
        this._time = this.startAtEnable ? 0 : this.duration + this.startDelay + 1;
        this._oldTime = this.app._time || 0;

        this._from = this.initFrom.clone();
        this._to = this.initTo.clone();

        this._initPosition = this.entity.getLocalPosition().clone();

        this._newPosition = new pc.Vec3(0, 0, 0);
    },

    postInitialize: function() {
        this.on('state', function(enabled) {
            if (enabled && this.startOnEnable) {
                this.startTween();
            }
        }, this);

        if (this.startAtEnable) {
            this.startTween();
        }
    },

    update: function(dt) {
        // Only execute code if this.time is between 0 and this.duration + this.startDelay
        if (this._time >= 0 && this._time <= this.duration + this.startDelay) {
            // Update time
            this.updateTime(dt);

            // Only update opacity after the start delay.
            if (this._time > this.startDelay) {
                // Formula: position = initPosition + (from - (from - to) * curve)
                this._newPosition
                    .set(this._from.x, this._from.y, this._from.z)
                    .sub(this._to)
                    .scale(this.curve.value((this._time - this.startDelay) / this.duration))
                    .sub2(this._from, this._newPosition)
                    .add(this._initPosition);
                this.entity.setLocalPosition(this._newPosition);
            }
            // Set new old time 
            this._oldTime = this.app._time;
        }

        // Execute if this.time is higher than this.duration + this.startDelay
        if (this._time >= this.duration + this.startDelay || this._time <= 0) {
            switch (this.playStyle) {
                case 0: break;
                case 1: this._time = 0;
                    break;
                case 2: this._time = 0; 
                    var temp = this._from;
                    this._from = this._to;
                    this._to = temp;
                    break;
            }
        }
    },

    /*
     * Update the time with the game time or the unscaled time
     */
    updateTime: function(dt) {
        this._time += this.ignoreTimeScale ? (this.app._time - this._oldTime) / 1000 : dt;
    },

    /*
     * Use this method to start a tween where the init position is resetted to the current position of the entity.
     */
    moveTo: function(from, to) {
        this._time = 0;

        this._from.set(0, 0, 0);
        this._to.set(0, 0, 0);
        this._to.sub(from);
        this._initPosition.set(from.x, from.y, from.z);
        this._oldTime = this.app._time;
    },

    /*
     * Set the correct value for starting a tween
     * This method can also be called to start a new tween
     */
    startTween: function() {
        try {
            this._time = 0;
            this._from.set(this.initFrom.x, this.initFrom.y, this.initFrom.z);
            this._to.set(this.initTo.x, this.initTo.y, this.initTo.z);
            this.entity.setLocalPosition(this._from.x + this._initPosition.x, this._from.y + this._initPosition.y, this._from.z + this._initPosition.z);
            this._oldTime = this.app._time;
        } catch(error) {
            console.log(error);
            setTimeout(this.startTween);
        }

    }, 
});





// TweenRotation.js
var TweenRotation = pc.createScript('tweenRotation');

TweenRotation.attributes.add('initFrom',        { type: 'vec3', default: [0, 0, 0], title: 'From' });
TweenRotation.attributes.add('initTo',          { type: 'vec3', default: [0, 0, 0], title: 'To' });
TweenRotation.attributes.add('playStyle', {
    type: 'number',
    enum: [
        { 'Once': 0 },
        { 'Loop': 1 },
        { 'PingPong': 2 }
    ],
    title: 'Play Style'
});

TweenRotation.attributes.add('duration',        { type: 'number', default: 1, title: 'duration' });
TweenRotation.attributes.add('curve',           { type: 'curve', title: 'Animation Curve' });
TweenRotation.attributes.add('ignoreTimeScale', { type: 'boolean', default: true, title: 'Ignore Time Scale' });
TweenRotation.attributes.add('startDelay',      { type: 'number', default: 0, title: 'Start Delay' });
TweenRotation.attributes.add('debug',           { type: 'boolean', default: false, title: 'Show Debug' });
TweenRotation.attributes.add('startOnEnable',   { type: 'boolean', default: true, title: 'Start on Enable'});
TweenRotation.attributes.add('startOnInit',     { type: 'boolean', default: true, title: 'Start on Initialize'});
TweenRotation.attributes.add('speed',           { type: 'number', default: 1, title: 'speed'});

pc.extend(TweenRotation.prototype, {
    
    initialize: function() {
        this.pause = false;
        this.on('attr:initFrom', function() {
            this.stopTween();
            this.startTween();
        }, this);
        
        this.on('attr:initTo', function() {
            this.stopTween();
            this.startTween();
        }, this);
        
        this._time = this.startOnInit ? 0 : this.duration + this.startDelay + 1;
        this._oldTime = this.app._time || 0;

        this._from = this.initFrom.clone();
        this._to = this.initTo.clone();
    },

    postInitialize: function() {
        this._initRotation = this.entity.getLocalEulerAngles();

        this._newRotation = new pc.Vec3(0, 0, 0);

        this.on('state', function(enabled) {
            if (enabled && this.startOnEnable) {
                this.startTween();
            }
        });

        if (this.startOnInit) {
            this.startTween();      
        }
    },

    update: function(dt) {
        // Only execute code if this.time is between 0 and this.duration + this.startDelay
        if (this._time >= 0 && this._time <= this.duration + this.startDelay) {
            // Update time
            this._updateTime(dt);

            // Only update opacity after the start delay.
            if (this._time > this.startDelay) {
                // Formula: rotation = initRotation + (from - (from - to) * curve)
                this._newRotation
                    .set(this._from.x, this._from.y, this._from.z)
                    .sub(this._to)
                    .scale(this.curve.value((this._time - this.startDelay) / this.duration))
                    .sub2(this._from, this._newRotation)
                    .add(this._initRotation);


                this.entity.setLocalEulerAngles(this._newRotation.x, this._newRotation.y, this._newRotation.z);
            }
            // Set new old time
            this._oldTime = this.app._time;
        }

        // Execute if this.time is higher than this.duration + this.startDelay
        if (this._time >= this.duration + this.startDelay || this._time <= 0) {
            switch(this.playStyle) {
                case 0: break;
                case 1: this._time = 0;
                    break;
                case 2: this._time = 0;
                    var temp = this._from;
                    this._from = this._to;
                    this._to = temp;
                    break;
            }
        }
    },
    
    /*
     * Update the time with the game time or the unscaled time
     */
    _updateTime: function(dt) {
        this._time += (this.ignoreTimeScale ? (this.app._time - this._oldTime) / 1000 : dt * this.speed);
    },

    setInitRotation: function(x, y, z) {
        this.entity.setLocalEulerAngles(x, y, z);
        this._initRotation.set(this.entity.getLocalEulerAngles().x, this.entity.getLocalEulerAngles().y, this.entity.getLocalEulerAngles().z);
    },

    /*
     * Set the correct value for starting a tween
     * This method can also be called to start a new tween
     */
    startTween:  function() {
        this._time = 0;
        this._from.set(this.initFrom.x, this.initFrom.y, this.initFrom.z);
        this._to.set(this.initTo.x, this.initTo.y, this.initTo.z);
        this.entity.setLocalEulerAngles(this._from.x, this._from.y, this._from.z);
        this._oldTime = this.app._time;
    },
    
    stopTween: function() {
        this.entity.setLocalEulerAngles(this.initFrom.x, this.initFrom.y, this.initFrom.z);
        this._time = this.duration + this.startDelay + 1;
    }
});


// TweenScale.js
var TweenScale = pc.createScript('tweenScale');

TweenScale.attributes.add('initFrom', { type: 'vec3', default: [0, 0, 0], title: 'From' });
TweenScale.attributes.add('initTo', { type: 'vec3', default: [0, 0, 0], title: 'To' });
TweenScale.attributes.add('playStyle', {
    type: 'number',
    enum: [
        { 'Once': 0 },
        { 'Loop': 1 },
        { 'PingPong': 2 }
    ],
    title: 'Play Style'
});

TweenScale.attributes.add('duration', { type: 'number', default: 1, title: 'duration' });
TweenScale.attributes.add('curve', { type: 'curve', title: 'Animation Curve' });
TweenScale.attributes.add('ignoreTimeScale', { type: 'boolean', default: true, title: 'Ignore Time Scale' });
TweenScale.attributes.add('startDelay', { type: 'number', default: 0, title: 'Start Delay' });
TweenScale.attributes.add('debug', { type: 'boolean', default: false, title: 'Show Debug' });
TweenScale.attributes.add('startOnEnable', { type: 'boolean', default: true, title: 'Start on Enable'});
TweenScale.attributes.add('startOnInit', { type: 'boolean', default: true, title: 'Start on Initialize'});

pc.extend(TweenScale.prototype, {
    initialize: function() {
        this._time = this.startAtEnable ? 0 : this.duration + this.startDelay + 1;
        this._oldTime = this.app._time || 0;

        this._active = false;
        
        this._from = this.initFrom;
        this._to = this.initTo;
        this._temp = new pc.Vec3(0,0,0);
        this._newScale = new pc.Vec3(0, 0, 0);
        
        this._initScale = this.entity.getLocalScale().clone();
    },

    postInitialize: function() {
        this._initScale = this.entity.getLocalScale().clone();

        this.on('state', function(enabled) {
            if (this.debug) {
                console.log(this.entity.name, enabled, this.startOnEnable, this.entity);
            }
            if (enabled && this.startOnEnable) {
                this.startTween();
            }
        });

        if (this.startOnInit) {
            this.startTween();
        }
    },

    update: function(dt) {
        if (!this._active) {
            return;
        }

        // Only execute code if this.time is between 0 and this.duration + this.startDelay
        if (this._time >= 0 && this._time <= this.duration + this.startDelay) {
            // Update time
            this._updateTime(dt);

            // Only update opacity after the start delay.
            if (this._time > this.startDelay) {
                // Formula: newScale = (from - (from - to) * curve) * initscale
                this._newScale
                    .set(this._from.x, this._from.y, this._from.z)
                    .sub(this._to)
                    .scale(this.curve.value((this._time - this.startDelay) / this.duration))
                    .sub2(this._from, this._newScale)
                    .mul(this._initScale);


                this.entity.setLocalScale(this._newScale.x, this._newScale.y, this._newScale.z);
            }  

            // Set new old time
            this._oldTime = this.app._time;
        }

        // Execute if this.time is higher than duration
        if (this._time >= this.duration + this.startDelay || this._time < 0) {
            switch (this.playStyle) {
                case 0: 
                    this.fire('finish');
                    break;
                case 1: this._time -= this.duration + this.startDelay;
                    break;
                case 2: this._time -= this.duration + this.startDelay;
                    this._temp.set(this._from.x, this._from.y, this._from.z);
                    this._from.set(this._to.x, this._to.y, this._to.z);
                    this._to.set(this._temp.x, this._temp.y, this._temp.z);
                    break;
            }
        }
    },

    /*
     * Update the time with the game time or the unscaled time
     */
    _updateTime: function(dt) {
        this._time += this.ignoreTimeScale ? (this.app._time - this._oldTime) / 1000 : dt;
    },


    /*
     * Set the correct value for starting a tween
     * This method can also be called to start a new tween
     */
    startTween: function() {
        if (!this._from) return;
        this._active = true;
        this._time = 0;
        this._from.set(this.initFrom.x, this.initFrom.y, this.initFrom.z);
        this._to.set(this.initTo.x, this.initTo.y, this.initTo.z);
        this.entity.setLocalScale(this._from.x * this._initScale.x, this._from.y * this._initScale.y, this._from.z * this._initScale.z);
        this._oldTime = this.app._time;
    },
    
    stopTween: function() {
        this._active = false;
        this._time = 0;
    },

    reset: function() {
        this.entity.setLocalScale(this.initFrom);
    },
    
    isTweening: function() {
        return this._time >= 0 && this._time < this.duration + this.startDelay;  
    },
});


// LevelLoader.js
var LevelLoader = pc.createScript('levelLoader');

LevelLoader.attributes.add('levelKey', { type: 'string', default: 'level' });

pc.extend(LevelLoader.prototype, {

    initialize: function () {
        if (Singleton.instance.canCreateInstance(this)) {
            LevelLoader.instance = this;
        }
    },

    loadLevel: function (level, callback, context, ignoreWarning) {
        var paddedLevelNumber = this.padLevelNumber(level);
        var asset = this.app.assets.find('level_' + paddedLevelNumber + '.json');
        LazyLoader.instance.lazyLoad(asset, callback, context, ignoreWarning);
    },

    padLevelNumber: function (levelNumber) {
        return String(levelNumber).padStart(4, '0');
    },

    lazyLoadLevels: function () {
        if (window.levelDataExporter) {
            this._lazyLoadLevelsSimultaneously();
        } else {
            AssetManager.instance.loadWorldLevels(WorldManager.instance.getWorldIndex());
        }
    },

    _lazyLoadLevel() {
        this.loadLevel(this.level, function () {
            this.level++;

            this._lazyLoadLevel();
        }, this, true);
    },

    _lazyLoadLevelsSimultaneously: function () {
        var arrays = []
        var assets = this.app.assets.findByTag('level');

        while (assets.length) {
            arrays.push(assets.splice(0, 1000));
        }

        console.log(arrays)

        var assetsLoaded = 0;
        var assetsTotal = 0;

        var self = this;

        var loadAssets = function (array) {
            assetsLoaded = 0;
            assetsTotal = array.length;

            for (var i = 0; i < array.length; i += 1) {
                if (array[i].resource) {
                    onAssetLoad();
                } else {
                    LazyLoader.instance.lazyLoad(array[i], onAssetLoad, this);
                }
            }
        }

        var onAssetLoad = function () {
            assetsLoaded += 1;
            if (assetsLoaded === assetsTotal) {
                arrays.shift();

                if (arrays[0]) {
                    loadAssets(arrays[0]);
                    return;
                }

                console.log("All levels loaded.");

                self.app.fire('LevelLoader:levelsLoaded');
            }
        };

        for (var i = 0; i < assets.length; i += 1) {
            if (assets[i].resource) {
                onAssetLoad();
            } else {
                LazyLoader.instance.lazyLoad(assets[i], onAssetLoad, this);
            }
        }

        loadAssets(arrays[0]);
    },
});


// VibrationManager.js
var VibrationManager = pc.createScript('vibrationManager');

pc.extend(VibrationManager.prototype, {
    initialize: function() {
        if (Singleton.instance.canCreateInstance(this)) {
            VibrationManager.instance = this;
        }

        // enable vibration support
        navigator.vibrate = navigator.vibrate || navigator.webkitVibrate || navigator.mozVibrate || navigator.msVibrate;

        this._isSupported = !!navigator.vibrate;

        this._defaultVibration = [100, 10, 100];
    },

    postInitialize: function() {
        this._vibration = StorageManager.instance.get('vibrate');

        if (!navigator.vibrate) {
            this.enabled = false;
            return;
        }

        this.app.on('vibrate', this._vibrate, this);   
        this.app.on("StorageManager:changedStorage", this._onStorageChange, this);
    },

    _onStorageChange: function() {
        this._vibration = StorageManager.instance.get('vibrate');

        if (!navigator.vibrate) {
            this.enabled = false;
            return;
        }
    },

    // ------------------------------------------------
    // PRIVATE METHODS
    // ------------------------------------------------

    /**
     * Don't call this method directly, make use of PC events to keep it modular.
     */
    _vibrate: function(parameters) {
        //console.log("Entered vibration function")
        
        if (!navigator.vibrate) {
            console.warn("Vibration not supported");
        }

        if (!this._vibration) {
            return;
        }
        
        navigator.vibrate(parameters || this._defaultVibration);
    },

    /**
     * Save to the storage.
     */ 
    _save: function() {
        StorageManager.instance.set('vibrate', this._vibration);
    },

    // ------------------------------------------------
    // PUBLIC METHODS
    // ------------------------------------------------
    /**
     * Return if the user wants to use vibration or not.
     */
    get: function() {
        return this._vibration;
    },

    /**
     * Set the new preference.
     */ 
    set: function(value) {
        this._vibration = value;  
        this._save();
    },

    /**
     * Toggle the vibration preference.
     */
    toggle: function() {
        this._vibration = !this._vibration;

        this.save();

        return this._vibration;
    },

    /**
     * Return if the vibration is supported or not. Use this method to check if the vibration button needs to be visible. 
     */
    isVibrationSupported: function() {
        return this._isSupported && pc.platform.mobile;  
    },
});



// LazyLoader.js
var LazyLoader = pc.createScript('lazyLoader');

pc.extend(LazyLoader.prototype, {

    initialize: function () {
        if (Singleton.instance.canCreateInstance(this)) {
            LazyLoader.instance = this;
        }

        var handler = this.app.loader.getHandler("texture");
        handler.crossOrigin = "anonymous";
    },

    lazyLoad: function (asset, callback, context, ignoreWarning) {
        if (!asset) {
            // TODO Better to show an error
            if (!ignoreWarning) {
                console.warn("Asset is undefined", callback, context);
            } else {
                // TODO fix this later
                this.app.fire('LevelLoader:levelsLoaded');
            }

            return;
        }
        // console.warn(asset)
        if (asset.resource) {
            // The material asset has already been loaded 

            if (callback) {
                callback.call(context, asset);
            }
        } else {
            var self = this;
            // Start async loading the material asset
            asset.once('load', function () {

                //setTimeout(function() {
                if (callback) {
                    callback.call(context, asset);
                }
                //});
            });

            this.app.assets.load(asset);
        }
    },

    lazyLoadParallel: function (assets, callback, context) {
        var total = assets.length;
        var totalLoaded = 0;

        var self = this;

        var onLoaded = function (asset) {
            asset.off('error', onError);
            totalLoaded++;

            self.fire('onLoaded', totalLoaded, total);
            if (total === totalLoaded) {

                if (typeof callback === 'function') {
                    callback.call(context);
                }
            }
        };

        var self = this;

        var onError = function (error, failedAsset) {
            console.log(error);

            onLoaded(failedAsset);

            // setTimeout(() => {
            //     console.log("re load")
            //     self.app.assets.load(failedAsset);
            //     onLoaded(failedAsset);
            // }, 1000);
        }


        for (var i = 0; i < assets.length; i++) {
            var asset = assets[i];

            if (!(asset instanceof pc.Asset)) {
                total--;
                continue;
            }

            asset.ready(onLoaded);
            asset.on('error', onError);

            this.app.assets.load(asset);
        }
    },

    lazyLoadSeries: function (assets, callback, context) {
        var index = -1;
        var self = this;

        var onLoaded = function () {
            index++;

            var asset = assets[index];

            if (!(asset instanceof pc.Asset)) {
                if (callback) {
                    callback.call(context);
                }
            } else {
                self.app.assets.load(asset);

                asset.ready(onLoaded);
            }
        };

        onLoaded();
    },
});


// UIManager.js
var UIManager = pc.createScript('uiManager');

UIManager.SCREEN_DIALOG = "Dialog";
UIManager.SCREEN_TUTORIAL_DIALOG = "Tutorial";

UIManager.attributes.add('loadingOverlay', { type: 'entity' });
UIManager.attributes.add('screenPrefabs', { type: 'entity' });

/**
 * How to use the UI Manager. 
 * Make sure that each screen has the UIEntity script. 
 * In the inspector of the UIEntity script you can define properties of each screen and it will add itself to the UIManager
 */
pc.extend(UIManager.prototype, {

    initialize: function () {
        if (Singleton.instance.canCreateInstance(this)) {
            UIManager.instance = this;
        }

        // this._screenScripts = this.screenPrefabs.findScripts('uiEntity');

        this._redirect = {};

        this._stackScreen = [];
        this._stackOverlay = [];
        this._stackPopup = [];

        this._uiTypes = ['Screen', 'Overlay', 'Popup'];

        this._uis = {};

        this.app.on('GameManager:ready', this._removeLoadingOverlay, this);
        this.app.on('UIManager:showUI', this._showUI, this);
        this.app.on('UIManager:hideUI', this._hideUI, this);
        this.app.on('UIManager:hideAll', this._hideAll, this);
    },

    postInitialize: function () {
        this.initChildrens();
        //this.enableChildrens();
    },

    initChildrens: function () {
        for (var i = 0; i < this.entity.children.length; i += 1) {
            var screen = this.entity.children[i];
            if (screen instanceof pc.Entity && screen.script && screen.script.has('uiEntity')) {
                screen.script.uiEntity.init();
            }
        }
    },

    enableChildrens: function () {
        for (var i = 0; i < this.entity.children.length; i += 1) {
            var screen = this.entity.children[i];
            if (screen instanceof pc.Entity) {
                if (!screen.script.uiEntity) {
                    //console.log(screen.name, "has no uiEntity script", screen);
                } else if (!screen.enabled) {
                    screen.enabled = true;
                }
            }
        }
    },

    getScreen: function (screenName) {
        if (this._redirect[screenName]) {
            screenName = this._redirect[screenName];
        }

        return this._uis[screenName].entity;
    },

    addUIEntity: function (name, type, entity, enabled) {
        var index = this._uiTypes.indexOf(type);

        if (index === -1) {
            console.warn("Type is not recognize", type);
            return;
        }

        if (typeof name !== 'string' || !name) {
            console.warn("Name is invalid", name);
        }

        if (this._uis[name]) {
            console.warn("This ui name is already occupied.", name);
            return;
        }

        this._uis[name] = { entity: entity, type: type };

        if (enabled) {
            this._showUI(name, null, true);
        } else {
            entity.enabled = false;
        }
    },

    _removeLoadingOverlay: function () {
        // Might need some refactoring
        if (this.loadingOverlay instanceof pc.Entity) {
            if (this.loadingOverlay.script) {
                delete this._uis[this.loadingOverlay.script.uiEntity.name];
                this.loadingOverlay.destroy();
            }
        }
    },

    _showUI: function (name, args, startUp) {
        if (this._redirect[name]) {
            return this._showUI(this._redirect[name], args, startUp);
        }

        var uiInfo = this.getScreen(name);

        if (!uiInfo) {
            console.warn('No ui is found with the name', name);
            return;
        }

        if (uiInfo.enabled || uiInfo.script.uiEntity.isBusy() && !startUp) {
            if (name === 'LoadingScreen' && !uiInfo.enabled && uiInfo.script.uiEntity.isBusy()) {

            } else {
                console.log('[UIManager] UI is already enabled', name);
                return;
            }
        }

        var promise = uiInfo.script.uiEntity.onOpen(args);

        if (!startUp) {
            if (promise instanceof Promise) {
                promise.then(function () {
                    this._showUIFinish(name, args);
                }.bind(this));
            } else {
                this._showUIFinish(name, args);
            }

            this.fire('showUI', name);
        }

        this._addToStack(uiInfo, uiInfo.script.uiEntity.type, startUp);

        this.app.fire('UIManager:opened', name);

        if (FirstTimeUserManager.instance) {
            FirstTimeUserManager.instance.checkDisappear();
        }

        return promise;
    },

    _showUIFinish: function (name, args) {
        var uiInfo = this.getScreen(name);

        if (!uiInfo) {
            console.warn('No ui is found with the name', name);
            return;
        }

        if (!uiInfo.script) return;
        uiInfo.script.uiEntity.onOpenFinish(args);
    },

    _hideUI: function (name, args, startUp) {
        var uiInfo = this.getScreen(name);

        if (!uiInfo) {
            console.warn('No ui is found with the name', name);
            return;
        }

        if (!uiInfo.enabled || uiInfo.script.uiEntity.isBusy() && !startUp) {
            if (name === 'LoadingScreen') {
                // console.warn('UI is already disabled', name);
            } else {
                return;
            }
        }
        if (!uiInfo.script) return;

        this._removeFromStack(uiInfo, uiInfo.script.uiEntity.type, startUp);

        if (startUp) {
            uiInfo.script.entity.enabled = false;
        } else {
            var promise = uiInfo.script.uiEntity.onClose(args);

            if (promise instanceof Promise) {
                promise.then(function () {
                    this._hideUIFinish(name, args);
                }.bind(this));
                this.fire('hideUI', name);

                return promise;
            } else {
                this._hideUIFinish(name, args);
                this.fire('hideUI', name);
            }
        }
    },

    _hideUIFinish: function (name, args) {
        var uiInfo = this.getScreen(name);

        if (!uiInfo) {
            console.warn('No ui is found with the name', name);
            return;
        }

        if (!uiInfo.script) return;

        uiInfo.script.uiEntity.onCloseFinish(args);
    },


    _addToStack: function (entity, type, startUp) {
        var stack = this._getStack(type);

        var index = stack.indexOf(entity);

        if (index !== -1) {
            console.log("Entity is already in the stack, pushed to the top", entity);
            stack.splice(index, 1);
        }

        stack.push(entity);
    },

    _removeFromStack: function (entity, type, startUp) {
        if (startUp) {
            return;
        }

        var stack = this._getStack(type);

        var index = stack.indexOf(entity);

        if (index === -1) {
            console.log("[UIManager] Entity doesn't exist in the stack", stack, entity);
            return;
        }

        stack.splice(index, 1);
    },

    _getStack: function (type) {
        return this['_stack' + type];
    },

    getTopStack: function (type) {
        var length = this['_stack' + type].length;
        return this['_stack' + type][length - 1];
    },

    getReferenceResolution: function () {
        return this.entity.screen.referenceResolution;
    },

    getScale: function () {
        return this.entity.screen.scale;
    },

    _hideAll: function (args) {
        var excludedUINames = ["SceneTransition", "LoadingScreen", 'blackOverlay'];
        for (var index = 0; index < arguments.length; index++) {
            if (arguments[index]) {
                excludedUINames[index] = arguments[index];
            }
        }

        var uiNames = Object.keys(this._uis);
        for (var i = 0; i < uiNames.length; i += 1) {
            var skip = false;
            for (var j = 0; j < excludedUINames.length; j++) {
                if (excludedUINames[j] === uiNames[i]) {
                    skip = true;
                }
            }
            if (!skip) {
                this._hideUI(uiNames[i], args);
            }
        }

    },

    isTopOfStack: function (type, name) {
        var topOfStack = this.getTopStack(type);
        if (topOfStack === undefined) return false;

        return topOfStack.name === name;
    },

    isOpen: function (name) {
        var ui = this._uis[name];

        if (!ui) {
            console.warn("No UI found with the name", name);
            return;
        }

        return ui.entity.enabled;
    },

    setRedirect: function (name, to) {
        this._redirect[name] = to;
    },
});

// StatisticsManager.js
var StatisticsManager = pc.createScript('statisticsManager');

StatisticsManager.STATISTICS = [
    "swaps_made", // done
    "flower_destroyed", // done
    "combo_made", // done
    "special_created", // done
    "special_triggered", // done
    "matches_made", // done
    "obstacle_destroyed", // done
    "special_combination", // done
    // "three_flower_matches_made", // done
    // "four_flower_matches_made", // done
    // "five_flower_matches_made", // done

    // "power_tiles_activated", // done
    // "bees_activated", // done
    // "ladybugs_activated", // done
    // "butterflies_activated", // done 

    // "flowers_destroyed", // done
    // "blue_flowers_destroyed", // done
    // "yellow_flowers_destroyed", // done
    // "red_flowers_destroyed", // done
    // "purple_flowers_destroyed", // done
    // "green_flowers_destroyed", // done
    // "orange_flowers_destroyed", // done

    "booster_used", // done
    "pre_booster_used", // done

    // "droppers_collected", // done
    "flowerparts_collected", // done
    "flower_collected", // done
    // "tiles_coated", // TO-DO: not made yet

    // "orders_completed", // done
    // "flower_orders_completed", // done
    // "blue_flower_orders_completed", // done
    // "yellow_flower_orders_completed", // done
    // "red_flower_orders_completed", // done
    // "purple_flower_orders_completed", // done
    // "green_flower_orders_completed", // done
    // "orange_flower_orders_completed", // done
    // "panels_orders_completed", // done
    // "blocker_orders_completed", // done
    // "locker_orders_completed", // done
    // "virus_orders_completed", // done
    // "sinker_orders_completed", // done
    // "switcher_orders_completed", // done
    // "copyer_orders_completed", // done
    // "popper_orders_completed", // done

    "coins_received", // done
    "coins_used", // done

    // "total_bought", // done
    // "free_swap_booster_bought", // done
    // "breaker_booster_bought", // done
    // "crossbomb_booster_bought", // done
    // "bees_pre_booster_bought", // done
    // "ladybugs_pre_booster_bought", // done
    // "butterflies_pre_booster_bought", // done
    'booster_bought',
    'pre_booster_bought',

    "level_completed", // done
    "level_failed", // done

    "revived", // TO-DO: not made yet

    "daily_reward_received", // done
    // "starter_pack_reward_gotten", // done
    // "mega_pack_reward_gotten", // done

    // "single_ad_total_ads_watched", // done
    // "mega_pack_total_ads_watched", // done
    // "starter_pack_total_ads_watched" // done

];

pc.extend(StatisticsManager.prototype, {

    initialize: function () {
        StatisticsManager.instance = this;

        this._dirty = false;
        this._data = this._getData();

        this.active = Wrapper.instance.hasFeature('trackstats');

        this._statsToBeUpdated = {};
        this.app.on("StorageManager:changedStorage", this._onStorageChange, this);
    },

    _onStorageChange: function () {
        this._dirty = false;
        this._data = this._getData();

        this._statsToBeUpdated = {};
    },

    _getData: function () {
        var data = StorageManager.instance.get('statistics');

        if (typeof data !== 'object' || Array.isArray(data)) {
            data = {};
        }

        var keys = Object.keys(data);

        for (var j = 0; j < keys.length; j++) {
            var key = keys[j];
            var index = StatisticsManager.STATISTICS.indexOf(key);

            if (index === -1) {
                delete data[key];
            }
        }

        for (var i = 0; i < StatisticsManager.STATISTICS.length; i++) {
            var key = StatisticsManager.STATISTICS[i];
            if (typeof data[key] !== 'number') {
                data[key] = 0;
            }
        }

        return data;
    },

    saveStatistics: function () {
        if (this._dirty) {
            this._updateStatistics();
            StorageManager.instance.set('statistics', this._data);
            this._dirty = false;
        }
    },

    _updateStatistics: function () {
        var keys = Object.keys(this._statsToBeUpdated);

        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            var value = this._statsToBeUpdated[key];
            if (value === 0 || isNaN(value)) {
                continue;
            }
            window.famobi_analytics.trackStats(key, value);
            this._statsToBeUpdated[key] = 0;
        }
    },

    incrementStatistic: function (key, data = {}, value = 1, autoSave = false) {
        if (!this._isKeyValid(key)) {
            return;
        }

        var incrementValue = value || 1;

        this._data[key] += incrementValue;

        if (this.active) {
            window.famobi_analytics.trackStats(key, data, value);
        }

        // this._setStatsToBeUpdated(key, incrementValue);
        // this._dirty = true;

        // if (autoSave) {
        //     this.saveStatistics();
        // }
    },

    setStatistic: function (key, value, higherOnly) {
        if (!this._isKeyValid(key)) {
            return;
        }

        var oldValue = this._data[key];

        if (oldValue === value) {
            return;
        }

        if (higherOnly && oldValue > value) {
            return;
        }

        this._data[key] = value;
        this._setStatsToBeUpdated(key, value - oldValue);
        this._dirty = true;
    },

    _isKeyValid: function (key) {
        var index = StatisticsManager.STATISTICS.indexOf(key);

        if (index === -1) {
            console.warn("No statistic found with the key", key);
        }

        return index !== -1;
    },

    _setStatsToBeUpdated: function (key, value) {
        if (typeof this._statsToBeUpdated[key] !== 'number') {
            this._statsToBeUpdated[key] = 0;
        }

        this._statsToBeUpdated[key] += value;
    },
});

// UIEntity.js
var UIEntity = pc.createScript('uiEntity');

UIEntity.attributes.add('name', { type: 'string', default: '' });
UIEntity.attributes.add('type', { type: 'string', enum: [
    { 'Screen':     'Screen' },
    { 'Overlay':    'Overlay' },
    { 'Popup':      'Popup' },
]});
UIEntity.attributes.add('scriptName', { type: 'string', default: '' });
UIEntity.attributes.add('showOnStartUp', { type: 'boolean', default: false });
UIEntity.attributes.add('ignoreHideAll', { type: 'boolean', default: false });

pc.extend(UIEntity.prototype, {

    init: function() {
        this.popUpUITween = this.entity.findScripts('PopUpUITween');
        this.moveUITween = this.entity.findScripts('MoveUITween');

        UIManager.instance.addUIEntity(this.name, this.type, this.entity, this.showOnStartUp); 

        this._isBusy = false;
        
        if (!this.entity.element) {
            console.warn(this.entity.name, "doesn't have a group element, please add it!");
        }

        if (!this.entity.script && !this.entity.script.dynamicScreen) {
            console.warn(this.entity.name, "doesn't have a dynamicScreen script, please add it!");
        }

        if (this.entity.script && this.entity.script.has(this.scriptName) && typeof this.entity.script[this.scriptName].init === 'function') {
            this.entity.script[this.scriptName].init();
        }
    },

    /**
     * Set the entity enabled to false and execute close function of a external script, if defined. 
     */ 
    onClose: function(args) {
        this.fire('closing');
        if (this.entity.script) {
            if (!(this.entity.script[this.scriptName] instanceof Object.getPrototypeOf(pc.script).constructor)) {
                // console.warn(this.scriptName, 'is not a valid script.');
            }
        }

        var promiseArray = [];

        if (this.entity.script && this.entity.script[this.scriptName] && typeof this.entity.script[this.scriptName].onUIEntityClose === 'function') {
            var entityPromise = this.entity.script[this.scriptName].onUIEntityClose(args);

            if (entityPromise instanceof Promise) {
                promiseArray.push(entityPromise);
            }
        }

        for (var i = 0; i < this.popUpUITween.length; i++) {
            promiseArray.push(this.popUpUITween[i].doCloseAnimation());
        }

        for (var j = 0; j < this.moveUITween.length; j++) {
            promiseArray.push(this.moveUITween[j].doCloseAnimation());
        }

        if (promiseArray.length > 0) {
            this._isBusy = true;
            var promise = Promise.all(promiseArray);

            promise.then(() => {
                // Fullfilled
                this.entity.enabled = false;
                this._isBusy = false;
            });

            return promise;
        } else {
            this.entity.enabled = false;
        }
    },

    onCloseFinish: function(args) {
        this.entity.enabled = false;

        if (!this.scriptName) {
            this.fire('closed');

            return false;
        }

        if (!(this.entity.script[this.scriptName] instanceof Object.getPrototypeOf(pc.script).constructor)) {
            console.warn(this.scriptName, 'is not a valid script.');
            this.entity.enabled = false;
            this.fire('closed');

            return false;
        }

        if (typeof this.entity.script[this.scriptName].onUIEntityCloseFinish !== 'function') {
            //console.log('No close function is not found', this.scriptName);
            this.entity.enabled = false;
            this.fire('closed');

            return false;
        }

        var promise = this.entity.script[this.scriptName].onUIEntityCloseFinish(args);
        
        this.fire("closeFinish");
        
        return promise;
    },

    /**
     * Set the entity enabled to true and execute open function of a external script, if defined. 
     */ 
    onOpen: function(args) {
        this.entity.enabled = true;

        if (this.entity.script) {
            if (!(this.entity.script[this.scriptName] instanceof Object.getPrototypeOf(pc.script).constructor)) {
                // console.warn(this.scriptName, 'is not a valid script.');
            }
        }

        var promiseArray = [];

        if (this.entity.script && this.entity.script[this.scriptName] && typeof this.entity.script[this.scriptName].onUIEntityOpen === 'function') {
            var entityPromise = this.entity.script[this.scriptName].onUIEntityOpen(args);

            if (entityPromise instanceof Promise) {
                promiseArray.push(entityPromise);
            }
        }        

        for (var i = 0; i < this.popUpUITween.length; i++) {
            promiseArray.push(this.popUpUITween[i].doOpenAnimation());
        }

        for (var j = 0; j < this.moveUITween.length; j++) {
            promiseArray.push(this.moveUITween[j].doOpenAnimation());
        }

        if (promiseArray.length > 0) {
            this._isBusy = true;
            var promise = Promise.all(promiseArray);

            promise.then(() => {
                this._isBusy = false;
            });
            return promise;
        }
    },

    onOpenFinish: function(args) {
        this.entity.enabled = true;

        if (!this.scriptName) {
            return false;
        }

        if (!(this.entity.script[this.scriptName] instanceof Object.getPrototypeOf(pc.script).constructor)) {
            console.warn(this.scriptName, 'is not a valid script.');
            this.entity.enabled = true;

            return false;
        }

        if (typeof this.entity.script[this.scriptName].onUIEntityOpenFinish !== 'function') {
            //console.log('No close function is not found', this.scriptName);
            this.entity.enabled = true;

            return false;
        }

        var promise = this.entity.script[this.scriptName].onUIEntityOpenFinish(args);

        return promise;
    },

    isBusy: function() {
        return this._isBusy;
    }
});


// ObjectPool.js
/*! deePool
    v2.2.0 (c) Kyle Simpson
    MIT License: http://getify.mit-license.org
    Source: https://github.com/getify/deePool
*/


var ObjectPool = pc.createScript('objectPool');

ObjectPool.attributes.add('templateEntity', { type: 'entity', title: 'Template Entity', });
ObjectPool.attributes.add('template', { type: 'asset', assetType: 'template', title: 'Template', });

ObjectPool.attributes.add('initialLength', { type: 'number', default: 16 });
ObjectPool.attributes.add('growCount', { type: 'number', default: 5 });
ObjectPool.attributes.add('disableOnInit', { type: 'boolean', default: true, title: 'Disable on Init' });
ObjectPool.attributes.add('disable', { type: 'boolean', default: true });
ObjectPool.attributes.add('debug', { type: 'boolean', default: false });

/**
 * ObjectPool
 * Creates re-usable objects of type Entity.
 * Pre-/allocation behaviours can be set using the prototype's attributes.
 */
pc.extend(ObjectPool.prototype, {

    initialize: function () {
        this._pool = [];
        this._nextFreeSlot = null;

        if (this.template) {
            const keys = Object.keys(this.template.resource._data.entities);

            for (var i = 0; i < keys.length; i++) {
                const key = keys[i];
                const entity = this.template.resource._data.entities[key];

                if (!entity.parent) {
                    this.name = entity.name;
                    break;
                }
            }
        } else if (this.templateEntity) {
            this.name = this.templateEntity.name;
        }

        this._grow(this.initialLength, true);
    },

    _grow: function (count, init) {
        if (this.debug) {
            console.warn("growing", this._pool.length + count, this.entity.name)
        }

        if (count > 0 && this._nextFreeSlot === null) {
            this._nextFreeSlot = 0;
        }

        if (count > 0) {
            var currentLength = this._pool.length;
            this._pool.length += Number(count);

            for (var i = currentLength; i < this._pool.length; i += 1) {
                // add new obj to pool
                var clonedEntity = this.template ? this.template.resource.instantiate() : this.templateEntity.clone();
                clonedEntity.enabled = false;
                clonedEntity.reparent(null);
                clonedEntity.objectPool = this;
                this._pool[i] = clonedEntity;

                clonedEntity.setPosition(0, 0, 0);

                if (this.disableOnInit) {
                    this._pool[i].enabled = false;
                    this._pool[i].reparent(null);
                }
            }
        }

        return this._pool.length;
    },

    /**
     * Retrieves an available object instance from the pool
     */
    use: function () {
        if (this._nextFreeSlot === null || this._nextFreeSlot === this._pool.length) {
            this._grow(this.growCount);
        }

        if (this.debug) {
            console.log("use")
        }

        var objToUse = this._pool[this._nextFreeSlot];
        this._pool[this._nextFreeSlot] = null;
        this._nextFreeSlot += 1;

        return objToUse;
    },

    /**
     * Inserts an object instance back into the pool for later reuse.
     */
    recycle: function (obj) {
        if (this.debug) {
            console.warn(obj);
        }

        if (obj.enabled && this.disable) {
            // console.warn("This object is not disabled", obj.name);
        }

        if (this.debug) {
            console.log("recycle")
        }

        if (obj.name !== this.name) {
            console.warn("Something went wrong", obj, this.templateEntity);
        }

        if (this._pool.indexOf(obj) !== -1) {
            console.log("already in the object pool", obj);
            return;
        }

        obj.enabled = false;
        obj.reparent(null);

        if (this._nextFreeSlot === null || this._nextFreeSlot === -1) {
            this._pool[this._pool.length] = obj;
        } else {
            this._pool[this._nextFreeSlot -= 1] = obj;
        }

        obj.setPosition(0, 0, 0);
    },

    /**
     * Return the size of the pool. For debugging purposes.
     */
    size: function () {
        return this._pool.length;
    }
});

// SwitchUIButton.js
var SwitchUibutton = pc.createScript('switchUibutton');

SwitchUibutton.attributes.add('openUIEntity', { type: 'entity', array: true, title: "Open UI Entities" });
SwitchUibutton.attributes.add('closeItself', { type: 'boolean', default: false, title: "Close current UI Entity" });
SwitchUibutton.attributes.add('closeUIEntity', { type: 'entity', array: true, title: "Close other UI Entities" });
SwitchUibutton.attributes.add('clickSFX', { type: 'string', default: 'button_click.mp3' });
SwitchUibutton.attributes.add('args', { type: 'string' });

pc.extend(SwitchUibutton.prototype, {

    initialize: function () {
        this._elementInput = null;

        this._waitForEvent = false;

        this._createInputEvent();
        this._setCloseItself();
    },

    _createInputEvent: function () {
        this._elementInput = this.entity.script.elementInput;

        if (!this._elementInput) {
            this._elementInput = this.entity.script.create('elementInput');
            console.warn('Add the script elementInput to this entity:', this.entity.name);
        }

        this._elementInput.on(inputEvents.CLICK, this._onClick, this);
    },

    _setCloseItself: function () {
        // Add to the list of closing entities.
        if (this.closeItself) {
            var UIEntity = this._getUIEntity(this.entity, 4);

            if (UIEntity instanceof pc.Entity) {
                this.closeUIEntity.push(UIEntity);
            } else {
                console.warn("Couldn't find a UI Entity");
            }
        }
    },

    _getUIEntity: function (entity, depth) {
        if (depth <= 0 && !(entity instanceof pc.Entity)) {
            return null;
        }

        if (entity.script && entity.script.uiEntity instanceof Object.getPrototypeOf(pc.script).constructor) {
            return entity;
        } else {
            return this._getUIEntity(entity.parent, depth -= 1);
        }
    },

    _onClick: function (event) {
        if (this._waitForEvent) {
            console.warn("Wait for promise to resolve");
            return;
        }
        if (this.isBusy()) {
            console.warn("Unable to switch while busy");
            return;
        }

        //this.app.fire('Audio:sfx', this.clickSFX);

        this._waitForEvent = true;
        this.fire('click');
        var promise = this._closeEntities();

        promise.then(() => {
            this._openEntities().then(() => {
                this._waitForEvent = false;
            });
        });
    },

    /** 
     * Open 
     */
    _openEntities: function () {
        var promises = [];
        for (var i = 0; i < this.openUIEntity.length; i += 1) {
            if (this.openUIEntity[i] instanceof pc.Entity) {
                promises.push(UIManager.instance._showUI(this.openUIEntity[i].script.uiEntity.name, this.args));
            } else {
                console.warn(this.entity.parent.name, 'has in invalid parameter in the array openUIEntity with index', i);
            }
        }

        return Promise.all(promises);
    },

    _onOpenEntities: function (closeEntities, openEntities) {
        for (var i = 0; i < this.openUIEntity.length; i += 1) {
            if (this.openUIEntity[i] instanceof pc.Entity) {
                promises.push(UIManager.instance._showUIFinish(this.openUIEntity[i].script.uiEntity.name, this.args));
            } else {
                console.warn(this.entity.parent.name, 'has in invalid parameter in the array closeUIEntity with index', i);
            }
        }
    },

    _closeEntities: function (closeEntities, openEntities) {
        var promises = [];
        for (var i = 0; i < this.closeUIEntity.length; i += 1) {
            if (this.closeUIEntity[i] instanceof pc.Entity) {
                promises.push(UIManager.instance._hideUI(this.closeUIEntity[i].script.uiEntity.name, this.args));
            } else {
                console.warn(this.entity.parent.name, 'has in invalid parameter in the array closeUIEntity with index', i);
            }
        }

        return Promise.all(promises);
    },

    _onClosedEntities: function (closeEntities, openEntities) {
        var promises = [];

        for (var i = 0; i < this.closeUIEntity.length; i += 1) {
            if (this.closeUIEntity[i] instanceof pc.Entity) {
                promises.push(UIManager.instance._hideUIFinish(this.closeUIEntity[i].script.uiEntity.name, this.args));
            } else {
                console.warn(this.entity.parent.name, 'has in invalid parameter in the array closeUIEntity with index', i);
            }
        }

        return Promise.all(promises);
    },

    isBusy: function () {
        for (var i = 0; i < this.closeUIEntity.length; i += 1) {
            if (this.closeUIEntity[i].script.uiEntity.isBusy()) {
                return true;
            }
        }

        return false;
    }
});


// Tween.js
pc.extend(pc, function () {

    /**
     * @name pc.TweenManager
     * @description Handles updating tweens
     * @param {pc.Application} app  The application
     */
    var TweenManager = function (app) {
        this._app = app;
        this._tweens = [];
        this._add = []; // to be added
    };

    TweenManager.prototype = {
        add: function (tween) {
            this._add.push(tween);
            return tween;
        },

        removeAll(entity) {
            for (var i = this._tweens.length - 1; i >= 0; i--) {

                if (this._tweens[i].entity === entity) {
                    this._tweens[i].stop();
                }
            }
        },

        update: function (dt) {
            var i = 0;
            var n = this._tweens.length;
            while (i < n) {
                if (this._tweens[i].update(dt)) {
                    i++;
                } else {
                    this._tweens.splice(i, 1);
                    n--;
                }
            }

            // add any tweens that were added mid-update
            if (this._add.length) {
                this._tweens = this._tweens.concat(this._add);
                this._add.length = 0;
            }
        }
    };

    /**
     * @name  pc.Tween
     * @param {Object} target The target property that will be tweened
     * @param {pc.TweenManager} manager The tween manager
     * @param {pc.Entity} entity The pc.Entity whose property we are tweening
     */
    var Tween = function (target, manager, entity) {
        pc.events.attach(this);

        this.manager = manager;

        if (entity) {
            this.entity = null; // if present the tween will dirty the transforms after modify the target
        }

        this.time = 0;

        this.complete = false;
        this.playing = false;
        this.stopped = true;
        this.pending = false;

        this.target = target;

        this.duration = 0;
        this._currentDelay = 0;
        this.timeScale = 1;
        this._reverse = false;

        this._delay = 0;
        this._yoyo = false;

        this._count = 0;
        this._numRepeats = 0;
        this._repeatDelay = 0;

        this._from = false; // indicates a "from" tween

        // for rotation tween
        this._slerp = false; // indicates a rotation tween
        this._fromQuat = new pc.Quat();
        this._toQuat = new pc.Quat();
        this._quat = new pc.Quat();

        this.easing = pc.Linear;

        this._sv = {}; // start values
        this._ev = {}; // end values
    };

    var _parseProperties = function (properties) {
        var _properties;
        if (properties instanceof pc.Vec2) {
            _properties = {
                x: properties.x,
                y: properties.y
            };
        } else if (properties instanceof pc.Vec3) {
            _properties = {
                x: properties.x,
                y: properties.y,
                z: properties.z
            };
        } else if (properties instanceof pc.Vec4) {
            _properties = {
                x: properties.x,
                y: properties.y,
                z: properties.z,
                w: properties.w
            };
        } else if (properties instanceof pc.Quat) {
            _properties = {
                x: properties.x,
                y: properties.y,
                z: properties.z,
                w: properties.w
            };
        } else if (properties instanceof pc.Color) {
            _properties = {
                r: properties.r,
                g: properties.g,
                b: properties.b,
            };
            if (properties.a !== undefined) {
                _properties.a = properties.a;
            }
        } else {
            _properties = properties;
        }
        return _properties;
    }
    Tween.prototype = {
        // properties - js obj of values to update in target
        to: function (properties, duration, easing, delay, repeat, yoyo) {
            this._properties = _parseProperties(properties);
            this.duration = duration;

            if (easing) this.easing = easing;
            if (delay) {
                this.delay(delay);
            }
            if (repeat) {
                this.repeat(repeat);
            }

            if (yoyo) {
                this.yoyo(yoyo);
            }

            return this;
        },

        from: function (properties, duration, easing, delay, repeat, yoyo) {
            this._properties = _parseProperties(properties);
            this.duration = duration;

            if (easing) this.easing = easing;
            if (delay) {
                this.delay(delay);
            }
            if (repeat) {
                this.repeat(repeat);
            }

            if (yoyo) {
                this.yoyo(yoyo);
            }

            this._from = true;

            return this;
        },

        rotate: function (properties, duration, easing, delay, repeat, yoyo) {
            this._properties = _parseProperties(properties);

            this.duration = duration;

            if (easing) this.easing = easing;
            if (delay) {
                this.delay(delay);
            }
            if (repeat) {
                this.repeat(repeat);
            }

            if (yoyo) {
                this.yoyo(yoyo);
            }

            this._slerp = true;

            return this;
        },

        start: function (set) {
            var prop, _x, _y, _z;

            this.playing = true;
            this.complete = false;
            this.stopped = false;
            this._count = 0;
            this.pending = (this._delay > 0);

            if (this._reverse && !this.pending) {
                this.time = this.duration;
            } else {
                this.time = 0;
            }

            if (this._from) {
                for (prop in this._properties) {
                    if (this._properties.hasOwnProperty(prop)) {
                        this._sv[prop] = this._properties[prop];
                        this._ev[prop] = this.target[prop];
                    }
                }

                if (this._slerp) {
                    this._toQuat.setFromEulerAngles(this.target.x, this.target.y, this.target.z);

                    _x = this._properties.x !== undefined ? this._properties.x : this.target.x;
                    _y = this._properties.y !== undefined ? this._properties.y : this.target.y;
                    _z = this._properties.z !== undefined ? this._properties.z : this.target.z;
                    this._fromQuat.setFromEulerAngles(_x, _y, _z);
                }
            } else {
                for (prop in this._properties) {
                    if (this._properties.hasOwnProperty(prop)) {
                        this._sv[prop] = this.target[prop];
                        this._ev[prop] = this._properties[prop];
                    }
                }

                if (this._slerp) {
                    if (set) {
                        this._fromQuat.set(this.target.x, this.target.y, this.target.z, this.target.w);
                    } else {
                        this._fromQuat.setFromEulerAngles(this.target.x, this.target.y, this.target.z);
                    }

                    _x = this._properties.x !== undefined ? this._properties.x : this.target.x;
                    _y = this._properties.y !== undefined ? this._properties.y : this.target.y;
                    _z = this._properties.z !== undefined ? this._properties.z : this.target.z;

                    this._toQuat.setFromEulerAngles(_x, _y, _z);
                }
            }

            // set delay
            this._currentDelay = this._delay;

            // add to manager when started
            this.manager.add(this);

            return this;
        },

        pause: function () {
            this.playing = false;
        },

        resume: function () {
            this.playing = true;
        },

        stop: function () {
            this.playing = false;
            this.stopped = true;
        },

        delay: function (delay) {
            this._delay = delay;
            this.pending = true;

            return this;
        },

        repeat: function (num, delay) {
            this._count = 0;
            this._numRepeats = num;
            if (delay) {
                this._repeatDelay = delay;
            } else {
                this._repeatDelay = 0;
            }

            return this;
        },

        loop: function (loop) {
            if (loop) {
                this._count = 0;
                this._numRepeats = Infinity;
            } else {
                this._numRepeats = 0;
            }

            return this;
        },

        yoyo: function (yoyo) {
            this._yoyo = yoyo;
            return this;
        },

        reverse: function () {
            this._reverse = !this._reverse;

            return this;
        },

        chain: function () {
            var n = arguments.length;

            while (n--) {
                if (n > 0) {
                    if (Array.isArray(arguments[n - 1])) {
                        arguments[n - 1][0]._chained = arguments[n];
                    } else {
                        arguments[n - 1]._chained = arguments[n];
                    }
                } else {
                    if (Array.isArray(this._chained)) {
                        this._chained[0] = arguments[n];
                    } else {
                        this._chained = arguments[n];

                    }
                }
            }

            return this;
        },

        update: function (dt) {
            if (this.stopped) return false;

            if (!this.playing) return true;

            if (!this._reverse || this.pending) {
                this.time += dt * this.timeScale;
            } else {
                this.time -= dt * this.timeScale;
            }

            // delay start if required
            if (this.pending) {
                if (this.time > this._currentDelay) {
                    if (this._reverse) {
                        this.time = this.duration - (this.time - this._currentDelay);
                    } else {
                        this.time = this.time - this._currentDelay;
                    }

                    this.fire('delayDone');

                    this.pending = false;
                } else {
                    return true;
                }
            }

            var _extra = 0;
            if ((!this._reverse && this.time > this.duration) || (this._reverse && this.time < 0)) {
                this._count++;
                this.complete = true;
                this.playing = false;
                if (this._reverse) {
                    _extra = this.duration - this.time;
                    this.time = 0;
                } else {
                    _extra = this.time - this.duration;
                    this.time = this.duration;
                }
            }

            var elapsed = (this.duration === 0) ? 1 : (this.time / this.duration);

            // run easing
            var a = this.easing(elapsed);

            // increment property
            var s, e, d;
            for (var prop in this._properties) {
                if (this._properties.hasOwnProperty(prop)) {
                    s = this._sv[prop];
                    e = this._ev[prop];
                    this.target[prop] = s + (e - s) * a;
                }
            }

            if (this._slerp) {
                this._quat.slerp(this._fromQuat, this._toQuat, a);
            }

            // if this is a entity property then we should dirty the transform
            if (this.entity) {
                this.entity._dirtifyLocal();

                // apply element property changes
                if (this.element && this.entity.element) {
                    this.entity.element[this.element] = this.target;
                }

                if (this._slerp) {
                    this.entity.setLocalRotation(this._quat);
                }
            }

            this.fire("update", dt, this);

            if (this.complete) {
                var repeat = this._repeat(_extra);
                if (!repeat) {
                    this.fire("complete", _extra, this.target);
                    if (this.entity)
                        this.entity.off('destroy', this.stop, this);
                    if (this._chained) {
                        if (Array.isArray(this._chained)) {
                            this._chained.forEach(chain => {
                                chain.start();
                            });
                        } else {
                            this._chained.start();
                        }
                    }

                } else {
                    this.fire("loop");
                }

                return repeat;
            }

            return true;
        },

        _repeat: function (extra) {
            // test for repeat conditions
            if (this._count < this._numRepeats) {
                // do a repeat
                if (this._reverse) {
                    this.time = this.duration - extra;
                } else {
                    this.time = extra; // include overspill time
                }
                this.complete = false;
                this.playing = true;

                this._currentDelay = this._repeatDelay;
                this.pending = true;

                if (this._yoyo) {
                    // swap start/end properties
                    for (var prop in this._properties) {
                        var tmp = this._sv[prop];
                        this._sv[prop] = this._ev[prop];
                        this._ev[prop] = tmp;
                    }

                    if (this._slerp) {
                        this._quat.copy(this._fromQuat);
                        this._fromQuat.copy(this._toQuat);
                        this._toQuat.copy(this._quat);
                    }
                    this.fire('yoyo');

                }

                return true;
            }
            return false;
        },

    };


    /**
     * Easing methods
     */

    var Linear = function (k) {
        return k;
    };

    var QuadraticIn = function (k) {
        return k * k;
    };

    var QuadraticOut = function (k) {
        return k * (2 - k);
    };

    var QuadraticInOut = function (k) {
        if ((k *= 2) < 1) {
            return 0.5 * k * k;
        }
        return -0.5 * (--k * (k - 2) - 1);
    };

    var CubicIn = function (k) {
        return k * k * k;
    };

    var CubicOut = function (k) {
        return --k * k * k + 1;
    };

    var CubicInOut = function (k) {
        if ((k *= 2) < 1) return 0.5 * k * k * k;
        return 0.5 * ((k -= 2) * k * k + 2);
    };

    var QuarticIn = function (k) {
        return k * k * k * k;
    };

    var QuarticOut = function (k) {
        return 1 - (--k * k * k * k);
    };

    var QuarticInOut = function (k) {
        if ((k *= 2) < 1) return 0.5 * k * k * k * k;
        return - 0.5 * ((k -= 2) * k * k * k - 2);
    };

    var QuinticIn = function (k) {
        return k * k * k * k * k;
    };

    var QuinticOut = function (k) {
        return --k * k * k * k * k + 1;
    };

    var QuinticInOut = function (k) {
        if ((k *= 2) < 1) return 0.5 * k * k * k * k * k;
        return 0.5 * ((k -= 2) * k * k * k * k + 2);
    };

    var SineIn = function (k) {
        if (k === 0) return 0;
        if (k === 1) return 1;
        return 1 - Math.cos(k * Math.PI / 2);
    };

    var SineOut = function (k) {
        if (k === 0) return 0;
        if (k === 1) return 1;
        return Math.sin(k * Math.PI / 2);
    };

    var SineInOut = function (k) {
        if (k === 0) return 0;
        if (k === 1) return 1;
        return 0.5 * (1 - Math.cos(Math.PI * k));
    };

    var ExponentialIn = function (k) {
        return k === 0 ? 0 : Math.pow(1024, k - 1);
    };

    var ExponentialOut = function (k) {
        return k === 1 ? 1 : 1 - Math.pow(2, - 10 * k);
    };

    var ExponentialInOut = function (k) {
        if (k === 0) return 0;
        if (k === 1) return 1;
        if ((k *= 2) < 1) return 0.5 * Math.pow(1024, k - 1);
        return 0.5 * (- Math.pow(2, - 10 * (k - 1)) + 2);
    };

    var CircularIn = function (k) {
        return 1 - Math.sqrt(1 - k * k);
    };

    var CircularOut = function (k) {
        return Math.sqrt(1 - (--k * k));
    };

    var CircularInOut = function (k) {
        if ((k *= 2) < 1) return - 0.5 * (Math.sqrt(1 - k * k) - 1);
        return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
    };

    var ElasticIn = function (k) {
        var s, a = 0.1, p = 0.4;
        if (k === 0) return 0;
        if (k === 1) return 1;
        if (!a || a < 1) { a = 1; s = p / 4; }
        else s = p * Math.asin(1 / a) / (2 * Math.PI);
        return - (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
    };

    var ElasticOut = function (k) {
        var s, a = 0.1, p = 0.4;
        if (k === 0) return 0;
        if (k === 1) return 1;
        if (!a || a < 1) { a = 1; s = p / 4; }
        else s = p * Math.asin(1 / a) / (2 * Math.PI);
        return (a * Math.pow(2, - 10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1);
    };

    var ElasticInOut = function (k) {
        var s, a = 0.1, p = 0.4;
        if (k === 0) return 0;
        if (k === 1) return 1;
        if (!a || a < 1) { a = 1; s = p / 4; }
        else s = p * Math.asin(1 / a) / (2 * Math.PI);
        if ((k *= 2) < 1) return - 0.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
        return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;
    };

    var BackIn = function (k) {
        var s = 1.70158;
        return k * k * ((s + 1) * k - s);
    };

    var BackOut = function (k) {
        var s = 1.70158;
        return --k * k * ((s + 1) * k + s) + 1;
    };

    var BackInOut = function (k) {
        var s = 1.70158 * 1.525;
        if ((k *= 2) < 1) return 0.5 * (k * k * ((s + 1) * k - s));
        return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
    };

    var BounceIn = function (k) {
        return 1 - BounceOut(1 - k);
    };

    var BounceOut = function (k) {
        if (k < (1 / 2.75)) {
            return 7.5625 * k * k;
        } else if (k < (2 / 2.75)) {
            return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;
        } else if (k < (2.5 / 2.75)) {
            return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;
        } else {
            return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;
        }
    };

    var BounceInOut = function (k) {
        if (k < 0.5) return BounceIn(k * 2) * 0.5;
        return BounceOut(k * 2 - 1) * 0.5 + 0.5;
    };

    var Bounce = function (k) {
        if (k < 0.5) return -((4 * k - 1) * (4 * k - 1)) + 1;
        else return (-((4 * k - 3) * (4 * k - 3)) + 1) * 0.5;
    }

    return {
        TweenManager: TweenManager,
        Tween: Tween,
        Linear: Linear,
        QuadraticIn: QuadraticIn,
        QuadraticOut: QuadraticOut,
        QuadraticInOut: QuadraticInOut,
        CubicIn: CubicIn,
        CubicOut: CubicOut,
        CubicInOut: CubicInOut,
        QuarticIn: QuarticIn,
        QuarticOut: QuarticOut,
        QuarticInOut: QuarticInOut,
        QuinticIn: QuinticIn,
        QuinticOut: QuinticOut,
        QuinticInOut: QuinticInOut,
        SineIn: SineIn,
        SineOut: SineOut,
        SineInOut: SineInOut,
        ExponentialIn: ExponentialIn,
        ExponentialOut: ExponentialOut,
        ExponentialInOut: ExponentialInOut,
        CircularIn: CircularIn,
        CircularOut: CircularOut,
        CircularInOut: CircularInOut,
        BackIn: BackIn,
        BackOut: BackOut,
        BackInOut: BackInOut,
        BounceIn: BounceIn,
        BounceOut: BounceOut,
        BounceInOut: BounceInOut,
        ElasticIn: ElasticIn,
        ElasticOut: ElasticOut,
        ElasticInOut: ElasticInOut,
        Bounce: Bounce
    };
}());

// Expose prototype methods and create a default tween manager on the application
(function () {
    // Add pc.Application#addTweenManager method
    pc.AppBase.prototype.addTweenManager = function () {
        this._tweenManager = new pc.TweenManager(this);

        this.on('update', function (dt) {
            this._tweenManager.update(dt);
        });
    };

    // Add pc.Application#tween method
    pc.AppBase.prototype.tween = function (target) {
        return new pc.Tween(target, this._tweenManager);
    };

    // Add pc.Entity#tween method
    pc.Entity.prototype.tween = function (target, options) {
        var tween = this._app.tween(target);
        tween.entity = this;

        this.once('destroy', tween.stop, tween);

        if (options && options.element) {
            // specifiy a element property to be updated
            tween.element = options.element;
        }
        return tween;
    };

    // Create a default tween manager on the application
    var application = pc.Application.getApplication();
    if (application) {
        application.addTweenManager();
    }
})();

// DynamicElement.js
var DynamicElement = pc.createScript('dynamicElement');

var ElementPreset = Object.freeze([
    { NONE: 'NONE' },
    { TOPLEFT: 'TOPLEFT', },
    { TOPLEFT_ANCHOR: 'TOPLEFT_ANCHOR', },
    { TOP: 'TOP', },
    { TOP_ANCHOR: 'TOP_ANCHOR', },
    { TOPRIGHT: 'TOPRIGHT', },
    { TOPRIGHT_ANCHOR: 'TOPRIGHT_ANCHOR', },
    { LEFT: 'LEFT', },
    { LEFT_ANCHOR: 'LEFT_ANCHOR', },
    { CENTER: 'CENTER', },
    { CENTER_ANCHOR: 'CENTER_ANCHOR', },
    { RIGHT: 'RIGHT', },
    { RIGHT_ANCHOR: 'RIGHT_ANCHOR', },
    { BOTTOMLEFT: 'BOTTOMLEFT', },
    { BOTTOMLEFT_ANCHOR: 'BOTTOMLEFT_ANCHOR', },
    { BOTTOM: 'BOTTOM', },
    { BOTTOM_ANCHOR: 'BOTTOM_ANCHOR', },
    { BOTTOMRIGHT: 'BOTTOMRIGHT', },
    { BOTTOMRIGHT_ANCHOR: 'BOTTOMRIGHT_ANCHOR', },
]);

var defaultString = "------------------------------------------------------";

DynamicElement.attributes.add('a', { type: 'string', title: 'Desktop Landscape', default: defaultString });

DynamicElement.attributes.add('desktopLandscapePreset', { type: 'string', enum: ElementPreset, title: 'Preset', default: 'NONE' });
DynamicElement.attributes.add('desktopLandscapeAnchor', { type: 'vec4', title: 'Anchor', });
DynamicElement.attributes.add('desktopLandscapePivot', { type: 'vec2', title: 'Pivot', });
DynamicElement.attributes.add('desktopLandscapePosition', { type: 'vec3', title: 'Position' });
DynamicElement.attributes.add('desktopLandscapeRotation', { type: 'vec3', title: 'Rotation', });
DynamicElement.attributes.add('desktopLandscapeScale', { type: 'vec3', title: 'Scale', default: [1, 1, 1] });

DynamicElement.attributes.add('b', { type: 'string', title: 'Desktop Portrait', default: defaultString });

DynamicElement.attributes.add('desktopPortraitPreset', { type: 'string', enum: ElementPreset, title: 'Preset', default: 'NONE' });
DynamicElement.attributes.add('desktopPortraitAnchor', { type: 'vec4', title: 'Anchor', });
DynamicElement.attributes.add('desktopPortraitPivot', { type: 'vec2', title: 'Pivot', });
DynamicElement.attributes.add('desktopPortraitPosition', { type: 'vec3', title: 'Position' });
DynamicElement.attributes.add('desktopPortraitRotation', { type: 'vec3', title: 'Rotation', });
DynamicElement.attributes.add('desktopPortraitScale', { type: 'vec3', title: 'Scale', default: [1, 1, 1] });

DynamicElement.attributes.add('desktopOrientationScale', { type: 'number', default: 1 });

DynamicElement.attributes.add('c', { type: 'string', title: 'Mobile Landscape', default: defaultString });

DynamicElement.attributes.add('mobileLandscapePreset', { type: 'string', enum: ElementPreset, title: 'Preset', default: 'NONE' });
DynamicElement.attributes.add('mobileLandscapeAnchor', { type: 'vec4', title: 'Anchor', });
DynamicElement.attributes.add('mobileLandscapePivot', { type: 'vec2', title: 'Pivot', });
DynamicElement.attributes.add('mobileLandscapePosition', { type: 'vec3', title: 'Position' });
DynamicElement.attributes.add('mobileLandscapeRotation', { type: 'vec3', title: 'Rotation', });
DynamicElement.attributes.add('mobileLandscapeScale', { type: 'vec3', title: 'Scale', default: [1.5, 1.5, 1.5] });

DynamicElement.attributes.add('d', { type: 'string', title: 'Mobile Portrait', default: defaultString });

DynamicElement.attributes.add('mobilePortraitPreset', { type: 'string', enum: ElementPreset, title: 'Preset', default: 'NONE' });
DynamicElement.attributes.add('mobilePortraitAnchor', { type: 'vec4', title: 'Anchor', });
DynamicElement.attributes.add('mobilePortraitPivot', { type: 'vec2', title: 'Pivot', });
DynamicElement.attributes.add('mobilePortraitPosition', { type: 'vec3', title: 'Position' });
DynamicElement.attributes.add('mobilePortraitRotation', { type: 'vec3', title: 'Rotation' });
DynamicElement.attributes.add('mobilePortraitScale', { type: 'vec3', title: 'Scale', default: [1, 1, 1] });

DynamicElement.attributes.add('updatePosition', { type: 'boolean', default: true, title: 'Update Position' });
DynamicElement.attributes.add('updateRotation', { type: 'boolean', default: true, title: 'Update Rotation' });
DynamicElement.attributes.add('updateScale', { type: 'boolean', default: true, title: 'Update Scale' });
DynamicElement.attributes.add('retry', { type: 'boolean', default: false, title: 'Retry' });

DynamicElement.attributes.add('debug', { type: 'boolean', default: false, title: 'Debug' });

pc.extend(DynamicElement.prototype, {
    initialize: function () {
        this._orientation = '';
        this._device = '';

        this._onResize(ViewportManager.instance.getOrientation(), ViewportManager.instance.width, ViewportManager.instance.height, ViewportManager.instance.getDevice());
        this.app.on('ViewportManager:onResize', this._onResize, this);

        this.on('destroy', this.onDestroy, this);
    },

    onDestroy: function () {
        this.app.off('ViewportManager:onResize', this._onResize, this);
    },

    _setCurrentProperties: function (orientation, device) {

        this._orientation = orientation;
        this._device = device;
    },

    _onResize: function (orientation, width, height, device) {
        if (pc.platform.desktop) {
            const ratio = width / height;

            if (ratio < this.desktopOrientationScale) {
                orientation = orientationEnum.PORTRAIT;
            } else {
                orientation = orientationEnum.LANDSCAPE;
            }
        }

        this._setCorrectOrientation(orientation || 'landscape', device, false);

        if (this.retry) {
            pc.timer.add(1, this._setCorrectOrientation.bind(this, orientation, device, true), this);
        }
    },

    _setCorrectOrientation: function (orientation, device, forced) {
        if (this._orientation === orientation && this._device === device && !forced) {
            return;
        }

        this._setCurrentProperties(orientation, device);

        if (device === deviceEnum.DESKTOP) {
            if (this._orientation === orientationEnum.LANDSCAPE) {
                this._applyOrientationTransform(
                    this.desktopLandscapePreset,
                    this.desktopLandscapePosition,
                    this.desktopLandscapeRotation,
                    this.desktopLandscapeScale,
                    this.desktopLandscapeAnchor,
                    this.desktopLandscapePivot
                );
                return;
            }

            if (this._orientation === orientationEnum.PORTRAIT) {
                this._applyOrientationTransform(
                    this.desktopPortraitPreset,
                    this.desktopPortraitPosition,
                    this.desktopPortraitRotation,
                    this.desktopPortraitScale,
                    this.desktopPortraitAnchor,
                    this.desktopPortraitPivot
                );
                return;
            }

            console.warn('Orientation', this._orientation, 'is not recognized!');
            return;
        }

        if (device === deviceEnum.MOBILE) {
            if (this._orientation === orientationEnum.LANDSCAPE) {
                this._applyOrientationTransform(
                    this.mobileLandscapePreset,
                    this.mobileLandscapePosition,
                    this.mobileLandscapeRotation,
                    this.mobileLandscapeScale,
                    this.mobileLandscapeAnchor,
                    this.mobileLandscapePivot
                );
                return;
            }

            if (this._orientation === orientationEnum.PORTRAIT) {
                this._applyOrientationTransform(
                    this.mobilePortraitPreset,
                    this.mobilePortraitPosition,
                    this.mobilePortraitRotation,
                    this.mobilePortraitScale,
                    this.mobilePortraitAnchor,
                    this.mobilePortraitPivot
                );
                return;
            }

            console.warn('Orientation', this._orientation, 'is not recognized!');
            return;
        }

        console.warn('Device', device, 'is not recognized!');
    },

    _applyOrientationTransform: function (preset, position, rotation, scale, anchor, pivot) {
        if (typeof preset !== 'string') {
            console.error("Preset should be a string", preset);
            return;
        }

        var presetValue = ElementPresetEnum[preset];

        if (!presetValue) {
            console.error("Something went wrong", preset, presetValue);
            return;
        }

        if (this.entity.element === undefined) {
            console.warn(this.entity)
            return;
        }

        if (presetValue.anchor) {
            this.entity.element.anchor.set(presetValue.anchor.x, presetValue.anchor.y, presetValue.anchor.z, presetValue.anchor.w);
        } else {
            this.entity.element.anchor.set(anchor.x, anchor.y, anchor.z, anchor.w);
        }

        if (presetValue.pivot) {
            this.entity.element.pivot.set(presetValue.pivot.x, presetValue.pivot.y);
        } else {
            this.entity.element.pivot.set(pivot.x, pivot.y);
        }

        this.entity.element.anchor = this.entity.element.anchor;
        this.entity.element.pivot = this.entity.element.pivot;

        if (this.debug) {
            console.warn("scale", scale)
        }

        if (this.updatePosition) this.entity.setLocalPosition(position);
        if (this.updateRotation) this.entity.setLocalEulerAngles(rotation);
        if (this.updateScale) this.entity.setLocalScale(scale);
    },

    getScale: function () {
        if (this._device === deviceEnum.DESKTOP) {
            if (this._orientation === orientationEnum.LANDSCAPE) {
                return this.desktopLandscapeScale;

            }

            if (this._orientation === orientationEnum.PORTRAIT) {
                return this.desktopPortraitScale;
            }

        }

        if (this._device === deviceEnum.MOBILE) {
            if (this._orientation === orientationEnum.LANDSCAPE) {
                return this.mobileLandscapeScale;
            }

            if (this._orientation === orientationEnum.PORTRAIT) {
                return this.mobilePortraitScale;
            }
        }
    },

    getPosition: function () {
        if (!this._device) {
            this._device = ViewportManager.instance.getDevice();
        }

        if (!this._orientation) {
            this._orientation = ViewportManager.instance.getOrientation();
        }

        if (this._device === deviceEnum.DESKTOP) {
            if (this._orientation === orientationEnum.LANDSCAPE) {
                return this.desktopLandscapePosition;

            }

            if (this._orientation === orientationEnum.PORTRAIT) {
                return this.desktopPortraitPosition;
            }

        }

        if (this._device === deviceEnum.MOBILE) {
            if (this._orientation === orientationEnum.LANDSCAPE) {
                return this.mobileLandscapePosition;
            }

            if (this._orientation === orientationEnum.PORTRAIT) {
                return this.mobilePortraitPosition;
            }
        }
    },
});


// NotificationBadge.js
var NotificationBadge = pc.createScript('notificationBadge');

NotificationBadge.attributes.add('id', { type: 'string', default: 'TEMPLATE_ID', description: 'This is an unique id, which is used to get the correct notification badge.' });
NotificationBadge.attributes.add('textEntity', { type: 'entity', description: 'Optional: A text entity in the notification badge that needs to be changed.', });
NotificationBadge.attributes.add('tween', {
    'type': 'string',
    enum: [
        { "None": "null" },
        { "Tween Scale": 'tweenScale' },
        { "Tween Position": 'tweenPosition' },
        { "Tween Rotation": 'tweenRotation' },
        { "Tween Alpha": 'tweenAlpha' },
    ]
});

NotificationBadge.attributes.add('disableOnClick', { type: 'boolean', default: false, description: 'If true, this notification badge will be disabled automatically when clicked on the button. It can also be disabled with the function "disable"' });
NotificationBadge.attributes.add('buttonEntity', { type: 'entity' });

NotificationBadge.attributes.add('target', { type: 'entity' });
NotificationBadge.attributes.add('debug', { type: 'boolean' });

/*
 * A compontent to regulate the behaviour of a notification badge. Its id should be unique and used to trigger the behaviour of a notification badge.
 *
 */
pc.extend(NotificationBadge.prototype, {

    initialize: function () {
        NotificationBadgeManager.instance.initializeBadge(this.entity, this.id);
if (this.debug) {
    console.log(this.entity)
}
        this._setDisableEvent();
    },

    postInitialize: function () {
        if (this.target) {
            if (!this.target.script) {
                this.target.addComponent('script');
            }

            if (!this.target.script.has('stateChecker')) {
                this.target.script.create('stateChecker');
            }

            this.target.script.stateChecker.on('state', (enabled) => {
                this.setState();
            }, this);
        }

        this.setState();
    },

    _setDisableEvent: function () {
        if (this.disableOnClick) {
            if (this.buttonEntity) {
                if (this.buttonEntity.script && this.buttonEntity.script.switchUibutton) {
                    this.buttonEntity.script.switchUibutton.on('click', this.disable, this);
                } else {
                    this.buttonEntity.element.on('click', this.disable, this);
                }
            } else {
                if (this.entity.parent.element) {
                    this.entity.parent.element.on('click', this.disable, this);
                } else {
                    console.warn('No viable button could be found.');
                }
            }
        }
    },

    setState: function (properties) {
        if (!properties) {
            properties = NotificationBadgeManager.instance.getBadgeProperties(this.id);
        }

        if (!properties) {
            console.warn('No properties are found with the id', this.id);
            return;
        }

        if (this.target && !this.target.enabled) {
            this.entity.enabled = false;
            return;
        }

        this.entity.enabled = properties.enabled;

        if (this.entity.enabled) {
            this._startTween();
        } else {
            this._stopTween();
        }

        if (this.textEntity && this.textEntity.element) {
            this.textEntity.element.text = properties.text;
        }
    },

    _startTween: function () {
        if (this.tween && this.tween !== "null") {
            if (this.entity.script[this.tween]) {
                this.entity.script[this.tween].startTween();
            } else {
                console.warn(this.entity.name, "doesn't have the script", this.tween);
            }
        }
    },

    _stopTween: function () {

    },

    hide: function() {
        this.entity.enabled = false;
    },

    show: function() {
        this.entity.enabled = true;
    },

    disable: function () {
        this.entity.enabled = false;

        NotificationBadgeManager.instance.setBadgeProperties(this.id, false);
    },
});


// NotificationBadgeManager.js
var NotificationBadgeManager = pc.createScript('notificationBadgeManager');

/*
 * A manager of all notification badges.
 *
 * Usage: Use this event (NotificationBadgeManager:set) to communicate with a certain notification badge. 
 * See function setBadgeProperties for more information.
 */
pc.extend(NotificationBadgeManager.prototype, {
    
    initialize: function() {
        if (Singleton.instance.canCreateInstance(this)) {
            NotificationBadgeManager.instance = this;
        }
        
        this._badgeStates = Object.freeze({
            DISABLED: false,
            ENABLED: true,
        });
        
        this._notificationBadges = {};
        
        this.app.on('NotificationBadgeManager:set', this.setBadgeProperties, this);
    },
    
    initializeBadge: function(entity, id) {
        const property = this._getProperty(id);
        
        if (property.id === 'TEMPLATE_ID') {
            console.warn('Change the id of the notification badge with the id', id);
            return;
        }  
        
        property.entities.push(entity);
        
        return property;
    },
    
    _createProperty: function(id) {
        this._notificationBadges[id] = { enabled: this._badgeStates.DISABLED, text: null, entities: [] };
        
        return this._notificationBadges[id];
    },
    
    _getProperty: function(id) {
        let property = this._notificationBadges[id];
        
        if (!property) {
            this._notificationBadges[id] = this._createProperty(id);
            
            property = this._notificationBadges[id];
        }
        
        return property;
    },
    
    /*
     * Set the properties of the notification badge. 
     *
     * @param { string } id - Unique id.
     * @param { boolean } enabled - Enable or disable the notification badge.
     * @param { string= } text - Optional. Text which the notication badge shows.
     */
    setBadgeProperties: function(id, enabled, text) {
        var properties = this._getProperty(id);
        
        properties.enabled = enabled;
        
        if (text) {
            properties.text = text;
        }
        
        properties.entities.forEach(entity => entity.script.notificationBadge.setState(properties));
    },
    
    /*
     * Return all properties of the unique id.
     * 
     * @param {string} id - Unique id of the notification.
     */
    getBadgeProperties: function(id) {        
        return this._notificationBadges[id];
    },
});


// PauseScreen.js
var PauseScreen = pc.createScript('pauseScreen');

PauseScreen.attributes.add('quitButton', { type: 'entity', });

pc.extend(PauseScreen.prototype, {

    initialize: function () {
        this.quitButton.script.elementInput.on('click', this.onQuit, this);
    },

    async onQuit() {
        Wrapper.instance.showInterstitialAd('quit_level', () => {
            this.app.fire('UIManager:hideUI', 'Pause', 'QUIT');
        });
    },

    onUIEntityOpen: function (args) {
        PlayerData.instance.inputBetweenGames = false;

        if (args === "PAUSE") {
            return GameManager.instance.trackEventPause();
        }
    },

    onUIEntityOpenFinish: function (args) {
        PauseManager.instance.pause();
    },

    onUIEntityClose: function (args) {
        PauseManager.instance.resume();
        PlayerData.instance.inputBetweenGames = true;
    },

    onUIEntityCloseFinish: function (args) {

        var promise = null;

        if (args) {
            if (args === 'CONTINUE') {
                promise = GameManager.instance.trackEventResume();

                return promise;
            } else if (args === 'QUIT') {
                promise = GameManager.instance.trackEventLevelQuit();

                promise.then(() => {
                    this.app.fire('UIManager:showUI', 'LoadingScreen');

                    LivesManager.instance.reduceLife(1, 'quit');

                    LoadingScreen.instance.setType(LoadingScreen.TYPES.ASSETS).once('fadeInComplete', () => {
                        AssetManager.instance.loadBookAssets(WorldManager.instance.getWorldIndex(), this._onAssetsLoaded, this);
                    });
                });

                return promise;
            }
        }
    },

    _onAssetsLoaded() {
        this.app.fire('UIManager:hideUI', 'LoadingScreen');

        this.app.fire('UIManager:hideAll');
        this.app.fire('UIManager:showUI', 'Book', { key: 'currentLevel' });

        LevelManager.instance.reset();
        TutorialManager.instance.endTutorial(true);
        this.app.fire('ConfirmLeaveGameButton:leave');
    }
});

// ViewportManager.js
var ViewportManager = pc.createScript('viewportManager');

ViewportManager.attributes.add('delay', { type: 'number', default: 100, title: 'Delay', description: 'Time till the dimension of the viewport is recalculated.', placeholder: 'ms' });
ViewportManager.attributes.add('delayIOS', { type: 'number', default: 300, title: 'Delay IOS', description: 'Time till the dimension of the viewport is recalculated.', placeholder: 'ms' });
ViewportManager.attributes.add('tabletWidthHeightRatio', { type: 'number', default: 1.6 });
ViewportManager.attributes.add('recheckDelay', { type: 'number', default: 2000, });

pc.extend(ViewportManager.prototype, {

    initialize: function () {
        if (Singleton.instance.canCreateInstance(this)) {
            ViewportManager.instance = this;
        }

        this.currentWidth = this.width;
        this.currentHeight = this.height;

        this.offsets = Wrapper.instance.getOffsets();

        this.calculateDPR();

        this.app.graphicsDevice.on('resizecanvas', this.onOrientationChange, this);
        Wrapper.instance.setOnOrientationChange(this.onOrientationChange, this);
        Wrapper.instance.setOffsetCallback(this.onOrientationChange.bind(this));

        /** viewport resize handling **/
        if (window.visualViewport) {
            window.visualViewport.addEventListener('resize', this.onOrientationChange.bind(this));
        } else {
            window.addEventListener('resize', this.onOrientationChange.bind(this), true);
        }

        this._onResize();

    },

    postInitialize: function () {
        this._longTimeout = pc.timer.add(this.recheckDelay, this._recheck, this);
    },

    /**
     * Send event that the game has been resized. Send 4 parameters: orientation, innerWidth, innerHeight and device;
     */

    onOrientationChange: function () {
        clearTimeout(this._timeout);
        pc.timer.remove(this._longTimeout);

        this.app.fire('ViewportManager:preResize');

        this._timeout = setTimeout(this._onResize.bind(this), pc.platform.ios ? this.delayIOS : this.delay);
    },

    _onResize: function () {
        const famobiOffsets = Wrapper.instance.getOffsets();

        const topPixels = famobiOffsets.top;
        const bottomPixels = famobiOffsets.bottom;
        const leftPixels = famobiOffsets.left;
        const rightPixels = famobiOffsets.right;

        const screenResHeight = this.screenHeight;
        const screenResWidth = this.screenWidth;
        this.availableWidth = screenResWidth - leftPixels - rightPixels;
        this.availableHeight = screenResHeight - topPixels - bottomPixels;

        this.app.setCanvasResolution(pc.RESOLUTION_FIXED, this.availableWidth, this.availableHeight);
        this.app.graphicsDevice.canvas.style.width = this.availableWidth + 'px';
        this.app.graphicsDevice.canvas.style.height = this.availableHeight + 'px';

        this.app.graphicsDevice.canvas.style.left = leftPixels + 'px';
        this.app.graphicsDevice.canvas.style.right = rightPixels + 'px';
        this.app.graphicsDevice.canvas.style.top = topPixels + 'px';
        this.app.graphicsDevice.canvas.style.bottom = bottomPixels + 'px';

        // this.app.updateCanvasSize();

        this.currentWidth = this.screenWidth;
        this.currentHeight = this.screenHeight;

        this.app.fire('ViewportManager:onResize', this.getOrientation(), this.availableWidth, this.availableHeight, this.getDevice());

        this._longTimeout = setTimeout(this.recheckDelay, this._recheck, this);
    },

    _recheck: function () {
        if (this.currentWidth !== this.width || this.currentHeight !== this.height) {
            this._onResize();
        }
    },

    getDevice: function () {
        if (pc.platform.desktop) {
            return deviceEnum.DESKTOP;
        }

        if (pc.platform.mobile) {
            if (this.width > this.height) {
                if ((this.width / this.height) < this.tabletWidthHeightRatio) {
                    return deviceEnum.DESKTOP;
                }
            }

            if (this.height >= this.width) {
                if ((this.height / this.width) < this.tabletWidthHeightRatio) {
                    return deviceEnum.DESKTOP;
                }
            }

            return deviceEnum.MOBILE;
        }

        return '';
    },

    getOrientation: function () {
        var orientation = Wrapper.instance.getOrientation();
        return orientation && orientation !== '' ? orientation : 'landscape';
    },

    calculateDPR: function () {
        this._dpr = Math.max(Math.min(window.devicePixelRatio, this.app.graphicsDevice.maxPixelRatio), 1);
    },

    getDPR: function () {
        return this._dpr;
    },

});

Object.defineProperty(ViewportManager.prototype, 'width', {
    get: function () {
        return this.availableWidth
    }
});

Object.defineProperty(ViewportManager.prototype, 'height', {
    get: function () {
        return this.availableHeight
    }
});

Object.defineProperty(ViewportManager.prototype, 'screenWidth', {
    get: function () {
        try {
            return document.documentElement.clientWidth;
        } catch (e) {

        }

        return window.innerWidth;
    }
});

Object.defineProperty(ViewportManager.prototype, 'screenHeight', {
    get: function () {
        try {
            return document.documentElement.clientHeight;
        } catch (e) {

        }

        return window.innerHeight;
    }
});


// GlobalEnumarator.js
var deviceEnum = Object.freeze({
    DESKTOP: 'desktop',
    MOBILE: 'mobile',
});

var orientationEnum = Object.freeze({
    LANDSCAPE: 'landscape',
    PORTRAIT: 'portrait',
});

var ElementPresetEnum = Object.freeze({
    TOPLEFT: {
        anchor: new pc.Vec4(0, 1, 0, 1),
        pivot: new pc.Vec2(0, 1),
    },
    TOPLEFT_ANCHOR: {
        anchor: new pc.Vec4(0, 1, 0, 1),
    },
    TOP: {
        anchor: new pc.Vec4(0.5, 1, 0.5, 1),
        pivot: new pc.Vec2(0.5, 1),
    },
    TOP_ANCHOR: {
        anchor: new pc.Vec4(0.5, 1, 0.5, 1),
    },
    TOPRIGHT: {
        anchor: new pc.Vec4(1, 1, 1, 1),
        pivot: new pc.Vec2(1, 1),
    },
    TOPRIGHT_ANCHOR: {
        anchor: new pc.Vec4(1, 1, 1, 1),
    },
    LEFT: {
        anchor: new pc.Vec4(0, 0.5, 0, 0.5),
        pivot: new pc.Vec2(0, 0.5),
    },
    LEFT_ANCHOR: {
        anchor: new pc.Vec4(0, 0.5, 0, 0.5),
    },
    CENTER: {
        anchor: new pc.Vec4(0.5, 0.5, 0.5, 0.5),
        pivot: new pc.Vec2(0.5, 0.5),
    },
    CENTER_ANCHOR: {
        anchor: new pc.Vec4(0.5, 0.5, 0.5, 0.5),
    },
    RIGHT: {
        anchor: new pc.Vec4(1, 0.5, 1, 0.5),
        pivot: new pc.Vec2(1, 0.5),
    },
    RIGHT_ANCHOR: {
        anchor: new pc.Vec4(1, 0.5, 1, 0.5),
    },
    BOTTOMLEFT: {
        anchor: new pc.Vec4(0, 0, 0, 0),
        pivot: new pc.Vec2(0, 0),
    },
    BOTTOMLEFT_ANCHOR: {
        anchor: new pc.Vec4(0, 0, 0, 0),
    },
    BOTTOM: {
        anchor: new pc.Vec4(0.5, 0, 0.5, 0),
        pivot: new pc.Vec2(0.5, 0),
    },
    BOTTOM_ANCHOR: {
        anchor: new pc.Vec4(0.5, 0, 0.5, 0),
    },
    BOTTOMRIGHT: {
        anchor: new pc.Vec4(1, 0, 1, 0),
        pivot: new pc.Vec2(1, 0),
    },
    BOTTOMRIGHT_ANCHOR: {
        anchor: new pc.Vec4(1, 0, 1, 0),
    },
    NONE: {
        
    }
});

var LayoutOrientationEnum = Object.freeze({
    VERTICAL: pc.ORIENTATION_VERTICAL,
    HORIZONTAL: pc.ORIENTATION_HORIZONTAL
});

// DynamicGroup.js
var DynamicGroup = pc.createScript('dynamicGroup');

DynamicGroup.attributes.add('desktopClamp', { type: 'boolean', default: true });
DynamicGroup.attributes.add('desktopClampWidth', { type: 'number', default: 1500 });

DynamicGroup.attributes.add('mobileClamp', { type: 'boolean', default: false });
DynamicGroup.attributes.add('mobileClampWidth', { type: 'number', default: 0 });

DynamicGroup.attributes.add('ignoreHeight', { type: 'boolean', });

DynamicGroup.attributes.add('debug', { type: 'boolean', default: false });

pc.extend(DynamicGroup.prototype, {

    initialize: function () {
        this._onResize(ViewportManager.instance.getOrientation(), ViewportManager.instance.width, ViewportManager.instance.height, ViewportManager.instance.getDevice());

        this.app.on('ViewportManager:onResize', this._onResize, this);
    },

    _onResize: function (orientation, width, height, device) {
        this._calculateDimensions(width, height);
        this._setClamp(device);
    },

    _calculateDimensions: function (width, height) {
        var scale = UIManager.instance.getReferenceResolution().y / height;

        if (!this.entity.element) return;
        this.entity.element.width = width * scale;

        if (!this.ignoreHeight) {
            this.entity.element.height = height * scale;
        }
    },

    _setClamp: function (device) {
        if (!this.entity.element) {
            return
        }

        var clamp = false;
        var clampWidth = 0;

        if (device === deviceEnum.DESKTOP) {
            clamp = this.desktopClamp;
            clampWidth = this.desktopClampWidth;
        }

        if (device === deviceEnum.MOBILE) {
            clamp = this.mobileClamp;
            clampWidth = this.mobileClampWidth;
        }

        if (clamp) {

            var width = this.entity.element.width;

            if (width > clampWidth) {
                this.entity.element.width = clampWidth;

                if (this.debug) {
                    console.log(this.entity.element.width)
                }
            }
        }

        this.fire('onChange');
    },
});


// InputManager.js
var InputManager = pc.createScript('inputManager');

InputManager.attributes.add('disableContextMenu', { type: 'boolean', default: true, description: 'Disable the context menu usually activated with right-click.', title: 'Disable Context Menu' });
InputManager.attributes.add('preventDefault', { type: 'boolean', default: true, title: 'Prevent Default' }); 
InputManager.attributes.add('disablePreventDefaultForKeyboardCodes', { type: 'string', array: true, default: ['F12', 'F5'] });

pc.extend(InputManager.prototype, {

    initialize: function() {
        if (Singleton.instance.canCreateInstance(this)) {
            InputManager.instance = this;
        }

        this._supportTouch = pc.platform.touch;
        this._supportMouse = true; // pc.platform.desktop; Mouse can be connected with almost any device.

        this._hasFocus = document.hasFocus();

        window.addEventListener('focus', this._onFocus.bind(this));
        window.addEventListener('blur', this._onBlur.bind(this));

        if (this._supportTouch) {
            if (this.disableContextMenu) {
                this.app.mouse.disableContextMenu();
            }
        }
        
        if (this.app.mouse) {
            this.app.mouse.on(pc.EVENT_MOUSEDOWN, this._onInput, this);
            this.app.mouse.on(pc.EVENT_MOUSEUP, this._onInput, this);
            //this.app.mouse.on(pc.EVENT_MOUSEMOVE, this._onInput, this);
            this.app.mouse.on(pc.EVENT_MOUSEWHEEL, this._onInput, this);
        }

        if (this.app.keyboard) {
            this.app.keyboard.on(pc.EVENT_KEYDOWN, this._onKeyInput, this);
            this.app.keyboard.on(pc.EVENT_KEYUP, this._onKeyInput, this);
        }

        if (this.app.touch) {
            this.app.touch.on(pc.EVENT_TOUCHCANCEL, this._onInput, this);
            this.app.touch.on(pc.EVENT_TOUCHEND, this._onInput, this);
            this.app.touch.on(pc.EVENT_TOUCHMOVE, this._onInput, this);
            this.app.touch.on(pc.EVENT_TOUCHSTART, this._onInput, this);
        }
    },

    _onFocus: function() {
        this._hasFocus = true;
    },

    _onBlur: function() {
        this._hasFocus = false;
    },

    _sendInputEvent: function(event) {
        this.app.fire('InputManager:input', event);  
    },

    _onInput: function(event) {
        this.doPreventDefault(event);
        this._sendInputEvent(event);
    },

    _onKeyInput: function(event) {
        this.keyboardPreventDefault(event);
        this._sendInputEvent(event);
    },

    getSupportTouch: function() {
        return this._supportTouch;
    },

    getSupportMouse: function() {
        return this._supportMouse;
    },
    
    // Prevent keyboard input, but it will ignore if its in the disable list.
    keyboardPreventDefault: function(event) {
        var index = this.disablePreventDefaultForKeyboardCodes.indexOf(event.event.code);  

        if (index === -1) {
            this.doPreventDefault(event);
        }
    },

    // When using this.app.mouse, this.app.touch or this.app.keyboard, make use of this function. 
    // It make sure that the input doesn't have a default behaviour on the browser, like scrolling up and down. 
    doPreventDefault: function(event) {
        if (!event) {
            console.warn("Event is undefined");
            return;
        }

        if (this.preventDefault && this._hasFocus) {
            event.event.preventDefault();
        }  
    },
});


// ElementInput.js
var ElementInput = pc.createScript('elementInput');

ElementInput.attributes.add('inputDownEvent', { type: 'boolean', default: false, title: 'Input Down Event', description: 'Send a input down event' });
ElementInput.attributes.add('inputUpEvent', { type: 'boolean', default: false, title: 'Input Up Event', description: 'Send a input up event' });
ElementInput.attributes.add('inputClickEvent', { type: 'boolean', default: true, title: 'Input Click Event', description: 'Send a input click event' });
ElementInput.attributes.add('inputMoveEvent', { type: 'boolean', default: false, title: 'Input Move Event', description: 'Send a input move event' });
ElementInput.attributes.add('clickSFX', { type: 'string', default: "button_click.mp3" });
ElementInput.attributes.add('debug', { type: 'boolean', default: false });
ElementInput.attributes.add('instant', { type: 'boolean', default: false });

var inputEvents = Object.freeze({
    DOWN: 'down',
    UP: 'up',
    CLICK: 'click',
    MOVE: 'move',
});

pc.extend(ElementInput.prototype, {
    initialize: function () {
        GameInput.instance = this;

        if (this.clickSFX !== 'button_click.mp3') {
            this.clickSFX = 'button_click.mp3';
        }

        this._touch = InputManager.instance.getSupportTouch();
        this._mouse = InputManager.instance.getSupportMouse();

        this._element = this.entity.element;
        this._button = this.entity.button;
        this._enter = false;
        this._inputDown = false;
        this._createButtonEvents();
        this._createElementEvents();

        this._events = [];
    },

    executeEvents: function () {
        try {
            this._events.forEach(event => {
                this.fire(event.inputEvent, event.event);
            });
        } catch (e) {
            Sentry.captureException(e);
        }

        delete this.timer;

        this._events.length = 0;
    },

    _createButtonEvents: function () {
        this.on('enable', this._resetButton, this);
    },

    _resetButton: function () {
        if (this._button) {
            this._button._isHovering = false;
        }
    },
    _createElementEvents: function () {
        if (!this._element) {
            console.warn('This entity with the name', this.entity.name, 'has no element component!');
            return;
        }

        if (!this._element.useInput) {
            // console.warn('This entity with the name', this.entity.name, 'has input disabled! Please turn it on.');
        }

        if (this._touch) {
            this._element.on(pc.EVENT_TOUCHSTART, this._onTouchStart, this);
            this._element.on(pc.EVENT_TOUCHMOVE, this._onTouchMove, this);
            this._element.on('touchleave', this._onTouchLeave, this);
            this._element.on(pc.EVENT_TOUCHEND, this._onTouchEnd, this);
        }

        if (this._mouse) {
            this._element.on(pc.EVENT_MOUSEDOWN, this._onMouseDown, this);
            this._element.on(pc.EVENT_MOUSEMOVE, this._onMouseMove, this);
            this._element.on('mouseleave', this._onMouseLeave, this);
            this._element.on('mouseenter', this._onMouseEnter, this);
            this._element.on(pc.EVENT_MOUSEUP, this._onMouseUp, this);
        }
    },

    _onTouchStart: function (event) {
        if (!this.getButtonActive()) return;
        this._inputDown = true;
        this._enter = true;
        this._sendDownEvent(event);
        this.fire('onButtonInputChange', this._inputDown, this._enter, this.getButtonActive());
    },

    _onTouchEnd: function (event) {
        if (!this.getButtonActive()) return;

        this._sendUpEvent(event);

        if (this._button) {
            this._button._onTouchEnd(event);
        }

        if (this._enter && this._inputDown) {
            this._sendClickEvent(event);
        }

        this._enter = false;
        this._inputDown = false;
        this.fire('onButtonInputChange', this._inputDown, this._enter, this.getButtonActive());
    },

    _onTouchLeave: function (event) {
        if (!this.getButtonActive()) return;

        this._enter = false;
        this._inputDown = false;
        this.fire('onButtonInputChange', this._inputDown, this._enter, this.getButtonActive());
    },

    _onTouchMove: function () {
        if (!this.getButtonActive()) return;

        if (this._enter) {
            this._sendMoveEvent(event);
        }
    },

    _onMouseDown: function (event) {
        if (!this.getButtonActive()) return;

        this._inputDown = true;
        this._enter = true;
        this._sendDownEvent(event);
        this.fire('onButtonInputChange', this._inputDown, this._enter, this.getButtonActive());
    },

    _onMouseLeave: function (event) {
        if (!this.getButtonActive()) return;

        this._enter = false;
        this._inputDown = false;
        this.fire('onButtonInputChange', this._inputDown, this._enter, this.getButtonActive());
    },

    _onMouseEnter: function (event) {
        if (!this.getButtonActive()) return;

        this._enter = true;
        this.fire('onButtonInputChange', this._inputDown, this._enter, this.getButtonActive());
    },

    _onMouseMove: function (event) {
        if (!this.getButtonActive()) return;

        if (this._inputDown && this._enter) {
            this._sendMoveEvent(event);
        }
    },

    _onMouseUp: function (event) {
        if (!this.getButtonActive()) return;

        this._sendUpEvent(event);

        if (this._enter && this._inputDown) {
            this._sendClickEvent(event);
        }

        this._enter = false;
        this._inputDown = false;
        this.fire('onButtonInputChange', this._inputDown, this._enter, this.getButtonActive());
    },

    _sendMoveEvent: function (event) {
        if (this.inputMoveEvent) {
            this.addEvent(inputEvents.MOVE, event);
        }
    },

    _sendDownEvent: function (event) {
        if (this.inputDownEvent) {
            this.addEvent(inputEvents.DOWN, event);
        }
    },

    _sendUpEvent: function (event) {
        if (this.inputUpEvent) {
            this.addEvent(inputEvents.UP, event);
        }
    },

    _sendClickEvent: function (event) {
        if (this.inputClickEvent) {
            if (this.clickSFX) {
                this.app.fire('Audio:sfx', this.clickSFX);
            }

            if (this.instant) {
                this.fire(inputEvents.CLICK, event);
            } else {
                this.addEvent(inputEvents.CLICK, event);
            }
        }
    },

    setActive: function (isActive) {
        this._button.active = isActive;
        this.fire('onButtonInputChange', this._inputDown, this._enter, this.getButtonActive());
    },

    getButtonActive: function () {
        if (this._button) {
            return this._button.active;
        } else {
            return true;
        }
    },

    addEvent(inputEvent, event) {
        this._events.push({
            inputEvent: inputEvent,
            event: event,
        });

        if (this.timer) {
            return;
        }

        this.timer = pc.timer.add(0, this.executeEvents, this);
    },

});

// Wrapper.js
var Wrapper = pc.createScript('wrapper');

Wrapper.attributes.add('api', { type: 'string', enum: [{ DEFAULT: 'defaultApi' }, { FAMOBI: 'famobiApi' }] });

pc.extend(Wrapper.prototype, {

    initialize: function () {
        Wrapper.instance = this;

        this._script = this._getAPIScript();
    },

    _getAPIScript: function () {
        if (!this.entity.script[this.api]) {
            console.warn("There is no api script", this.api);
            return;
        }

        return this.entity.script[this.api];
    },

    getBrandingButtonImage: function () {
        return this._script.getBrandingButtonImage();
    },

    moreGamesLink: function () {
        this._script.moreGamesLink();
    },

    showAd: function () {
        return this._script.showAd();
    },

    showInterstitialAd: function (eventId, callback) {
        this.app.fire("UIManager:showUI", 'InputDisabler');
        const _callback = () => {
            this.app.fire("UIManager:hideUI", 'InputDisabler');
            callback();
        }
        this._script.showInterstitialAd(eventId, _callback);
    },

    hasRewardedAd: function () {
        return this._script.hasRewardedAd();
    },

    rewardedAd: function (callback, context) {
        this._script.rewardedAd(callback.bind(context));
    },

    setOnPauseRequested: function (onPauseFunction, context) {
        this._script.setOnPauseRequested(onPauseFunction, context);
    },

    setOnResumeRequested: function (onResumeFunction, context) {
        this._script.setOnResumeRequested(onResumeFunction, context);
    },

    get: function (key) {
        return this._script.get(key);
    },

    getCurrentLanguage: function () {
        return this._script.getCurrentLanguage();
    },

    setLocalStorageItem: function (key, value, localStorageOnly, ignoreTimeSaved) {
        var now = Date.now();

        if (Firebase.instance.loggedIn() && Firebase.instance.loaded && !localStorageOnly) {
            Firebase.instance.save(key, value);

            if (!ignoreTimeSaved) {
                Firebase.instance.save('timeSaved', now);
            }
        }

        this._script.setLocalStorageItem(key, JSON.stringify(value));

        if (!ignoreTimeSaved) {
            this._script.setLocalStorageItem('timeSaved', JSON.stringify(now));
        }
    },

    getLocalStorageItem: function (key) {
        const value = this._script.getLocalStorageItem(key)
        try {
            return JSON.parse(value);
        } catch (e) {
            return value;
        }
    },

    removeLocalStorageItem: function (key) {
        this._script.removeLocalStorageItem(key);
    },

    clearLocalStorage: function () {
        this._script.clearLocalStorage();
    },

    localStorageHasKey: function () {
        return this._script.localStorageHasKey();
    },

    setSessionStorageItem: function (key, value) {
        this._script.setSessionStorageItem(key, value);
    },

    getSessionStorageItem: function (key) {
        return this._script.getSessionStorageItem(key);
    },

    removeSessionStorageItem: function (key) {
        this._script.removeSessionStorageItem(key);
    },

    clearSessionStorage: function () {
        this._script.clearSessionStorage();
    },

    getOrientation: function () {
        return this._script.getOrientation();
    },

    setOnOrientationChange: function (callback, context) {
        this._script.setOnOrientationChange(callback.bind(context));
    },

    gameReady: function () {
        this._script.gameReady();
    },

    hasFeature: function (feature) {
        return this._script.hasFeature(feature);
    },

    onRequest: function (event, callback) {
        this._script.onRequest(event, callback);
    },

    getFeatureProperties: function (feature) {
        return this._script.getFeatureProperties(feature);
    },

    getVolume: function () {
        return this._script.getVolume();
    },

    playerReady: function () {
        this._script.playerReady();
    },

    _checkHasRewardedAd: function () {
        if (this.hasRewardedAd()) {
            return;
        }
    },

    sendGAEvent(...params) {
        this._script.sendGAEvent(...params)
    },

    getOffsets() {
        return this._script.getOffsets();
    },

    setOffsetCallback(...params) {
        this._script.setOffsetCallback(...params)
    },
});

Wrapper.GA_EVENT_TYPE = Object.freeze({
    BUSINESS: 'business',
    RESOURCE: 'resource',
    PROGRESSION: 'progression',
    ERROR: 'error',
    DESIGN: 'design',
});

// DefaultAPI.js
var DefaultApi = pc.createScript('defaultApi');

var templateName = 'TEMPLATE_NAME-'

DefaultApi.attributes.add('templateName', { type: 'string', default: templateName, title: 'Template Name', description: 'This value is used for saving in the localStorage. Make sure to make it unique, so it doesn\'t override any other storages.' });
DefaultApi.attributes.add('hasRewardedAdValue', { type: 'boolean', default: true });
DefaultApi.attributes.add('interstitialAdDuration', { type : 'number', default: 3000 });
DefaultApi.attributes.add('rewardedAdDuration', { type : 'number', default: 3000 });
DefaultApi.attributes.add('currentLanguage', { type: 'string', default: 'en', 'title': 'Default Language', enum: [
    { 'German':     'de' },
    { 'English':    'en' },
    { 'Turkish':    'tr' },
    { 'Polish':     'pl' },
    { 'Russian':    'ru' },
    { 'Dutch':      'nl' },
    { 'Spanish':    'es' },
    { 'Portuguese': 'pt' },
    { 'French':     'fr' },
]});

pc.extend(DefaultApi.prototype, {
    
    initialize: function() {
        if (this.templateName === templateName) {
            console.warn("Please change the template name of the API");
        }
    },

    getBrandingButtonImage: function() {
        return 'randomLink';
    },

    moreGamesLink: function() {
        alert("Opening more games");
    },

    showInterstitialAd: function() {
        console.log("[Show Interstitital Ad] Waiting for " + this.interstitialAdDuration / 1000 + " seconds");

        if (typeof window.defaultAPI_onPauseRequested === 'function') {
            window.defaultAPI_onPauseRequested();    
        }

        var duration = this.interstitialAdDuration;
        
        return new Promise(function(resolve, reject) {
            this.timeoutInterstitial = setTimeout(function() {
                if (typeof window.defaultAPI_onResumeRequested === 'function') {
                    window.defaultAPI_onResumeRequested();    
                }
                clearTimeout(this.timeoutInterstitial);
                resolve();
            }, duration);
        });
    },

    hasRewardedAd: function() {
        return this.hasRewardedAdValue;
    },

    rewardedAd: function(callback) {
        console.log("[Show Rewarded Ad] Waiting for " + this.rewardedAdDuration / 1000 + " seconds");

        if (typeof window.defaultAPI_onPauseRequested === 'function') {
            window.defaultAPI_onPauseRequested();    
        }

        this.timeoutRewarded = setTimeout(function() {
            if (typeof window.defaultAPI_onResumeRequested === 'function') {
                window.defaultAPI_onResumeRequested();    
            }
            clearTimeout(this.timeoutRewarded);
            callback();
        }, this.rewardedAdDuration);
    },

    setOnPauseRequested: function(onPauseFunction, context) {
        window.defaultAPI_onPauseRequested = onPauseFunction.bind(context || this);
    },

    setOnResumeRequested: function(onResumeFunction, context) {
        window.defaultAPI_onResumeRequested = onResumeFunction.bind(context || this);
    },

    get: function(key) {
        console.log("need a smart solution for this.");

        return key;
    },

    getCurrentLanguage: function() {
        return this.currentLanguage;
    },

    setLocalStorageItem: function(key, value) {
        window.localStorage.setItem(this.templateName + ":" + key, value);
    },

    getLocalStorageItem: function(key) {
        return window.localStorage.getItem(this.templateName + ":" + key);
    },

    removeLocalStorageItem: function(key) {
        window.localStorage.removeItem(this.templateName + ":" + key);
    },

    clearLocalStorage: function() {
        for (var key in window.localStorage) {
            if (key.startsWith(this.templateName + ":")) {
                window.localStorage.removeItem(key);
            }
        }
    },

    setSessionStorageItem: function(key, value) {
        window.sessionStorage.setItem(this.templateName + ":" + key, value);
    },

    getSessionStorageItem: function(key) {
        return window.sessionStorage.getItem(this.templateName + ":" + key);
    },

    removeSessionStorageItem: function(key) {
        window.sessionStorage.removeItem(this.templateName + ": " + key);
    },

    clearSessionStorage: function() {
        for (var key in window.sessionStorage) {
            if (key.startsWith(this.templateName + ":")) {
                window.sessionStorage.removeItem(key);
            }
        }
    },

    getOrientation: function() {
        var innerWidth = window.innerWidth;
        var innerHeight = window.innerHeight;

        if (innerWidth > innerHeight) return 'landscape';
        if (innerWidth < innerHeight) return 'portrait';
        return "";
    },

    setOnOrientationChange: function(callback) {
        window.addEventListener('resize', callback);
    },
});


// Singleton.js
var Singleton = pc.createScript('singleton');

/*
 * Overriding is impossible, so this script can check if the instance already exists.
 */

pc.extend(Singleton.prototype, {
    
    initialize: function() {
        if (this.canCreateInstance(this)) {
            Singleton.instance = this;
        }
    },
    
    // See the example in the initialize how to use it.
    canCreateInstance: function(script) {
        var constructor = Object.getPrototypeOf(script).constructor;

        if (constructor.instance) {
            console.error("A singleton instance is already made of", constructor.__name);
        }
        
        return !constructor.instance;
    },
    
    createInstance: function(_class, script) {
        if (this.canCreateInstance(script)) {
            _class.instance = script;
        }
    },
});


// StorageManager.js
var StorageManager = pc.createScript('storageManager');

StorageManager.attributes.add('defaultSaveData', { type: 'asset', assetType: 'json' });

pc.extend(StorageManager.prototype, {

    initialize: function () {
        if (Singleton.instance.canCreateInstance(this)) {
            StorageManager.instance = this;
        }

        this._hold = false;
        this.queue = [];

        this._basicInfo = this.defaultSaveData.resource;
        this._basicInfoKeys = Object.keys(this.defaultSaveData.resource);

        this._storages = Object.freeze({ LOCALSTORAGE: 'LOCALSTORAGE', SESSIONSTORAGE: 'SESSIONSTORAGE' });

        this._localStorage = {};
        this._sessionStorage = {};

        this._timeSaved = 0;


        this.app.on('Firebase:logchange', this.onUserChange, this);
        this.app.on('Firebase:dataConflictDone', this.onDataConflictDone, this);

        this.loadSaveData();
    },

    postInitialize: function () {
        if (Firebase.instance.loaded || !Firebase.instance.active) {
            this.onUserChange(!!Firebase.instance.user);
        }
    },

    onUserChange: function (loggedIn) {
        if (loggedIn) {
            this._compareSaveData();
        } else {
            this.app.fire('StorageManager:changedStorage');
        }
    },

    onDataConflictDone(updateLocalStorage) {
        this._hold = false;

        if (updateLocalStorage) {
            for (var i = 0; i < this.queue.length; i++) {
                var data = this.queue[i];
                this.set(data.key, data.value, data.compare, data.storage);
            }
        }

        this.queue.length = 0;
    },

    _compareSaveData: function () {
        var data = Firebase.instance.data || {};

        if (!data) {
            return;
        }

        this.validateData(Firebase.instance.data);

        var firebaseId = data.id;
        var firebaseCurrentLevel = data && data.levelData ? data.levelData.currentLevel : 0;
        var firebaseTimeSaved = data.timeSaved;

        var localStorageId = this._localStorage.id;
        var localStorageCurrentLevel = this._localStorage.levelData.currentLevel;
        var localStorageTimeSaved = this._localStorage.timeSaved;

        //         console.log(Firebase.instance.data, this._localStorage)

        //         console.log(firebaseId, localStorageId)

        //         console.log(firebaseTimeSaved, localStorageTimeSaved, firebaseTimeSaved > localStorageTimeSaved, firebaseTimeSaved < localStorageTimeSaved)

        if (!firebaseId || firebaseId === "undefined") {
            // Update firebase
            this._saveToFirebase();
        } else if (firebaseId === localStorageId) {
            var firebaseStars = this._getTotalStars(data);
            var localStorageStars = this._getTotalStars(data);

            if (firebaseStars > localStorage) {
                this._saveToLocalStorage();
            } else if (firebaseStars < localStorage) {
                this._saveToFirebase();
            } else if (firebaseTimeSaved > localStorageTimeSaved) {
                // Update localStorage
                this._saveToLocalStorage();
            } else if (firebaseTimeSaved < localStorageTimeSaved) {
                // Update firebase
                this._saveToFirebase();
            } else {
                // Check if dat is equal
                this.checkIfDataIsEqual(Firebase.instance.data, this._localStorage);
            }

            this.app.fire("StorageManager:changedStorage");
        } else {
            // TODO
            // console.log("firebase id is not the same", firebaseId, localStorageId);
            // console.log(data, this._localStorage)

            this._hold = true;

            pc.timer.add(0.01, () => {
                this.app.fire('UIManager:showUI', 'DataConflict', { localStorage: this._localStorage, firebase: data });
            }, this);
        }
    },

    checkIfDataIsEqual(firebase, localStorage) {
        for (var i = 0; i < this._basicInfoKeys.length; i++) {
            var key = this._basicInfoKeys[i];

            var localStorageValue = localStorage[key];
            var firebaseValue = firebase[key];


            if (typeof localStorageValue !== typeof firebaseValue) {
                if (firebaseValue === undefined) {
                } else {
                    this.set(key, localStorageValue);
                }
            }
        }
    },

    _getTotalStars: function (levelData) {
        var totalStars = 0;

        if (!levelData) {
            return 0;
        }

        Object.keys(levelData).forEach(worldID => {
            if (worldID !== 'currentLevel') {
                Object.keys(levelData[worldID]).forEach(level => {
                    if (level && typeof level.stars === 'number') {
                        totalStars += level.stars;
                    }
                });
            }
        });

        return totalStars;
    },

    _saveToLocalStorage: function () {
        // Update localstorage
        this._localStorage = Firebase.instance.data;

        // this.validateLocalStorage();

        for (var i = 0; i < this._basicInfoKeys.length; i++) {
            var key = this._basicInfoKeys[i];

            Wrapper.instance.setLocalStorageItem(key, this._localStorage[key], true);
        }

        this.app.fire("StorageManager:changedStorage");
    },

    _saveToFirebase: function () {
        var firebaseData = Firebase.instance.data;
        if (firebaseData) {
            var firebaseDataKeys = Object.keys(Firebase.instance.data);

            // Remove keys that doesn't belong in the save data
            firebaseDataKeys.forEach(key => {
                if (!this._basicInfoKeys.includes(key)) {
                    Firebase.instance.save(key, null);
                }
            });
        }

        // Save the data
        this._basicInfoKeys.forEach(key => {
            Firebase.instance.save(key, this._localStorage[key]);
        });

        Xsolla.instance.setInventory(this._localStorage.inventory);

        this.app.fire("StorageManager:changedStorage");
    },

    resetAll() {
        // Remove everything
        for (var i = 0; i < this._basicInfoKeys.length; i++) {
            var key = this._basicInfoKeys[i];

            Wrapper.instance.setLocalStorageItem(key, null);
        }

        this.loadSaveData();

        this.app.fire("StorageManager:changedStorage");
    },

    /**
     * Get the value with the corresponding key.
     *
     * @param {string} key - Key of the value.
     * @returns {*} Value.
     */
    get: function (key, storage) {
        storage = storage || 'LOCALSTORAGE';

        switch (storage.toUpperCase()) {
            case this._storages.LOCALSTORAGE:
                return this._localStorage[key];
            case this._storages.SESSIONSTORAGE:
                return this._sessionStorage[key];
            default:
                console.warn("Storage is " + storage + ", which is incorrect.");
                return null;
        }
    },

    /**
     * Save the value in the storage.
     *
     * @param {string} key - Key of the value.
     * @param {*} value - Can be any JSON valid value.
     * @param {boolean} [compare=false] - If true, it will compare with the old value.
     * If the new value is higher, it will save. Otherwise it will ignore.
     * @param {'localstorage'|'sessionstorage} [storage='localStorage] - Use the correct storage.
     */
    set: function (key, value, compare, storage, localStorageOnly, ignoreTimeSaved) {
        if (this._hold) {
            console.warn("hold it!", key, value, compare, storage)
            this.queue.push({ key, value, compare, storage });
            return;
        }

        compare = compare || false;
        storage = storage || 'localStorage';

        if (compare) {
            var currentValue = this.get(key);

            switch (typeof value) {
                case 'number':
                    if (value <= currentValue) {
                        return;
                    }
                    break;
                default:
                    break;
            }
        }

        this._writeToStorage(key, value, storage, localStorageOnly, ignoreTimeSaved);
    },

    /**
     * Set the value to the basic value.
     *
     * @param {string} key - Key of the value.
     * @param {'localstorage'|'sessionstorage} [storage='localStorage] - Use the correct storage.
     */
    remove: function (key, storage) {
        this._getStorage(storage)[key] = this._basicInfo[key];

        switch (storage.toUpperCase()) {
            case this._storages.LOCALSTORAGE:
                Wrapper.instance.removeLocalStorageItem(key);
                break;
            case this._storages.SESSIONSTORAGE:
                Wrapper.instance.removeSessionStorageItem(key);
                break;
            default:
                console.warn('Storage is not recognized.', 'Key is ' + key);
                break;
        }
    },

    /**
     * Delete the whole save data. Use the default data file.
     *
     * @param {'localstorage'|'sessionstorage} [storage='localStorage] - Use the correct storage.
     */
    delete: function (storage) {
        var specificStorage = this._getStorage(storage);
        specificStorage = this._basicInfo;

        switch (storage.toUpperCase()) {
            case this._storages.LOCALSTORAGE:
                Wrapper.instance.clearLocalStorage();
                break;
            case this._storages.SESSIONSTORAGE:
                Wrapper.instance.clearSessionStorage();
                break;
            default:
                console.warn('Storage is not recognized.');
                break;
        }
    },

    /**
     * Write the data to the save file.
     *
     * @private
     * @param {string} key - Key of the value.
     * @param {*} value - Can be any JSON valid value.
     * @param {'localstorage'|'sessionstorage'} [storage='localStorage] - Use the correct storage.
     */
    _writeToStorage: function (key, value, storage, localStorageOnly) {
        this._getStorage(storage)[key] = value;

        switch (storage.toUpperCase()) {
            case this._storages.LOCALSTORAGE:
                Wrapper.instance.setLocalStorageItem(key, value, localStorageOnly);
                break;
            case this._storages.SESSIONSTORAGE:
                Wrapper.instance.setSessionStorageItem(key, value, localStorageOnly);
                break;
            default:
                console.warn('Storage is not recognized.', 'Key is ' + key);
                break;
        }
    },

    /**
     * Return the correct storage data.
     *
     * @private
     * @param {'localstorage'|'sessionstorage'} storage
     */
    _getStorage: function (storage) {
        switch (storage.toUpperCase()) {
            case this._storages.LOCALSTORAGE:
                return this._localStorage;
            case this._storages.SESSIONSTORAGE:
                return this._localStorage;
            default:
                console.warn('Storage ' + storage + ' not found');
                return null;
        }
    },

    /**
     * Load the save file.
     */
    loadSaveData: function () {
        var keys = Object.keys(this._basicInfo);


        for (var i = 0; i < keys.length; i += 1) {
            var key = keys[i];

            var value = Wrapper.instance.getLocalStorageItem(key);

            try {
                this._localStorage[key] = JSON.parse(value);
            } catch (error) {
                this._localStorage[key] = value;
            }

            if (this._localStorage[key] === undefined ||
                this._localStorage[key] === null ||
                typeof this._localStorage[key] !== typeof this._basicInfo[key] ||
                Array.isArray(this._localStorage[key]) !== Array.isArray(this._basicInfo[key])) {
                this._localStorage[key] = this._basicInfo[key];
                this.set(key, this._localStorage[key], null, null, true, true);
            }

            if (Array.isArray(this._basicInfo[key]) && !Array.isArray(this._localStorage[key])) {
                this._localStorage[key] = this._basicInfo[key];
                this.set(key, this._localStorage[key], null, null, true, true);
            }

            // Check if type is equal, or else replace with default value
            if (typeof this._localStorage[key] !== typeof this._basicInfo[key]) {
                this._localStorage[key] = this._basicInfo[key];
                this.set(key, this._localStorage[key], null, null, true, true);
            }
        }

        if (!this._localStorage.id || this._localStorage.id === "undefined") {
            this.set("id", this._createID(), true, null, true, true);
        }
    },

    validateData: function (data) {
        var keys = Object.keys(this._basicInfo);

        for (var i = 0; i < keys.length; i++) {
            const key = keys[i];

            if (typeof data[key] !== typeof this._basicInfo[key]) {
                data[key] = JSON.parse(JSON.stringify(this._basicInfo[key]));
            }
        }
    },

    _createID: function () {
        var text = "";

        var charset = "abcdefghijklmnopqrstuvwxyz0123456789";

        for (var i = 0; i < 10; i++)
            text += charset.charAt(Math.floor(Math.random() * charset.length));

        text += Date.now();

        return text;
    },
});


// TilePrefabManager.js
var TilePrefabManager = pc.createScript('tilePrefabManager');

//TilePrefabManager.attributes.add('objectPools', { type: 'entity', array: true });

pc.extend(TilePrefabManager.prototype, {
    initialize: function() {
        TilePrefabManager.instance = this;
        
        this._objectPools = {};
        
        var components = this.entity.findComponents('script');
        
        for (var i = 0; i < components.length; i++) {
            var objectPool = components[i].get('objectPool');
            
            if (objectPool) {
                this._objectPools[objectPool.entity.name] = objectPool;
            }
        }
    },
    
    getObjectPool: function(name) {
        var objectPool = this._objectPools[name];
        
        if (!(objectPool instanceof ObjectPool)) {
            console.warn(objectPool, 'is not an object pool', name);
        }
        
        return objectPool;
    },    
});


// TileLibrary.js
var TileLibrary = pc.createScript('tileLibrary');

var tileLayerEnum = { FOREGROUND: 0, BACKGROUND: 1 };

var foregroundTileEnum = Object.freeze({
    EMPTY: 0,
    DEFAULT: 1,
    LINE_H: 2,
    LINE_V: 3,
    BOMB: 4,
    COLORBOMB: 5,
    DROPPER: 6,
    KEY: 7,
    SWITCHER: 8,
    EXPLODER: 9,
    DROPPER_COLLECTION: 10,
    SINKER_1: 11,
    SINKER_2: 12,
    SINKER_3: 13,
});

var backgroundTileEnum = Object.freeze({
    EMPTY: 0,
    WALL: 1,
    PANEL: 2,
    BLOCKER: 3,
    LOCKER: 4,
    VIRUS: 5,
    COAT: 6,
    CHEST: 7,
    // SINKER: 8, // Not used anymore
    COPYER: 8,
    POPPER: 9,
});

var tileColorEnum = Object.freeze({
    NONE: 0,
    BLUE: 1,
    YELLOW: 2,
    RED: 3,
    PURPLE: 4,
    GREEN: 5,
    ORANGE: 6,
});

TileLibrary.backgroundTiles = backgroundTileEnum;


TileLibrary.attributes.add('pyzomathLibrary', { type: 'asset', assetType: 'json' });

pc.extend(TileLibrary.prototype, {
    initialize: function () {
        TileLibrary.instance = this;

        this.colors = ["none", "blue", "yellow", "red", "purple", "green", "orange"];
        this.specials = {
            2: 'bee_horizontal',
            3: 'bee_vertical',
            4: 'ladybug',
            5: 'butterfly',

            9: 'popper',
        };

        this._objectPoolTypeEnum = Object.freeze({
            COLOR: 0,
            NOCOLOR: 1
        });

        this.obstacleNames = Object.freeze({
            2: 'grass',
            3: 'crate',
            4: 'ice',
            5: 'virus',
            6: 'coat',
            7: 'chest',
            // SINKER: 8, // Not used anymore
            8: 'vial',
            9: 'lava',
        });
    },

    getColorName: function (id) {
        return this.colors[id];
    },

    getPowerTileName: function (id) {
        return this.specials[id];
    },

    getObstacleName: function (id) {
        return this.obstacleNames[id];
    },

    postInitialize: function () {
        this._createLibrary();

        this._pyzomathLibrary = this.pyzomathLibrary.resource.gameLibrary;
        this._createLibraryLink();
    },

    // Used for getting objects based on foregroundTileEnum / backgroundTileEnum id's
    getObject: function (layer, id, colorID) {
        if (!this._library.hasOwnProperty(layer) || !this._library[layer].hasOwnProperty(id)) {
            return null;
        }

        var prefabData = this._library[layer][id].prefab;
        var pool = this._getColorOrNoColorPool(prefabData, colorID);
        var object = this._tryUsePool(pool);

        return object;
    },

    returnObject: function (object, layer, id, colorID) {
        if (!this._library.hasOwnProperty(layer) || !this._library[layer].hasOwnProperty(id)) {
            return null;
        }
        var prefabData = this._library[layer][id].prefab;
        var pool = this._getColorOrNoColorPool(prefabData, colorID);

        var success = this._tryReturnPool(pool, object);

        if (!success) {
            console.error('Tries recycling object to pool but it failed', object, layer, id, colorID);
        }
    },

    getTileData: function (layer, id) {
        if (!this._library.hasOwnProperty(layer) || !this._library[layer].hasOwnProperty(id)) {
            return null;
        }
        return this._library[layer][id];
    },

    isTileColored: function (layer, id) {
        if (!this._library.hasOwnProperty(layer) || !this._library[layer].hasOwnProperty(id)) {
            return false;
        }
        return this._library[layer][id].prefab.hasOwnProperty(this._objectPoolTypeEnum.COLOR);
    },

    getOriginalTypeID: function (layer, pyzomathID) {
        if (this._linkLibrary[layer].hasOwnProperty(pyzomathID)) {
            return this._linkLibrary[layer][pyzomathID];
        } else {
            return null;
        }
    },

    getTileSprite: function (name) {
        if (typeof name === 'object') {
            if (name.layerID === 0 && name.typeID === 0 && name.colorID === 0) {
                return this.app.assets.find('115_ui_icon_highscore.png');
            }

            // Dropper collection
            if (name.layerID === tileLayerEnum.FOREGROUND && name.typeID === foregroundTileEnum.DROPPER_COLLECTION) {
                return WorldManager.instance.getPartAssets(WorldManager.instance.getWorldIndex()).partSprite;
            }

            // Switcher
            if (name.layerID === tileLayerEnum.FOREGROUND && name.typeID === foregroundTileEnum.SWITCHER) {
                var colors = ColorManager.instance.maxColors;

                switch (colors) {
                    case 4: return this.app.assets.find('171_ui_objective_switcher-4.png');
                    case 5: return this.app.assets.find('172_ui_objective_switcher-5.png');
                    case 6: return this.app.assets.find('173_ui_objective_switcher-6.png');
                    default: console.warn("Wrong number", colors);
                        return this.app.assets.find('171_ui_objective_switcher-4.png');
                }
            }

            var sprite = this._library[name.layerID][name.typeID].sprite;

            if (name.colorID && name.colorID >= 0) {
                return sprite[this._objectPoolTypeEnum.COLOR][name.colorID];
            } else {
                return sprite[this._objectPoolTypeEnum.NOCOLOR];
            }
        }

        if (name.includes('default')) {
            var values = name.split('_');

            var color = Number(values[1]);

            return this._getColorOrNoColorSprite(tileLayerEnum.FOREGROUND, foregroundTileEnum.DEFAULT, color);
        }

        if (name.includes('exploder')) {
            var values = name.split('_');
            var color = Number(values[1]);

            return this._getColorOrNoColorSprite(tileLayerEnum.FOREGROUND, foregroundTileEnum.EXPLODER, color);
        }

        if (name.includes('switcher')) {
            var values = name.split('_');
            var colors = Number(values[1]);

            switch (colors) {
                case 4: return this.app.assets.find('171_ui_objective_switcher-4.png');
                case 5: return this.app.assets.find('172_ui_objective_switcher-5.png');
                case 6: return this.app.assets.find('173_ui_objective_switcher-6.png');
                default: console.warn("Wrong number", colors);
                    return this.app.assets.find('171_ui_objective_switcher-4.png');
            }
        }

        if (name.includes('points')) {
            return this.app.assets.find('115_ui_icon_highscore.png');
        }

        switch (name) {
            case 'panel':
                return this._library[tileLayerEnum.BACKGROUND][backgroundTileEnum.PANEL].sprite[this._objectPoolTypeEnum.NOCOLOR];
            case 'blocker':
                return this._library[tileLayerEnum.BACKGROUND][backgroundTileEnum.BLOCKER].sprite[this._objectPoolTypeEnum.NOCOLOR];
            case 'dropper':
                return this._library[tileLayerEnum.FOREGROUND][foregroundTileEnum.DROPPER].sprite[this._objectPoolTypeEnum.NOCOLOR];
            case 'collectdropper':
                return WorldManager.instance.getPartAssets(WorldManager.instance.getWorldIndex()).partSprite;
            case 'locker':
            case 'Locker':
                return this._library[tileLayerEnum.BACKGROUND][backgroundTileEnum.LOCKER].sprite[this._objectPoolTypeEnum.NOCOLOR];
            case 'virus':
                return this._library[tileLayerEnum.BACKGROUND][backgroundTileEnum.VIRUS].sprite[this._objectPoolTypeEnum.NOCOLOR];
            case 'score':
                return this.app.assets.find('115_ui_icon_highscore.png');
            case 'carpet':
            case 'coat':
                return this._library[tileLayerEnum.BACKGROUND][backgroundTileEnum.COAT].sprite[this._objectPoolTypeEnum.NOCOLOR];
            case 'switcher':
                return this._library[tileLayerEnum.FOREGROUND][foregroundTileEnum.SWITCHER].sprite[this._objectPoolTypeEnum.NOCOLOR];
            case 'sinker':
                return this._library[tileLayerEnum.FOREGROUND][foregroundTileEnum.SINKER_1].sprite[this._objectPoolTypeEnum.NOCOLOR];
            case 'copyer':
                return this._library[tileLayerEnum.BACKGROUND][backgroundTileEnum.COPYER].sprite[this._objectPoolTypeEnum.NOCOLOR];
            case 'popper':
                return this._library[tileLayerEnum.BACKGROUND][backgroundTileEnum.POPPER].sprite[this._objectPoolTypeEnum.NOCOLOR];
            default:
                console.warn("Nothing found with the name", name);
                break;
        }
    },

    _getColorOrNoColorPool: function (prefabData, colorID) {
        if (prefabData.hasOwnProperty(this._objectPoolTypeEnum.COLOR) && prefabData[this._objectPoolTypeEnum.COLOR][colorID]) {
            if (colorID === undefined) {
                console.warn('Object is a colored object, but color was not provided', prefabData, colorID);
                //return null;
            }

            if (!prefabData[this._objectPoolTypeEnum.COLOR].hasOwnProperty(colorID)) {
                console.warn('Object is a colored object, but color does not exist', prefabData, colorID);
                return null;
            }


            return prefabData[this._objectPoolTypeEnum.COLOR][colorID];
        } else if (prefabData.hasOwnProperty(this._objectPoolTypeEnum.NOCOLOR)) {
            return prefabData[this._objectPoolTypeEnum.NOCOLOR];
        }

        return null;
    },

    _getColorOrNoColorSprite: function (layer, id, color) {
        if (color === -1) return this._library[layer][id].sprite[this._objectPoolTypeEnum.NOCOLOR];
        return this._library[layer][id].sprite[this._objectPoolTypeEnum.COLOR][color];
    },

    _tryUsePool: function (pool) {
        if (pool instanceof ObjectPool) {
            return pool.use();
        } else {
            console.warn('Objectpool missing in library for object');
            return null;
        }
    },

    _tryReturnPool: function (pool, object) {
        if (pool instanceof ObjectPool) {
            pool.recycle(object);
            return true;
        } else {
            console.warn('Objectpool missing in library for object');
            return false;
        }
    },

    _createLibraryLink: function () {
        this._linkLibrary = {
            [tileLayerEnum.FOREGROUND]: {},
            [tileLayerEnum.BACKGROUND]: {},
        };

        var foregroundKeys = Object.keys(this._library[tileLayerEnum.FOREGROUND]);

        for (var i = 0; i < this._pyzomathLibrary.foregrounds.length; i += 1) {
            var pyzomathTile = this._pyzomathLibrary.foregrounds[i];
            for (var j = 0; j < foregroundKeys.length; j += 1) {

                var libraryTile = this._library[tileLayerEnum.FOREGROUND][foregroundKeys[j]];

                if (libraryTile.name === pyzomathTile.name) {
                    this._linkLibrary[tileLayerEnum.FOREGROUND][pyzomathTile.id] = parseInt(foregroundKeys[j])
                    break;
                }
            }
        }

        var backgroundKeys = Object.keys(this._library[tileLayerEnum.BACKGROUND]);
        for (var i = 0; i < this._pyzomathLibrary.backgrounds.length; i += 1) {
            var pyzomathTile = this._pyzomathLibrary.backgrounds[i];
            for (var j = 0; j < backgroundKeys.length; j += 1) {
                var libraryTile = this._library[tileLayerEnum.BACKGROUND][backgroundKeys[j]];
                if (libraryTile.name === pyzomathTile.name) {
                    this._linkLibrary[tileLayerEnum.BACKGROUND][pyzomathTile.id] = parseInt(backgroundKeys[j]);
                }
            }
        }
    },

    colorIDToName: function (id) {
        return Object.keys(tileColorEnum)[id];
    },

    _createLibrary: function () {
        this._library = {
            [tileLayerEnum.FOREGROUND]: {
                [foregroundTileEnum.DEFAULT]: {
                    name: 'default',
                    prefab: {
                        [this._objectPoolTypeEnum.COLOR]: {
                            [tileColorEnum.BLUE]: TilePrefabManager.instance.getObjectPool('TileBlueObjectPool'),
                            [tileColorEnum.YELLOW]: TilePrefabManager.instance.getObjectPool('TileYellowObjectPool'),
                            [tileColorEnum.RED]: TilePrefabManager.instance.getObjectPool('TileRedObjectPool'),
                            [tileColorEnum.PURPLE]: TilePrefabManager.instance.getObjectPool('TilePurpleObjectPool'),
                            [tileColorEnum.GREEN]: TilePrefabManager.instance.getObjectPool('TileGreenObjectPool'),
                            [tileColorEnum.ORANGE]: TilePrefabManager.instance.getObjectPool('TileOrangeObjectPool')
                        }
                    },
                    sprite: {
                        [this._objectPoolTypeEnum.NOCOLOR]: this.app.assets.find('169_ui_objective_default.png'),
                        [this._objectPoolTypeEnum.COLOR]: {
                            [tileColorEnum.BLUE]: this.app.assets.find('120_ui_objective_default_blue.png'),
                            [tileColorEnum.YELLOW]: this.app.assets.find('125_ui_objective_default_yellow.png'),
                            [tileColorEnum.RED]: this.app.assets.find('124_ui_objective_default_red.png'),
                            [tileColorEnum.PURPLE]: this.app.assets.find('123_ui_objective_default_purple.png'),
                            [tileColorEnum.GREEN]: this.app.assets.find('121_ui_objective_default_green.png'),
                            [tileColorEnum.ORANGE]: this.app.assets.find('122_ui_objective_default_orange.png'),
                        }
                    }
                },
                [foregroundTileEnum.LINE_H]: {
                    name: 'line_h',
                    prefab: {
                        [this._objectPoolTypeEnum.COLOR]: {
                            [tileColorEnum.BLUE]: TilePrefabManager.instance.getObjectPool('HorizontalBlueObjectPool'),
                            [tileColorEnum.YELLOW]: TilePrefabManager.instance.getObjectPool('HorizontalYellowObjectPool'),
                            [tileColorEnum.RED]: TilePrefabManager.instance.getObjectPool('HorizontalRedObjectPool'),
                            [tileColorEnum.PURPLE]: TilePrefabManager.instance.getObjectPool('HorizontalPurpleObjectPool'),
                            [tileColorEnum.GREEN]: TilePrefabManager.instance.getObjectPool('HorizontalGreenObjectPool'),
                            [tileColorEnum.ORANGE]: TilePrefabManager.instance.getObjectPool('HorizontalOrangeObjectPool')
                        }
                    },
                    sprite: {
                        [this._objectPoolTypeEnum.COLOR]: {
                            [tileColorEnum.BLUE]: this.app.assets.find('040_tile_lineh.png'),
                            [tileColorEnum.YELLOW]: this.app.assets.find('040_tile_lineh.png'),
                            [tileColorEnum.RED]: this.app.assets.find('040_tile_lineh.png'),
                            [tileColorEnum.PURPLE]: this.app.assets.find('040_tile_lineh.png'),
                            [tileColorEnum.GREEN]: this.app.assets.find('040_tile_lineh.png'),
                            [tileColorEnum.ORANGE]: this.app.assets.find('040_tile_lineh.png'),
                        }
                    }
                },
                [foregroundTileEnum.LINE_V]: {
                    name: 'line_v',
                    prefab: {
                        [this._objectPoolTypeEnum.COLOR]: {
                            [tileColorEnum.BLUE]: TilePrefabManager.instance.getObjectPool('VerticalBlueObjectPool'),
                            [tileColorEnum.YELLOW]: TilePrefabManager.instance.getObjectPool('VerticalYellowObjectPool'),
                            [tileColorEnum.RED]: TilePrefabManager.instance.getObjectPool('VerticalRedObjectPool'),
                            [tileColorEnum.PURPLE]: TilePrefabManager.instance.getObjectPool('VerticalPurpleObjectPool'),
                            [tileColorEnum.GREEN]: TilePrefabManager.instance.getObjectPool('VerticalGreenObjectPool'),
                            [tileColorEnum.ORANGE]: TilePrefabManager.instance.getObjectPool('VerticalOrangeObjectPool')
                        }
                    },
                    sprite: {
                        [this._objectPoolTypeEnum.COLOR]: {
                            [tileColorEnum.BLUE]: this.app.assets.find('040_tile_linev.png'),
                            [tileColorEnum.YELLOW]: this.app.assets.find('040_tile_linev.png'),
                            [tileColorEnum.RED]: this.app.assets.find('040_tile_linev.png'),
                            [tileColorEnum.PURPLE]: this.app.assets.find('040_tile_linev.png'),
                            [tileColorEnum.GREEN]: this.app.assets.find('040_tile_linev.png'),
                            [tileColorEnum.ORANGE]: this.app.assets.find('040_tile_linev.png'),
                        }
                    }
                },
                [foregroundTileEnum.BOMB]: {
                    name: 'bomb',
                    prefab: {
                        [this._objectPoolTypeEnum.COLOR]: {
                            [tileColorEnum.BLUE]: TilePrefabManager.instance.getObjectPool('BombBlueObjectPool'),
                            [tileColorEnum.YELLOW]: TilePrefabManager.instance.getObjectPool('BombYellowObjectPool'),
                            [tileColorEnum.RED]: TilePrefabManager.instance.getObjectPool('BombRedObjectPool'),
                            [tileColorEnum.PURPLE]: TilePrefabManager.instance.getObjectPool('BombPurpleObjectPool'),
                            [tileColorEnum.GREEN]: TilePrefabManager.instance.getObjectPool('BombGreenObjectPool'),
                            [tileColorEnum.ORANGE]: TilePrefabManager.instance.getObjectPool('BombOrangeObjectPool')
                        }
                    },
                    sprite: {
                        [this._objectPoolTypeEnum.COLOR]: {
                            [tileColorEnum.BLUE]: this.app.assets.find('039_tile_bomb.png'),
                            [tileColorEnum.YELLOW]: this.app.assets.find('039_tile_bomb.png'),
                            [tileColorEnum.RED]: this.app.assets.find('039_tile_bomb.png'),
                            [tileColorEnum.PURPLE]: this.app.assets.find('039_tile_bomb.png'),
                            [tileColorEnum.GREEN]: this.app.assets.find('039_tile_bomb.png'),
                            [tileColorEnum.ORANGE]: this.app.assets.find('039_tile_bomb.png'),
                        }
                    }
                },
                [foregroundTileEnum.COLORBOMB]: {
                    name: 'colorbomb',
                    prefab: {
                        [this._objectPoolTypeEnum.NOCOLOR]: TilePrefabManager.instance.getObjectPool('ColorBombObjectPool')
                    },
                    sprite: {
                        [this._objectPoolTypeEnum.NOCOLOR]: this.app.assets.find('041_tile_colorbomb.png'),
                    },
                },
                [foregroundTileEnum.DROPPER]: {
                    name: 'dropper',
                    prefab: {
                        [this._objectPoolTypeEnum.NOCOLOR]: TilePrefabManager.instance.getObjectPool('DropperObjectPool')
                    },
                    sprite: {
                        [this._objectPoolTypeEnum.NOCOLOR]: this.app.assets.find('079_ui_objective_dropper_1.png'),
                    }
                },
                [foregroundTileEnum.KEY]: {
                    name: 'key',
                    prefab: {
                        [this._objectPoolTypeEnum.COLOR]: {
                            [tileColorEnum.BLUE]: TilePrefabManager.instance.getObjectPool('KeyBlueObjectPool'),
                            [tileColorEnum.YELLOW]: TilePrefabManager.instance.getObjectPool('KeyYellowObjectPool'),
                            [tileColorEnum.RED]: TilePrefabManager.instance.getObjectPool('KeyRedObjectPool'),
                            [tileColorEnum.PURPLE]: TilePrefabManager.instance.getObjectPool('KeyPurpleObjectPool'),
                            [tileColorEnum.GREEN]: TilePrefabManager.instance.getObjectPool('KeyGreenObjectPool'),
                            [tileColorEnum.ORANGE]: TilePrefabManager.instance.getObjectPool('KeyOrangeObjectPool'),
                        }
                    }
                },
                [foregroundTileEnum.SWITCHER]: {
                    name: 'switcher',
                    prefab: {
                        [this._objectPoolTypeEnum.NOCOLOR]: TilePrefabManager.instance.getObjectPool('SwitcherObjectPool'),
                        [this._objectPoolTypeEnum.COLOR]: {
                            [tileColorEnum.BLUE]: TilePrefabManager.instance.getObjectPool('SwitcherObjectPool'),
                            [tileColorEnum.YELLOW]: TilePrefabManager.instance.getObjectPool('SwitcherObjectPool'),
                            [tileColorEnum.RED]: TilePrefabManager.instance.getObjectPool('SwitcherObjectPool'),
                            [tileColorEnum.PURPLE]: TilePrefabManager.instance.getObjectPool('SwitcherObjectPool'),
                            [tileColorEnum.GREEN]: TilePrefabManager.instance.getObjectPool('SwitcherObjectPool'),
                            [tileColorEnum.ORANGE]: TilePrefabManager.instance.getObjectPool('SwitcherObjectPool')
                        }
                    },
                    sprite: {
                        [this._objectPoolTypeEnum.NOCOLOR]: this.app.assets.find('005_ui_chapterbutton.png'),
                        [this._objectPoolTypeEnum.COLOR]: {
                            [tileColorEnum.BLUE]: this.app.assets.find('005_ui_chapterbutton.png'),
                            [tileColorEnum.YELLOW]: this.app.assets.find('005_ui_chapterbutton.png'),
                            [tileColorEnum.RED]: this.app.assets.find('005_ui_chapterbutton.png'),
                            [tileColorEnum.PURPLE]: this.app.assets.find('005_ui_chapterbutton.png'),
                            [tileColorEnum.GREEN]: this.app.assets.find('005_ui_chapterbutton.png'),
                            [tileColorEnum.ORANGE]: this.app.assets.find('005_ui_chapterbutton.png'),
                        }
                    }
                },
                [foregroundTileEnum.EXPLODER]: {
                    name: 'exploder',
                    prefab: {
                        [this._objectPoolTypeEnum.COLOR]: {
                            [tileColorEnum.BLUE]: TilePrefabManager.instance.getObjectPool('ExploderBlueObjectPool'),
                            [tileColorEnum.YELLOW]: TilePrefabManager.instance.getObjectPool('ExploderYellowObjectPool'),
                            [tileColorEnum.RED]: TilePrefabManager.instance.getObjectPool('ExploderRedObjectPool'),
                            [tileColorEnum.PURPLE]: TilePrefabManager.instance.getObjectPool('ExploderPurpleObjectPool'),
                            [tileColorEnum.GREEN]: TilePrefabManager.instance.getObjectPool('ExploderGreenObjectPool'),
                            [tileColorEnum.ORANGE]: TilePrefabManager.instance.getObjectPool('ExploderOrangeObjectPool')
                        }
                    },
                    sprite: {
                        [this._objectPoolTypeEnum.NOCOLOR]: this.app.assets.find('160_ui_objective_exploder.png'),
                        [this._objectPoolTypeEnum.COLOR]: {
                            [tileColorEnum.BLUE]: this.app.assets.find('163_ui_objective_exploder_blue.png'),
                            [tileColorEnum.YELLOW]: this.app.assets.find('168_ui_objective_exploder_yellow.png'),
                            [tileColorEnum.RED]: this.app.assets.find('167_ui_objective_exploder_red.png'),
                            [tileColorEnum.PURPLE]: this.app.assets.find('166_ui_objective_exploder_purple.png'),
                            [tileColorEnum.GREEN]: this.app.assets.find('164_ui_objective_exploder_green.png'),
                            [tileColorEnum.ORANGE]: this.app.assets.find('165_ui_objective_exploder_orange.png'),
                        },
                    }
                },
                [foregroundTileEnum.DROPPER_COLLECTION]: {
                    name: 'collectdropper',
                    prefab: {
                        [this._objectPoolTypeEnum.NOCOLOR]: TilePrefabManager.instance.getObjectPool('DropperCollectionObjectPool')
                    },
                },

                [foregroundTileEnum.SINKER_1]: {
                    name: 'sinker 1',
                    prefab: {
                        [this._objectPoolTypeEnum.NOCOLOR]: TilePrefabManager.instance.getObjectPool('SinkerObjectPool')
                    },
                    sprite: {
                        [this._objectPoolTypeEnum.NOCOLOR]: this.app.assets.find('221_ui_objective_sinker.png'),
                    },
                },

                [foregroundTileEnum.SINKER_2]: {
                    name: 'sinker 2',
                    prefab: {
                        [this._objectPoolTypeEnum.NOCOLOR]: TilePrefabManager.instance.getObjectPool('SinkerObjectPool')
                    },
                    sprite: {
                        [this._objectPoolTypeEnum.NOCOLOR]: this.app.assets.find('221_ui_objective_sinker.png'),
                    },
                },

                [foregroundTileEnum.SINKER_3]: {
                    name: 'sinker 3',
                    prefab: {
                        [this._objectPoolTypeEnum.NOCOLOR]: TilePrefabManager.instance.getObjectPool('SinkerObjectPool')
                    },
                    sprite: {
                        [this._objectPoolTypeEnum.NOCOLOR]: this.app.assets.find('221_ui_objective_sinker.png'),
                    },
                },
            },
            [tileLayerEnum.BACKGROUND]: {
                [backgroundTileEnum.EMPTY]: {
                    name: 'empty',
                    prefab: {
                        [this._objectPoolTypeEnum.NOCOLOR]: TilePrefabManager.instance.getObjectPool('DefaultBackgroundTileObjectPool')
                    }
                },
                [backgroundTileEnum.WALL]: {
                    name: 'inaccessible',
                    prefab: {
                        [this._objectPoolTypeEnum.NOCOLOR]: TilePrefabManager.instance.getObjectPool('WallObjectPool')
                    }
                },
                [backgroundTileEnum.PANEL]: {
                    name: 'panel',
                    prefab: {
                        [this._objectPoolTypeEnum.NOCOLOR]: TilePrefabManager.instance.getObjectPool('PanelObjectPool')
                    },
                    sprite: {
                        [this._objectPoolTypeEnum.NOCOLOR]: this.app.assets.find('119_ui_objective_panel.png')
                    }
                },
                [backgroundTileEnum.BLOCKER]: {
                    name: 'blocker',
                    prefab: {
                        [this._objectPoolTypeEnum.NOCOLOR]: TilePrefabManager.instance.getObjectPool('BlockerObjectPool')
                    },
                    sprite: {
                        [this._objectPoolTypeEnum.NOCOLOR]: this.app.assets.find('118_ui_objective_blocker.png')
                    }
                },
                [backgroundTileEnum.LOCKER]: {
                    name: 'locker',
                    prefab: {
                        [this._objectPoolTypeEnum.NOCOLOR]: TilePrefabManager.instance.getObjectPool('LockerObjectPool')
                    },
                    sprite: {
                        [this._objectPoolTypeEnum.NOCOLOR]: this.app.assets.find('147_icon_objective_locker.png')
                    }
                },
                [backgroundTileEnum.VIRUS]: {
                    name: 'virus',
                    prefab: {
                        [this._objectPoolTypeEnum.NOCOLOR]: TilePrefabManager.instance.getObjectPool('VirusObjectPool')
                    },
                    sprite: {
                        [this._objectPoolTypeEnum.NOCOLOR]: this.app.assets.find('152_ui_objective_virus.png')
                    }
                },
                [backgroundTileEnum.COAT]: {
                    name: 'coat',
                    prefab: {
                        [this._objectPoolTypeEnum.NOCOLOR]: TilePrefabManager.instance.getObjectPool('CoatObjectPool')
                    },
                    sprite: {
                        [this._objectPoolTypeEnum.NOCOLOR]: this.app.assets.find('159_ui_objective_coat.png')
                    }
                },
                [backgroundTileEnum.SINKER]: {
                    name: 'sinker',
                    prefab: {
                        [this._objectPoolTypeEnum.NOCOLOR]: TilePrefabManager.instance.getObjectPool('SinkerObjectPool')
                    },
                    sprite: {
                        [this._objectPoolTypeEnum.NOCOLOR]: this.app.assets.find('221_ui_objective_sinker.png')
                    }
                },
                [backgroundTileEnum.CHEST]: {
                    name: 'chest',
                    prefab: {
                        [this._objectPoolTypeEnum.NOCOLOR]: TilePrefabManager.instance.getObjectPool('ChestObjectPool')
                    }
                },
                [backgroundTileEnum.COPYER]: {
                    name: 'copyer',
                    prefab: {
                        [this._objectPoolTypeEnum.NOCOLOR]: TilePrefabManager.instance.getObjectPool('CopyerObjectPool')
                    },
                    sprite: {
                        [this._objectPoolTypeEnum.NOCOLOR]: this.app.assets.find('222_ui_objective_copyer.png'),
                        [this._objectPoolTypeEnum.COLOR]: {
                            [tileColorEnum.BLUE]: this.app.assets.find('222_ui_objective_copyer.png'),
                            [tileColorEnum.YELLOW]: this.app.assets.find('222_ui_objective_copyer.png'),
                            [tileColorEnum.RED]: this.app.assets.find('222_ui_objective_copyer.png'),
                            [tileColorEnum.PURPLE]: this.app.assets.find('222_ui_objective_copyer.png'),
                            [tileColorEnum.GREEN]: this.app.assets.find('222_ui_objective_copyer.png'),
                            [tileColorEnum.ORANGE]: this.app.assets.find('222_ui_objective_copyer.png'),
                        }

                    },
                },
                [backgroundTileEnum.POPPER]: {
                    name: 'popper',
                    prefab: {
                        [this._objectPoolTypeEnum.NOCOLOR]: TilePrefabManager.instance.getObjectPool('PopperObjectPool')
                    },
                    sprite: {
                        [this._objectPoolTypeEnum.NOCOLOR]: this.app.assets.find('223_ui_objective_popper.png')
                    }
                },
            }
        };
    }
});

// SwapMode.js
var SwapMode = pc.createScript('swapMode');

SwapMode.attributes.add('minimalLength', { type: 'number', default: 3 });
SwapMode.attributes.add('endModePowerTilesAmount', { type: 'number', default: 3 });
SwapMode.attributes.add('endModeMaxCascades', { type: 'number', default: 2 });
SwapMode.attributes.add('endModeSpawnDelay', { type: 'number', default: 0.2 });
SwapMode.attributes.add('quitButton', { type: 'entity' });

var matchStates = Object.freeze({
    WAIT: 0,
    MATCH: 1,
    DESPAWN: 2,
    GRAVITY: 3,
    END: 4,
    ENDSPAWN: 5,
});

pc.extend(SwapMode.prototype, {
    initialize: function () {
        SwapMode.instance = this;

        this._selectedTile1 = null;
        this._selectedTile2 = null;

        this.tutorialTile = null;

        this._triedMatch = false;

        this._cascadeCounter = 0;

        this.app.on('SwapMode:inputStopped', this.setTriedMatch, this);
        this.app.on('GameInput:forced' + inputEvents.DOWN, this._onClick, this);

        this._counter = 0;
        this._isCounting = false;
        this._endModeMaxCascadeCounter = 0;
        this.startedEnd = false;

        this.app.on('SwapMode:deselect', this.deselect, this);
    },

    _onClick: function () {
        if (this.startedEnd) {
            PauseManager.instance.setTimeScale(2);
            this.app.fire('SwapMode:speedUp');
        }
    },

    update: function (dt) {
        if (this._isCounting) {
            this._counter += dt;
            if (this._counter >= this.currentStateDuration) {
                this._isCounting = false;
                this._onStateEnd();
            }
        }
    },

    setup: function () {
        this.setState(matchStates.WAIT);
        this._endModeMaxCascadeCounter = 0;
        this.startedEnd = false;
        this.quitButton.element.useInput = true;

        if (GardenDataManager.instance.firstTime) {
            this.app.once('SwapMode:onMoveStart', this.firstMatch, this);
        }

        this.deselect();
    },

    firstMatch() {
        Wrapper.instance.sendGAEvent(Wrapper.GA_EVENT_TYPE.DESIGN, { eventId: 'tutorialFunnel:firstMatchMade' });
    },

    onSelect: function (tileScript, id) {
        if (!tileScript.isSelectable()) {
            return;
        }

        if (!tileScript.isSwappable() && !BoosterManager.instance.isBoosterActive(boosterEnum.BREAKER)) {
            return;
        }

        if ((this._selectedTile1 === tileScript || this._triedMatch) && !BoosterManager.instance.isBoosterActive(boosterEnum.BREAKER)) {
            return;
        }

        if (this._selectedTile1) {
            this._selectedTile2 = tileScript;
            this._selectedTile2.setHighlight(true);
            this._triedMatch = this._swap();
        } else {
            this._select(tileScript);
        }
    },

    _swap: function () {
        if (MatchLogic.areNeighbours(this._selectedTile1, this._selectedTile2)) {
            this._startSwap();
            return true;
        } else {
            this._select(this._selectedTile2);
            return false;
        }
    },

    _select: function (tileScript) {
        GridManager.instance.setAbleToSpawnDropper(true);

        if (BoosterManager.instance.isBoosterActive(boosterEnum.BREAKER)) {
            if (TutorialManager.instance.active && !TutorialManager.instance.canUseBooster(tileScript)) {

            } else {
                var success = BoosterManager.instance.doBreaker(tileScript);

                this.updateTracking = true;

                this.ignoreMove = true;
                if (success) {
                    this.app.fire("GameInput:toggleGameInput", false);
                    this.app.fire('ParticleManager:speedUpParticles', 0.5);
                }
            }

            return;
        }

        if (BoosterManager.instance.isBoosterActive(boosterEnum.CROSSBOMB)) {
            if (TutorialManager.instance.active && !TutorialManager.instance.canUseBooster(tileScript)) {
            } else {
                var success = BoosterManager.instance.doCrossBomb(tileScript);

                this.updateTracking = true;

                if (success) {
                    this.ignoreMove = true;
                    this.app.fire("GameInput:toggleGameInput", false);
                    this.app.fire('ParticleManager:speedUpParticles', 0.5);
                }
            }

            return;
        }


        if (this._selectedTile1) {
            // this._selectedTile1.setLayer(tileLayersEnum.DEFAULT);
            this._selectedTile1.setHighlight(false);
        }

        this._selectedTile1 = tileScript;
        // this._selectedTile1.setLayer(tileLayersEnum.HIGHLIGHT);
        this._selectedTile1.setHighlight(true);
        this._selectedTile2 = null;
    },

    deselect: function () {
        if (this._selectedTile1) {
            // this._selectedTile1.setLayer(tileLayersEnum.DEFAULT);
            this._selectedTile1.setHighlight(false);
        }

        if (this._selectedTile2) {
            // this._selectedTile2.setLayer(tileLayersEnum.DEFAULT);
            this._selectedTile2.setHighlight(false);
        }

        this._selectedTile1 = null;
        this._selectedTile2 = null;
    },

    _startSwap: function () {
        this.app.fire("GameInput:toggleGameInput", false);
        GridManager.instance.stopHint();

        this.app.fire('Audio:sfx', 'tile_swap.mp3');
        GameVibrationManager.instance.addVibration(GameVibrationManager.MATCH_PATTERN);
        this.ignoreMove = false;
        var doFreeSwapAnimation = BoosterManager.instance.isBoosterActive(boosterEnum.FREESWAP);
        var matchDelay = doFreeSwapAnimation ? BoosterManager.instance.freeSwapAnimationDelay : 0;
        if (doFreeSwapAnimation) {
            BoosterManager.instance.doFreeSwapAnimation(this._selectedTile1, this._selectedTile2);
            this.ignoreMove = true;
        }

        GridManager.instance.swapTiles(this._selectedTile1, this._selectedTile2, matchDelay);

        this.setState(matchStates.MATCH, GridManager.instance.moveDuration + matchDelay);
    },

    _handlePlayerMatches: function () {
        var freeswapUsed = false;
        if (!TutorialManager.instance.checkAllowedSwap(this._selectedTile1, this._selectedTile2)) {
            GridManager.instance.swapTiles(this._selectedTile1, this._selectedTile2);
            this.setState(matchStates.WAIT);
            this.deselect();
            return;
        }

        var powerTileMatches = [];

        if (!BoosterManager.instance.isBoosterActive(boosterEnum.FREESWAP)) {
            powerTileMatches = PowerTileManager.instance.onTileSwap(this._selectedTile1, this._selectedTile2);
        } else {
            this.updateTracking = true;
            freeswapUsed = true;
        }

        // var powerTileMatches = this._selectedTile1.powerTileHandler.onTileSwap(this._selectedTile2);
        powerTileMatches = MatchLogic.getChainedPowerTileMatches(powerTileMatches);
        var dropperMatches = MatchLogic.getDropperMatches();
        var matches1 = [];
        var matches2 = [];
        // prevent double use of 1 tile
        // if (powerTileMatches.length === 0 || BoosterManager.instance.freeSwapPowerUpActivated) {

        var isPowerCombination = PowerTileManager.instance.isPowerCombination(this._selectedTile1, this._selectedTile2);

        if (!isPowerCombination && this._selectedTile1.typeID !== foregroundTileEnum.COLORBOMB && this._selectedTile2.typeID !== foregroundTileEnum.COLORBOMB) { // dont check if matching with color bomb
            if (this._selectedTile1 instanceof ForegroundTile) {
                matches1 = MatchLogic.getMatch(this._selectedTile1, this.minimalLength);
            }

            if (this._selectedTile2 instanceof ForegroundTile) {
                matches2 = MatchLogic.getMatch(this._selectedTile2, this.minimalLength);
            }
        } else {

        }

        if (this._checkIfPlayerIsAllowedToSwap(matches1, matches2, powerTileMatches)) {


            var despawnDuration = GridManager.instance.getLongestTileDespawnDuration();


            this.app.fire('ParticleManager:speedUpParticles', 0.5);

            if (!isPowerCombination) {
                if (matches1.length > 0) {
                    // this.app.fire('Audio:sfx', 'combo_1.mp3');
                    this.app.fire('SwapMode:onTileMatch', matches1);
                }

                if (matches2.length > 0) {
                    //this.app.fire('Audio:sfx', 'combo_1.mp3');
                    this.app.fire('SwapMode:onTileMatch', matches2);
                }
            } else {
                if (matches1.length > 0) {
                    // this.app.fire('Audio:sfx', 'combo_1.mp3');
                    this.app.fire('SwapMode:onTileMatch', [this._selectedTile1, this._selectedTile2]);
                }
            }

            if (powerTileMatches.length > 0) {
                //this.app.fire('Audio:sfx', 'combo_1.mp3');
                this.app.fire('SwapMode:onTileMatch', powerTileMatches);
            }

            if (dropperMatches.length > 0) {
                //this.app.fire('Audio:sfx', 'combo_1.mp3');
                this.app.fire('SwapMode:onTileMatch', dropperMatches);
            }

            var postDespawnDuration = GridManager.instance.getLongestTileDespawnDuration();

            this.setState(matchStates.DESPAWN, Math.max(despawnDuration, postDespawnDuration));

            this._updateMatchStatistics(matches1.length, matches2.length, powerTileMatches.length);

            GridManager.instance.spawnPowerTiles();

            GridManager.instance.active(false);

            StatisticsManager.instance.incrementStatistic('swaps_made');

            if (!freeswapUsed)
                this.app.fire('SwapMode:onMoveStart', this.ignoreMove);
        } else {
            GridManager.instance.swapTiles(this._selectedTile1, this._selectedTile2);
            this.setState(matchStates.WAIT);
            GridManager.instance.startHintCountdown();
        }

        this.deselect();
    },

    _checkIfPlayerIsAllowedToSwap: function (matches1, matches2, powerTileMatches) {
        if (BoosterManager.instance.isBoosterActive(boosterEnum.FREESWAP)) {
            BoosterManager.instance.doFreeSwap();
            return true;
        } else if (matches1.length > 0 || matches2.length > 0 || powerTileMatches.length > 0) {
            this.app.fire('SwapMode:onPlayerMove');
            return true;
        } else {
            return false;
        }
    },

    _updateMatchStatistics: function (matchOneLength, matchTwoLength, powerTileMatchLength) {
        if (matchOneLength > 0) StatisticsManager.instance.incrementStatistic("matches_made", { length: matchOneLength }, 1);
        if (matchTwoLength > 0) StatisticsManager.instance.incrementStatistic("matches_made", { length: matchTwoLength }, 1);
        if (powerTileMatchLength > 0) StatisticsManager.instance.incrementStatistic("matches_made", { length: powerTileMatchLength }, 1);

        // if (matchOneLength > 0) StatisticsManager.instance.incrementStatistic("matches_made", 1);
        // if (matchTwoLength > 0) StatisticsManager.instance.incrementStatistic("matches_made", 1);
        // if (powerTileMatchLength > 0) StatisticsManager.instance.incrementStatistic("matches_made", 1);

        // if (matchOneLength === 3) StatisticsManager.instance.incrementStatistic("three_flower_matches_made", 1);
        // if (matchOneLength === 4) StatisticsManager.instance.incrementStatistic("four_flower_matches_made", 1);
        // if (matchOneLength === 5) StatisticsManager.instance.incrementStatistic("five_flower_matches_made", 1);

        // if (matchTwoLength === 3) StatisticsManager.instance.incrementStatistic("three_flower_matches_made", 1);
        // if (matchTwoLength === 4) StatisticsManager.instance.incrementStatistic("four_flower_matches_made", 1);
        // if (matchTwoLength === 5) StatisticsManager.instance.incrementStatistic("five_flower_matches_made", 1);
    },

    _handleCascadeMatches: function () {
        GridManager.instance.resetDespawnDelay();
        this.app.fire('SwapMode:onCascadeNext');

        var matchData = MatchLogic.getCascadeMatches(this.minimalLength);
        var array = matchData.tiles;
        var matches = matchData.matches;

        if (array.length > 0) {

            //             if(!this.startedEnd){

            //             }

            this._cascadeCounter++;
            //this.app.fire('ParticleManager:speedUpParticles', 0.5);
            var combo = pc.math.clamp(this._cascadeCounter + 1, 2, 7);
            this.app.fire('Audio:sfx', 'combo_' + combo + '.mp3');

            GridManager.instance.expandCoats(matches);
            var cascadeMatches = MatchLogic.triggerPowerTiles(array, matches);
            pc.utils.fuseUniqueArray(array, cascadeMatches);
            var despawnDuration = GridManager.instance.getLongestTileDespawnDuration();

            this.app.fire('SwapMode:onTileMatch', array, matches);

            despawnDuration = Math.max(despawnDuration, GridManager.instance.getLongestTileDespawnDuration());

            this.setState(matchStates.DESPAWN, despawnDuration);

            GridManager.instance.spawnPowerTiles();

        } else {
            // if (GridManager.instance.hasExploderTriggered()) {
            //     GridManager.instance.explodeExploder();
            //     return;
            // }

            if (!TutorialManager.instance.active) {
                BoosterManager.instance.spawnPreGameBoosters();
            }


            this.app.fire("SwapMode:onMoveEnd", this.ignoreMove);

            if (!this.startedEnd) {
                GridManager.instance.active(true);
            }


            if (!this.ignoreMove) {
                GridManager.instance.expandVirus();
                this.ignoreMove = false;
                GridManager.instance.regrowBackgroundTiles();
            }

            GameManager.instance.trackLiveScore();


            this.app.fire('CascadeIndicatorInterface:onCascade', this._cascadeCounter);
            StatisticsManager.instance.incrementStatistic('combo_made', { combo_amount: this._cascadeCounter + 1 });
            this._cascadeCounter = 0;
            this.app.fire('SwapMode:onCascadeDone');

            if (!this.startedEnd && this.updateTracking) {
                TrackingManager.instance.levelUpdate();

                this.updateTracking = false;
            }

            this._handleEndOfMove();
            StatisticsManager.instance.saveStatistics();

        }
        this.app.fire('SwapMode:onGravityEnd');
        //GridManager.instance.removeAllDestroyedBackgroundTiles();

    },

    _handleEndOfMove: function () {
        var levelCompleted = null;
        if (!this.startedEnd) {
            this.app.fire('ParticleManager:switchState', animationStates.SPEEDDOWN);
            levelCompleted = LevelManager.instance.onMoveDone();
            if (levelCompleted) {
                this._startFinale();
                return;
            }
        }

        if (this.startedEnd) {
            // end mode ongoing
            this.setState(matchStates.END, 0.2);
        } else if (levelCompleted === false) {
            // add moves screen
            this.app.fire("GameInput:toggleGameInput", false);
        } else if (levelCompleted === null) {
            // no result yet
            GridManager.instance.checkAllPossibleMatches();
            this.setState(matchStates.WAIT);

        }

    },

    _startFinale: function () {
        this.app.fire('SwapMode:onEndStart');
        this.app.fire('Audio:bgm', 'end_mode.mp3');
        this.startedEnd = true;
        this._endModeMaxCascadeCounter = 0;
        this.quitButton.element.useInput = false;
        GridManager.instance.active(false);
        this._spawnEndGamePowerups();
    },

    _handleEndMatches: function () {
        var powerTiles = GridManager.instance.getAllExplodablePowerTiles();
        if (powerTiles.length > 0) {
            var matchTiles = [];
            if (this.endModePowerTilesAmount > 0) {
                for (var i = 0; i < this.endModePowerTilesAmount; i += 1) {
                    if (powerTiles.length > 0) {
                        var randomID = Math.floor(Math.random() * powerTiles.length);
                        matchTiles.push(powerTiles[randomID]);
                        powerTiles.splice(randomID, 1);
                    }
                }
            } else {
                matchTiles = powerTiles;
            }
            matchTiles = MatchLogic.getChainedPowerTileMatches(matchTiles);

            var despawnDuration = GridManager.instance.getLongestTileDespawnDuration();
            this.setState(matchStates.DESPAWN, despawnDuration);

            this.app.fire('SwapMode:onTileMatch', matchTiles);
        } else {
            this.startedEnd = false;
            this.setState(matchStates.WAIT);
            this.app.fire('SwapMode:onFinaleDone');
            PauseManager.instance.setTimeScale(1);
        }
    },

    _applyGravity: function () {
        this._endModeMaxCascadeCounter += 1;
        var avoidMatch = TutorialManager.instance.active;
        if (this.startedEnd) {
            var increaseColors = ColorManager.instance.endGameIncreaseColor(this._endModeMaxCascadeCounter);
            if (increaseColors) this._endModeMaxCascadeCounter = 0;
        }
        var durationGravity = GridManager.instance.applyGravityToTiles(avoidMatch);
        this.setState(matchStates.GRAVITY, durationGravity);
    },

    _spawnEndGamePowerups: function () {
        GridManager.instance.active(false);
        var availableTiles = GridManager.instance.getForegroundTilesOfType(foregroundTileEnum.DEFAULT, 0);
        var amountOfEndPowerups = MovesManager.instance.getMoves();
        var powerOptions = [foregroundTileEnum.LINE_H, foregroundTileEnum.LINE_V, foregroundTileEnum.BOMB];
        for (var i = 1; i <= amountOfEndPowerups; i++) {
            if (availableTiles.length === 0) {
                availableTiles = GridManager.instance.getForegroundTilesOfType([foregroundTileEnum.LINE_V, foregroundTileEnum.LINE_H, foregroundTileEnum.BOMB]);
            }

            var id = Math.floor(Math.random() * availableTiles.length);
            var replace = availableTiles[id];
            if (replace) {
                var randompower = powerOptions[Math.floor(Math.random() * powerOptions.length)];
                var newTile = PowerTileManager.instance.switchTilePower(replace, randompower, this.endModeSpawnDelay * i);
                PowerTileManager.instance.setTileState(newTile, ForegroundTile._PowerStates.ACTIVE);
            }
            this.app.fire('ScoreManager:scoreEndModeCreatePower', replace);
            availableTiles.splice(id, 1);
        }
        this.setState(matchStates.ENDSPAWN, amountOfEndPowerups * this.endModeSpawnDelay);
    },


    setTriedMatch: function (setTo) {
        this._triedMatch = setTo;
    },

    setState: function (state, duration) {

        //console.log('switch state: ', Object.keys(matchStates)[state], 'duration', duration)
        this.currentState = state;
        this._onStateSwitch();

        this.currentStateDuration = duration;
        this._counter = 0;
        this._isCounting = typeof duration === 'number';
    },

    _onStateSwitch: function () {
        switch (this.currentState) {
            case matchStates.WAIT:
                this.app.fire("GameInput:toggleGameInput", true);
                this.app.fire('SwapMode:onWait');
                break;
            case matchStates.MATCH:
                break;
            case matchStates.DESPAWN:
                break;
            case matchStates.GRAVITY:
                break;
            case matchStates.END:
                break;
            case matchStates.ENDSPAWN:
                break;
        }
    },

    _onStateEnd: function () {
        switch (this.currentState) {
            case matchStates.WAIT:
                break;
            case matchStates.MATCH:
                this._handlePlayerMatches();
                break;
            case matchStates.DESPAWN:
                this._applyGravity();
                break;
            case matchStates.GRAVITY:
                this._handleCascadeMatches();
                break;
            case matchStates.END:
                this._handleEndMatches();
                break;
            case matchStates.ENDSPAWN:
                this.setState(matchStates.END, 1);
                break;
        }
    },

    isWaiting: function () {
        return this.currentState === matchStates.WAIT;
    }
});

// Utils.js
var Utils = pc.createScript('utils');

pc.extend(Utils.prototype, {
    initialize: function () {
        pc.utils = this;
    },

    addButtonClickEvent: function (entity, callback, context) {
        entity.element.on('click', callback, context);
    },

    shuffleArray: function (array) {
        for (var i = array.length - 1; i > 0; i--) {
            var j = Math.floor(Math.random() * (i + 1));
            var temp = array[i];
            array[i] = array[j];
            array[j] = temp;
        }
    },

    removeArrayDuplicates: function (array) {
        return [...new Set(array)];
    },

    multiDimensionArray: function (dimensions) {
        var array = [];

        for (var i = 0; i < dimensions[0]; i += 1) {
            array.push(dimensions.length === 1 ? 0 : this.multiDimensionArray(dimensions.slice(1)));
        }

        return array;
    },

    fuseArray: function (array1, array2) {
        for (var i = 0; i < array2.length; i++) {
            array1.push(array2[i]);
        }
    },

    fuseUniqueArray: function (array1, array2) {
        if (!Array.isArray(array1)) {
            console.warn("array 1 is not an array")
            return;
        }

        if (!Array.isArray(array2)) {
            console.warn("array 2 is not an array")
            return;
        }

        for (var i = 0; i < array2.length; i++) {
            if (array1.indexOf(array2[i]) !== -1) {
                continue;
            }

            array1.push(array2[i]);
        }
    },

    removeDuplicate: function (array1, array2) {
        for (var i = array1.length - 1; i >= 0; i--) {
            if (array2.indexOf(array1[i]) !== -1) {
                array1.splice(i, 1);
            }
        }
    },

    duplicateArray: function (array1) {
        var array = [];

        for (var i = 0; i < array1.length; i++) {
            array.push(array1[i]);
        }

        return array;
    },

    isElementInArray: function (element, array) {
        for (var x = 0; x < array.length; x++) {
            if (array[x] === element) {
                return true;
            }
        }
        return false;
    },

    isElementIn2DArray: function (element, array) {
        for (var x = 0; x < array.length; x++) {
            for (var y = 0; y < array[x].length; y++) {
                if (array[x][y] === element) {
                    return true;
                }
            }
        }
        return false;
    },

    isDuplicateIn2DArrayAndArray: function (array1, array2) {
        for (var x = 0; x < array1.length; x++) {
            for (var y = 0; y < array1[x].length; y++) {
                if (array2.indexOf(array1[x][y]) !== -1) {
                    return true;
                }
            }
        }
        return false;
    },

    delay: function (milliseconds = 0.01) {
        return new Promise(function (resolve) {
            pc.timer.add(milliseconds, resolve);
        });
    },

    millisecondsToTimeFormat: function (milliseconds) {
        var ms = milliseconds % 1000;
        milliseconds = (milliseconds - ms) / 1000;
        var secs = milliseconds % 60;
        milliseconds = (milliseconds - secs) / 60;
        var mins = milliseconds % 60;
        var hrs = (milliseconds - mins) / 60;

        mins = mins.toString();
        secs = secs.toString();

        return hrs + ':' + mins.padStart(2, '0') + ':' + secs.padStart(2, '0');
    },
});


// ColorManager.js
var ColorManager = pc.createScript('colorManager');

pc.extend(ColorManager.prototype, {

    initialize: function() {
        ColorManager.instance = this;
        
        this.maxColors = 4;
        
        this.colorAppearOrder = [tileColorEnum.YELLOW, tileColorEnum.GREEN, tileColorEnum.RED, tileColorEnum.BLUE, tileColorEnum.PURPLE, tileColorEnum.ORANGE];
    },

    getRandomColor: function() {
        return this.colorAppearOrder[Math.floor(pc.math.random(0, this.maxColors))]; 
    },
    
    getColorInOrder: function(colorID) {
        if (colorID === -1) return colorID;
        if (colorID === 0) return null;
        
        var translatedColor = this.colorAppearOrder[colorID - 1];
        // console.log('Translated color ' + colorID + ' to ' + translatedColor)
        return translatedColor;
    },
    
    endGameIncreaseColor: function(cascaseValue) {
        if (cascaseValue >= this._endGameIncreaseColorOn()) {
            if (this.maxColors < this.colorAppearOrder.length) {
                this.maxColors += 1;
                this.hasIncreasedColorOnce = true;
            }
            return true;
        } else {
            return false;
        }
    },
    
    _endGameIncreaseColorOn: function() {
        if (!this.hasIncreasedColorOnce) {
            return 5;
        } else {
            return 2;
        }
    },
    
    // get the color that has the most tiles in the grid
    getColorMostInGrid: function() {
        // vars
        var rows = GridManager.instance.rows;
        var columns =  GridManager.instance.columns;
        var colorTileLog = {}; // keeps track of how many tiles there are for each color
        var results = [];
        
        // check all tiles and make object containing {colorID: amountOfTiles}
        for (var x = 0; x < columns; x++) {
            for (var y = 0; y < rows; y++) {
                var tile = GridManager.instance.getTile(x, y);
                if(tile && tile.isActive() && tile.colorID !== tileColorEnum.NONE && !tile.isHitByPower()) {
                    colorTileLog[tile.colorID] = colorTileLog[tile.colorID] !== undefined ? colorTileLog[tile.colorID] + 1 : 1;
                }
            }
        }
        
        // Loop through all colors and check which ones are the most frequent
        for(var key in colorTileLog) {
            if(results.length === 0 || colorTileLog[key] > colorTileLog[results[0]]) {
                results.length = 0;
                results.push(key);
            } else if(colorTileLog[key] == colorTileLog[results[0]]) {
                results.push(key);
            }
        }
        
        // chose a tile thats the most frequent
        return parseInt(results[Math.floor(pc.math.random(0, results.length))]);
    }, 

    getRandomColorNoMatch: function(x, y) {
        var previousRowTile = GridManager.instance.getTile(x, y - 1);
        var previousColumnTile = GridManager.instance.getTile(x - 1, y);
        var secondPreviousRowTile = GridManager.instance.getTile(x, y - 2);
        var secondPreviousColumnTile = GridManager.instance.getTile(x - 2, y);
        var nextRowTile = GridManager.instance.getTile(x, y + 1);
        var nextColumnTile = GridManager.instance.getTile(x + 1, y);
        var secondNextRowTile = GridManager.instance.getTile(x, y + 2);
        var secondNextColumnTile = GridManager.instance.getTile(x + 2, y);

        var randomColor = this.getEasyNoMatchColor(previousRowTile, previousColumnTile, nextRowTile, nextColumnTile);
        if (randomColor === null) this.getComplexNoMatchColor(previousRowTile, previousColumnTile, secondPreviousRowTile, secondPreviousColumnTile);
        if (randomColor === null) {
            console.warn('There was a mistake in the spawn algorithm, no posssible gem was found: Spawning gem with ID 0');
            randomColor = tileColorEnum.BLUE;
        }
         return randomColor;
    },

    // this algorithm is used to determine whether an eady option for color without a match exists -> a color exists that is not around the tile
    getEasyNoMatchColor: function(previousRowTile, previousColumnTile, nextRowTile, nextColumnTile) {
        var possibleColors = [];
        for (var i = 0; i < this.maxColors; i += 1) {
            var colorIsNotPreviousRowTile = !previousRowTile || this.colorAppearOrder[i] !== previousRowTile.colorID;
            var colorIsNotPreviousColumnTile = !previousColumnTile || this.colorAppearOrder[i] !== previousColumnTile.colorID;
            var colorIsNotNextRowTile = !nextRowTile || this.colorAppearOrder[i] !== nextRowTile.colorID;
            var colorIsNotNextColumnTile = !nextColumnTile || this.colorAppearOrder[i] !== nextColumnTile.colorID;

            if (colorIsNotPreviousRowTile && colorIsNotPreviousColumnTile && colorIsNotNextRowTile && colorIsNotNextColumnTile) {
                possibleColors.push(this.colorAppearOrder[i]);
            }
        }
        if (possibleColors.length === 0) {
            return null;
        }
        
        var color = possibleColors[Math.floor(pc.math.random(0, possibleColors.length))];
                
        return color;
    },

    getComplexNoMatchColor: function(previousRowTile, previousColumnTile, secondPreviousRowTile, secondPreviousColumnTile) {
        var twoTheSameAbove = previousRowTile && secondPreviousRowTile && previousRowTile.colorID === secondPreviousRowTile.colorID;
        var twoTheSameLeft = previousColumnTile && secondPreviousColumnTile && previousColumnTile.colorID === secondPreviousColumnTile.colorID;
        
        var possibleColors = [];
        // A loop to find possible colors based on previously placed tiles
        for (var i = 0; i < this.maxColors; i += 1) {
            // compare color i to previous tiles
            var colorIsNotPreviousRowTile = !previousRowTile || this.colorAppearOrder[i] !== previousRowTile.colorID;
            var colorIsNotPreviousColumnTile = !previousColumnTile || this.colorAppearOrder[i] !== previousColumnTile.colorID;

            // store each way a color can be blocked separately
            var colorCanSpawnBasedOnAbove = !twoTheSameAbove || colorIsNotPreviousRowTile;
            var colorCanSpawnBasedOnLeft = !twoTheSameLeft || colorIsNotPreviousColumnTile;

            // only add to list if color i complies with all rules
            if (colorCanSpawnBasedOnAbove && colorCanSpawnBasedOnLeft) {
                possibleColors.push(this.colorAppearOrder[i]);
            }
        }

        if (possibleColors.length === 0) {
            return null;
        }
        return possibleColors[Math.floor(pc.math.random(0, possibleColors.length))];
    },
    
    getColorArray: function() {
        return this.colorAppearOrder.slice(0, this.maxColors);
    }
});

// GridManager.js
var GridManager = pc.createScript('gridManager');

GridManager.attributes.add('tileOffset', { type: 'number' });
GridManager.attributes.add('shape', { type: 'number', enum: [{ 'circle': 0 }, { 'heart': 1 }, { 'flat': 2 }] });

GridManager.attributes.add('cellWidth', { type: 'number', default: 1 });
GridManager.attributes.add('cellHeight', { type: 'number', default: 1 });

GridManager.attributes.add('objectPoolEntity', { type: 'entity' });
GridManager.attributes.add('focusPoint', { type: 'entity' });
GridManager.attributes.add('camera', { type: 'entity' });
GridManager.attributes.add('centerShape', { type: 'entity' });

GridManager.attributes.add('startFallDuration', { type: 'number', default: 0.3 });
GridManager.attributes.add('fallDurationPerCell', { type: 'number', default: 0.1 });

GridManager.attributes.add('despawnDuration', { type: 'number', default: 0.3 });
GridManager.attributes.add('moveDuration', { type: 'number', default: 0.3 });
GridManager.attributes.add('powerTileCreationDuration', { type: 'number', default: 0.6 });

GridManager.attributes.add('scoreDistance', { type: 'number' });

GridManager.attributes.add('hintDelay', { type: 'number' });
GridManager.attributes.add('shuffleDuration', { type: 'number', default: 1 });

GridManager.attributes.add('tutorialHand', { type: 'entity' });

pc.extend(GridManager.prototype, {
    initialize: function () {
        GridManager.instance = this;

        this.columns = 0;
        this.rows = 0;

        this.skipSpawnShine = false;

        this.scorePool = TilePrefabManager.instance.getObjectPool('ScoreTextObjectPool');
        this.particlePool = TilePrefabManager.instance.getObjectPool('ParticleObjectPool');

        this._active = false;

        this._dropperAmount = 0;
        this._droppers = [];

        this._viruses = [];
        this._virusHit = false;
        this.nViruses = 0;

        this._exploders = [];

        this._coats = [];
        this._coatTimer = 0;
        this._coatIdleTime = 0;
        this._randomCoatIdleTime = 0;
        this._totalCoatWeight = GridManager.WEIGHTED_COAT_IDLE_ANIMATION.reduce((acc, cur) => acc + cur);

        this._chests = [];
        this._keys = [];

        this._switcherSound = '';

        this._exits = [];
        this._spawnPoints = [];
        this._canSpawnDropper = false;
        this._maxDropperAmount = 0;

        this._tempVec3 = new pc.Vec3();

        this.hasCoat = false;

        this.app.on('SwapMode:onCascadeDone', this.startHintCountdown, this);
        this.app.on('SwapMode:onPlayerMove', this.stopHint, this);
        this.app.on('SwapMode:onTileMatch', this.explodeTiles, this);
        this.app.on('ObjectiveManager:onObjectiveAdd', this._onObjectAdd, this);

        this._sfxPlayed = [];

        // var miniStats = new pcx.MiniStats(this.app); // TODO set this line of code somewhere else. Creating multiple mini stats causes WebGL errors

        this.powerTileArray = [];
        // this._tileArray = pc.utils.multiDimensionArray([this.columns, this.rows]);

        this.tutorialHand.enabled = false;
        this.on('destroy', this._onDestroy, this);
        this.app.on('WorldSelection:switchScene', this._onSwitchScene, this);
    },

    _onSwitchScene: function () {
        this.despawnAllInstant();
    },

    _onObjectAdd: function (objective) {
        if (objective.orderTypeObject.layerID === tileLayerEnum.FOREGROUND && objective.orderTypeObject.typeID === foregroundTileEnum.DROPPER) {
            this._dropperAmount = objective.values.goal - this._droppers.length;
            this._maxDropperAmount = this._droppers.length || 1;
            if (this._droppers.length === 0) {
                this.setAbleToSpawnDropper(true);
            }
        }
    },

    _onDestroy: function () {
        this.app.off('SwapMode:onCascadeDone', this.startHintCountdown, this);
        this.app.off('SwapMode:onPlayerMove', this.stopHint, this);
        this.app.off('SwapMode:onTileMatch', this.explodeTiles, this);
    },

    postInitialize: function () {
        // this._setFocusPoint();
    },

    active: function (value) {
        this._active = value;
    },

    playSFX: function (sound) {
        if (!LevelManager.instance.playing) {
            return;
        }

        if (this._sfxPlayed.indexOf(sound) !== -1) {
            return;
        }

        this._sfxPlayed.push(sound);
        this.app.fire('Audio:sfx', sound);
    },

    playSwitcherSFX: function (sound) {
        if (sound > this._switcherSound) {
            this._switcherSound = sound;
        }
    },

    resetSFX: function () {
        this._sfxPlayed.length = 0;
    },

    postUpdate: function () {
        if (!LevelManager.instance.playing) {
            return;
        }

        this.resetSFX();

        if (this._switcherSound) {
            this.app.fire('Audio:sfx', this._switcherSound);

            this._switcherSound = '';
        }
    },

    update: function (dt) {
        if (!LevelManager.instance.playing) {
            return;
        }

        if (this.hasCoat) {
            this._coatTimer += dt;

            if (this._coatTimer >= this._randomCoatIdleTime) {
                this.doCoatIdleAnimationParticle();
                this._coatTimer = 0;
                this._randomCoatIdleTime = this._coatIdleTime * Math.random();
            }
        }

        if (TutorialManager.instance.active) {
            return;
        }

        if (!this._active) {
            return;
        }

        if (this._waitingForHint) {
            this._hintCountdown += dt;
            if (this._hintCountdown > this.hintDelay) {
                var matches = MatchLogic.getAllPossibleMatches();
                this.setHintMatch(matches);
                this.showHint();
            }
        }
        if (this.shuffling) {
            this._shuffleTimer += dt;
            if (this._shuffleTimer > this.shuffleDuration) {
                this._onShuffleEnd();
            }
        }
    },

    _setFocusPoint: function () {
        //this.focusPoint.setPosition(0, this.height / 2, 0);
        //this.camera.script.orbitCamera.focusEntity = this.focusPoint;
        //this.focusPoint.setLocalScale(this.radius * 1.3, this.height * 2, this.radius * 1.5);
        // this.camera.script.orbitCamera.initPitchAndYaw();
    },

    setAbleToSpawnDropper: function (value) {
        this._canSpawnDropper = value;
    },

    spawnLevel: function (columns, rows, tiles) {
        if (columns) this.columns = columns;
        if (rows) this.rows = rows;

        this._hasDropperCollection = false;


        this._tileArrayForeground = pc.utils.multiDimensionArray([this.columns, this.rows]);
        this._tileArrayBackground = pc.utils.multiDimensionArray([this.columns, this.rows]);
        this._spawnOvershoot = new Array(this.columns).fill(0);

        this._exits.length = 0;
        this._spawnPoints.length = 0;
        this._dropperAmount = 0;
        this._droppers.length = 0;
        this._viruses.length = 0;
        this._virusHit = false;
        this._coats.length = 0;
        this.hasCoat = false;
        this._coatTimer = 0;
        this._coatIdleTime = 1;
        this._exploders.length = 0;

        this._chests.length = 0;
        this._keys.length = 0;

        this._canSpawnDropper = false;
        this._maxDropperAmount = 0;

        this._switcherSound = '';

        MatchLogic.setGridSize(this.columns, this.rows);
        this._calculateShapeSize();

        this._spawnTiles(tiles);
        this._setFocusPoint();
        this.stopHint();
        this.startHintCountdown();

        this._predefinedTiles = tiles;

        BackgroundMeshHandler.instance.generateMesh(this._tileArrayBackground);
        BackgroundBorderHandler.instance.generateMesh(this._tileArrayBackground);

        MatchLogic.setGrid(this._tileArrayForeground, this._tileArrayBackground, this._exits);

        DropperExitManager.instance.setExits(this._exits, this._droppers.length > 0 || this._hasDropperCollection);

        PerspectiveView.instance.setAABB(BackgroundBorderHandler.instance.getAABB());

        this.checkAllPossibleMatches(true);

        this.calculateCoatIdleTime();

        this._coatTimer = Math.random() * this._randomCoatIdleTime;

        if (this.hasCoat) {
            CoatBorderHandler.instance.generateMesh(this._tileArrayBackground);
        }
    },

    getNumberOfCoats: function () {
        var amount = 0;

        for (var x = 0; x < this._tileArrayBackground.length; x++) {
            for (var y = 0; y < this._tileArrayBackground[0].length; y++) {
                var backgroundTile = this._tileArrayBackground[x][y];

                if (backgroundTile.isCoat()) {
                    amount++;
                }
            }
        }
        return this._coats.length;
    },

    removeDropper: function (tile) {
        var index = this._droppers.indexOf(tile.entity);

        if (index === -1) {
            console.warn("Something went wrong", tile, this._droppers);
            return;
        }

        this._droppers.splice(index, 1);
    },

    _spawnTiles: function (tiles) {
        this.hasCoat = tiles.some(tile => tile.setBackground.background === backgroundTileEnum.COAT);

        var randomForegroundPositions = [];

        for (var i = 0; i < tiles.length; i += 1) {
            var tile = tiles[i];

            if (tile.setExit) {
                this._exits.push({ x: tile.x, y: tile.y });
            }

            if (tile.setSpawnPoint) {
                this._spawnPoints.push({ x: tile.x, y: tile.y });
            }

            var backgroundData = tile.setBackground;
            var convertedBackgroundID = TileLibrary.instance.getOriginalTypeID(tileLayerEnum.BACKGROUND, backgroundData.background);
            var backgroundTile = null;
            if (convertedBackgroundID !== null) {
                backgroundTile = this._spawnBackgroundTile(backgroundData.background, tile.x, tile.y, 0, backgroundData.layers);
            } else {
                backgroundTile = this._spawnBackgroundTile(backgroundTileEnum.EMPTY, tile.x, tile.y, 0, 1);
            }
            this._tileArrayBackground[tile.x][tile.y] = backgroundTile;

            if (!this._tileArrayBackground[tile.x][tile.y].hasForeground) {
                backgroundTile.postAwake();
                continue;
            }

            var foregroundData = tile.setForeground;
            var convertedForegroundID = TileLibrary.instance.getOriginalTypeID(tileLayerEnum.FOREGROUND, foregroundData.foreground);
            var foregroundTile = null;
            if (convertedForegroundID !== null) {
                foregroundTile = this._spawnForegroundTile(tile.x, tile.y, true, 0, ColorManager.instance.getColorInOrder(foregroundData.color), convertedForegroundID, true, 0, false, foregroundData.maxTimer);

                foregroundTile.setPredefined();

                this._tileArrayForeground[tile.x][tile.y] = foregroundTile;
            } else {
                randomForegroundPositions.push({ x: tile.x, y: tile.y });
            }

            backgroundTile.postAwake();
        }

        for (var j = 0; j < randomForegroundPositions.length; j++) {
            var position = randomForegroundPositions[j];
            var foregroundTile = this._spawnForegroundTile(position.x, position.y, true, 0, null, foregroundTileEnum.DEFAULT, true, 0, false);
            var backgroundTile = this.getBackgroundTile(position.x, position.y);
            this._tileArrayForeground[position.x][position.y] = foregroundTile;
            backgroundTile.postAwake();
        }


        this.app.fire('GridManager:onLevelSpawn');
    },

    _spawnBackgroundTile: function (typeID, x, y, offset, layers) {
        offset = offset || 0;

        var position = null;

        // TODO change default tile to what's in level data
        var tile = TileLibrary.instance.getObject(tileLayerEnum.BACKGROUND, typeID);

        if (typeID === backgroundTileEnum.VIRUS) {
            this._viruses.push(tile.script.backgroundTile);
            this.nViruses = this._viruses.length;
        }

        if (tile === null) tile = TileLibrary.instance.getObject(tileLayerEnum.BACKGROUND, backgroundTileEnum.EMPTY);

        if (typeID === backgroundTileEnum.COAT) {
            this._coats.push(tile.script.backgroundTile);
        }

        if (typeID === backgroundTileEnum.CHEST) {
            this._chests.push(tile.script.backgroundTile);
        }

        position = this.calculatePosition(x, y + offset, 0.1);
        tile.enabled = true;

        tile.script.backgroundTile.awake(position, this, layers);
        tile.script.backgroundTile.setProperties(x, y);

        return tile.script.backgroundTile;
    },

    _spawnForegroundTile: function (x, y, avoidMatch, offset, presetColor, presetType, doSpawnAnimation, spawnDelay, doSpawnShine, timer) {
        offset = offset || 0;
        spawnDelay = spawnDelay || 0;
        doSpawnShine = doSpawnShine || false;

        var tileInfo = {};

        if (presetColor === tileColorEnum.NONE || presetColor === null) {
            presetColor = avoidMatch ? ColorManager.instance.getRandomColorNoMatch(x, y) : ColorManager.instance.getRandomColor();
        }
        if (presetType === undefined) presetType = backgroundTileEnum.EMPTY;

        var tile = TileLibrary.instance.getObject(tileLayerEnum.FOREGROUND, presetType, presetColor);
        if (tile === null) tile = TileLibrary.instance.getObject(tileLayerEnum.FOREGROUND, foregroundTileEnum.DEFAULT, presetColor);

        tile.enabled = true;

        if (presetType === foregroundTileEnum.DROPPER) {
            this._droppers.push(tile);
        }

        if (presetType === foregroundTileEnum.DROPPER_COLLECTION) {
            this._hasDropperCollection = true;
        }

        if (presetType === foregroundTileEnum.KEY) {
            this._keys.push(tile.script.key);
        }

        var position = this.calculatePosition(x, y + offset, 0.2);

        // neighbour tiles data

        tile.script.foregroundTile.awake(position, this, timer);
        tile.script.foregroundTile.setProperties(x, y);

        if (presetType === foregroundTileEnum.SWITCHER) {
            tile.script.Switcher.setStartingColor(presetColor);
        }

        if (presetType === foregroundTileEnum.SINKER_1) {
            tile.script.Sinker.setLayers(1);
        }

        if (presetType === foregroundTileEnum.SINKER_2) {
            tile.script.Sinker.setLayers(2);
        }

        if (presetType === foregroundTileEnum.SINKER_3) {
            tile.script.Sinker.setLayers(3);
        }

        if (doSpawnAnimation) tile.script.foregroundTile.spawnAnimation(undefined, spawnDelay, doSpawnShine);

        if (this.hasCoat) {
            tile.script.foregroundTile.setCoatSize();
        }
        return tile.script.foregroundTile;
    },

    intersectsRay: function (ray, position) {
        if (!this.columns && !this.rows || !this._tileArrayForeground) {
            return;
        }

        var hits = [];
        var points = [];

        for (var x = 0; x < this.columns; x++) {
            for (var y = 0; y < this.rows; y++) {
                var foregroundTile = this._tileArrayForeground[x][y];
                var backgroundTile = this._tileArrayBackground[x][y];

                if (!backgroundTile) {
                    console.warn("herer")
                    Sentry.captureMessage(`No background tile. x: ${x}, y: ${y}, level: ${LevelManager.instance.currentLevel}`);
                } else if (backgroundTile.intersectsRay(ray)) {
                    hits.push(backgroundTile);
                }

                if (foregroundTile) {
                    if (foregroundTile.intersectsRay(ray)) {
                        hits.push(foregroundTile);
                    }
                }
            }
        }

        if (hits.length === 0) {
            return null;
        }

        if (hits.length === 1) {
            return hits[0];
        }

        var shortestCameraDistance = Number.POSITIVE_INFINITY;
        var shortestHit = null;

        for (var i = 0; i < hits.length; i++) {
            var hit = hits[i];
            var entityPosition = hit.entity.getPosition();
            var point = points[i];

            var cameraDeltaX = position.x - entityPosition.x;
            var cameraDeltaY = position.y - entityPosition.y;
            var cameraDeltaZ = position.z - entityPosition.z;

            var cameraDistanceSq = cameraDeltaX * cameraDeltaX + cameraDeltaY * cameraDeltaY + cameraDeltaZ * cameraDeltaZ;

            if (cameraDistanceSq < shortestCameraDistance) {
                shortestHit = hit;
            }
        }

        return shortestHit;
    },

    getTile: function (x, y) {
        if (x < 0) {
            return null;
        }

        if (x >= this._tileArrayForeground.length) {
            return null;
        }

        var tile = this._tileArrayForeground[x][y];

        return tile;
    },

    getBackgroundTile: function (x, y) {
        if (x < 0 || x > this.columns - 1) {
            return null;
        }
        return this._tileArrayBackground[x][y];
    },

    calculatePosition: function (column, row, radius) {
        switch (this.shape) {
            case 0: // Circle
                var degree = 360 / this.columns * column;
                var radian = degree * Math.PI / 180;
                var x = Math.sin(radian) * radius;
                var z = Math.cos(radian) * radius;
                var y = this.height / this.rows * row; // TODO shouldnt be hardcoded

                return new pc.Vec3(x, y, z);
            case 1: // heart
                var t = column / this.columns * 2 * Math.PI;
                var x = radius * Math.pow(Math.sin(t), 3);
                var z = radius * 13 / 16 * Math.cos(t) - radius * 5 / 16 * Math.cos(2 * t) - radius * 2 / 16 * Math.cos(3 * t) - radius / 16 * Math.cos(4 * t);
                var y = this.height / this.rows * row;

                return new pc.Vec3(x, y, z);
            case 2: // Flat
                return new pc.Vec3((column - this.columns / 2 + 0.5) * this.cellWidth, (row - this.rows / 2 + 0.5) * this.cellHeight, radius);
        }
    },

    _despawnTile: function (x, y) {
        if (this._tileArrayForeground[x][y] && !this._tileArrayForeground[x][y].isActive()) {
            this._tileArrayForeground[x][y] = null;
        }
    },

    explodeTiles: function (array, matches) {
        for (var i = 0; i < array.length; i++) {
            if (!array[i].isActive()) {
                continue;
            }
            var tile = array[i];

            var destroyed = tile.explode();
            var exploded = tile.hasExploded();

            this.explodeBackground(tile, destroyed);

            //var backgroundTile = this.getBackgroundTile(tile.x, tile.y);

            if (destroyed) {
                tile.updateFlowerStatistics();

                this._despawnTile(tile.x, tile.y);
            } else {
                //console.warn("not destroyed")
            }
        }
        //let strength = pc.math.clamp(array.length * GameVibrationManager.SINGLE_TILE, 0, 125);
        //GameVibrationManager.instance.addVibration(strength);
    },

    expandCoats: function (matches) {
        for (var i = 0; i < matches.length; i++) {
            var match = matches[i];

            var coatFound = false;

            var tile = null;
            var background = null;

            for (var j = 0; j < match.horizontalMatch.length; j++) {
                tile = match.horizontalMatch[j];
                background = this.getBackgroundTile(tile.x, tile.y);

                if (background.isCoat()) {
                    coatFound = true;
                    break;
                }
            }

            if (!coatFound) {
                for (var k = 0; k < match.verticalMatch.length; k++) {
                    tile = match.verticalMatch[k];
                    background = this.getBackgroundTile(tile.x, tile.y);

                    if (background.isCoat()) {
                        coatFound = true;
                        break;
                    }
                }
            }

            if (coatFound) {
                for (var l = 0; l < match.horizontalMatch.length; l++) {
                    tile = match.horizontalMatch[l];
                    background = this.getBackgroundTile(tile.x, tile.y);

                    background.changeToCoat();

                }

                for (var m = 0; m < match.verticalMatch.length; m++) {
                    tile = match.verticalMatch[m];
                    background = this.getBackgroundTile(tile.x, tile.y);

                    background.changeToCoat();
                }
            }
        }
    },

    explodeBackground: function (tile, destroyed) {
        var hasColor = tile.hasColor;

        if (!hasColor) {
            return;
        }

        var x = tile.x;
        var y = tile.y;
        var tileDelay = tile.getDespawnDelay(true);
        var exploded = tile.hasExploded();
        var hitByMatch = tile.isHitByMatch();

        var backgroundTile = this._tileArrayBackground[x][y];

        if (backgroundTile.explodeMethod === BackgroundTile.ExplodeMethodEnum.EXPLODES_IF_HIT) {
            backgroundTile.explode(tileDelay, tile);
        }

        if (exploded || destroyed) {
            var neighbours = MatchLogic.getNeighbours(backgroundTile, null, tileLayerEnum.BACKGROUND);

            for (var i = 0; i < neighbours.length; i++) {
                if (neighbours[i].explodeMethod === BackgroundTile.ExplodeMethodEnum.EXPLODES_IF_ADJACENT) {
                    neighbours[i].explode(tileDelay, tile);
                }

                if (neighbours[i].explodeMethod === BackgroundTile.ExplodeMethodEnum.EXPLODES_IF_ADJACENT_MATCH && hitByMatch) {
                    neighbours[i].explode(tileDelay, tile);
                }
            }
        }
    },

    removeAllDestroyedBackgroundTiles: function () {
        var destroyedAny = false;

        for (var x = 0; x < this.columns; x++) {
            for (var y = 0; y < this.rows; y++) {
                var tile = this._tileArrayBackground[x][y];
                if (tile.isDestroyed) {
                    this._tileArrayBackground[x][y] = this._spawnBackgroundTile(backgroundTileEnum.EMPTY, x, y); // this._spawnTileLibrary.instance.getObject(tileLayerEnum.BACKGROUND, backgroundTileEnum.EMPTY).backgroundTile;
                    destroyedAny = true;
                } else {
                    tile.hasExploded = false;
                }
            }
        }

        return destroyedAny;
    },

    applyGravityToTiles: function (avoidMatch) {
        var maxDuration = 0;

        this._spawnOvershoot.fill(0);

        var destroyedBackground = this.removeAllDestroyedBackgroundTiles();

        while (true) {

            var durationVertical = this._applyGravityVertical();
            var durationSpawn = this.spawnNewTiles(avoidMatch);
            var durationDiagonal = this._applyGravityDiagonal();

            maxDuration = Math.max(maxDuration, durationSpawn, durationVertical, durationDiagonal);

            if (!(durationVertical || durationSpawn || durationDiagonal)) {
                break;
            }
        }

        this.setCoatSize();

        return maxDuration;
    },

    _applyGravityVertical: function () {
        var maxDuration = 0;
        var maxIndex = 0;

        for (var x = 0; x < this.columns; x++) {
            var fallIndex = 0;
            for (var y = 0; y < this.rows; y++) {
                var foregroundTile = this._tileArrayForeground[x][y];
                var backgroundTile = this._tileArrayBackground[x][y];
                if (!foregroundTile) {
                    if (backgroundTile.backgroundHasGravity) {

                    } else if (backgroundTile.hasForeground && backgroundTile.hasGravity) {
                        fallIndex += 1;
                    } else {
                        fallIndex = 0;
                        continue;
                    }

                    if (maxIndex < fallIndex) {
                        maxIndex = fallIndex;
                    }

                    if (backgroundTile.backgroundHasGravity && fallIndex > 0) {
                        var duration = backgroundTile.applyGravity(x, y, x, y - fallIndex, fallIndex * this.fallDurationPerCell);
                        var temp = this._tileArrayBackground[x][y - fallIndex];



                        this._tileArrayBackground[x][y - fallIndex] = backgroundTile;
                        this._tileArrayBackground[x][y] = temp;
                        temp.x = x;
                        temp.y = y;

                        maxDuration = Math.max(maxDuration, duration);
                    }
                } else if (fallIndex > 0) {
                    if (!backgroundTile.hasGravity) {
                        fallIndex = 0;
                        continue;
                    }

                    if (fallIndex <= 0) {
                        console.error("Fall index", "Something went wrong!", this._tileArrayForeground[x][y]);
                        continue;
                    }

                    if ((y - fallIndex) === y) {
                        console.error("Fall index", "Something went wrong!", this._tileArrayForeground[x][y]);
                    }

                    //this._tileArrayForeground[x][y].fallIntoLevel(fallIndex, this.startFallDuration + fallIndex * this.fallDurationPerCell);
                    var duration = foregroundTile.applyGravity(x, y, x, y - fallIndex, fallIndex * this.fallDurationPerCell);
                    this._tileArrayForeground[x][y - fallIndex] = foregroundTile;
                    this._tileArrayForeground[x][y] = null;

                    //    console.log(null, x, y)

                    maxDuration = Math.max(maxDuration, duration);
                }
            }
        }

        return maxDuration;
    },

    _applyGravityDiagonal: function () {
        var maxDuration = 0;

        for (var x = this._tileArrayForeground.length - 1; x >= 0; x--) {
            for (var y = this._tileArrayForeground[0].length - 2; y >= 0; y--) {
                var backgroundTile = this.getBackgroundTile(x, y);
                var backgroundTileHasGravity = backgroundTile.backgroundHasGravity;

                if (!this._tileArrayForeground[x][y] && this._tileArrayBackground[x][y].hasForeground && this._tileArrayBackground[x][y].hasGravity && !this._tileArrayBackground[x][y].backgroundHasGravity) {
                    if (!this._isAnyTileAbove(x, y)) {

                        if (this._tileArrayForeground[x + 1] && this._tileArrayForeground[x + 1][y + 1] && this._tileArrayBackground[x + 1][y + 1].hasGravity) {
                            if (!this._tileArrayForeground[x + 1][y] && this._tileArrayBackground[x + 1][y].hasForeground) {
                                continue;
                            }
                            var tile = this._tileArrayForeground[x + 1][y + 1];

                            var duration = this.fallDiagonal(tile, x, y, 1, 1);

                            maxDuration = Math.max(duration, maxDuration);

                            continue;
                        } else if (this._tileArrayBackground[x + 1] && this._tileArrayBackground[x + 1][y + 1] && this._tileArrayBackground[x + 1][y + 1].backgroundHasGravity) {
                            var tile = this._tileArrayBackground[x + 1][y + 1];

                            var duration = this.fallDiagonalBackground(tile, x, y, 1, 1);

                            maxDuration = Math.max(duration, maxDuration);

                            continue;
                        }

                        if (this._tileArrayForeground[x - 1] && this._tileArrayForeground[x - 1][y + 1] && this._tileArrayBackground[x - 1][y + 1].hasGravity) {
                            if (!this._tileArrayForeground[x - 1][y] && this._tileArrayBackground[x - 1][y].hasForeground && this._tileArrayBackground[x - 1][y].hasGravity) {
                                continue;
                            }

                            var tile = this._tileArrayForeground[x - 1][y + 1];

                            var duration = this.fallDiagonal(tile, x, y, -1, 1);

                            maxDuration = Math.max(duration, maxDuration);
                            continue;
                        } else if (this._tileArrayBackground[x - 1] && this._tileArrayBackground[x - 1][y + 1] && this._tileArrayBackground[x - 1][y + 1].backgroundHasGravity) {
                            var tile = this._tileArrayBackground[x - 1][y + 1];

                            var duration = this.fallDiagonalBackground(tile, x, y, -1, 1);

                            maxDuration = Math.max(duration, maxDuration);

                            continue;
                        }
                    }
                }
            }
        }

        return maxDuration;
    },

    _isAnyTileAbove: function (x, y) {
        while (true) {
            y++;
            if (y >= this.rows) {
                return true;
            }

            if (this._tileArrayBackground[x][y].backgroundHasGravity) {
                return true;
            }

            if (!this._tileArrayBackground[x][y].hasForeground || !this._tileArrayBackground[x][y].hasGravity) {
                return false;
            }

            if (this._tileArrayForeground[x][y]) {
                return true;
            }
        }
    },

    spawnNewTiles: function (avoidMatch) {
        var dropperIndex = -1;

        if (this._canSpawnDropper && this._dropperAmount > 0 && this._droppers.length < this._maxDropperAmount) {
            var sum = 0;

            for (var i = 0; i < this._spawnPoints.length; i++) {
                var spawnPoint = this._spawnPoints[i];

                var tile = this.getTile(spawnPoint.x, spawnPoint.y);

                if (!tile) {
                    if (this.getBackgroundTile(spawnPoint.x, spawnPoint.y).hasForeground && this.getBackgroundTile(spawnPoint.x, spawnPoint.y).hasGravity) {
                        sum++;
                    }
                }
            }

            if (sum > 0) {
                dropperIndex = Math.floor(Math.random() * sum);
            }
        }

        var maxIndex = 0;

        var spawnedAtSpawnPoint = 0;

        for (var x = 0; x < this.columns; x++) {
            for (var y = 0; y < this.rows; y++) {
                if (!this._tileArrayForeground[x][y] && this._tileArrayBackground[x][y].hasForeground && this._tileArrayBackground[x][y].hasGravity) {
                    var columnData = this.isColumnFree(x, y);
                    if (columnData.free) {
                        var yOffset = this._spawnOvershoot[x]++;

                        var fromY = columnData.y;
                        var toY = y;

                        var offset = fromY - toY;

                        var tile = null;
                        var delay = yOffset * this.fallDurationPerCell;

                        var atSpawnPoint = this.isSpawnPoint(x, y);

                        if (atSpawnPoint) {
                            if (spawnedAtSpawnPoint === dropperIndex) {
                                this._dropperAmount--;

                                this.setAbleToSpawnDropper(false);

                                tile = this._spawnForegroundTile(x, y, false, offset, tileColorEnum.NONE, foregroundTileEnum.DROPPER, true, delay, false);
                            } else {
                                tile = this._spawnForegroundTile(x, y, avoidMatch, offset, null, null, true, delay, false);
                            }

                            spawnedAtSpawnPoint++;
                        } else {
                            tile = this._spawnForegroundTile(x, y, avoidMatch, offset, null, null, true, delay, false);
                        }

                        tile.appear(x, fromY, (fromY - toY) * this.fallDurationPerCell, delay);

                        if (maxIndex < offset) {
                            maxIndex = offset;
                        }

                        this._tileArrayForeground[x][y] = tile;
                    }
                }
            }
        }

        if (maxIndex === 0) {
            return 0;
        } else {
            return maxIndex * this.fallDurationPerCell + 0.5;
        }
    },

    fallDiagonal: function (tile, x, y, deltaX, deltaY) {
        if (deltaX === 0 && deltaY === 0) {
            console.error("Something went wrong!", tile, x, y, deltaX, deltaY);
        }

        this._tileArrayForeground[x][y] = tile;
        this._tileArrayForeground[x + deltaX][y + deltaY] = null;

        return tile.applyGravity(x + deltaX, y + deltaY, x, y, this.fallDurationPerCell);
    },

    fallDiagonalBackground: function (tile, x, y, deltaX, deltaY) {
        if (deltaX === 0 && deltaY === 0) {
            console.error("Something went wrong!", tile, x, y, deltaX, deltaY);
        }

        var temp = this._tileArrayBackground[x][y];
        this._tileArrayBackground[x][y] = tile;
        this._tileArrayBackground[x + deltaX][y + deltaY] = temp;

        temp.x = x + deltaX;
        temp.y = y + deltaY;

        return tile.applyGravity(x + deltaX, y + deltaY, x, y, this.fallDurationPerCell);
    },

    isSpawnPoint: function (x, y) {
        for (var i = 0; i < this._spawnPoints.length; i++) {
            var spawnPoint = this._spawnPoints[i];

            if (spawnPoint.x === x && spawnPoint.y === y) {
                return true;
            }
        }

        return false;
    },

    isColumnFree: function (x, y) {
        var newY = y;

        var possibleSpawnPoints = this._spawnPoints.filter(function (point) {
            return x === point.x;
        });

        if (possibleSpawnPoints.length === 0) {
            return { free: false };
        }

        while (true) {
            if (newY >= this.rows) {
                return { free: false };
            }
            if (!this._tileArrayBackground[x][newY].hasForeground || !this._tileArrayBackground[x][newY].hasGravity) {
                return { free: false };
            }

            for (var i = 0; i < possibleSpawnPoints.length; i++) {
                if (possibleSpawnPoints[i].y === newY) {
                    return { free: true, y: newY + 1 };
                }
            }

            newY++;
        }
    },

    swapTiles: function (tileScript1, tileScript2, delay) {
        var tileScript1X = tileScript1.x;
        var tileScript1Y = tileScript1.y;

        var tileScript2X = tileScript2.x;
        var tileScript2Y = tileScript2.y;

        var tileScript1IsForegroundTile = !(tileScript1 instanceof BackgroundTile);
        var tileScript2IsForegroundTile = !(tileScript2 instanceof BackgroundTile);

        if (tileScript1IsForegroundTile && tileScript2IsForegroundTile) {
            this._tileArrayForeground[tileScript2X][tileScript2Y] = tileScript1;
            this._tileArrayForeground[tileScript1X][tileScript1Y] = tileScript2;
        } else if (!tileScript1IsForegroundTile && !tileScript2IsForegroundTile) {
            this._tileArrayBackground[tileScript2X][tileScript2Y] = tileScript1;
            this._tileArrayBackground[tileScript1X][tileScript1Y] = tileScript2;
        } else if (!tileScript1IsForegroundTile && tileScript2IsForegroundTile) {
            var backgroundTemp = this._tileArrayBackground[tileScript2X][tileScript2Y];
            var foregroundTemp = this._tileArrayForeground[tileScript1X][tileScript1Y];

            backgroundTemp.x = tileScript1X;
            backgroundTemp.y = tileScript1Y;

            foregroundTemp.x = tileScript2X;
            foregroundTemp.y = tileScript2Y;

            this._tileArrayForeground[tileScript1X][tileScript1Y] = tileScript2;
            this._tileArrayForeground[tileScript2X][tileScript2Y] = foregroundTemp;

            this._tileArrayBackground[tileScript1X][tileScript1Y] = backgroundTemp;
            this._tileArrayBackground[tileScript2X][tileScript2Y] = tileScript1;

            tileScript1.x = tileScript2X;
            tileScript1.x = tileScript2Y;

            tileScript2.x = tileScript1X;
            tileScript2.x = tileScript1Y;
        } else if (tileScript1IsForegroundTile && !tileScript2IsForegroundTile) {
            var backgroundTemp = this._tileArrayBackground[tileScript1X][tileScript1Y];
            var foregroundTemp = this._tileArrayForeground[tileScript2X][tileScript2Y];

            backgroundTemp.x = tileScript2X;
            backgroundTemp.y = tileScript2Y;

            foregroundTemp.x = tileScript1X;
            foregroundTemp.y = tileScript1Y;

            this._tileArrayBackground[tileScript1X][tileScript1Y] = tileScript2;
            this._tileArrayBackground[tileScript2X][tileScript2Y] = backgroundTemp;

            this._tileArrayForeground[tileScript1X][tileScript1Y] = foregroundTemp;
            this._tileArrayForeground[tileScript2X][tileScript2Y] = tileScript1;


            tileScript1.x = tileScript2X;
            tileScript1.x = tileScript2Y;

            tileScript2.x = tileScript1X;
            tileScript2.x = tileScript1Y;
        }

        tileScript1.move(tileScript2X, tileScript2Y, this.moveDuration, delay);
        tileScript2.move(tileScript1X, tileScript1Y, this.moveDuration, delay);
    },

    addScoreForEachTileInMatch: function (match) {
        var amountOfTilesInMatch = 1;

        if (match.horizontalMatch.length > 0) {
            amountOfTilesInMatch += match.horizontalMatch.length - 1;
        }

        if (match.verticalMatch.length > 0) {
            amountOfTilesInMatch += match.verticalMatch.length - 1;
        }

        this.app.fire('ScoreManager:onTileMatch', amountOfTilesInMatch, match.matchTile);
    },

    _getDuplicateInCascadeMatches: function (allMatches, verticalMatch) {
        for (var x = 0; x < allMatches.length; x++) {
            var horizontalMatch = allMatches[x].horizontalMatch;
            for (var y = 0; y < horizontalMatch.length; y++) {
                if (verticalMatch.indexOf(horizontalMatch[y]) !== -1) {
                    return { matchID: x, tileID: y };
                }
            }
        }
        return null;
    },

    //     // check if powerups should spawn based on horizontal and vertical match lengths, if so dont despawn tile but change to powerup
    //     _checkPowerTileChange: function(tileScript, arrayHorizontal, arrayVertical) {
    //         if (tileScript.powerTileHandler !== undefined) {
    //             var typeID = tileScript.powerTileHandler.checkPowerTileSpawn(arrayHorizontal.length, arrayVertical.length);
    //             if (PowerTileManager.instance.isPowerTile(typeID)) {
    //                 this.powerTileArray.push({ x: tileScript.x, y: tileScript.y, colorID: tileScript.colorID, typeID: typeID });
    //                 this.setTileConvergencePoint(tileScript.x, tileScript.y, arrayHorizontal, arrayVertical);
    //             }
    //         }
    //     },

    setTileConvergencePoint: function (x, y, arrayHorizontal, arrayVertical) {
        GridManager.instance.playSFX('power_create.mp3');

        for (var h = 0; h < arrayHorizontal.length; h += 1) {
            if (this.canExplode(arrayHorizontal[h].x, arrayHorizontal[h].y)) {
                arrayHorizontal[h].setDespawnEndPosition(x, y);
            }
        }
        for (var v = 0; v < arrayVertical.length; v += 1) {
            if (this.canExplode(arrayVertical[v].x, arrayVertical[v].y)) {
                arrayVertical[v].setDespawnEndPosition(x, y);
            }
        }
    },

    spawnPowerTiles: function () {
        for (var i = 0; i < this.powerTileArray.length; i++) {
            var tile = this._spawnForegroundTile(this.powerTileArray[i].x, this.powerTileArray[i].y, true, 0, this.powerTileArray[i].colorID, this.powerTileArray[i].typeID, true, 0, true);
            tile.isMovedTile = true

            var foregroundTile = this._tileArrayForeground[this.powerTileArray[i].x][this.powerTileArray[i].y];

            if (foregroundTile) {
                foregroundTile.despawn();
            }

            this._tileArrayForeground[this.powerTileArray[i].x][this.powerTileArray[i].y] = tile;
        }

        this.powerTileArray.length = 0;
    },

    _calculateShapeSize: function (column, row) {
        var height = 1;
        var radius = 1;

        var tileSize = 0.9;

        switch (this.shape) {
            case 0: // Circle
                height = tileSize * this.rows + (this.rows - 1) * this.tileOffset;
                radius = (tileSize * this.columns + this.columns * this.tileOffset) / (2 * Math.PI);
                break;
            case 1: // heart copied circle :)
                height = tileSize * this.rows + (this.rows - 1) * this.tileOffset;
                radius = (tileSize * this.columns + this.columns * this.tileOffset) / (2 * Math.PI);
                break;
        }

        this.height = height;
        this.radius = radius;
    },

    despawnAll: async function () {
        if (!this._tileArrayForeground || this._tileArrayForeground.length === 0) return;

        for (var x = 0; x < this._tileArrayForeground.length; x++) {
            for (var y = 0; y < this._tileArrayForeground[x].length; y++) {
                var foregroundTile = this.getTile(x, y);
                if (foregroundTile) {
                    this._despawnForegroundTile(foregroundTile);
                }
            }
            this._tileArrayForeground[x].length = 0;
        }

        await pc.utils.delay();

        MatchLogic.removeGrid();
        await pc.utils.delay();
        BackgroundMeshHandler.instance.reset();
        await pc.utils.delay();
        BackgroundBorderHandler.instance.reset();
        await pc.utils.delay();
        CoatBorderHandler.instance.reset();
        await pc.utils.delay();
        DropperExitManager.instance.removeExits();
        await pc.utils.delay();

        this._despawnAllBackgroundTiles();

        this.app.fire('GridManager:onDespawn');
    },

    _despawnForegroundTile: function (tile) {
        if (!(tile instanceof ForegroundTile)) {
            console.warn("This is not a foreground tile");
            return;
        }
        tile.stopAllTweens();
        tile.despawn();
        this._despawnTile(tile.x, tile.y);
    },

    despawnAllInstant: function () {
        for (var x = 0; x < this._tileArrayForeground.length; x++) {
            for (var y = 0; y < this._tileArrayForeground[x].length; y++) {
                if (this._tileArrayForeground[x][y]) {
                    this._tileArrayForeground[x][y].despawnInstant();
                    this.recycleTile(this._tileArrayForeground[x][y].entity);
                }
            }
        }
        this._tileArrayForeground.length = 0;
        MatchLogic.removeGrid();

        DropperExitManager.instance.removeExits();

        this._despawnAllBackgroundTiles();
    },

    _despawnBackgroundTile: function (tile) {
        var backgroundTile = this._tileArrayBackground[tile.x][tile.y];

        backgroundTile.despawnInstant();
        backgroundTile.entity.enabled = false;
        backgroundTile.entity.reparent(null);
        TileLibrary.instance.returnObject(backgroundTile.entity, tileLayerEnum.BACKGROUND, backgroundTile.typeID, backgroundTile.colorID);

        this._tileArrayBackground[tile.x][tile.y] = null;
    },

    _despawnAllBackgroundTiles: function () {
        for (var x = 0; x < this._tileArrayBackground.length; x++) {
            for (var y = 0; y < this._tileArrayBackground[x].length; y++) {
                var backgroundTile = this._tileArrayBackground[x][y];

                if (backgroundTile) {
                    this._despawnBackgroundTile(backgroundTile);
                }
            }
        }
    },

    _getMovedTiles: function () {
        var movedTiles = [];
        for (var x = 0; x < this._tileArrayForeground.length; x++) {
            for (var y = 0; y < this._tileArrayForeground[x].length; y++) {
                if (this._tileArrayForeground[x][y].isMovedTile) {
                    movedTiles.push(this._tileArrayForeground[x][y]);
                    this._tileArrayForeground[x][y].isMovedTile = false;
                }
            }
        }
        return movedTiles;
    },

    getLongestTileDespawnDuration: function () {
        var longestDuration = 0;

        for (var x = 0; x < this._tileArrayForeground.length; x++) {
            for (var y = 0; y < this._tileArrayForeground[x].length; y++) {
                if (!this._tileArrayForeground[x][y]) {
                    continue;
                }
                var tileDelay = this._tileArrayForeground[x][y].getDespawnDelay();
                if (tileDelay > longestDuration) {
                    longestDuration = tileDelay;
                }
            }
        }

        for (var x = 0; x < this._tileArrayBackground.length; x++) {
            for (var y = 0; y < this._tileArrayBackground[x].length; y++) {
                if (!this._tileArrayBackground[x][y]) {
                    continue;
                }
                var tileDelay = this._tileArrayBackground[x][y].getDespawnDelay();
                if (tileDelay > longestDuration) {
                    longestDuration = tileDelay;
                }
            }
        }

        if (this.powerTileArray.length > 0) {
            longestDuration += this.powerTileCreationDuration;
        } else {
            // longestDuration += this.despawnDuration;
        }

        return longestDuration;
    },

    cheatPowerTile: function (x, y, powerID) {
        var powerTileScript = this.getTile(x, y).entity.script.powerTileHandler;
        powerTileScript.switchTilePower(powerID);
        powerTileScript.setTileState(powerTileScript.tileStates.ACTIVE);
    },

    showScore: function (tile, score) {
        if (!LevelManager.instance.playing) {
            return;
        }

        var scoreScreen = this.scorePool.use();

        scoreScreen.enabled = true;
        var position = this.calculatePosition(tile.x, tile.y, this.radius + this.scoreDistance);


        var color = tile.hasColor || tile.customScoreColor && tile.scoreColorId ? tile.scoreColorId : null;
        var outlineColor = tile.hasColor || tile.customScoreColor && tile.scoreOutlineColorId ? tile.scoreOutlineColorId : null;


        if (tile.typeID === foregroundTileEnum.COLORBOMB && tile instanceof ForegroundTile) {
            var matchedTile = tile.colorBombCause;
            color = matchedTile && (matchedTile.hasColor || matchedTile.customScoreColor) && matchedTile.scoreColorId ? matchedTile.scoreColorId : null;
            outlineColor = matchedTile && (matchedTile.hasColor || matchedTile.customScoreColor) && matchedTile.scoreOutlineColorId ? matchedTile.scoreOutlineColorId : null;
            tile.colorBombCause = null;
        }

        scoreScreen.script.hoverScore.awake(score, position, this.entity, tile.y, color, outlineColor);
    },

    recycleScore: function (entity) {
        entity.enabled = false;
        entity.reparent(null);

        this.scorePool.recycle(entity);
    },

    showParticle: function (x, y, texture, color) {
        var particle = this.particlePool.use();
        particle.enabled = true;
        var position = this.calculatePosition(x, y, this.radius);

        particle.script.particleHandler.awake(position, this.entity, texture, color);
    },

    recycleParticle: function (entity) {
        entity.enabled = false;
        entity.reparent(null);

        this.particlePool.recycle(entity);
    },

    startHintCountdown: function () {
        this._hintCountdown = 0;
        this._waitingForHint = true;
        if (TutorialManager.instance.active) this._hintCountdown = this.hintDelay;
    },

    setHintMatch: function (possibleMatches) {
        // if (TutorialManager.instance.active) {
        //     this.hintMatch = TutorialManager.instance.getTutorialMatch(possibleMatches);
        //     return;
        // }

        var matchArray = {};
        // first get a random match
        this.hintMatch = possibleMatches[Math.floor(Math.random() * possibleMatches.length)];
        var highestValue;
        for (var i = 0; i < possibleMatches.length; i++) {
            if (this._isFullyColorless(possibleMatches[i].matchTiles)) continue;

            // check if colorBomb
            if (possibleMatches[i].matchTiles.length === 5 && this._checkIfMatchOnTheSameAxis(possibleMatches[i].matchTiles)) {
                if (!matchArray.colorBomb) {
                    matchArray.colorBomb = [];
                    highestValue = "colorBomb";
                }
                matchArray.colorBomb.push(possibleMatches[i]);
            } else {
                // check length and put in array
                if (!matchArray[possibleMatches[i].matchTiles.length]) {
                    matchArray[possibleMatches[i].matchTiles.length] = [];
                    if (!highestValue || possibleMatches[i].matchTiles.length > highestValue) {
                        highestValue = possibleMatches[i].matchTiles.length;
                    }
                }
                matchArray[possibleMatches[i].matchTiles.length].push(possibleMatches[i]);
            }
        }

        // check als je geen powerup kan maken of er een powerup is die je kan gebruiken
        if (highestValue === 3) {
            var bestPowerTile;
            for (var i = 0; i < matchArray[highestValue].length; i++) {
                for (var j = 0; j < matchArray[highestValue][i].matchTiles.length; j++) {
                    if (matchArray[highestValue][i].matchTiles[j].isPowerTile() && (!bestPowerTile || PowerTileManager.instance.isPowerStronger(matchArray[highestValue][i].matchTiles[j], bestPowerTile))) {
                        bestPowerTile = matchArray[highestValue][i];
                    }
                }
            }
            if (bestPowerTile) {
                this.hintMatch = bestPowerTile;
            } else {
                this.hintMatch = matchArray[highestValue][Math.floor(Math.random() * matchArray[highestValue].length)];
            }
        } else {
            if (Object.keys(matchArray).length === 0) {
                this.hintMatch = null
            } else {
                this.hintMatch = matchArray[highestValue][Math.floor(Math.random() * matchArray[highestValue].length)];
            }
        }
    },

    _isFullyColorless: function (tiles) {
        for (var i = 1; i < tiles.length; i++) {
            if (tiles[i].colorID !== tileColorEnum.NONE) {
                return false;
            }
        }
        return true;
    },

    _checkIfMatchOnTheSameAxis: function (tiles) {
        var XTheSame = 1;
        var YTheSame = 1;
        for (var i = 1; i < tiles.length; i++) {
            if (tiles[i].x === tiles[0].x)
                XTheSame++;

            if (tiles[i].y === tiles[0].y)
                YTheSame++;
        }
        return (XTheSame == (tiles.length - 1) || YTheSame == (tiles.length - 1));
    },

    getMovableSwitchTile: function () {
        for (var i = 0; i < this.hintMatch.matchTiles.length; i++) {
            for (var j = 0; j < this.hintMatch.switchTiles.length; j++) {
                if (this.hintMatch.matchTiles[i] === this.hintMatch.switchTiles[j]) {
                    return this.hintMatch.switchTiles[j];
                }
            }
        }
    },

    showHint: function () {
        this.backgroundTile = null;
        this._waitingForHint = false;
        if (this.hintMatch) {
            this.showHintMove();

            for (var i = 0; i < this.hintMatch.matchTiles.length; i += 1) {
                this.hintMatch.matchTiles[i].doHintAnimation();
                this.backgroundTile = this.getBackgroundTile(this.hintMatch.matchTiles[i].x, this.hintMatch.matchTiles[i].y);
                if (this.backgroundTile) {
                    this.backgroundTile.doHintAnimation();
                }
            }
        }
    },

    showHintMove: function () {
        var tile = this.getMovableSwitchTile();
        for (var j = 0; j < this.hintMatch.switchTiles.length; j++) {
            if (tile !== this.hintMatch.switchTiles[j]) {
                tile.makeHintMoveAnimation(tile.x - this.hintMatch.switchTiles[j].x, tile.y - this.hintMatch.switchTiles[j].y);
            }
        }
    },


    stopHint: function () {
        this._waitingForHint = false;
        for (var x = 0; x < this._tileArrayForeground.length; x++) {
            for (var y = 0; y < this._tileArrayForeground[x].length; y++) {
                if (this._tileArrayForeground[x][y]) {
                    this._tileArrayForeground[x][y].stopHintAnimation();
                    this.backgroundTile = this.getBackgroundTile(x, y);
                    if (this.backgroundTile) {
                        this.backgroundTile.stopHintAnimation();
                    }
                }
            }
        }
    },

    setTileDespawnDelay: function (array) {
        for (var i = 0; i < array.length; i += 1) {
            array[i].setDespawnDelay(0);
        }
    },

    getAllExplodablePowerTiles: function () {
        var array = [];
        for (var x = 0; x < this._tileArrayForeground.length; x++) {
            for (var y = 0; y < this._tileArrayForeground[x].length; y++) {
                var tile = this._tileArrayForeground[x][y];
                if (tile && tile.isPowerTile() && this.canExplode(x, y)) array.push(tile);
            }
        }
        return array;
    },

    shuffle: async function (includePowerTiles, atStart, attempts) {
        try {
            var tiles = [];

            // Get all foreground tiles
            for (var x = 0; x < this.columns; x++) {
                for (var y = 0; y < this.rows; y++) {
                    var foregroundTile = this._tileArrayForeground[x][y];

                    if (foregroundTile) {
                        if (foregroundTile.isPredefined()) {
                            continue;
                        }

                        foregroundTile.isMovedTile = true;

                        if (includePowerTiles) {
                            if (!(foregroundTile.isFlower() || foregroundTile.isPowerTile())) {
                                continue;
                            }
                        } else if (!foregroundTile.isFlower()) {
                            continue;
                        }

                        if (!foregroundTile.isSwappable()) {
                            continue;
                        }

                        tiles.push(foregroundTile);
                    }
                }
            }

            // shuffle it once
            this._shuffleTileArray(tiles);

            // Get the matches and shuffle those.
            while (true) {
                var matches = MatchLogic.getCascadeMatches(3, true).tiles;

                if (matches.length === 0) {
                    break;
                }

                for (var i = 0; i < matches.length; i++) {
                    this._shuffleTile(matches[i], tiles, includePowerTiles);
                }
            }

            var matches = MatchLogic.getAllPossibleMatches();

            if (matches.length === 0) {
                if (attempts > 30) {
                    if (atStart) {
                        console.error("Level", LevelManager.instance.currentLevel, "is not solvable!");

                        this.setCoatSize();

                        for (var j = 0; j < tiles.length; j++) {
                            var tile = tiles[j];
                            if (!atStart) {
                                tile.stopAllTweens();
                            }
                            tile.move(tile.x, tile.y, atStart ? 0.001 : 1);
                        }
                    } else {
                        LevelManager.instance.onLose();
                    }

                    return;
                }

                this.shuffle(true, atStart, ++attempts);
                return;
            }

            this.setCoatSize();

            for (var j = 0; j < tiles.length; j++) {
                var tile = tiles[j];
                if (!atStart) {
                    tile.stopAllTweens();
                }
                tile.move(tile.x, tile.y, atStart ? 0.001 : 1);
            }

            this.stopHint();
            this.startHintCountdown();

            if (!atStart) {
                this.shuffling = true;
                this._shuffleTimer = 0;
                this.app.fire('GridManager:onShuffleStart');
            }
        } catch (e) {
            this.app.fire('UIManager:hideAll');
            await GameManager.instance.trackEventEnd("fail");

            this.app.fire('UIManager:showUI', 'FloatingUI');
            this.app.fire('UIManager:showUI', 'Lose');
        }
    },

    _shuffleTile: function (tile, array, includePowerTiles) {
        var randomIndex = Math.floor(Math.random() * array.length);

        var temp1 = tile;
        var temp2 = array[randomIndex];

        if (temp1.isPredefined()) {
            return;
        }

        if (includePowerTiles) {
            if (!(temp1.isFlower() || temp1.isPowerTile())) {
                return;
            }
        } else if (!temp1.isFlower()) {
            return;
        }

        if (!temp1.isSwappable()) {
            return;
        }

        if (!temp2.isSwappable()) {
            return;
        }

        var x1 = temp1.x;
        var y1 = temp1.y;

        var x2 = temp2.x;
        var y2 = temp2.y;

        this._tileArrayForeground[x1][y1] = temp2;
        this._tileArrayForeground[x2][y2] = temp1;

        temp1.x = x2;
        temp1.y = y2;

        temp2.x = x1;
        temp2.y = y1;

        temp1.isMovedTile = true;
        temp2.isMovedTile = true;
    },

    _shuffleTileArray: function (array) {
        for (var i = array.length - 1; i > 0; i--) {

            var j = Math.floor(Math.random() * (i + 1));
            var temp1 = array[i];
            var temp2 = array[j];

            var x1 = temp1.x;
            var y1 = temp1.y;

            var x2 = temp2.x;
            var y2 = temp2.y;

            this._tileArrayForeground[x1][y1] = temp2;
            this._tileArrayForeground[x2][y2] = temp1;

            temp1.x = x2;
            temp1.y = y2;

            temp2.x = x1;
            temp2.y = y1;
        }
    },

    _onShuffleEnd: function () {
        this.app.fire('GridManager:onShuffleEnd');
        this.shuffling = false;
        //this._shuffleRefill();
        //this.checkAllPossibleMatches();
        this.startHintCountdown();
    },

    _shuffleRefill: function () {
        for (var x = 0; x < this._tileArrayForeground.length; x++) {
            for (var y = 0; y < this._tileArrayForeground[x].length; y++) {
                var tile = this._tileArrayForeground[x][y];

                if (this._tileArrayForeground[x][y] === null) {
                    var newTile = this._spawnForegroundTile(x, y, true, 0, null, undefined, true, 0, false);
                    this._tileArrayForeground[x][y] = newTile;
                }
            }
        }
    },

    checkAllPossibleMatches: function (atStart) {
        // if (SwapMode.instance.startedEnd) {
        //     console.warn("test")
        //     return;
        // }
        var matches = MatchLogic.getAllPossibleMatches();

        if (matches.length > 0) {
            // this.setHintMatch(matches);
        } else {
            this.shuffle(false, atStart, 0);
        }
    },

    // get all tiles that can be used for other stuff
    getForegroundTilesOfType: function (typeID, amountOfNeighbours, checkOnlyBackgroundExplodes) {
        var availableTiles = [];

        var maxAmount = 0;

        var anyAvailable = false;

        for (var x = 0; x < this.columns; x++) {
            for (var y = 0; y < this.rows; y++) {
                var tile = this._tileArrayForeground[x][y];

                if (tile) {
                    if (Array.isArray(typeID)) {
                        if (typeID.includes(tile.typeID))
                            anyAvailable = true;
                        availableTiles.push(tile);
                    } else {
                        if (tile.typeID == typeID) {
                            var amount = MatchLogic.getAmountOfNeighbours(tile, checkOnlyBackgroundExplodes);

                            anyAvailable = true;

                            if (amount > maxAmount) {
                                maxAmount = amount;
                            }

                            if (amount < amountOfNeighbours) {
                                continue;
                            }

                            availableTiles.push(tile);
                        }
                    }
                }
            }
        }

        if (availableTiles.length === 0) {

            if (!anyAvailable || maxAmount === 0) {
                return availableTiles;
            }

            return this.getForegroundTilesOfType(typeID, maxAmount);
        }

        return availableTiles;
    },

    showTutorialHint: function (tiles) {
        this.hintMatch = {
            matchTiles: tiles
        };
        this.showHint();
    },

    showTutorialMatch: function (tiles) {
        var matches = MatchLogic.getAllPossibleMatches();

        for (var i = 0; i < matches.length; i++) {
            var match = matches[i];

            var foundTile1 = tiles.indexOf(match.switchTiles[0]) !== -1;
            var foundTile2 = tiles.indexOf(match.switchTiles[1]) !== -1;

            if (foundTile1 && foundTile2) {
                if (match.matchTiles.indexOf(tiles[0]) !== -1) {
                    this.hintMatch = match;
                    this.showHint();
                    return;
                }
            }
        }
    },

    calculateAngle: function (x1, y1, x2, y2) {
        var deltaX = x1 - x2;
        var deltaY = y1 - y2;
        var degrees = Math.atan2(deltaY, deltaX) * 180.0 / Math.PI;
        return degrees * -1 + 90;
    },

    resetDespawnDelay: function () {
        for (var x = 0; x < this.columns; x++) {
            for (var y = 0; y < this.rows; y++) {
                var tile = this._tileArrayForeground[x][y];
                if (!(tile instanceof ForegroundTile)) {
                    continue;
                }
                this._tileArrayForeground[x][y].despawnDelay = 0;
            }
        }
    },

    canExplode: function (x, y) {
        var backgroundTile = this.getBackgroundTile(x, y);

        return !(backgroundTile.onlyBackgroundExplodes);
    },

    onVirusDespawn: function (tile) {
        var index = this._viruses.indexOf(tile);

        if (index === -1) {
            console.warn("No virus has been found", tile, this._viruses);
            return;
        }

        this._viruses.splice(index, 1);
    },

    onVirusHit: function () {
        this._virusHit = true;

        this.nViruses--;
    },

    expandVirus: function () {
        var validNeighbours = [];

        if (!this._virusHit && this._viruses.length > 0) {
            for (var i = 0; i < this._viruses.length; i++) {
                var virus = this._viruses[i];

                var neighbours = MatchLogic.getNeighbours(virus, null, tileLayerEnum.FOREGROUND, true);

                for (var j = 0; j < neighbours.length; j++) {
                    var neighbour = neighbours[j];
                    var backgroundTile = this.getBackgroundTile(neighbour.x, neighbour.y);
                    if (!(neighbour instanceof ForegroundTile) && typeof neighbour.x === 'number') {
                        if (backgroundTile.isDefault() || backgroundTile.isCoat()) {
                            validNeighbours.push({ virus: virus, neighbour: neighbour });
                        }
                    } else if ((neighbour.isFlower() || neighbour.isPowerTile()) && (backgroundTile.isDefault() || backgroundTile.isCoat())) {
                        validNeighbours.push({ virus: virus, neighbour: neighbour });
                    }
                }
            }

            if (validNeighbours.length > 0) {
                var randomNeighbour = validNeighbours[Math.floor(Math.random() * validNeighbours.length)];

                var isForegroundTile = randomNeighbour.neighbour instanceof ForegroundTile;

                var x = randomNeighbour.neighbour.x;
                var y = randomNeighbour.neighbour.y;

                var backgroundTile = this.getBackgroundTile(x, y);

                if (isForegroundTile) {
                    this._despawnForegroundTile(randomNeighbour.neighbour);
                    randomNeighbour.neighbour.ignoreDespawnStats();
                }

                randomNeighbour.virus.playAnimation('virus_angry.glb', 0, null, null, 1);

                var isCoat = backgroundTile.entity.script.has('coat');

                backgroundTile.explode();
                this._despawnBackgroundTile(backgroundTile);

                var virus = this._spawnBackgroundTile(backgroundTileEnum.VIRUS, x, y, 0, 1);
                virus.playAnimation('virus_spawn.glb', 0, null, null, 2);
                virus.playAnimation('virus_angry.glb', 0, null, null, 1);
                ObjectiveManager.instance.increaseVirusObjective();
                this._tileArrayBackground[x][y] = virus;

                if (isCoat) {
                    CoatBorderHandler.instance.generateMesh(this._tileArrayBackground);
                }
                this.playSFX('virus_multiply.mp3');
            }
        }

        this._virusHit = false;
        return 0;
    },

    changeToCoat: function (backgroundTile) {
        var x = backgroundTile.x;
        var y = backgroundTile.y;
        this._despawnBackgroundTile(backgroundTile);

        var coat = this._spawnBackgroundTile(backgroundTileEnum.COAT, x, y, 0, 1);
        coat.entity.script.coat.spawn();

        this._tileArrayBackground[x][y] = coat;

        this.calculateCoatIdleTime();

        CoatBorderHandler.instance.generateMesh(this._tileArrayBackground);
    },

    doCoatIdleAnimationParticle: function () {
        var attempts = 0;

        while (attempts < 20) {
            var randomIndex = Math.floor(Math.random() * this._coats.length);

            var coat = this._coats[randomIndex];

            if (!coat.entity.script.tileAnimationController.playing) {
                this.playCoatIdleAnimation(coat);
                break;
            }

            attempts++;
        }
    },

    playCoatIdleAnimation: function (coat) {
        var randomNumber = Math.random() * this._totalCoatWeight;
        var currentTier = 0;
        var i = 0;

        for (; i < GridManager.WEIGHTED_COAT_IDLE_ANIMATION.length; i++) {
            currentTier += GridManager.WEIGHTED_COAT_IDLE_ANIMATION[i];
            if (randomNumber < currentTier) {
                break;
            }
        }

        coat.entity.script.tileAnimationController.playAnimation(`coat_sparkle_0${i + 1}_animation.glb`);
    },

    calculateCoatIdleTime: function () {
        this._coatIdleTime = 10 / Math.pow(this._coats.length, 0.4);
        this._randomCoatIdleTime = Math.random() * this._coatIdleTime;
    },

    addExploder: function (exploder) {
        this._exploders.push(exploder);
    },

    removeExploder: function (exploder) {
        var index = this._exploders.indexOf(exploder);

        if (index === -1) {
            console.warn("Exploder not found");
            return;
        }

        this._exploders.splice(index, 1);
    },

    hasExploderTriggered: function () {
        for (var i = 0; i < this._exploders.length; i++) {
            if (this._exploders[i].isTriggered()) {

                return true;
            }
        }

        return false;
    },

    addExploderTimer: function (amount) {
        for (var i = 0; i < this._exploders.length; i++) {
            this._exploders[i].addTimer(amount);
        }
    },

    setCoatSize: function () {
        if (!this.hasCoat) {
            return;
        }

        for (var x = 0; x < this.columns; x++) {
            for (var y = 0; y < this.rows; y++) {
                var tile = this._tileArrayForeground[x][y];

                if (tile) {
                    tile.setCoatSize();
                }
            }
        }
    },

    regrowBackgroundTiles() {
        var array = this._tileArrayBackground;

        for (var x = 0; x < array.length; x++) {
            for (var y = 0; y < array[0].length; y++) {
                if (!array[x][y]) {
                    console.warn("x", x, "y", y, array[x][y]);
                } else {
                    array[x][y].activateRegrow();
                }
            }
        }
    },

    onKeyDestroy(tile, delay) {
        for (var i = 0; i < this._chests.length; i++) {
            var chest = this._chests[i];

            var exploded = chest.explode(delay);
        }
    },

    removeChest: function (tile) {
        var index = this._chests.indexOf(tile);

        if (index === -1) {
            console.warn("tile not found", tile);
            return;
        }

        this._chests.splice(index, 1);
    },
});

GridManager.WEIGHTED_COAT_IDLE_ANIMATION = [10, 5, 2];

// BoosterManager.js
/*jshint esversion: 6 */

var BoosterManager = pc.createScript('boosterManager');

// Uncomment this if you want to parse this script.
// var foregroundTileEnum = Object.freeze({
//     EMPTY: 0,
//     DEFAULT: 1,
//     LINE_H: 2,
//     LINE_V: 3,
//     BOMB: 4,
//     COLORBOMB: 5,
//     DROPPER: 6,
//     KEY: 7,
//     SWITCHER: 8,
//     EXPLODER: 9,
//     DROPPER_COLLECTION: 10
// });

var boosterEnum = Object.freeze({
    FREESWAP: 0,
    BREAKER: 1,
    CROSSBOMB: 2
});

var preGameBoosters = Object.freeze({
    LINECLEAR: [foregroundTileEnum.LINE_H, foregroundTileEnum.LINE_V],
    COLORBOMB: foregroundTileEnum.COLORBOMB,
    BOMB: foregroundTileEnum.BOMB,
});

BoosterManager.attributes.add('preBoostDelay', { type: 'number', default: 0.3 });
BoosterManager.attributes.add('shovelAnimationPool', { type: 'entity' });
BoosterManager.attributes.add('freeswapAnimationPool', { type: 'entity' });
BoosterManager.attributes.add('crossbombAnimationPool', { type: 'entity' });
BoosterManager.attributes.add('preboosterAnimationTime', { type: 'number', default: 2 });

pc.extend(BoosterManager.prototype, {

    initialize: function () {
        BoosterManager.instance = this;
        this.crossBombBehaviour = new CrossBombBehaviour();
        this.preGameBoosterQueue = [];

        this._boostersActive = {};
        for (var booster in boosterEnum) {
            this._boostersActive[boosterEnum[booster]] = false;
        }

        this.preboosterAnimationLibrary = Object.freeze({
            [foregroundTileEnum.LINE_H]: powerAnimationTypes.LINES,
            [foregroundTileEnum.LINE_V]: powerAnimationTypes.LINES,
            [foregroundTileEnum.BOMB]: powerAnimationTypes.BOMB,
            [foregroundTileEnum.COLORBOMB]: powerAnimationTypes.COLORBOMB,
        });

        this.shovelPool = this.shovelAnimationPool.script.objectPool;
        this.handPool = this.freeswapAnimationPool.script.objectPool;
        this.crossBombPool = this.crossbombAnimationPool.script.objectPool;

        this.freeSwapAnimationDelay = 0.3;
    },

    // add a pre game booster tho the queue
    addPreBoosterToQueue: function (boosterID, amount, tutorial) {
        if (Array.isArray(boosterID)) {
            for (i = 1; i <= amount; i++) {
                this.preGameBoosterQueue.push({
                    typeID: boosterID[i % boosterID.length],
                    amount: 1,
                    tutorial: tutorial,
                });
            }
        } else {
            this.preGameBoosterQueue.push({
                typeID: boosterID,
                amount: amount,
                tutorial: tutorial,
            });
        }
    },

    reset: function () {
        for (var i = 0; i < this.preGameBoosterQueue.length; i++) {
            var preGameBooster = this.preGameBoosterQueue[i];

            switch (preGameBooster.typeID) {
                case preGameBoosters.LINECLEAR[0]:
                    Inventory.instance.addItem('PREBOOSTER_1', 1, 'return', 'unconsumed');
                    break;
                case preGameBoosters.BOMB:
                    Inventory.instance.addItem('PREBOOSTER_2', 1, 'return', 'unconsumed');
                    break;
                case preGameBoosters.COLORBOMB:
                    Inventory.instance.addItem('PREBOOSTER_3', 1, 'return', 'unconsumed');
                    break;
                default:
                    console.warn(preGameBooster.typeID, "not found");
                    break;
            }
        }
        this.preGameBoosterQueue.length = 0;
    },

    spawnPreGameBoosters: function () {
        if (this.preGameBoosterQueue.length > 0) {
            // check the available tile locations
            var availableTiles = GridManager.instance.getForegroundTilesOfType(foregroundTileEnum.DEFAULT, 3, true);

            while (this.preGameBoosterQueue.length > 0) {
                if (availableTiles.length === 0) {
                    availableTiles = GridManager.instance.getForegroundTilesOfType(foregroundTileEnum.DEFAULT, 2, true);
                    if (availableTiles.length === 0) {
                        break;
                    }
                }

                if (this.preGameBoosterQueue[this.preGameBoosterQueue.length - 1].amount > availableTiles.length) {
                    break;
                }

                var currentBooster = this.preGameBoosterQueue.pop();

                if (Xsolla.instance.loggedIn) {
                    if (!currentBooster.tutorial) {
                        switch (currentBooster.typeID) {
                            case foregroundTileEnum.LINE_H:
                                Xsolla.instance.consumeItem(Xsolla.SKU.BEES);
                                break;

                            case preGameBoosters.BOMB:
                                Xsolla.instance.consumeItem(Xsolla.SKU.LADYBUGS);
                                break;

                            case foregroundTileEnum.COLORBOMB:
                                Xsolla.instance.consumeItem(Xsolla.SKU.BUTTERFLY);
                                break;
                        }
                    }
                }

                for (var i = 0; i < currentBooster.amount; i++) {
                    var randomItemID = (availableTiles.length * Math.random() | 0);
                    var currentTile = availableTiles[randomItemID];
                    availableTiles.splice(randomItemID, 1);

                    // set new tile
                    var newTile = PowerTileManager.instance.switchTilePower(currentTile, currentBooster.typeID, this.preboosterAnimationTime);
                    PowerTileManager.instance.setTileState(newTile, ForegroundTile._PowerStates.ACTIVE);

                    var realX = currentTile.x;
                    var realY = currentTile.y;

                    var angle = GridManager.instance.calculateAngle(realX, realY, 0, 0);

                    currentTile.shakeTile();
                    currentTile.enlargeTile();

                    var boosterAnimationType = this.preboosterAnimationLibrary[currentBooster.typeID];

                    PowerAnimationManager.instance.preboosterSpawnAnimation(new pc.Vec2(0, 0), this.preboosterAnimationTime, realX === 0, realX < 0, realX, realY, angle, Math.max(Math.abs(0 - realX), Math.abs(0 - realY)), currentTile.colorID, currentTile, boosterAnimationType);
                }
            }


            GridManager.instance.checkAllPossibleMatches();
            GridManager.instance.startHintCountdown();
        }
    },


    doFreeSwap: function () {
        this._boostersActive[boosterEnum.FREESWAP] = false;
        GridManager.instance.stopHint();
        this.app.fire('BoosterManager:confirmedBooster', boosterEnum.FREESWAP);
    },

    doBreaker: function (tileScript) {
        if (!tileScript.canExplode) {
            return false;
        }

        this.app.fire('SwapMode:onPlayerMove');
        this.app.fire('Audio:sfx', 'shovel_dig.mp3');

        var matchTiles = [tileScript];

        tileScript.setDespawnDelay(1);
        if (PowerTileManager.instance.isPowerTile(tileScript.typeID)) {
            matchTiles = PowerTileManager.instance.activatePower(tileScript);
        }

        matchTiles = MatchLogic.getChainedPowerTileMatches(matchTiles);


        matchTiles.push(tileScript);

        var despawnDuration = GridManager.instance.getLongestTileDespawnDuration();

        SwapMode.instance.setState(matchStates.DESPAWN, despawnDuration);

        this.app.fire('SwapMode:onTileMatch', matchTiles);
        this.app.fire('BoosterManager:confirmedBooster', boosterEnum.BREAKER);
        this._boostersActive[boosterEnum.BREAKER] = false;

        this.doBreakerAnimation(tileScript.x, tileScript.y);

        return true;
    },

    doCrossBomb: function (tileScript) {
        if (!tileScript.canExplode) {
            return false;
        }
        this.app.fire('SwapMode:onPlayerMove');

        // zo gekopieerd van breaker
        var matchTiles = this.crossBombBehaviour.getAffectedTiles(tileScript);

        this.crossBombBehaviour.doActivateAnimation(tileScript);

        matchTiles = MatchLogic.getChainedPowerTileMatches(matchTiles);

        var despawnDuration = GridManager.instance.getLongestTileDespawnDuration();

        SwapMode.instance.setState(matchStates.DESPAWN, despawnDuration);

        matchTiles.push(tileScript);

        this.app.fire('SwapMode:onTileMatch', matchTiles);
        this.app.fire('Audio:sfx', 'beehive_hit.mp3');

        this.app.fire('BoosterManager:confirmedBooster', boosterEnum.CROSSBOMB);

        this.doCrossBombAnimation(tileScript.x, tileScript.y);
        this._boostersActive[boosterEnum.CROSSBOMB] = false;
        return true;
    },

    isBoosterActive: function (type) {
        return this._boostersActive[type];
    },

    activateBooster: function (type) {
        this._boostersActive[type] = true;
    },

    cancelBooster: function (type) {
        this._boostersActive[type] = false;
    },

    doBreakerAnimation: function (x, y) {
        var breakerAnimationObject = this.shovelPool.use();
        breakerAnimationObject.enabled = true;
        breakerAnimationObject.reparent(GridManager.instance.entity);
        var position = GridManager.instance.calculatePosition(x, y, 0);
        breakerAnimationObject.setPosition(position.x, position.y, position.z);
        breakerAnimationObject.animation.play('shovel_dig.glb', 0);
        pc.timer.add(0.8, () => {
            this.app.fire('vibrate', 100);
        });
        pc.timer.add(1.5, () => {
            this.shovelPool.recycle(breakerAnimationObject);
        }, this);
    },

    doFreeSwapAnimation: function (tile1, tile2) {
        var freeswapAnimationObject = this.handPool.use();
        freeswapAnimationObject.enabled = true;
        freeswapAnimationObject.reparent(GridManager.instance.entity);
        var position = GridManager.instance.calculatePosition(tile1.x, tile1.y, 0.5);
        freeswapAnimationObject.setPosition(position.x, position.y, position.z);
        // freeswapAnimationObject.setLocalPosition(0, 0, 0);
        freeswapAnimationObject.animation.play('freeswap_hand_grab.glb', 0);
        pc.timer.add(0.4, () => {
            this.app.fire('vibrate', 100);
        });

        var newPosition = GridManager.instance.calculatePosition(tile2.x, tile2.y, position.z);

        var moveTween = freeswapAnimationObject.tween(freeswapAnimationObject.getLocalPosition())
            .to({ x: newPosition.x, y: newPosition.y, z: newPosition.z }, GridManager.instance.moveDuration, pc.QuadraticInOut, this.freeSwapAnimationDelay)
            .start();

        pc.timer.add(1.5, () => {
            this.handPool.recycle(freeswapAnimationObject);
        }, this);
    },

    doCrossBombAnimation: function (x, y) {
        var crossbombAnimationObject = this.crossBombPool.use();
        crossbombAnimationObject.enabled = true;
        crossbombAnimationObject.reparent(GridManager.instance.entity);
        var position = GridManager.instance.calculatePosition(x, y, 0);
        crossbombAnimationObject.setPosition(position.x, position.y, position.z);
        crossbombAnimationObject.animation.play('beehiveabimnew.glb', 0);
        pc.timer.add(0.5, () => {
            this.app.fire('vibrate', 200);
        });

        pc.timer.add(1.5, () => {
            this.crossBombPool.recycle(crossbombAnimationObject);
        }, this);
    }
});

// LineHBehaviour.js
var LineHBehaviour = function() {
    this.initialize();
};

LineHBehaviour.duration = new pc.Vec2(0, 0.1); // Duration/offset

pc.extend(LineHBehaviour.prototype, {
    initialize: function() {
        this.combinationBehaviourScripts = Object.freeze({
            [foregroundTileEnum.LINE_H]: new LineCrossBehaviour(),
            [foregroundTileEnum.LINE_V]: new LineCrossBehaviour(),
            [foregroundTileEnum.COLORBOMB]: new LineColorBombBehaviour(),
            [foregroundTileEnum.BOMB]: new LineBombHBehaviour(),
        });

        this.app = pc.Application.getApplication();

        this.gridOvershoot = 2;
    },

    getAffectedTiles: function(tile, matchedTile) {
        var array = [];

        var hasCoat = tile.hasCoat() || (matchedTile && matchedTile.hasCoat());
        
        var animationData = { top: null, bottom: null };

        for (var x = tile.x; x < MatchLogic.columns; x += 1) {
            var _backgroundTile = GridManager.instance.getBackgroundTile(x, tile.y);

            var dX = Math.abs(x - tile.x);

            if (_backgroundTile.isPopper()) {
                if (!_backgroundTile.isPowerTriggered()) {
                    _backgroundTile.explode(PowerTileManager.instance.calculateDespawnDelay(dX, LineHBehaviour.duration.x, LineHBehaviour.duration.y) + tile.getDespawnDelay(), tile);

                    if (_backgroundTile.isDestroyed) {
                        var popperArray = PowerTileManager.instance.explodePopper(_backgroundTile);

                        pc.utils.fuseArray(array, popperArray);
                    }
                }
            }
            else if (_backgroundTile.canExplode()) {
                _backgroundTile.explode(PowerTileManager.instance.calculateDespawnDelay(dX, LineHBehaviour.duration.x, LineHBehaviour.duration.y) + tile.getDespawnDelay(), tile);
            }

            if (_backgroundTile.onlyBackgroundExplodes) {
                continue;
            }

            if (hasCoat) {
                _backgroundTile.changeToCoat(PowerTileManager.instance.calculateDespawnDelay(dX, LineHBehaviour.duration.x, LineHBehaviour.duration.y) + tile.getDespawnDelay());
            }

            var _tile = GridManager.instance.getTile(x, tile.y);
            if (!_tile) {
                continue;
            }

            if (!_tile.canExplode) {
                continue;
            }

            if (_tile.isHitByPower()) {
                continue;
            }

            array.push(_tile);
            _tile.setHitByPower();


            // set tile despawn if powerup
            if(_tile.typeID !== foregroundTileEnum.NONE && _tile.typeID !== foregroundTileEnum.DEFAULT) {
                _tile.setDespawnCause(foregroundTileEnum.LINE_H);
            }

            PowerTileManager.instance.setTileDespawnDelay(tile, _tile, dX, LineHBehaviour.duration.x, LineHBehaviour.duration.y);
            ImpulseManager.applyPulse(_tile.x, _tile.y, 1, 0.3, 0.05 + _tile.despawnDelay, 0.2);
            
            if (_tile.isSinker()) {
                animationData.right = x;
                break;
            }
        }

        for (var x = tile.x - 1; x >= 0; x--) {
            var _backgroundTile = GridManager.instance.getBackgroundTile(x, tile.y);

            var dX = Math.abs(x - tile.x);

            if (_backgroundTile.isPopper()) {
                if (!_backgroundTile.isPowerTriggered()) {
                    _backgroundTile.explode(PowerTileManager.instance.calculateDespawnDelay(dX, LineHBehaviour.duration.x, LineHBehaviour.duration.y) + tile.getDespawnDelay(), tile);

                    if (_backgroundTile.isDestroyed) {
                        var popperArray = PowerTileManager.instance.explodePopper(_backgroundTile);

                        pc.utils.fuseArray(array, popperArray);
                    }
                }
            }
            else if (_backgroundTile.canExplode()) {
                _backgroundTile.explode(PowerTileManager.instance.calculateDespawnDelay(dX, LineHBehaviour.duration.x, LineHBehaviour.duration.y) + tile.getDespawnDelay(), tile);
            }

            if (_backgroundTile.onlyBackgroundExplodes) {
                continue;
            }

            if (hasCoat) {
                _backgroundTile.changeToCoat(PowerTileManager.instance.calculateDespawnDelay(dX, LineHBehaviour.duration.x, LineHBehaviour.duration.y) + tile.getDespawnDelay());
            }

            var _tile = GridManager.instance.getTile(x, tile.y);
            if (!_tile) {
                continue;
            }

            if (!_tile.canExplode) {
                continue;
            }

            if (_tile.isHitByPower()) {
                continue;
            }

            array.push(_tile);
            _tile.setHitByPower();

            // set tile despawn if powerup
            if(_tile.typeID !== foregroundTileEnum.NONE && _tile.typeID !== foregroundTileEnum.DEFAULT) {
                _tile.setDespawnCause(foregroundTileEnum.LINE_H);
            }

            PowerTileManager.instance.setTileDespawnDelay(tile, _tile, dX, LineHBehaviour.duration.x, LineHBehaviour.duration.y);
            ImpulseManager.applyPulse(_tile.x, _tile.y, 1, 0.3, 0.05 + _tile.despawnDelay, 0.2);
            
            if (_tile.isSinker()) {
                animationData.left = x;
                break;
            }
        }

        tile.setPowerAnimation(animationData);

        return array;
    },

    getCombinationScript: function(power2ID) {
        var combinationBehaviour = this.combinationBehaviourScripts[power2ID];
        if (!combinationBehaviour) {
            return null;
        }
        return combinationBehaviour;
    },

    doActivateAnimation: function(tile) {
        var animationData = tile.getPowerAnimation();

        var leftX = animationData && typeof animationData.left === 'number' ? animationData.left : 0 - this.gridOvershoot;
        var rightX = animationData && typeof animationData.right === 'number' ? animationData.right : MatchLogic.columns - 1 + this.gridOvershoot;
        
        //start anim
        GridManager.instance.playSFX('line_flowers.mp3');
        GameVibrationManager.instance.addVibration(GameVibrationManager.LINE_BOMB_PATTERN);
        PowerAnimationManager.instance.createLineAnimation(tile, LineHBehaviour.duration, false, true, leftX, tile.y, 270, tile.colorID);
        PowerAnimationManager.instance.createLineAnimation(tile, LineHBehaviour.duration, false, false, rightX, tile.y, 90, tile.colorID);
    },
});

// LineVBehaviour.js
var LineVBehaviour = function() {
    this.initialize();  
};

LineVBehaviour.duration = new pc.Vec2(0, 0.1); // Duration/offset

pc.extend(LineVBehaviour.prototype, {
    initialize: function() {
        this.combinationBehaviourScripts = Object.freeze({
            [foregroundTileEnum.LINE_H]: new LineCrossBehaviour(),
            [foregroundTileEnum.LINE_V]: new LineCrossBehaviour(),
            [foregroundTileEnum.COLORBOMB]: new LineColorBombBehaviour(),
            [foregroundTileEnum.BOMB]: new LineBombVBehaviour(),
        });

        this.app = pc.Application.getApplication();

        this.gridOvershoot = 2;
    },

    getAffectedTiles: function(tile, matchedTile) {
        var array = [];

        var hasCoat = tile.hasCoat() || (matchedTile && matchedTile.hasCoat());

        var animationData = { top: null, bottom: null };
        
        for (var y = tile.y; y < MatchLogic.rows; y += 1) {
            var _backgroundTile = GridManager.instance.getBackgroundTile(tile.x, y);

            var dY = Math.abs(y - tile.y);

            if (hasCoat) {
                _backgroundTile.changeToCoat(PowerTileManager.instance.calculateDespawnDelay(dY, LineVBehaviour.duration.x, LineVBehaviour.duration.y) + tile.getDespawnDelay());
            }

            if (_backgroundTile.isPopper()) {
                if (!_backgroundTile.isPowerTriggered()) {
                    _backgroundTile.explode(PowerTileManager.instance.calculateDespawnDelay(dY, LineVBehaviour.duration.x, LineVBehaviour.duration.y) + tile.getDespawnDelay(), tile);

                    if (_backgroundTile.isDestroyed) {
                        var popperArray = PowerTileManager.instance.explodePopper(_backgroundTile);

                        pc.utils.fuseArray(array, popperArray);
                    }
                }
            }
            else if (_backgroundTile.canExplode()) {
                _backgroundTile.explode(PowerTileManager.instance.calculateDespawnDelay(dY, LineVBehaviour.duration.x, LineVBehaviour.duration.y) + tile.getDespawnDelay(), tile);
            }

            if (_backgroundTile.onlyBackgroundExplodes) {
                continue;
            }

            var _tile = GridManager.instance.getTile(tile.x, y);

            if (!_tile) {
                continue;
            }

            if (!_tile.canExplode) {
                continue;
            }

            if (_tile.isHitByPower()) {
                continue;
            }

            array.push(_tile);
            _tile.setHitByPower();

            // set tile despawn if powerup
            if(_tile.typeID !== foregroundTileEnum.NONE && _tile.typeID !== foregroundTileEnum.DEFAULT) {
                _tile.setDespawnCause(foregroundTileEnum.LINE_V);
            }

            PowerTileManager.instance.setTileDespawnDelay(tile, _tile, dY, LineVBehaviour.duration.x, LineVBehaviour.duration.y);
            ImpulseManager.applyPulse(_tile.x, _tile.y, 1, 0.3, 0.05 + _tile.despawnDelay, 0.2);
            
            if (_tile.isSinker()) {
                animationData.top = y;
                break;
            }
        }

        for (var y = tile.y - 1; y >= 0; y--) {
            var _backgroundTile = GridManager.instance.getBackgroundTile(tile.x, y);

            var dY = Math.abs(y - tile.y);

            if (hasCoat) {
                _backgroundTile.changeToCoat(PowerTileManager.instance.calculateDespawnDelay(dY, LineVBehaviour.duration.x, LineVBehaviour.duration.y) + tile.getDespawnDelay());
            }

            if (_backgroundTile.isPopper()) {
                if (!_backgroundTile.isPowerTriggered()) {
                    _backgroundTile.explode(PowerTileManager.instance.calculateDespawnDelay(dY, LineVBehaviour.duration.x, LineVBehaviour.duration.y) + tile.getDespawnDelay(), tile);

                    if (_backgroundTile.isDestroyed) {
                        var popperArray = PowerTileManager.instance.explodePopper(_backgroundTile);

                        pc.utils.fuseArray(array, popperArray);
                    }
                }
            }
            else if (_backgroundTile.canExplode()) {
                _backgroundTile.explode(PowerTileManager.instance.calculateDespawnDelay(dY, LineVBehaviour.duration.x, LineVBehaviour.duration.y) + tile.getDespawnDelay(), tile);
            }

            if (_backgroundTile.onlyBackgroundExplodes) {
                continue;
            }

            var _tile = GridManager.instance.getTile(tile.x, y);

            if (!_tile) {
                continue;
            }

            if (!_tile.canExplode) {
                continue;
            }

            if (_tile.isHitByPower()) {
                continue;
            }

            array.push(_tile);
            _tile.setHitByPower();

            // set tile despawn if powerup
            if(_tile.typeID !== foregroundTileEnum.NONE && _tile.typeID !== foregroundTileEnum.DEFAULT) {
                _tile.setDespawnCause(foregroundTileEnum.LINE_V);
            }

            PowerTileManager.instance.setTileDespawnDelay(tile, _tile, dY, LineVBehaviour.duration.x, LineVBehaviour.duration.y);
            ImpulseManager.applyPulse(_tile.x, _tile.y, 1, 0.3, 0.05 + _tile.despawnDelay, 0.2);
            
            
            if (_tile.isSinker()) {
                animationData.bottom = y;

                break;
            }
        }
        
        tile.setPowerAnimation(animationData);

        return array;
    },

    getCombinationScript: function(power2ID) {
        var combinationBehaviour = this.combinationBehaviourScripts[power2ID];
        if (!combinationBehaviour) {
            return null;
        }
        return combinationBehaviour;
    },

    doActivateAnimation: function(tile) {
        var animationData = tile.getPowerAnimation();
        
        var topY = animationData && typeof animationData.bottom === 'number' ? animationData.bottom : 0 - this.gridOvershoot;
        var bottomY = animationData && typeof animationData.top === 'number' ? animationData.top : MatchLogic.rows - 1 + this.gridOvershoot;


        PowerAnimationManager.instance.createLineAnimation(tile, LineVBehaviour.duration, true, true, tile.x, topY, 180, tile.colorID);
        PowerAnimationManager.instance.createLineAnimation(tile, LineVBehaviour.duration, true, true, tile.x, bottomY, 0, tile.colorID);
        GridManager.instance.playSFX('line_flowers.mp3');
        GameVibrationManager.instance.addVibration(GameVibrationManager.LINE_BOMB_PATTERN);
    },
});

// BombBehaviour.js
var BombBehaviour = function() {
    this.initialize();
};

BombBehaviour.duration = new pc.Vec2(0, 0.2); // Duration/offset

pc.extend(BombBehaviour.prototype, {
    initialize: function() {
        this.combinationBehaviourScripts = Object.freeze({
            [foregroundTileEnum.LINE_H]: new LineBombHBehaviour(),
            [foregroundTileEnum.LINE_V]: new LineBombVBehaviour(),
            [foregroundTileEnum.COLORBOMB]: new BombColorBombBehaviour(),
            [foregroundTileEnum.BOMB]: new BigBombBehaviour(),
        });

        this.lines = [];
        this.sinkers = [];

        this.app = pc.Application.getApplication();

        this.duration = new pc.Vec2(0, 0);
    },

    getAffectedTiles: function(tile, matchedTile) {
        var array = [];

        var affectedTiles = [];
        this.sinkers.length = 0;
        this.lines.length = 0;

        var hasCoat = tile.hasCoat() || (matchedTile && matchedTile.hasCoat());

        for (var x = tile.x - 2; x <= tile.x + 2; x += 1) {
            var maxLimit = 2; // default height

            if(x === tile.x - 2 || x === tile.x + 2)
                maxLimit = 1;

            for (var y = tile.y - maxLimit; y <= tile.y + maxLimit; y += 1) {
                // fix grid edge seam
                if (x < 0) continue;
                if (x >= MatchLogic.columns) continue;

                if (y >= 0 && y < MatchLogic.rows) {
                    var _tile = GridManager.instance.getTile(x, y);

                    affectedTiles.push({ x, y });

                    if (_tile && _tile.isSinker()) {            
                        this.sinkers.push({ x, y });
                    }
                }
            }
        }

        for (var i = 0; i < this.sinkers.length; i++) {
            var x = this.sinkers[i].x;
            var y = this.sinkers[i].y;
            this.createLines(x, y);
        }

        this.filterLines();

        //RenderLine.instance.set(this.lines);

        for (var i = 0; i < affectedTiles.length; i++) {
            var x = affectedTiles[i].x;
            var y = affectedTiles[i].y;

            if (this.lineCollision(tile.x + 0.5, tile.y + 0.5, x + 0.5, y + 0.5)) {
                continue;
            }

            var _backgroundTile = GridManager.instance.getBackgroundTile(x, y);

            var dX = Math.abs(tile.x - x);
            var dY = Math.abs(tile.y - y);

            var despawnDelay = PowerTileManager.instance.calculateDespawnDelay(Math.max(dX, dY), BombBehaviour.duration.x, BombBehaviour.duration.y) + tile.getDespawnDelay();

            if (hasCoat) {
                _backgroundTile.changeToCoat(despawnDelay);
            }

            if (_backgroundTile.isPopper()) {
                if (!_backgroundTile.isPowerTriggered()) {
                    _backgroundTile.explode(despawnDelay, tile);

                    if (_backgroundTile.isDestroyed) {
                        var popperArray = PowerTileManager.instance.explodePopper(_backgroundTile);

                        pc.utils.fuseArray(array, popperArray);
                    }
                }
            } else if (_backgroundTile.canExplode()) {

                _backgroundTile.explode(despawnDelay, tile);
            }

            if (_backgroundTile.onlyBackgroundExplodes) {
                continue;
            }

            var _tile = GridManager.instance.getTile(x, y);
            if (!_tile) {
                continue;
            }

            if (!_tile.canExplode) {
                continue;
            }

            if (_tile.isHitByPower()) {
                continue;
            }

            array.push(_tile);
            _tile.setHitByPower();


            if(_tile.typeID !== foregroundTileEnum.NONE && _tile.typeID !== foregroundTileEnum.DEFAULT) {
                _tile.setDespawnCause(foregroundTileEnum.BOMB);
            }

            PowerTileManager.instance.setTileDespawnDelay(tile, _tile, Math.max(dX, dY), BombBehaviour.duration.x, BombBehaviour.duration.y);
        }

        var animationData = [];

        for (var x = tile.x - 2; x <= tile.x + 2; x += 1) {
            var maxLimit = 2; // default height

            if(x === tile.x - 2 || x === tile.x + 2)
                maxLimit = 1;

            for (var y = tile.y - maxLimit; y <= tile.y + maxLimit; y += 1) {
                if((y > tile.y - maxLimit && y < tile.y + maxLimit) && x !== tile.x - 2 && x !== tile.x + 2) continue; 

                animationData.push(this.getLinePosition(tile.x + 0.5, tile.y + 0.5, x + 0.5, y + 0.5));
            }
        }

        tile.setPowerAnimation(animationData);

        ImpulseManager.applyPulse(tile.x, tile.y, 5, 1, 0.05 + tile.despawnDelay, 0.2);

        return array;
    },

    getCombinationScript: function(power2ID) {
        var combinationBehaviour = this.combinationBehaviourScripts[power2ID];
        if (!combinationBehaviour) {
            return null;
        }
        return combinationBehaviour;
    },

    doActivateAnimation: function(tile) {
        var canPlaySound = true;

        GridManager.instance.playSFX('bomb_detonate_flowers.mp3');
        GameVibrationManager.instance.addVibration(GameVibrationManager.BOMB_PATTERN);

        var animationData = tile.getPowerAnimation();

        for (var i = 0; i < animationData.length; i++) {
            this.createAnimation(animationData, i, tile, 0.01, canPlaySound);
        }
    },

    createAnimation: function(animationData, i, tile, delay, canPlaySound) {
        pc.timer.add(delay, () => {
            var data = animationData[i];

            var realX = data.x;
            var realY = data.y;

            var angle = this.calculateAngle(realX, realY, tile.x, tile.y);
            this.duration.set(BombBehaviour.duration.x / Math.max(Math.abs(tile.x - realX), Math.abs(tile.y - realY)) * 2, BombBehaviour.duration.y / Math.max(Math.abs(tile.x - realX), Math.abs(tile.y - realY)) * 2);
            PowerAnimationManager.instance.createBombAnimation(tile, this.duration, realX === tile.x, realX < tile.x, realX, realY, angle, Math.max(Math.abs(tile.x - realX), Math.abs(tile.y - realY)), tile.colorID, canPlaySound);
        });
    },

    calculateAngle: function(x, y, centerx, centery) {
        var deltaX =  x - centerx;
        var deltaY =  y - centery;
        var degrees = Math.atan2(deltaY, deltaX) * 180.0 / Math.PI;
        return degrees * -1 + 90;
    },

    createLines: function(_x, _y) {
        this.lines.push({ x1: _x, y1: _y, x2: _x + 1, y2: _y });
        this.lines.push({ x1: _x, y1: _y, x2: _x, y2: _y + 1 });
        this.lines.push({ x1: _x + 1, y1: _y, x2: _x + 1, y2: _y + 1 });
        this.lines.push({ x1: _x, y1: _y + 1, x2: _x + 1, y2: _y + 1 });

        this.lines.push({ x1: _x, y1: _y, x2: _x + 1, y2: _y + 1 });
        this.lines.push({ x1: _x, y1: _y + 1, x2: _x + 1, y2: _y });

        if (this.sinkers.find(sinker => sinker.x === _x - 1 && sinker.y === _y + 1)) {
            this.lines.push({ x1: _x + 0.5 - 1, y1: _y + 0.5 + 1, x2: _x + 0.5, y2: _y + 0.5 });
            this.lines.push({ x1: _x + 0.5 - 1, y1: _y + 0.5, x2: _x + 0.5, y2: _y + 0.5 + 1 });
        } 

        if (this.sinkers.find(sinker => sinker.x === _x + 1 && sinker.y === _y + 1)) {
            this.lines.push({ x1: _x + 0.5, y1: _y + 0.5 + 1, x2: _x + 0.5 + 1, y2: _y + 0.5 });
            this.lines.push({ x1: _x + 0.5, y1: _y + 0.5, x2: _x + 0.5 + 1, y2: _y + 0.5 + 1 });
        } 
    },

    filterLines: function() {
        for (var i = this.lines.length - 1; i >= 0; i--) {
            var _x1 = this.lines[i].x1;
            var _y1 = this.lines[i].y1;

            var _x2 = this.lines[i].x2;
            var _y2 = this.lines[i].y2;

            for (var j = this.lines.length - 1; j >= 0; j--) {
                if (i === j) {
                    continue;
                }

                var x1 = this.lines[j].x1;
                var y1 = this.lines[j].y1;

                var x2 = this.lines[j].x2;
                var y2 = this.lines[j].y2;

                if ((_x1 === x1 && _y1 === y1 && _x2 === x2 && _y2 === y2) || (_x1 === x2 && _y1 === y2 && _x2 === x1 && _y2 === y1)) {
                    this.lines.splice(i, 1);
                    break;
                }
            } 
        }
    },

    lineCollision: function(x1, y1, x2, y2) {
        var count = 0; 
        for (var i = 0; i < this.lines.length; i++) {
            var line = this.lines[i];

            if (this.checkLineIntersection(x1, y1, x2, y2, line.x1, line.y1, line.x2, line.y2)) {
                count++;

                if (count > 1) {
                    return true;
                }
            }
        }  

        return count > 1;
    },

    checkLineIntersection: function(x1, y1, x2,y2, x3, y3, x4, y4) {        
        if (x1 === x3 && x2 === x4 && y1 === y3 && y2 === y4) {
            return true;
        }

        var denominator = (x2 - x1) * (y4 - y3) - (y2 - y1) * (x4 - x3);

        if (denominator === 0) {
            var x3Dif = x3 - x1;
            var x4Dif = x4 - x1;

            if ((x3Dif === 0 && y3 === y1 || this.equals((y3 - y1) / (x3 - x1), (y2 - y1) / (x2 - x1))) && (x4Dif === 0 && y4 === y1 || this.equals((y4 - y1) / (x4 - x1), (y2 - y1) / (x2 - x1)))) {
                if (x3 < Math.max(x1, x2) && x3 > Math.min(x1, x2)) {
                    return true;
                }

                if (x4 < Math.max(x1, x2) && x4 > Math.min(x1, x2)) {
                    return true;
                }

                if (y3 < Math.max(y1, y2) && y3 > Math.min(y1, y2)) {
                    return true;
                }

                if (y4 < Math.max(y1, y2) && y4 > Math.min(y1, y2)) {
                    return true;
                }

                return false;
            } else {
                return false;
            }
        }

        var numerator1 = (y1 - y3) * (x4 - x3) - (x1 - x3) * (y4 - y3);
        var numerator2 = (y1 - y3) * (x2 - x1) - (x1 - x3) * (y2 - y1);

        if (numerator1 === 0 || numerator2 === 0)
        {
            return false;
        }

        var r = numerator1 / denominator;
        var s = numerator2 / denominator;

        return (r > 0 && r < 1) && (s > 0 && s < 1);
    },

    getLinePosition: function(x1, y1, x2, y2) {
        var collisions = [];

        for (var i = 0; i < this.lines.length; i++) {
            var line = this.lines[i];

            var position = this.getLineIntersectionPosition(x1, y1, x2, y2, line.x1, line.y1, line.x2, line.y2);

            if (position instanceof pc.Vec3) {
                collisions.push(position);
            }
        }  

        if (collisions.length > 1) {
            collisions.sort((vec3_1, vec3_2) => ((vec3_1.x - x1) * (vec3_1.x - x1) + (vec3_1.y - y1) * (vec3_1.y - y1)) - ((vec3_2.x - x1) * (vec3_2.x - x1) + (vec3_2.y - y1) * (vec3_2.y - y1)));

            collisions[1].sub(new pc.Vec3(0.5, 0.5, 0.5));

            return collisions[1];
        } else {
            return new pc.Vec3(x2 - 0.5, y2 - 0.5, 1);
        }
    },

    getLineIntersectionPosition: function(x1, y1, x2,y2, x3, y3, x4, y4) {        
        if (x1 === x3 && x2 === x4 && y1 === y3 && y2 === y4) {
            return new pc.Vec3((x3 + x4) / 2, (y3 + y4) / 2, 0);
        }

        var denominator = (x2 - x1) * (y4 - y3) - (y2 - y1) * (x4 - x3);

        if (denominator === 0) {
            var x3Dif = x3 - x1;
            var x4Dif = x4 - x1;

            if ((x3Dif === 0 && y3 === y1 || this.equals((y3 - y1) / (x3 - x1), (y2 - y1) / (x2 - x1))) && (x4Dif === 0 && y4 === y1 || this.equals((y4 - y1) / (x4 - x1), (y2 - y1) / (x2 - x1)))) {
                if (x3 < Math.max(x1, x2) && x3 > Math.min(x1, x2)) {
                    return new pc.Vec3((x3 + x4) / 2, (y3 + y4) / 2, 0);
                }

                if (x4 < Math.max(x1, x2) && x4 > Math.min(x1, x2)) {
                    return new pc.Vec3((x3 + x4) / 2, (y3 + y4) / 2, 0);
                }

                if (y3 < Math.max(y1, y2) && y3 > Math.min(y1, y2)) {
                    return new pc.Vec3((x3 + x4) / 2, (y3 + y4) / 2, 0);
                }

                if (y4 < Math.max(y1, y2) && y4 > Math.min(y1, y2)) {
                    return new pc.Vec3((x3 + x4) / 2, (y3 + y4) / 2, 0);
                }

                return null;
            } else {
                return null;
            }
        }

        var numerator1 = (y1 - y3) * (x4 - x3) - (x1 - x3) * (y4 - y3);
        var numerator2 = (y1 - y3) * (x2 - x1) - (x1 - x3) * (y2 - y1);

        if (numerator1 === 0 || numerator2 === 0)
        {
            return null;
        }

        var r = numerator1 / denominator;
        var s = numerator2 / denominator;

        if ((r > 0 && r < 1) && (s > 0 && s < 1)) {
            var x = x1 + (r * (x2 - x1));
            var y = y1 + (r * (y2 - y1));
            return new pc.Vec3(x, y, 0);
        }
    },

    equals(a, b) {
        return a > b - BombBehaviour.EPS && a < b + BombBehaviour.EPS;
    }
});

BombBehaviour.EPS = 0.0000001;


// ColorBombBehaviour.js
var ColorBombBehaviour = function () {
    this.initialize();
};

ColorBombBehaviour.duration = new pc.Vec2(0, 2); // Duration/offset was: 2
ColorBombBehaviour.DELAY_BETWEEN_TILE = 0.1;
pc.extend(ColorBombBehaviour.prototype, {
    initialize: function () {
        this.combinationBehaviourScripts = Object.freeze({
            [foregroundTileEnum.LINE_H]: new LineColorBombBehaviour(),
            [foregroundTileEnum.LINE_V]: new LineColorBombBehaviour(),
            [foregroundTileEnum.COLORBOMB]: new UltimateColorBombBehaviour(),
            [foregroundTileEnum.BOMB]: new BombColorBombBehaviour(),
        });

        this.array = [];
        this.affectedTiles = [];

        this.app = pc.Application.getApplication();
    },

    getAffectedTiles: function (tile, matchedTile) {
        var matchedTileColorID = null;
        if (!matchedTile) {
            // color bomb is set off by another powerTile, get random color
            matchedTileColorID = ColorManager.instance.getColorMostInGrid();

        } else {
            matchedTileColorID = matchedTile.colorID;

            if (matchedTileColorID === tileColorEnum.NONE) {
                return [];
            }

            tile.colorBombCause = matchedTile;
        }

        var hasCoat = tile.hasCoat() || (matchedTile && matchedTile.hasCoat());
        this.array.length = 0;
        this.affectedTiles.length = 0;

        for (var y = MatchLogic.rows - 1; y >= 0; y -= 1) {
            for (var x = 0; x < MatchLogic.columns; x += 1) {

                var _tile = GridManager.instance.getTile(x, y);
                var _backgroundTile = GridManager.instance.getBackgroundTile(x, y);

                if (_backgroundTile.onlyBackgroundExplodes && !_backgroundTile.canExplode()) {
                    continue;
                }

                if (!_tile) {
                    continue;
                }

                if (!_tile.canExplode) {
                    continue;
                }

                if (_tile.isHitByPower()) {
                    continue;
                }

                if (!_tile.isActive()) {
                    continue;
                }

                if (_tile.colorID === matchedTileColorID && !_tile.isHitByPower()) {
                    this.affectedTiles.push(_tile);
                }
            }
        }

        pc.utils.shuffleArray(this.affectedTiles);

        let delay = PowerTileManager.instance.calculateDespawnDelay(1, ColorBombBehaviour.duration.x, ColorBombBehaviour.duration.y);

        for (var i = 0; i < this.affectedTiles.length; i++) {
            const _tile = this.affectedTiles[i];
            this.array.push(_tile);
            _tile.setHitByPower();
            if (!tile.colorBombCause) {
                tile.colorBombCause = _tile;
            }

            PowerTileManager.instance.setTileDespawnDelay(tile, _tile, delay);

            delay += ColorBombBehaviour.DELAY_BETWEEN_TILE;

            if (hasCoat) {
                const _backgroundTile = GridManager.instance.getBackgroundTile(_tile.x, _tile.y);
                if (_backgroundTile) {
                    const realDelay = tile ? tile.getDespawnDelay() : delay;

                    _backgroundTile.changeToCoat(realDelay + delay);

                } else {
                    console.log("no background tile")
                }
            }
        }


        // add the bomb itself
        this.array.push(tile);

        tile.setDespawnCause(foregroundTileEnum.COLORBOMB);

        PowerTileManager.instance.setTileDespawnDelay(tile, tile, 0, ColorBombBehaviour.duration.x, ColorBombBehaviour.duration.y);

        return this.array;
    },

    getCombinationScript: function (power2ID) {
        var combinationBehaviour = this.combinationBehaviourScripts[power2ID];
        if (!combinationBehaviour) {
            return null;
        }
        return combinationBehaviour;
    },

    doActivateAnimation: function (tile, affectedTiles) {
        for (var i = 0; i < affectedTiles.length; i++) {

            var realX = affectedTiles[i].x;
            var realY = affectedTiles[i].y;
            var angle = GridManager.instance.calculateAngle(realX, realY, tile.x, tile.y);

            if (!(realX === tile.x && realY === tile.y)) {
                this.createColorBombParticleAnimation(tile, realX, realY, angle, tile.colorID, affectedTiles[i], 0.01 + i * BombColorBombBehaviour.DELAY_BETWEEN_TILE);

                affectedTiles[i].shakeTile();
                var backgroundTile = GridManager.instance.getBackgroundTile(affectedTiles[i].x, affectedTiles[i].y);
                if (backgroundTile) {
                    backgroundTile.shakeTile();
                }
                affectedTiles[i].enlargeTile();
            }
        }
        PowerAnimationManager.instance.createColorBombAnimation(tile, ColorBombBehaviour.duration.y);
        GridManager.instance.playSFX('colorbomb_flowers.mp3');
        GameVibrationManager.instance.addVibration(GameVibrationManager.COLOR_BOMB_PATTERN);
    },


    createColorBombParticleAnimation: function (tile, realX, realY, angle, colorID, shakingTile, delay) {
        pc.timer.add(delay, () => {
            PowerAnimationManager.instance.createColorBombParticleAnimation(tile, ColorBombBehaviour.duration.y, realX === tile.x, realX < tile.x, realX, realY, angle, Math.max(Math.abs(tile.x - realX), Math.abs(tile.y - realY)), colorID, shakingTile, powerAnimationTypes.COLORBOMB);
        });
    },

});

// ScoreManager.js
var ScoreManager = pc.createScript('scoreManager');

// WK: in the future this manager, or another script, needs to be able to define the position of the score in a 3D space.

pc.extend(ScoreManager.prototype, {

    initialize: function() {
        ScoreManager.instance = this;

        this._score = 0;

        this._levelScore = 0;

        this._cascadeValue = 1;
        this._cascadeIncrease = 1;

        this._threeTileMatchScore = 60;
        this._fourTileMatchScore = 120;
        this._fiveTileMatchScore = 200;

        this._powerTilePoints = 60;
        this._createdEndPowerTilePoints = 3000;

        this._backgroundDefaultPoints = 20;
        this._backgroundObjectivePoints = 100;

        this._foregroundObjectivePoints = 100;
        this._foregroundSpecialPoints = 10000;
        this._foregroundExploderPoints = 3000;

        this.app.on('SwapMode:onCascadeNext', this._increaseCascadeValue, this);
        this.app.on('SwapMode:onCascadeDone', this._resetCascadeValue, this);

        this.app.on('ScoreManager:onTileMatch', this._tileMatchScore, this);

        this.app.on('ScoreManager:scoreEachPowerTile', this._addDestroyedPowerTilePoints, this);
        this.app.on('ScoreManager:scoreBackgroundTile', this._scoreBackgroundTile, this);
        this.app.on('ScoreManager:scoreForegroundTile', this._scoreForegroundTile, this);
        this.app.on('ScoreManager:scoreEndModeCreatePower', this._scoreEndModeCreatePower, this);

        this.app.on('LevelManager:onLevelStart', this._resetScore, this);
        this.app.on('LevelManager:levelComplete', this._onGameFinish, this);

        // this.app.on('LevelManager:onLevelStart', this.setStarValues, this);
    },

    _addToScore: function(addition) {
        this._score += addition;
        this._levelScore += addition;
        
        this.app.fire('ScoreManager:setScore', this._score);
    },

    _tileMatchScore: function(tilesInMatch, matchTile) {
        if (tilesInMatch === 3) {
            this._threeTileMatch(matchTile);
        } 
        else if (tilesInMatch === 4) {
            this._fourTileMatch(matchTile);
        }
        else if (tilesInMatch >= 5) {
            this._overFiveMatch(matchTile);
        }
    },

    _threeTileMatch: function(matchTile) {
        var score = this._threeTileMatchScore * this._cascadeValue;
        matchTile.setScoreAfterDelay(score);
        this._addToScore(score);
    },

    _fourTileMatch: function(matchTile) {
        var score = this._fourTileMatchScore * this._cascadeValue;
        matchTile.setScoreAfterDelay(score);
        this._addToScore(score);
    },

    _overFiveMatch: function(matchTile) {
        var score = this._fiveTileMatchScore * this._cascadeValue;
        matchTile.setScoreAfterDelay(score);
        this._addToScore(score);
    },

    _addDestroyedPowerTilePoints: function(tiles) {
        var score = this._powerTilePoints * tiles.length;
        for (var i = 0; i < tiles.length; i += 1) {
            var tile = tiles[i];
            
            if (!tile.canGetPointsFromDestroyedPowerTile()) {
                continue;
            }
            
            if (!GridManager.instance.canExplode(tile.x, tile.y)) {
                score -= this._powerTilePoints;
            } else {
                tile.setScoreAfterDelay(this._powerTilePoints);
            }
        }
                
        this._addToScore(score);
    },

    _scoreEndModeCreatePower: function(tile) {
        var score = this._createdEndPowerTilePoints;
        tile.setScoreAfterDelay(score);
        this._addToScore(score);
    },

    _scoreBackgroundTile: function(type, isObjective, tile) {
        var score = 0;
        switch (type) {
            case backgroundTileEnum.COAT:
                break;
            default:
                score = isObjective ? this._backgroundObjectivePoints : this._backgroundDefaultPoints;
                break;
        }
        
        tile.setScoreAfterDelay(score);
        this._addToScore(score);
    },

    _scoreForegroundTile: function(type, isObjective, tile) {
        var score = 0;
        switch (type) {
            case foregroundTileEnum.EXPLODER:
                score = this._foregroundExploderPoints;
                break;
                
            case foregroundTileEnum.SWITCHER:
            case foregroundTileEnum.DROPPER:
                score = this._foregroundSpecialPoints;
                break;
                
            case foregroundTileEnum.DEFAULT:
                score = isObjective ? this._foregroundObjectivePoints : 0;
                break;
        }

        if (score === 0) return;
        tile.setScoreAfterDelay(score);
        this._addToScore(score);
    },

    _increaseCascadeValue: function() {
        this._cascadeValue += this._cascadeIncrease;

        TrackingManager.instance.updateScore();
    },

    _resetCascadeValue: function() {
        this._cascadeValue = 1;
    },

    _onGameFinish: function() {

    },

    //TODO: Only reset after score screen after level
    _resetScore: function() {
        this._score = 0;
        this.resetLevelScore();
        this.app.fire('ScoreManager:setScore', this._score);
    },

    resetLevelScore: function() {
        this._levelScore = 0;
    },

    getCurrentLevelScore: function() {
        return this._levelScore;
    },

    getScore: function() {
        return this._score;
    },

    getStars: function() {
        var stars = 1;
        
        if (this._score >= this.star3Value) stars = 3;
        else if (this._score >= this.star2Value) stars = 2;
        else if (this._score >= this.star1Value) stars = 1;
        return stars;
    },

    setStarValues: function(starArray) {
        this.star3Value = starArray[2]; //TODO get from level data
        this.star2Value = starArray[1]; //TODO get from level data
        this.star1Value = starArray[0];
        this.app.fire('ScoreManager:setStarValues', this.star1Value, this.star2Value, this.star3Value);
    },
    
    cheatStars: function(amount) {
        if (!amount) amount = 1;
        if (amount === 3) {
            this._score = this.star3Value;
        } else if (amount === 2) {
            this._score = this.star2Value;
        } else {
            this._score = this.star1Value;
        }
        this.app.fire('ScoreManager:setScore', this._score);
        LevelManager.instance.onWin();
    }
});

// LineCrossBehaviour.js
var LineCrossBehaviour = function() {
    this.initialize();  
};

//LineCrossBehaviour.duration = new pc.Vec2(0, 0.1);
LineCrossBehaviour.duration = new pc.Vec2(1.2, 0.07);

pc.extend(LineCrossBehaviour.prototype, {
    initialize: function() {
        this.app = pc.Application.getApplication();
        this.gridOvershoot = 2;
    },

    getAffectedTiles: function(tile1, tile2) {
        var array = [];
        var tile;

        var animationData = {
            left: null,
            right: null,
            top: null,
            bottom: null,
        };

        var hasCoat = tile1.hasCoat() || (tile2 && tile2.hasCoat());
        
        for (var x = tile1.x; x < MatchLogic.columns; x += 1) {
            var _backgroundTile = GridManager.instance.getBackgroundTile(x, tile1.y);

            var dX = Math.abs(x - tile1.x);

            if (_backgroundTile.isPopper()) {
                if (!_backgroundTile.isPowerTriggered()) {
                    _backgroundTile.explode(PowerTileManager.instance.calculateDespawnDelay(dX, LineCrossBehaviour.duration.x, LineCrossBehaviour.duration.y), tile);

                    if (_backgroundTile.isDestroyed) {
                        var popperArray = PowerTileManager.instance.explodePopper(_backgroundTile);

                        pc.utils.fuseArray(array, popperArray);
                    }
                }
            }
            else if (_backgroundTile.canExplode()) {
                _backgroundTile.explode(PowerTileManager.instance.calculateDespawnDelay(dX, LineCrossBehaviour.duration.x, LineCrossBehaviour.duration.y), tile1);
            }    

            if (_backgroundTile.onlyBackgroundExplodes) {
                continue;
            }

            if (hasCoat) {
                _backgroundTile.changeToCoat(PowerTileManager.instance.calculateDespawnDelay(dX, LineCrossBehaviour.duration.x, LineCrossBehaviour.duration.y));
            }

            tile = GridManager.instance.getTile(x, tile1.y);

            if (!tile) {
                continue;
            }

            if (tile === tile1 || tile === tile2) {
                continue;
            }

            if (!tile.canExplode) {
                continue;
            }

            if (tile.isHitByPower()) {
                continue;
            }

            array.push(tile);
            tile.setDespawnCause(foregroundTileEnum.LINE_H);

            PowerTileManager.instance.setTileDespawnDelay(tile1, tile, dX, LineCrossBehaviour.duration.x, LineCrossBehaviour.duration.y);
            ImpulseManager.applyPulse(tile.x, tile.y, 1, 0.3, 0.05 + tile.despawnDelay, 0.2);
            
            if (tile.isSinker()) {
                animationData.right = x;
                break;
            }
        }

        for (var x = tile1.x - 1; x >= 0; x--) {
            var _backgroundTile = GridManager.instance.getBackgroundTile(x, tile1.y);

            var dX = Math.abs(x - tile1.x);

            if (_backgroundTile.isPopper()) {
                if (!_backgroundTile.isPowerTriggered()) {
                    _backgroundTile.explode(PowerTileManager.instance.calculateDespawnDelay(dX, LineCrossBehaviour.duration.x, LineCrossBehaviour.duration.y), tile);

                    if (_backgroundTile.isDestroyed) {
                        var popperArray = PowerTileManager.instance.explodePopper(_backgroundTile);

                        pc.utils.fuseArray(array, popperArray);
                    }
                }
            } else if (_backgroundTile.canExplode()) {
                _backgroundTile.explode(PowerTileManager.instance.calculateDespawnDelay(dX, LineCrossBehaviour.duration.x, LineCrossBehaviour.duration.y), tile1);
            }    

            if (_backgroundTile.onlyBackgroundExplodes) {
                continue;
            }

            if (hasCoat) {
                _backgroundTile.changeToCoat(PowerTileManager.instance.calculateDespawnDelay(dX, LineCrossBehaviour.duration.x, LineCrossBehaviour.duration.y));
            }

            tile = GridManager.instance.getTile(x, tile1.y);

            if (!tile) {
                continue;
            }

            if (tile === tile1 || tile === tile2) {
                continue;
            }

            if (!tile.canExplode) {
                continue;
            }

            if (tile.isHitByPower()) {
                continue;
            }

            array.push(tile);
            tile.setDespawnCause(foregroundTileEnum.LINE_H);

            PowerTileManager.instance.setTileDespawnDelay(tile1, tile, dX, LineCrossBehaviour.duration.x, LineCrossBehaviour.duration.y);
            ImpulseManager.applyPulse(tile.x, tile.y, 1, 0.3, 0.05 + tile.despawnDelay, 0.2);
            
            if (tile.isSinker()) {
                animationData.left = x;
                break;
            }
        }

        for (var y = tile1.y; y < MatchLogic.rows; y += 1) {
            var _backgroundTile = GridManager.instance.getBackgroundTile(tile1.x, y);

            var dY = Math.abs(y - tile1.y);

            if (_backgroundTile.isPopper()) {
                if (_backgroundTile.isPowerTriggered()) {
                    _backgroundTile.explode(PowerTileManager.instance.calculateDespawnDelay(dY, LineCrossBehaviour.duration.x, LineCrossBehaviour.duration.y), tile);

                    if (_backgroundTile.isDestroyed) {
                        var popperArray = PowerTileManager.instance.explodePopper(_backgroundTile);

                        pc.utils.fuseArray(array, popperArray);
                    }
                }
            }
            else if (_backgroundTile.canExplode()) {
                _backgroundTile.explode(PowerTileManager.instance.calculateDespawnDelay(dY, LineCrossBehaviour.duration.x, LineCrossBehaviour.duration.y), tile1);
            }  

            if (_backgroundTile.onlyBackgroundExplodes) {
                continue;
            }

            if (hasCoat) {
                _backgroundTile.changeToCoat(PowerTileManager.instance.calculateDespawnDelay(dY, LineCrossBehaviour.duration.x, LineCrossBehaviour.duration.y));
            }

            tile = GridManager.instance.getTile(tile1.x, y);

            if (!tile) {
                continue;
            }


            if (tile === tile1 || tile === tile2) {
                continue;
            }

            if (!tile.canExplode) {
                continue;
            }

            array.push(tile);
            tile.setHitByPower();
            tile.setDespawnCause(foregroundTileEnum.LINE_V);
            PowerTileManager.instance.setTileDespawnDelay(tile1, tile, dY, LineCrossBehaviour.duration.x, LineCrossBehaviour.duration.y);
            ImpulseManager.applyPulse(tile.x, tile.y, 1, 0.3, 0.05 + tile.despawnDelay, 0.2);
            
            if (tile.isSinker()) {
                animationData.top = y;
                break;
            }
        }

        for (var y = tile1.y - 1; y >= 0; y--) {
            var _backgroundTile = GridManager.instance.getBackgroundTile(tile1.x, y);

            var dY = Math.abs(y - tile1.y);


            if (_backgroundTile.isPopper()) {
                if (_backgroundTile.isPowerTriggered()) {
                    _backgroundTile.explode(PowerTileManager.instance.calculateDespawnDelay(dY, LineCrossBehaviour.duration.x, LineCrossBehaviour.duration.y), tile);

                    if (_backgroundTile.isDestroyed) {
                        var popperArray = PowerTileManager.instance.explodePopper(_backgroundTile);

                        pc.utils.fuseArray(array, popperArray);
                    }
                }
            }
            else if (_backgroundTile.canExplode()) {
                _backgroundTile.explode(PowerTileManager.instance.calculateDespawnDelay(dY, LineCrossBehaviour.duration.x, LineCrossBehaviour.duration.y), tile1);
            }  

            if (_backgroundTile.onlyBackgroundExplodes) {
                continue;
            }

            if (hasCoat) {
                _backgroundTile.changeToCoat(PowerTileManager.instance.calculateDespawnDelay(dY, LineCrossBehaviour.duration.x, LineCrossBehaviour.duration.y));
            }

            tile = GridManager.instance.getTile(tile1.x, y);

            if (!tile) {
                continue;
            }


            if (tile === tile1 || tile === tile2) {
                continue;
            }

            if (!tile.canExplode) {
                continue;
            }

            array.push(tile);
            tile.setHitByPower();
            tile.setDespawnCause(foregroundTileEnum.LINE_V);
            PowerTileManager.instance.setTileDespawnDelay(tile1, tile, dY, LineCrossBehaviour.duration.x, LineCrossBehaviour.duration.y);
            ImpulseManager.applyPulse(tile.x, tile.y, 1, 0.3, 0.05 + tile.despawnDelay, 0.2);
            
            if (tile.isSinker()) {
                animationData.bottom = y;
                break;
            }
        }
        
        tile1.setPowerAnimation(animationData);

        // add matched tiles without delay
        array.push(tile1, tile2);
        // prevent added delay
        tile1.setHitByPower();
        tile2.setHitByPower();

        return array;
    },

    doActivateAnimation: function(tile, affectedTiles, matchedTile) {
        PowerAnimationManager.instance.createPowerCombinationAnimation(tile, matchedTile, LineCrossBehaviour.duration.x, this.onFuseAnimDone.bind(this));
    },

    onFuseAnimDone: function(tile, matchedTile) {
        this.app.fire("ShakeCamera:shake", LineCrossBehaviour.duration.x);
        GameVibrationManager.instance.addVibration(GameVibrationManager.LINE_POWER_PATTERN);

        var animationData = tile.getPowerAnimation();

        var bottomY = animationData && typeof animationData.bottom === 'number' ? animationData.bottom : 0 - this.gridOvershoot;
        var topY = animationData && typeof animationData.top === 'number' ? animationData.top : MatchLogic.rows - 1 + this.gridOvershoot;
        var leftX = animationData && typeof animationData.left === 'number' ? animationData.left : 0 - this.gridOvershoot;
        var rightX = animationData && typeof animationData.right === 'number' ? animationData.right : MatchLogic.columns - 1 + this.gridOvershoot;

        // vertical bees
        PowerAnimationManager.instance.createLineAnimation(tile, LineCrossBehaviour.duration, true, true, tile.x, bottomY, 180, tile.colorID);
        PowerAnimationManager.instance.createLineAnimation(tile, LineCrossBehaviour.duration, true, true, tile.x, topY, 0, tile.colorID);

        // horizontal bees
        PowerAnimationManager.instance.createLineAnimation(tile, LineCrossBehaviour.duration, false, true, leftX, tile.y, 270, matchedTile.colorID);
        PowerAnimationManager.instance.createLineAnimation(tile, LineCrossBehaviour.duration, false, false, rightX, tile.y, 90, matchedTile.colorID);

        GridManager.instance.playSFX('line_flowers.mp3');
    }
});

// LineBombVBehaviour.js
var LineBombVBehaviour = function() {
    this.initialize();  
};

//LineBombVBehaviour.duration = new pc.Vec2(0, 0.1);
LineBombVBehaviour.duration = new pc.Vec2(1.2, 0.07);

pc.extend(LineBombVBehaviour.prototype, {
    initialize: function() {
        this.app = pc.Application.getApplication();

        this.gridOvershoot = 2;
    },

    getAffectedTiles: function(tile1, tile2) {
        var array = [];

        var hasCoat = tile1.hasCoat() || (tile2 && tile2.hasCoat());

        var animationData = {
            top1: null,
            top2: null,
            top3: null,
            bottom1: null,
            bottom2: null,
            bottom3: null,
        };

        for (var x = tile1.x - 1; x <= tile1.x + 1; x += 1) {
            for (var y = tile1.y; y < MatchLogic.rows; y += 1) {
                // fix grid edge seam
                if (x < 0) continue;
                if (x >= MatchLogic.columns) continue;

                var _backgroundTile = GridManager.instance.getBackgroundTile(x, y);

                if (_backgroundTile.isPopper()) {

                    if (!_backgroundTile.isPowerTriggered()) {
                        _backgroundTile.explode(PowerTileManager.instance.calculateDespawnDelay(Math.abs(y - tile1.y), LineBombVBehaviour.duration.x, LineBombVBehaviour.duration.y), tile);

                        if (_backgroundTile.isDestroyed) {
                            var popperArray = PowerTileManager.instance.explodePopper(_backgroundTile);

                            pc.utils.fuseArray(array, popperArray);
                        }
                    }
                }
                else if (_backgroundTile.canExplode()) {
                    _backgroundTile.explode(PowerTileManager.instance.calculateDespawnDelay(Math.abs(y - tile1.y), LineBombVBehaviour.duration.x, LineBombVBehaviour.duration.y), tile1);
                }           

                if (_backgroundTile.isSinker()) {
                    animationData[`top${x - tile1.x + 2}`] = y;
                    break;
                }

                if (_backgroundTile.onlyBackgroundExplodes) {
                    continue;
                }

                if (hasCoat) {
                    _backgroundTile.changeToCoat(PowerTileManager.instance.calculateDespawnDelay(Math.abs(y - tile1.y), LineBombVBehaviour.duration.x, LineBombVBehaviour.duration.y));
                }

                var tile = GridManager.instance.getTile(x, y);
                if (!tile) {
                    continue;
                }

                if (tile === tile1 || tile === tile2) {
                    continue;
                }

                if (!tile.canExplode) {
                    continue;
                }

                if (tile.isHitByPower()) {
                    continue;
                }

                array.push(tile);
                tile.setHitByPower();

                if(tile.typeID !== foregroundTileEnum.NONE && tile.typeID !== foregroundTileEnum.DEFAULT) {
                    tile.setDespawnCause(foregroundTileEnum.LINE_V);
                }
                PowerTileManager.instance.setTileDespawnDelay(tile1, tile, Math.abs(y - tile1.y), LineBombVBehaviour.duration.x, LineBombVBehaviour.duration.y);
                ImpulseManager.applyPulse(tile.x, tile.y, 1, 0.3, 0.05 + tile.despawnDelay, 0.2);
                                
                if (tile.isSinker()) {
                    animationData[`top${x - tile1.x + 2}`] = y;
                    break;
                }
            }

            for (var y = tile1.y - 1; y >= 0; y--) {
                // fix grid edge seam
                if (x < 0) continue;
                if (x >= MatchLogic.columns) continue;

                var _backgroundTile = GridManager.instance.getBackgroundTile(x, y);

                if (_backgroundTile.isPopper()) {
                    if (!_backgroundTile.isPowerTriggered()) {
                        _backgroundTile.explode(PowerTileManager.instance.calculateDespawnDelay(Math.abs(y - tile1.y), LineBombVBehaviour.duration.x, LineBombVBehaviour.duration.y), tile);

                        if (_backgroundTile.isDestroyed) {
                            var popperArray = PowerTileManager.instance.explodePopper(_backgroundTile);

                            pc.utils.fuseArray(array, popperArray);
                        }
                    }
                }
                else if (_backgroundTile.canExplode()) {
                    _backgroundTile.explode(PowerTileManager.instance.calculateDespawnDelay(Math.abs(y - tile1.y), LineBombVBehaviour.duration.x, LineBombVBehaviour.duration.y), tile1);
                }       

                if (_backgroundTile.onlyBackgroundExplodes) {
                    continue;
                }

                if (hasCoat) {
                    _backgroundTile.changeToCoat(PowerTileManager.instance.calculateDespawnDelay(Math.abs(y - tile1.y), LineBombVBehaviour.duration.x, LineBombVBehaviour.duration.y));
                }

                var tile = GridManager.instance.getTile(x, y);

                if (!tile) {
                    continue;
                }

                if (tile === tile1 || tile === tile2) {
                    continue;
                }

                if (!tile.canExplode) {
                    continue;
                }

                if (tile.isHitByPower()) {
                    continue;
                }

                array.push(tile);
                tile.setHitByPower();

                if(tile.typeID !== foregroundTileEnum.NONE && tile.typeID !== foregroundTileEnum.DEFAULT) {
                    tile.setDespawnCause(foregroundTileEnum.LINE_V);
                }
                PowerTileManager.instance.setTileDespawnDelay(tile1, tile, Math.abs(y - tile1.y), LineBombVBehaviour.duration.x, LineBombVBehaviour.duration.y);
                ImpulseManager.applyPulse(tile.x, tile.y, 1, 0.3, 0.05 + tile.despawnDelay, 0.2);
                
                if (tile.isSinker()) {
                    animationData[`bottom${x - tile1.x + 2}`] = y;

                    break;
                }
            }
        }

        tile1.setPowerAnimation(animationData);

        // add matched tiles without delay
        array.push(tile1, tile2);
        // prevent added delay
        tile1.setHitByPower();
        tile2.setHitByPower();

        return array;
    },

    doActivateAnimation: function(tile, affectedTiles, matchedTile) {
        PowerAnimationManager.instance.createPowerCombinationAnimation(tile, matchedTile, LineBombVBehaviour.duration.x, this.onFuseAnimDone.bind(this));
    },  


    onFuseAnimDone: function(tile, matchedTile) {
        var animationData = tile.getPowerAnimation();

        var topY = animationData && typeof animationData.bottom2 === 'number' ? animationData.bottom2 : 0 - this.gridOvershoot;
        var bottomY = animationData && typeof animationData.top2 === 'number' ? animationData.top2 : MatchLogic.rows - 1 + this.gridOvershoot;


        PowerAnimationManager.instance.createLineAnimation(tile, LineBombHBehaviour.duration, true, true, tile.x, topY, 180, tile.colorID);
        PowerAnimationManager.instance.createLineAnimation(tile, LineBombHBehaviour.duration, true, true, tile.x, bottomY, 0, tile.colorID);
        var duration;
        //start anim

        if((topY - tile.x) * -1 > bottomY - tile.x) {
            duration = Math.abs(topY - tile.x) * LineBombHBehaviour.duration.y;
        } else {
            duration = Math.abs(bottomY - tile.x) * LineBombHBehaviour.duration.y;
        }

        this.app.fire("ShakeCamera:shake", duration);
        GameVibrationManager.instance.addVibration(GameVibrationManager.LINE_BOMB_PATTERN);

        PowerAnimationManager.instance.createLineAnimation(tile, LineBombVBehaviour.duration, true, true, tile.x, topY, 180, tile.colorID);
        PowerAnimationManager.instance.createLineAnimation(tile, LineBombVBehaviour.duration, true, true, tile.x, bottomY, 0, tile.colorID);

        var leftX = tile.x - 1;
        if (leftX >= 0) {
            topY = animationData && typeof animationData.bottom1 === 'number' ? animationData.bottom1 : 0 - this.gridOvershoot;
            bottomY = animationData && typeof animationData.top1 === 'number' ? animationData.top1 : MatchLogic.rows - 1 + this.gridOvershoot;

            PowerAnimationManager.instance.createLineAnimationBomb(tile, LineBombVBehaviour.duration, true, true, leftX, topY, 180, matchedTile.colorID);
            PowerAnimationManager.instance.createLineAnimationBomb(tile, LineBombVBehaviour.duration, true, true, leftX, bottomY, 0, matchedTile.colorID);

        }
        var rightX = tile.x + 1;
        if (rightX < MatchLogic.columns) {
            topY = animationData && typeof animationData.bottom3 === 'number' ? animationData.bottom3 : 0 - this.gridOvershoot;
            bottomY = animationData && typeof animationData.top3 === 'number' ? animationData.top3 : MatchLogic.rows - 1 + this.gridOvershoot;

            PowerAnimationManager.instance.createLineAnimationBomb(tile, LineBombVBehaviour.duration, true, true, rightX, topY, 180, matchedTile.colorID);
            PowerAnimationManager.instance.createLineAnimationBomb(tile, LineBombVBehaviour.duration, true, true, rightX, bottomY, 0, matchedTile.colorID);
        }
        GridManager.instance.playSFX('line_flowers.mp3');
    }
}); 

// LineBombHBehaviour.js
var LineBombHBehaviour = function() {
    this.initialize();  
};

// LineBombHBehaviour.duration = new pc.Vec2(0, 0.1);
LineBombHBehaviour.duration = new pc.Vec2(1.2, 0.07);

pc.extend(LineBombHBehaviour.prototype, {
    initialize: function() {
        this.app = pc.Application.getApplication();

        this.gridOvershoot = 2;
    },

    getAffectedTiles: function(tile1, tile2) {
        var array = [];

        var hasCoat = tile1.hasCoat() || (tile2 && tile2.hasCoat());

        var animationData = {
            left1: null,
            left2: null,
            left3: null,
            right1: null,
            right2: null,
            right3: null,
        };

        for (var y = tile1.y - 1; y <= tile1.y + 1; y += 1) {
            for (var x = tile1.x; x < MatchLogic.columns; x += 1) {
                if (y >= 0 && y < MatchLogic.rows) {
                    var _backgroundTile = GridManager.instance.getBackgroundTile(x, y);

                    if (_backgroundTile.isPopper()) {
                        if (!_backgroundTile.isPowerTriggered()) {
                            _backgroundTile.explode(PowerTileManager.instance.calculateDespawnDelay(Math.abs(x - tile1.x), LineBombHBehaviour.duration.x, LineBombHBehaviour.duration.y), tile);

                            if (_backgroundTile.isDestroyed) {
                                var popperArray = PowerTileManager.instance.explodePopper(_backgroundTile);

                                pc.utils.fuseArray(array, popperArray);
                            }
                        }
                    }
                    else if (_backgroundTile.canExplode()) {
                        _backgroundTile.explode(PowerTileManager.instance.calculateDespawnDelay(Math.abs(x - tile1.x), LineBombHBehaviour.duration.x, LineBombHBehaviour.duration.y), tile1);
                    }

                    if (_backgroundTile.onlyBackgroundExplodes) {
                        continue;
                    }

                    if (hasCoat) {
                        _backgroundTile.changeToCoat(PowerTileManager.instance.calculateDespawnDelay(Math.abs(x - tile1.x), LineBombHBehaviour.duration.x, LineBombHBehaviour.duration.y));
                    }

                    var tile = GridManager.instance.getTile(x, y);
                    if (!tile) {
                        continue;
                    }

                    if (tile === tile1 || tile === tile2) {
                        continue;
                    }

                    if (!tile.canExplode) {
                        continue;
                    }

                    if (tile.isHitByPower()) {
                        continue;
                    }

                    array.push(tile);
                    tile.setHitByPower();

                    if(tile.typeID !== foregroundTileEnum.NONE && tile.typeID !== foregroundTileEnum.DEFAULT) {
                        tile.setDespawnCause(foregroundTileEnum.LINE_H);
                    }

                    PowerTileManager.instance.setTileDespawnDelay(tile1, tile, Math.abs(x - tile1.x), LineBombHBehaviour.duration.x, LineBombHBehaviour.duration.y);
                    ImpulseManager.applyPulse(tile.x, tile.y, 1, 0.3, 0.05 + tile.despawnDelay, 0.2);
                    
                    if (tile.isSinker()) {
                        animationData[`right${y - tile1.y + 2}`] = x;
                        break;
                    }
                }
            }

            for (var x = tile1.x - 1; x >= 0; x--) {
                if (y >= 0 && y < MatchLogic.rows ) {
                    var _backgroundTile = GridManager.instance.getBackgroundTile(x, y);

                    if (_backgroundTile.isPopper()) {
                        if (!_backgroundTile.isPowerTriggered()) {
                            _backgroundTile.explode(PowerTileManager.instance.calculateDespawnDelay(Math.abs(x - tile1.x), LineBombHBehaviour.duration.x, LineBombHBehaviour.duration.y), tile);

                            if (_backgroundTile.isDestroyed) {
                                var popperArray = PowerTileManager.instance.explodePopper(_backgroundTile);

                                pc.utils.fuseArray(array, popperArray);
                            }
                        }
                    }
                    else if (_backgroundTile.canExplode()) {
                        _backgroundTile.explode(PowerTileManager.instance.calculateDespawnDelay(Math.abs(x - tile1.x), LineBombHBehaviour.duration.x, LineBombHBehaviour.duration.y), tile1);
                    }

                    if (_backgroundTile.onlyBackgroundExplodes) {
                        continue;
                    }

                    if (hasCoat) {
                        _backgroundTile.changeToCoat(PowerTileManager.instance.calculateDespawnDelay(Math.abs(x - tile1.x), LineBombHBehaviour.duration.x, LineBombHBehaviour.duration.y));
                    }

                    var tile = GridManager.instance.getTile(x, y);
                    if (!tile) {
                        continue;
                    }

                    if (tile === tile1 || tile === tile2) {
                        continue;
                    }

                    if (!tile.canExplode) {
                        continue;
                    }

                    if (tile.isHitByPower()) {
                        continue;
                    }

                    array.push(tile);
                    tile.setHitByPower();

                    if(tile.typeID !== foregroundTileEnum.NONE && tile.typeID !== foregroundTileEnum.DEFAULT) {
                        tile.setDespawnCause(foregroundTileEnum.LINE_H);
                    }

                    PowerTileManager.instance.setTileDespawnDelay(tile1, tile, Math.abs(x - tile1.x), LineBombHBehaviour.duration.x, LineBombHBehaviour.duration.y);
                    ImpulseManager.applyPulse(tile.x, tile.y, 1, 0.3, 0.05 + tile.despawnDelay, 0.2);
                    
                    if (tile.isSinker()) {
                        animationData[`left${y - tile1.y + 2}`] = x;
                        break;
                    }
                }
            }
        } 

        tile1.setPowerAnimation(animationData);

        // add matched tiles without delay
        array.push(tile1, tile2);
        // prevent added delay
        tile1.setHitByPower();
        tile2.setHitByPower();

        return array;
    },

    doActivateAnimation: function(tile, affectedTiles, matchedTile) {

        PowerAnimationManager.instance.createPowerCombinationAnimation(tile, matchedTile, LineBombHBehaviour.duration.x, this.onFuseAnimDone.bind(this));
    },  

    onFuseAnimDone: function(tile, matchedTile) {
        var animationData = tile.getPowerAnimation();

        var leftX =  animationData && typeof animationData.left2 === 'number' ? animationData.left2 : 0 - this.gridOvershoot;
        var rightX =  animationData && typeof animationData.right2 === 'number' ? animationData.right2 : MatchLogic.columns - 1 + this.gridOvershoot;

        var duration;

        //start anim

        if((leftX - tile.x) * -1 > rightX - tile.x) {
            duration = Math.abs(leftX - tile.x) * LineBombHBehaviour.duration.y;
        } else {
            duration = Math.abs(rightX - tile.x) * LineBombHBehaviour.duration.y;
        }

        this.app.fire("ShakeCamera:shake", duration);
        GameVibrationManager.instance.addVibration(GameVibrationManager.LINE_BOMB_PATTERN);

        PowerAnimationManager.instance.createLineAnimation(tile, LineBombHBehaviour.duration, false, true, leftX, tile.y, 270, tile.colorID);
        PowerAnimationManager.instance.createLineAnimation(tile, LineBombHBehaviour.duration, false, false, rightX, tile.y, 90, tile.colorID);

        var topY = tile.y + 1;
        if (topY < MatchLogic.rows) {

            leftX =  animationData && typeof animationData.left3 === 'number' ? animationData.left3 : 0 - this.gridOvershoot;
            rightX =  animationData && typeof animationData.right3 === 'number' ? animationData.right3 : MatchLogic.columns - 1 + this.gridOvershoot;

            PowerAnimationManager.instance.createLineAnimationBomb(tile, LineBombHBehaviour.duration, false, true, leftX, topY, 270, matchedTile.colorID);
            PowerAnimationManager.instance.createLineAnimationBomb(tile, LineBombHBehaviour.duration, false, false, rightX, topY, 90, matchedTile.colorID);
        }

        var bottomY = tile.y - 1;
        if (bottomY >= 0) {
            leftX =  animationData && typeof animationData.left1 === 'number' ? animationData.left1 : 0 - this.gridOvershoot;
            rightX =  animationData && typeof animationData.right1 === 'number' ? animationData.right1 : MatchLogic.columns - 1 + this.gridOvershoot;

            PowerAnimationManager.instance.createLineAnimationBomb(tile, LineBombHBehaviour.duration, false, true, leftX, bottomY, 270, matchedTile.colorID);
            PowerAnimationManager.instance.createLineAnimationBomb(tile, LineBombHBehaviour.duration, false, false, rightX, bottomY, 90, matchedTile.colorID);
        }

        GridManager.instance.playSFX('line_flowers.mp3');
    }
});

// BigBombBehaviour.js
var BigBombBehaviour = function() {
    this.initialize();  
};

BigBombBehaviour.duration = new pc.Vec2(1.2, 0.1);

pc.extend(BigBombBehaviour.prototype, {
    initialize: function() {
        this.app = pc.Application.getApplication();

        this.lines = [];
        this.sinkers = [];
    }, 

    getAffectedTiles: function(tile1, tile2) {
        var array = [];

        var hasCoat = tile1.hasCoat() || (tile2 && tile2.hasCoat());

        var affectedTiles = [];
        this.sinkers.length = 0;
        this.lines.length = 0;

        for (var x = tile1.x - 3; x <= tile1.x + 3; x += 1) {
            for (var y = tile1.y - 3; y <= tile1.y + 3; y += 1) {
                // fix grid edge seam
                if (x < 0)
                    continue;

                if (x >= MatchLogic.columns)
                    continue;

                if (y >= 0 && y < MatchLogic.rows) {
                    if((x === tile1.x - 3 || x === tile1.x + 3) && (y <= tile1.y - 2 || y >= tile1.y + 2)) continue;
                    if((x === tile1.x - 2 || x === tile1.x + 2) && (y <= tile1.y - 3 || y >= tile1.y + 3)) continue;

                    var _tile = GridManager.instance.getTile(x, y);

                    affectedTiles.push({ x, y });

                    if (_tile && _tile.isSinker()) {
                        this.sinkers.push({ x, y });
                    }
//                 }
//             }
//         }

//         for (var i = 0; i < this.sinkers.length; i++) {
//             var x = this.sinkers[i].x;
//             var y = this.sinkers[i].y;
//             this.createLines(x, y);
//         }

//         this.filterLines();

//         for (var i = 0; i < affectedTiles.length; i++) {
//             var x = affectedTiles[i].x;
//             var y = affectedTiles[i].y;

//             if (this.lineCollision(tile1.x + 0.5, tile1.y + 0.5, x + 0.5, y + 0.5)) {
//                 continue;
//             }

//             var _backgroundTile = GridManager.instance.getBackgroundTile(x, y);

//             var dX = Math.abs(tile1.x - x);
//             var dY = Math.abs(tile1.y - y);

//             if (_backgroundTile.canExplode()) {
//                 _backgroundTile.explode(PowerTileManager.instance.calculateDespawnDelay(Math.max(dX, dY), BigBombBehaviour.duration.x, BigBombBehaviour.duration.y), tile1);
//             }
                }
            }
        }

//             if (_backgroundTile.onlyBackgroundExplodes) {
//                 continue;
//             }

//             if (hasCoat) {
//                 _backgroundTile.changeToCoat(PowerTileManager.instance.calculateDespawnDelay(Math.max(dX, dY), BigBombBehaviour.duration.x, BigBombBehaviour.duration.y));
//             }

//             var tile = GridManager.instance.getTile(x, y);
//             if (!tile) {
//                 continue;
//             }

//             if (tile === tile1 || tile === tile2) {
//                 continue;
//             }

//             if (!tile.canExplode) {
//                 continue;
//             }

//             if (tile.isHitByPower()) {
//                 continue;
//             }
//             array.push(tile);
//             tile.setHitByPower();


//             if (tile!== tile2) PowerTileManager.instance.setTileDespawnDelay(tile1, tile, Math.max(dX, dY), BigBombBehaviour.duration.x, BigBombBehaviour.duration.y);
        for (var i = 0; i < this.sinkers.length; i++) {
            var x = this.sinkers[i].x;
            var y = this.sinkers[i].y;
            this.createLines(x, y);
        }

        this.filterLines();

        for (var i = 0; i < affectedTiles.length; i++) {
            var x = affectedTiles[i].x;
            var y = affectedTiles[i].y;

            if (this.lineCollision(tile1.x + 0.5, tile1.y + 0.5, x + 0.5, y + 0.5)) {
                continue;
            }

            var _backgroundTile = GridManager.instance.getBackgroundTile(x, y);

            var dX = Math.abs(tile1.x - x);
            var dY = Math.abs(tile1.y - y);

            if (_backgroundTile.isPopper()) {
                if (!_backgroundTile.isPowerTriggered()) {
                    _backgroundTile.explode(PowerTileManager.instance.calculateDespawnDelay(Math.max(dX, dY), BigBombBehaviour.duration.x, BigBombBehaviour.duration.y), tile);

                    if (_backgroundTile.isDestroyed) {
                        var popperArray = PowerTileManager.instance.explodePopper(_backgroundTile);

                        pc.utils.fuseArray(array, popperArray);
                    }
                }
            }
            else if (_backgroundTile.canExplode()) {
                _backgroundTile.explode(PowerTileManager.instance.calculateDespawnDelay(Math.max(dX, dY), BigBombBehaviour.duration.x, BigBombBehaviour.duration.y), tile1);
            }

            if (_backgroundTile.onlyBackgroundExplodes) {
                continue;
            }

            if (hasCoat) {
                _backgroundTile.changeToCoat(PowerTileManager.instance.calculateDespawnDelay(Math.max(dX, dY), BigBombBehaviour.duration.x, BigBombBehaviour.duration.y));
            }

            var tile = GridManager.instance.getTile(x, y);
            if (!tile) {
                continue;
            }

            if (tile === tile1 || tile === tile2) {
                continue;
            }

            if (!tile.canExplode) {
                continue;
            }

            if (tile.isHitByPower()) {
                continue;
            }
            array.push(tile);
            tile.setHitByPower();


            if (tile!== tile2) PowerTileManager.instance.setTileDespawnDelay(tile1, tile, Math.max(dX, dY), BigBombBehaviour.duration.x, BigBombBehaviour.duration.y);
        }

        var animationData = [];

        for (var x = tile1.x - 3; x <= tile1.x + 3; x += 1) {
            var maxLimit = 3; // default height

            if(x === tile1.x - 2 || x === tile1.x + 2)
                maxLimit = 2;

            if(x === tile1.x - 3 || x === tile1.x + 3)
                maxLimit = 1;

            for (var y = tile1.y - maxLimit; y <= tile1.y + maxLimit; y += 1) {
                if((y > tile1.y - maxLimit && y < tile1.y + maxLimit) && x !== tile1.x - 3 && x !== tile1.x + 3) continue; // skip inside tiles for the animation
                animationData.push(this.getLinePosition(tile1.x + 0.5, tile1.y + 0.5, x + 0.5, y + 0.5));
            }
        }
        tile1.setPowerAnimation(animationData);

        ImpulseManager.applyPulse(tile1.x, tile1.y, 6, 1, 0.05 + BigBombBehaviour.duration.x, 0.2);        

        // add matched tiles without delay
        array.push(tile1, tile2);
        // prevent added delay
        tile1.setHitByPower();
        tile2.setHitByPower();

        return array;
    },

    doActivateAnimation: function(tile, affectedTiles, matchedTile) {
        PowerAnimationManager.instance.createPowerCombinationAnimation(tile, matchedTile, BigBombBehaviour.duration.x, this.onFuseAnimDone.bind(this));
    },  

    onFuseAnimDone: function(tile, matchedTile) {
        var iterator = 0;
        var canPlaySound = true;    
        GridManager.instance.playSFX('bomb_detonate_flowers.mp3');
        GameVibrationManager.instance.addVibration(GameVibrationManager.COLOR_CARPET_BOMB_PATTERN);

        //         for (var x = tile.x - 3; x <= tile.x + 3; x += 1) {
        //             var maxLimit = 3; // default height

        //             if(x === tile.x - 2 || x === tile.x + 2)
        //                 maxLimit = 2;

        //             if(x === tile.x - 3 || x === tile.x + 3)
        //                 maxLimit = 1;

        //             for (var y = tile.y - maxLimit; y <= tile.y + maxLimit; y += 1) {
        //                 if((y > tile.y - maxLimit && y < tile.y + maxLimit) && x !== tile.x - 3 && x !== tile.x + 3) continue; // skip inside tiles for the animation

        //                 var realX = x;
        //                 var realY = y;

        //                 var angle = this.calculateAngle(x, y, tile.x, tile.y);
        //                 var tileID = iterator % 2 === 0 ? tile.colorID : matchedTile.colorID;
        //                 var specificDuration = new pc.Vec2(BigBombBehaviour.duration.x / Math.max(Math.abs(tile.x - realX), Math.abs(tile.y - realY)) * 3, BigBombBehaviour.duration.y / Math.max(Math.abs(tile.x - realX), Math.abs(tile.y - realY)) * 3);
        //                 PowerAnimationManager.instance.createBombAnimation(tile, specificDuration, realX === tile.x, realX < tile.x, realX, realY, angle, Math.max(Math.abs(tile.x - realX), Math.abs(tile.y - realY)), tileID, canPlaySound);
        //                 iterator += 1;
        //                 canPlaySound = false;

        //             }
        //         }

        var animationData = tile.getPowerAnimation();

        for (var i = 0; i < animationData.length; i++) {
            var data = animationData[i];

            var realX = data.x;
            var realY = data.y;

            var angle = this.calculateAngle(realX, realY, tile.x, tile.y);
            var tileID = iterator % 2 === 0 ? tile.colorID : matchedTile.colorID;
            var specificDuration = new pc.Vec2(BigBombBehaviour.duration.x / Math.max(Math.abs(tile.x - realX), Math.abs(tile.y - realY)) * 3, BigBombBehaviour.duration.y / Math.max(Math.abs(tile.x - realX), Math.abs(tile.y - realY)) * 3);
            PowerAnimationManager.instance.createBombAnimation(tile, specificDuration, realX === tile.x, realX < tile.x, realX, realY, angle, Math.max(Math.abs(tile.x - realX), Math.abs(tile.y - realY)), tileID, canPlaySound);
            canPlaySound = false;
            iterator += 1;
        }

        this.app.fire("ShakeCamera:shake", BigBombBehaviour.duration.x);
    },

    calculateAngle: function(x, y, centerx, centery) {
        var deltaX =  x - centerx;
        var deltaY =  y - centery;
        var degrees = Math.atan2(deltaY, deltaX) * 180.0 / Math.PI;
        return degrees * -1 + 90;
    },

    createLines: function(_x, _y) {
        this.lines.push({ x1: _x, y1: _y, x2: _x + 1, y2: _y });
        this.lines.push({ x1: _x, y1: _y, x2: _x, y2: _y + 1 });
        this.lines.push({ x1: _x + 1, y1: _y, x2: _x + 1, y2: _y + 1 });
        this.lines.push({ x1: _x, y1: _y + 1, x2: _x + 1, y2: _y + 1 });

        this.lines.push({ x1: _x, y1: _y, x2: _x + 1, y2: _y + 1 });
        this.lines.push({ x1: _x, y1: _y + 1, x2: _x + 1, y2: _y });

        if (this.sinkers.find(sinker => sinker.x === _x - 1 && sinker.y === _y + 1)) {
            this.lines.push({ x1: _x + 0.5 - 1, y1: _y + 0.5 + 1, x2: _x + 0.5, y2: _y + 0.5 });
            this.lines.push({ x1: _x + 0.5 - 1, y1: _y + 0.5, x2: _x + 0.5, y2: _y + 0.5 + 1 });
        } 

        if (this.sinkers.find(sinker => sinker.x === _x + 1 && sinker.y === _y + 1)) {
            this.lines.push({ x1: _x + 0.5, y1: _y + 0.5 + 1, x2: _x + 0.5 + 1, y2: _y + 0.5 });
            this.lines.push({ x1: _x + 0.5, y1: _y + 0.5, x2: _x + 0.5 + 1, y2: _y + 0.5 + 1 });
        } 
    },

    filterLines: function() {
        for (var i = this.lines.length - 1; i >= 0; i--) {
            var _x1 = this.lines[i].x1;
            var _y1 = this.lines[i].y1;

            var _x2 = this.lines[i].x2;
            var _y2 = this.lines[i].y2;

            for (var j = this.lines.length - 1; j >= 0; j--) {
                if (i === j) {
                    continue;
                }

                var x1 = this.lines[j].x1;
                var y1 = this.lines[j].y1;

                var x2 = this.lines[j].x2;
                var y2 = this.lines[j].y2;

                if ((_x1 === x1 && _y1 === y1 && _x2 === x2 && _y2 === y2) || (_x1 === x2 && _y1 === y2 && _x2 === x1 && _y2 === y1)) {
                    this.lines.splice(i, 1);
                    break;
                }
            } 
        }
    },

    lineCollision: function(x1, y1, x2, y2) {
        var count = 0; 
        for (var i = 0; i < this.lines.length; i++) {
            var line = this.lines[i];

            if (this.checkLineIntersection(x1, y1, x2, y2, line.x1, line.y1, line.x2, line.y2)) {
                count++;

                if (count > 1) {
                    return true;
                }
            }
        }  

        return count > 1;
    },

    checkLineIntersection: function(x1, y1, x2,y2, x3, y3, x4, y4) {        
        if (x1 === x3 && x2 === x4 && y1 === y3 && y2 === y4) {
            return true;
        }

        var denominator = (x2 - x1) * (y4 - y3) - (y2 - y1) * (x4 - x3);

        //console.log(denominator)

        if (denominator === 0) {
            var x3Dif = x3 - x1;
            var x4Dif = x4 - x1;

            if ((x3Dif === 0 && y3 === y1 || this.equals((y3 - y1) / (x3 - x1), (y2 - y1) / (x2 - x1))) && (x4Dif === 0 && y4 === y1 || this.equals((y4 - y1) / (x4 - x1), (y2 - y1) / (x2 - x1)))) {
                if (x3 < Math.max(x1, x2) && x3 > Math.min(x1, x2)) {
                    return true;
                }

                if (x4 < Math.max(x1, x2) && x4 > Math.min(x1, x2)) {
                    return true;
                }

                if (y3 < Math.max(y1, y2) && y3 > Math.min(y1, y2)) {
                    return true;
                }

                if (y4 < Math.max(y1, y2) && y4 > Math.min(y1, y2)) {
                    return true;
                }

                return false;
            } else {
                return false;
            }
        }

        var numerator1 = (y1 - y3) * (x4 - x3) - (x1 - x3) * (y4 - y3);
        var numerator2 = (y1 - y3) * (x2 - x1) - (x1 - x3) * (y2 - y1);

        if (numerator1 === 0 || numerator2 === 0)
        {
            return false;
        }

        var r = numerator1 / denominator;
        var s = numerator2 / denominator;


        return (r > 0 && r < 1) && (s > 0 && s < 1);
    },


    getLinePosition: function(x1, y1, x2, y2) {
        var collisions = [];

        for (var i = 0; i < this.lines.length; i++) {
            var line = this.lines[i];

            var position = this.getLineIntersectionPosition(x1, y1, x2, y2, line.x1, line.y1, line.x2, line.y2);

            if (position instanceof pc.Vec3) {
                collisions.push(position);
            }
        }  

        if (collisions.length > 1) {
            collisions.sort((vec3_1, vec3_2) => ((vec3_1.x - x1) * (vec3_1.x - x1) + (vec3_1.y - y1) * (vec3_1.y - y1)) - ((vec3_2.x - x1) * (vec3_2.x - x1) + (vec3_2.y - y1) * (vec3_2.y - y1)));

            collisions[1].sub(new pc.Vec3(0.5, 0.5, 0.5));
            
            return collisions[1];
        } else {
            return new pc.Vec3(x2 - 0.5, y2 - 0.5, 1);
        }
    },

    getLineIntersectionPosition: function(x1, y1, x2,y2, x3, y3, x4, y4) {        
        if (x1 === x3 && x2 === x4 && y1 === y3 && y2 === y4) {
            return new pc.Vec3((x3 + x4) / 2, (y3 + y4) / 2, 0);
        }

        var denominator = (x2 - x1) * (y4 - y3) - (y2 - y1) * (x4 - x3);

        if (denominator === 0) {
            var x3Dif = x3 - x1;
            var x4Dif = x4 - x1;

            if ((x3Dif === 0 && y3 === y1 || this.equals((y3 - y1) / (x3 - x1), (y2 - y1) / (x2 - x1))) && (x4Dif === 0 && y4 === y1 || this.equals((y4 - y1) / (x4 - x1), (y2 - y1) / (x2 - x1)))) {
                if (x3 < Math.max(x1, x2) && x3 > Math.min(x1, x2)) {
                    return new pc.Vec3((x3 + x4) / 2, (y3 + y4) / 2, 0);
                }

                if (x4 < Math.max(x1, x2) && x4 > Math.min(x1, x2)) {
                    return new pc.Vec3((x3 + x4) / 2, (y3 + y4) / 2, 0);
                }

                if (y3 < Math.max(y1, y2) && y3 > Math.min(y1, y2)) {
                    return new pc.Vec3((x3 + x4) / 2, (y3 + y4) / 2, 0);
                }

                if (y4 < Math.max(y1, y2) && y4 > Math.min(y1, y2)) {
                    return new pc.Vec3((x3 + x4) / 2, (y3 + y4) / 2, 0);
                }

                return null;
            } else {
                return null;
            }
        }

        var numerator1 = (y1 - y3) * (x4 - x3) - (x1 - x3) * (y4 - y3);
        var numerator2 = (y1 - y3) * (x2 - x1) - (x1 - x3) * (y2 - y1);

        if (numerator1 === 0 || numerator2 === 0)
        {
            return null;
        }

        var r = numerator1 / denominator;
        var s = numerator2 / denominator;

        if ((r > 0 && r < 1) && (s > 0 && s < 1)) {
            var x = x1 + (r * (x2 - x1));
            var y = y1 + (r * (y2 - y1));
            return new pc.Vec3(x, y, 0);
        }
    },

    equals(a, b) {
        return a > b - BombBehaviour.EPS && a < b + BombBehaviour.EPS;
    }
});

// LineColorBombBehaviour.js
var LineColorBombBehaviour = function() {
    this.initialize();  
};

LineColorBombBehaviour.duration = new pc.Vec3(1.2, 2);
LineColorBombBehaviour.DELAY_BETWEEN_TILE = 0.1;

pc.extend(LineColorBombBehaviour.prototype, {
    initialize: function() {
        this.app = pc.Application.getApplication();

        this.tiles = [];
        this.affectedTiles = [];

    },

    getAffectedTiles: function(tile1, matchedTile, colorID) {
        var array = [];
        this.tiles.length = 0;
        this.affectedTiles.length = 0;
        var extraDelay = 0;

        var hasCoat = tile1.hasCoat() || matchedTile.hasCoat();

        for (var x = 0; x < MatchLogic.columns; x += 1) {
            for (var y = 0; y < MatchLogic.rows; y += 1) {
                var tile = GridManager.instance.getTile(x, y);
                if (tile && tile.colorID === colorID && tile !== matchedTile && tile !== tile1) {
                    this.affectedTiles.push(tile);
                }
            }
        }
        
        pc.utils.shuffleArray(this.affectedTiles);

        let delay = PowerTileManager.instance.calculateDespawnDelay(1, LineColorBombBehaviour.duration.x, LineColorBombBehaviour.duration.y);

        for (var i = 0; i < this.affectedTiles.length; i++) {
            const tile = this.affectedTiles[i];
            const x = tile.x;
            const y = tile.y;

            var _backgroundTile = GridManager.instance.getBackgroundTile(x, y);

            if (_backgroundTile.onlyBackgroundExplodes && !_backgroundTile.canExplode()) {
                continue;
            }

            if (_backgroundTile.canExplode()) {
                _backgroundTile.explode(delay, tile1);
            }

            if (!tile) {
                continue;
            }

            if (!tile.canExplode) {
                continue;
            }
            // if (tile.typeID !== foregroundTileEnum.DEFAULT) {
            //     continue;
            // }

            if (tile.isHitByPower()) {
                continue;
            }

            if (!tile.isActive()) {
                continue;
            }

            this.tiles.push(tile);

            if (tile.typeID === foregroundTileEnum.DEFAULT) {
                var isHorizontal = Math.random() >= 0.5;
                var tileIndex = isHorizontal ? Math.abs(x - matchedTile.x) : Math.abs(y - matchedTile.y);
                var randomType = isHorizontal ? foregroundTileEnum.LINE_H : foregroundTileEnum.LINE_V;

                var newPowerTile = PowerTileManager.instance.switchTilePower(tile, randomType, delay);
                PowerTileManager.instance.setTileState(newPowerTile, ForegroundTile._PowerStates.ACTIVE);

                if (_backgroundTile.onlyBackgroundExplodes) {
                    continue;
                }

                if (hasCoat) {
                    _backgroundTile.changeToCoat(delay);
                }

                // set off all new spawned line clears
                array.push(newPowerTile);
                newPowerTile.setHitByPower();

                PowerTileManager.instance.setTileDespawnDelay(tile1, newPowerTile, delay);
            } else {
                if (_backgroundTile.onlyBackgroundExplodes) {
                    continue;
                }

                array.push(tile);
                tile.setHitByPower();
                if(!tile.colorBombCause) {
                    tile.colorBombCause = tile;
                }

                if (hasCoat) {
                    _backgroundTile.changeToCoat(delay);
                } 

                PowerTileManager.instance.setTileDespawnDelay(tile1, tile, delay);
            }
            
            delay += LineColorBombBehaviour.DELAY_BETWEEN_TILE;
            extraDelay += LineColorBombBehaviour.DELAY_BETWEEN_TILE;
        }

        // add matched tiles without delay
        array.push(tile1, matchedTile);
        // prevent added delay
        tile1.setHitByPower();
        matchedTile.setHitByPower();
        return array;
    },

    doActivateAnimation: function(tile, affectedTiles, matchedTile) {
        PowerAnimationManager.instance.createPowerCombinationAnimation(tile, matchedTile, LineColorBombBehaviour.duration.x, this.onFuseAnimDone.bind(this));
    },

    onFuseAnimDone: function(tile, matchedTile) {
        this.app.fire("ShakeCamera:shake", LineColorBombBehaviour.duration.y);

        var colorID = matchedTile.colorID || tile.colorID;

        var shakingTiles = this.tiles;
        for(var i = 0; i < shakingTiles.length; i++) {

            var realX = shakingTiles[i].x;
            var realY = shakingTiles[i].y;
            var angle = GridManager.instance.calculateAngle(realX, realY, tile.x, tile.y);

            if(!(realX === tile.x && realY === tile.y)) {
                this.createColorBombParticleAnimation(tile, realX, realY, angle, colorID, shakingTiles[i], 0.01 + i * LineColorBombBehaviour.DELAY_BETWEEN_TILE);

                shakingTiles[i].shakeTile();
                shakingTiles[i].enlargeTile();
            }
        }

        GridManager.instance.playSFX('colorbomb_flowers.mp3');
    },
    
    createColorBombParticleAnimation: function(tile, realX, realY, angle, colorID, shakingTile, delay) {
        pc.timer.add(delay, () => {
            PowerAnimationManager.instance.createColorBombParticleAnimation(tile, LineColorBombBehaviour.duration.y, realX === tile.x, realX < tile.x, realX, realY, angle, Math.max(Math.abs(tile.x - realX), Math.abs(tile.y - realY)), colorID, shakingTile, powerAnimationTypes.LINES);
        });
    },
});

// TrackingManager.js
var TrackingManager = pc.createScript('trackingManager');

TrackingManager.attributes.add('settings', { type: 'asset', assetType: 'json' });
TrackingManager.attributes.add('delay', { type: 'number', placeholder: 'sec', default: 0.05 });

pc.extend(TrackingManager.prototype, {

    initialize: function() {
        TrackingManager.instance = this;

        this._resetData();

        this._settings = this.settings.resource;

        window.famobi_tracking.init(this._settings.gameTitle, this._settings.preferredUid, this._settings.versionNumber, this._settings.enableLog, this._settings.trackAds);

        this.app.on('TrackingManager:freeSwap', this._updatePowerUpFreeSwap, this);
        this.app.on('TrackingManager:breaker', this._updatePowerUpBreaker, this);
        this.app.on('TrackingManager:crossbomb', this._updatePowerUpCrossbomb, this);

        this._currentData.movesAvailable = MovesManager.instance._startMoves;
    },

    //     update: function(dt) {

    //         if (this._ended) {
    //             return;
    //         }

    //         if (!this._update) {
    //             return;
    //         }

    //         this._timer += dt;

    //         if (this._timer > this.delay) {
    //             if (this._end) {
    //                 this._levelEnd();
    //             } else {
    //                 this._levelUpdate();
    //             }

    //             this._timer = 0;
    //             this._update = false;
    //         }
    //     },

    _resetData: function() {
        this._timer = 0;
        this._update = false;

        this._end = false;
        this._ended = true;

        this._currentData = {};
        this._powerUpJSON = {};
        this._jumpStarterJSON = {};
        this.data = {};
    },

    updateScore: function() {

        this._currentData.score = ScoreManager.instance.getCurrentLevelScore();
        this._update = true;
    },

    _updatePowerUpFreeSwap: function() {
        if (!this._powerUpJSON.freeSwap) {
            this._powerUpJSON.freeSwap = 0;
        }

        if (!this._currentData.powerups) {
            this._currentData.powerups = this._powerUpJSON;
        }

        this._powerUpJSON.freeSwap += 1; 
        this._update = true;
    },

    _updatePowerUpBreaker: function() {
        if (!this._powerUpJSON.breaker) {
            this._powerUpJSON.breaker = 0;
        }

        if (!this._currentData.powerups) {
            this._currentData.powerups = this._powerUpJSON;
        }

        this._powerUpJSON.breaker += 1; 
        this._update = true;
    },

    _updatePowerUpCrossbomb: function() {
        if (!this._powerUpJSON.crossbomb) {
            this._powerUpJSON.crossbomb = 0;
        }

        if (!this._currentData.powerups) {
            this._currentData.powerups = this._powerUpJSON;
        }

        this._powerUpJSON.crossbomb += 1; 
        this._update = true;
    },

    _levelUpdate: function() {
        window.famobi_tracking.trackEvent(window.famobi_tracking.EVENTS.LEVEL_UPDATE, this._getCurrentData());
    },

    _levelEnd: function() {

        this._currentData.stars = ScoreManager.instance.getStars();
        window.famobi_tracking.trackEvent(window.famobi_tracking.EVENTS.LEVEL_END, this._getCurrentData());


        this._ended = true;
    },

    _getCurrentData: function() {
        return JSON.parse(JSON.stringify(this._currentData));
    },

    levelStart: function() {
        this._resetData();

        this._ended = false;

        this._currentData.level = LevelManager.instance.getCurrentLevelNumber();
        this._currentData.movesAvailable = MovesManager.instance._startMoves;
        this._currentData.movesLeft = MovesManager.instance._startMoves;

        if (BoosterManager.instance.preGameBoosterQueue.length > 0) {
            for (var i = 0; i < BoosterManager.instance.preGameBoosterQueue.length; i++) {
                var id = BoosterManager.instance.preGameBoosterQueue[i].typeID;

                switch(id) {
                    case 2: 
                        this.setJumpStarter('bee');
                        break;
                    case 4: 
                        this.setJumpStarter('ladybug');
                        break;
                    case 5:
                        this.setJumpStarter('butterfly');
                        break;
                }
            }
        }

        window.famobi_tracking.trackEvent(window.famobi_tracking.EVENTS.LEVEL_START, this._getCurrentData());
    },

    levelEnd: function(success) {

        this.updateScore();

        this._end = true;
        this._update = true;

        this._currentData.success = success;

        this._levelEnd();
    },

    addRevive: function() {
        if (!this._currentData.revives) {
            this._currentData.revives = 0;
        }

        this._update = true;
        this._currentData.revives++;
    },

    onMove: function(movesLeft) {
        this._currentData.movesLeft = movesLeft;
        this._update = true;
    },

    levelUpdate: function() {
        this._levelUpdate();
    },

    setJumpStarter: function(name) {
        this._jumpStarterJSON[name] = 1;

        if (!this._currentData.jumpStarters) {
            this._currentData.jumpStarters = this._jumpStarterJSON;
        }

        this._update = true;
    },
});

// BombColorBombBehaviour.js
var BombColorBombBehaviour = function() {
    this.initialize();  
};

BombColorBombBehaviour.duration = new pc.Vec2(1.2, 2);
BombColorBombBehaviour.DELAY_BETWEEN_TILE = 0.1;
// 2 explosion delay
// o.2 iterator

pc.extend(BombColorBombBehaviour.prototype, {
    initialize: function() { 
        this.app = pc.Application.getApplication();

        this.tiles = [];
        this.affectedTiles = [];
    },

    getAffectedTiles: function(tile1, matchedTile, colorID) {

        var array = [];
        this.tiles.length = 0;
        this.affectedTiles.length = 0;

        var extraDelay = 0;

        var hasCoat = tile1.hasCoat() || matchedTile.hasCoat();

        

        for (var x = 0; x < MatchLogic.columns; x += 1) {
            for (var y = 0; y < MatchLogic.rows; y += 1) {
                var tile = GridManager.instance.getTile(x, y);
                if (tile && tile.colorID === colorID && tile !== matchedTile && tile !== tile1) {
                    this.affectedTiles.push(tile);
                }
            }
        }
        
        pc.utils.shuffleArray(this.affectedTiles);
        
        let delay = PowerTileManager.instance.calculateDespawnDelay(1, BombColorBombBehaviour.duration.x, BombColorBombBehaviour.duration.y);

        for (var i = 0; i < this.affectedTiles.length; i++) {
            const tile = this.affectedTiles[i];
            const x = tile.x;
            const y = tile.y;

            var _backgroundTile = GridManager.instance.getBackgroundTile(x, y);


            if (_backgroundTile.onlyBackgroundExplodes && !_backgroundTile.canExplode()) {
                continue;
            }

            if (_backgroundTile.canExplode()) {
                _backgroundTile.explode(delay, tile1);
            }

            if (hasCoat) {
                _backgroundTile.changeToCoat(delay);
            }

            if (!tile.canExplode) {
                continue;
            }

            // if (tile.typeID !== foregroundTileEnum.DEFAULT) {
            //     continue;
            // }

            if (tile.isHitByPower()) {
                continue;
            }

            if (!tile.isActive()) {
                continue;
            }

            this.tiles.push(tile);


            if (tile.typeID === foregroundTileEnum.DEFAULT) {
                var newPowerTile = PowerTileManager.instance.switchTilePower(tile, foregroundTileEnum.BOMB, delay);
                PowerTileManager.instance.setTileState(newPowerTile, ForegroundTile._PowerStates.ACTIVE);

                // set off all new spawned line clears

                if (_backgroundTile.onlyBackgroundExplodes) {
                    continue;
                }

                newPowerTile.setHitByPower();

                array.push(newPowerTile);

                PowerTileManager.instance.setTileDespawnDelay(tile1, newPowerTile, delay);
            } else {
                if (_backgroundTile.onlyBackgroundExplodes) {
                    continue;
                }

                array.push(tile);
                tile.setHitByPower();
                if(!tile.colorBombCause) {
                    tile.colorBombCause = tile;
                }

                if (hasCoat) {
                    _backgroundTile.changeToCoat(delay);
                } 

                PowerTileManager.instance.setTileDespawnDelay(tile1, tile, delay);
            }

            delay += BombColorBombBehaviour.DELAY_BETWEEN_TILE;
            extraDelay += BombColorBombBehaviour.DELAY_BETWEEN_TILE;
        }
        // add matched tiles without delay
        array.push(tile1, matchedTile);
        // prevent added delay
        tile1.setHitByPower();
        matchedTile.setHitByPower();
        return array;
    },

    doActivateAnimation: function(tile, affectedTiles, matchedTile) {
        PowerAnimationManager.instance.createPowerCombinationAnimation(tile, matchedTile, BombColorBombBehaviour.duration.x, this.onFuseAnimDone.bind(this));
    },  

    onFuseAnimDone: function(tile, matchedTile) {
        this.app.fire("ShakeCamera:shake", BombColorBombBehaviour.duration.y);

        var colorID = matchedTile.colorID || tile.colorID;

        var shakingTiles = this.tiles;
        for(var i = 0; i < shakingTiles.length; i++) {

            var realX = shakingTiles[i].x;
            var realY = shakingTiles[i].y;
            var angle = GridManager.instance.calculateAngle(realX, realY, tile.x, tile.y);

            if(!(realX === tile.x && realY === tile.y)) {
                this.createColorBombParticleAnimation(tile, realX, realY, angle, colorID, shakingTiles[i], 0.01 + i * BombColorBombBehaviour.DELAY_BETWEEN_TILE);

                shakingTiles[i].shakeTile();
                shakingTiles[i].enlargeTile();
            }
        }

        PowerAnimationManager.instance.createColorBombAnimation(tile, ColorBombBehaviour.duration.y);

        GridManager.instance.playSFX('colorbomb_flowers.mp3');
        GameVibrationManager.instance.addVibration(GameVibrationManager.COLOR_CARPET_BOMB_PATTERN);
    },

    createColorBombParticleAnimation: function(tile, realX, realY, angle, colorID, shakingTile, delay) {
        pc.timer.add(delay, () => {
            PowerAnimationManager.instance.createColorBombParticleAnimation(tile, ColorBombBehaviour.duration.y, realX === tile.x, realX < tile.x, realX, realY, angle, Math.max(Math.abs(tile.x - realX), Math.abs(tile.y - realY)), colorID, shakingTile, powerAnimationTypes.BOMB);
        });
    },
});

// UltimateColorBombBehaviour.js
var UltimateColorBombBehaviour = function() {
    this.initialize();  
};

UltimateColorBombBehaviour.duration = new pc.Vec2(1.2, 0.05);

pc.extend(UltimateColorBombBehaviour.prototype, {
    initialize: function() {
        this.app = pc.Application.getApplication();
    },

    getAffectedTiles: function(tile, matchedTile) {
        var array = [];

        var iterator = 0;

        var hasCoat = tile.hasCoat() || (matchedTile && matchedTile.hasCoat());

        for (var y = MatchLogic.rows - 1; y >= 0; y -= 1) {
            for (var x = 0; x < MatchLogic.columns; x += 1) {
                var _backgroundTile = GridManager.instance.getBackgroundTile(x, y);

                if (_backgroundTile.isPopper()) {
                    if (_backgroundTile.isPowerTriggered()) {
                        _backgroundTile.explode(despawnDelay, tile);

                        if (_backgroundTile.isDestroyed) {
                            var popperArray = PowerTileManager.instance.explodePopper(_backgroundTile);

                            pc.utils.fuseArray(array, popperArray);
                        }
                    }
                }
                else if (_backgroundTile.canExplode()) {
                    _backgroundTile.explode(PowerTileManager.instance.calculateDespawnDelay(iterator, UltimateColorBombBehaviour.duration.x, UltimateColorBombBehaviour.duration.y), tile);
                    iterator += 1;
                }
                if (_backgroundTile.onlyBackgroundExplodes && !_backgroundTile.canExplode()) {
                    continue;
                }
                                    
                if (_backgroundTile.onlyBackgroundExplodes) {
                    continue;
                }

                if (hasCoat) {
                    _backgroundTile.changeToCoat(PowerTileManager.instance.calculateDespawnDelay(iterator, UltimateColorBombBehaviour.duration.x, UltimateColorBombBehaviour.duration.y));
                }

                var _tile = GridManager.instance.getTile(x, y);

                if (!_tile) {
                    continue;
                }

                if (!_tile.canExplode) {
                    continue;
                }

                if (_tile.isHitByPower()) {
                    continue;
                }

                if (!_tile.isActive()) {
                    continue;
                }

                if (_tile !== matchedTile && _tile !== tile) {
                    array.push(_tile);
                    _tile.setHitByPower();
                    PowerTileManager.instance.setTileDespawnDelay(tile, _tile, iterator, UltimateColorBombBehaviour.duration.x, UltimateColorBombBehaviour.duration.y);
                    this.lastDespawnDelay = _tile.getDespawnDelay();
                    iterator += 1;
                }
            }
        }
        // add matched tiles without delay
        array.push(tile, matchedTile);
        // prevent added delay
        tile.setHitByPower();
        matchedTile.setHitByPower();
        return array;
    },

    doActivateAnimation: function(tile, affectedTiles, matchedTile) {
        PowerAnimationManager.instance.createPowerCombinationAnimation(tile, matchedTile, UltimateColorBombBehaviour.duration.x, this.onFuseAnimDone.bind(this));
        this.affectedTiles = affectedTiles;
    },  

    onFuseAnimDone: function(tile, matchedTile) {
        this.app.fire("ShakeCamera:shake", this.lastDespawnDelay);

        PowerAnimationManager.instance.createColorBombAnimation(tile, this.affectedTiles.length * UltimateColorBombBehaviour.duration.y);
        this.affectedTiles = null;
        GridManager.instance.playSFX('colorbomb_flowers.mp3');
        GameVibrationManager.instance.addVibration(GameVibrationManager.ULTIMATE_COLOR_BOMB_PATTERN);
    }
});

// LevelManager.js
var LevelManager = pc.createScript('levelManager');

LevelManager.attributes.add('levelsData', { type: 'asset' });

pc.extend(LevelManager.prototype, {
    initialize: function () {
        LevelManager.instance = this;

        this.playing = false;

        this.currentChapter = null;
        this.currentLevel = null;

        this.app.on('SwapMode:onFinaleDone', this.onWin, this);
        this.app.on('GameManager:quit', this.onQuit, this);
        this.app.on('CameraAnimations:hasSkipped', this._cameraSkip, this);

        window.addEventListener('beforeunload', this.beforeUnload, this);
    },

    beforeUnload() {
        if (this.playing) {
            Wrapper.instance.sendGAEvent(Wrapper.GA_EVENT_TYPE.DESIGN, { eventID: 'level:fail:manual' });
        }
    },

    _loadLevel: function (levelID) {
        LevelLoader.instance.loadLevel(this.currentLevel, this._onLevelLoaded, this);
    },

    _loadWorldAssets: function (showLoadingScreen) {

        LoadingScreen.instance.setType(LoadingScreen.TYPES.ASSETS);

        if (this.wasInWorld) {
            if (showLoadingScreen) {
                if (UIManager.instance.getScreen('LoadingScreen').script.loadingScreen.fadeInCompleted) {
                    AssetManager.instance.loadWorldAssets(this.currentChapter, this._loadLevel, this, false, true);
                } else {
                    LoadingScreen.instance.once('fadeInComplete', () => {
                        AssetManager.instance.loadWorldAssets(this.currentChapter, this._loadLevel, this, false, true);

                    });
                }

            } else {
                this._loadLevel();
            }

        } else {
            AssetManager.instance.loadWorldAssets(this.currentChapter, this._loadLevel, this, false, true);
        }

    },

    // update: function() {
    //     if(this.app.keyboard.wasPressed(pc.KEY_A)){
    //         SwapMode.instance._startFinale();
    //     } 
    // },

    _onLevelLoaded: async function (data) {
        this._currentLevelData = data.resource;
        this.canAddMoves = true;

        ColorManager.instance.maxColors = PyzomathDataReader.getColors(this._currentLevelData);
        MovesManager.instance.setMoveAmount(PyzomathDataReader.getMoves(this._currentLevelData));
        ScoreManager.instance.setStarValues(PyzomathDataReader.getStarValues(this._currentLevelData));
        var objectives = PyzomathDataReader.getObjectives(this._currentLevelData);

        this.app.fire('LevelManager:onLevelStart', this._currentLevelData);


        var columns = PyzomathDataReader.getColumns(this._currentLevelData);
        var rows = PyzomathDataReader.getRows(this._currentLevelData);

        await GridManager.instance.despawnAll();
        GridManager.instance.spawnLevel(columns, rows, PyzomathDataReader.getTiles(this._currentLevelData));

        ObjectiveManager.instance.setObjectives(objectives);

        SwapMode.instance.setup();
        this.app.fire('UIManager:hideUI', "LoadingScreen");

        this.app.fire('UIManager:hideAll');

        Wrapper.instance.gameReady();

        TrackingManager.instance.levelStart();
        CameraAnimations.instance.playRandomIntro().once('complete', this._onCameraComplete, this);

        GameManager.instance.applyForcedModeProperties();

        this.slot = AudioManager.instance._playSFX('level_intro.mp3');

        if (this.currentLevel !== LevelDataManager.instance.getRealCurrentLevel()) {
            if (this._restart) {
                Wrapper.instance.sendGAEvent(Wrapper.GA_EVENT_TYPE.DESIGN, {
                    eventId: `replay:direct:${this.currentLevel}`
                });
            } else {
                Wrapper.instance.sendGAEvent(Wrapper.GA_EVENT_TYPE.DESIGN, {
                    eventId: `replay:revisit:${this.currentLevel}`
                });

            }
        }

        const loadDuration = (Date.now() - this.loadDuration) / 1000;

        this.endFTUEEvent(loadDuration);

        Wrapper.instance.sendGAEvent(Wrapper.GA_EVENT_TYPE.DESIGN, {
            eventId: `level_${LevelManager.instance.currentLevel}:load:complete`,
            value: loadDuration,
        });
    },

    _onCameraComplete: function () {
        this.app.fire('UIManager:showUI', 'Intro');
        this.playing = true;
        GameManager.instance.resetGameSession();
    },

    _cameraSkip: function () {
        if (this.slot) {
            if (this.slot.currentTime < 5) {
                this.slot.currentTime = 5;
            }
        }
    },

    restart: function () {
        GameManager.instance.trackEventLevelStart(true)
            .then(() => {
                this.app.fire('AudioManager:stopBgm');
                this._loadLevel();
            });
    },

    doFTUEEvent() {
        Wrapper.instance.sendGAEvent(Wrapper.GA_EVENT_TYPE.DESIGN, { eventId: 'tutorialFunnel:levelLoadStart' });
        this.ftue = true;
    },

    endFTUEEvent(loadDuration) {
        if (this.ftue) {
            this.ftue = false;
            Wrapper.instance.sendGAEvent(Wrapper.GA_EVENT_TYPE.DESIGN, { eventId: 'tutorialFunnel:levelLoadComplete', value: loadDuration });
        }
    },

    startLevel: async function (levelID, chapterID, restart, retry, showLoadingScreen = true) {
        //         this.app.fire('LevelManager:startLevel');
        //         if (Application.currentScene !== 'World') {
        //             LoadSceneController.load('World', true);
        //             AssetManager.instance.loadWorldAssets();

        //             this.app.once('switchedScene', this.startLevel.bind(this, levelID, chapterID, restart), this);
        //             return;
        //         }

        this._restart = restart;

        if (showLoadingScreen) {
            this.app.fire('UIManager:showUI', 'LoadingScreen', LoadingScreen.BACKGROUND.WORLD);
        }

        if (!retry) {
            Wrapper.instance.sendGAEvent(Wrapper.GA_EVENT_TYPE.DESIGN, {
                eventId: `level_${levelID}:load:start`,
                value: 0
            });

            this.loadDuration = Date.now();

            this.wasInWorld = Application.currentScene === "World";
        }

        if (Application.currentScene !== "World") {
            // this.app.fire('UIManager:showUI', 'loading');

            var loadSceneController = LoadSceneController.load('World', false, LoadingScreen.BACKGROUND.WORLD);

            loadSceneController.once('finish', this.startLevel.bind(this, levelID, chapterID, restart, true));

            return;
        }

        LevelDataManager.instance.compareCurrentLevel(levelID);

        await this.reset();
        this.currentLevel = levelID;
        this.currentChapter = chapterID;
        this.app.fire('ParticleManager:enableParticles', chapterID);

        LevelDataManager.instance.startLevel(this.currentLevel);

        GameManager.instance.trackEventLevelStart(restart)
            .then(() => {
                this._loadWorldAssets(showLoadingScreen);
            });

        //==========================
        //== this still has to be ==
        //==    completed later   ==
        //==========================
        //has to be made dynamic with the level intros not settimeout

        this.app.fire('AudioManager:stopBgm');
    },

    onWin: async function () {
        this.playing = false;
        this.app.fire("GameInput:toggleGameInput", false);

        AudioManager.instance.fadeOutMusicSlot(1, 1.5);

        await GameManager.instance.trackEventEnd("success");

        CameraAnimations.instance.playRandomOutro().once('complete', async function () {
            // get out of level
            await this.reset();
            // this is saved and given to winscreen before the leveldata is saved and currentLevel is incremented so unlokc animations only happen once
            var replayingLevel = LevelManager.instance.getCurrentLevelNumber() !== LevelDataManager.instance.getCurrentLevel();

            this.app.fire('LevelManager:levelComplete', true);
            this.app.fire('UIManager:hideAll');

            if (this.currentLevel === LevelDataManager.instance.getRealCurrentLevel() && WorldManager.instance.isEndOfPage(this.currentLevel)) {
                var currentWorldPartsAssets = WorldManager.instance.getPartAssets(this.getCurrentChapterNumber());
                var amountOfParts = LevelDataManager.instance.getPartsData(this.currentChapter) + 1;
                var totalParts = WorldManager.instance.getNumberOfParts(this.currentChapter);
                var flowerUnlocked = false;

                StatisticsManager.instance.incrementStatistic("flowerparts_collected", { chapter: Number.parseInt(this.currentChapter) });

                if (amountOfParts === totalParts) {
                    StatisticsManager.instance.incrementStatistic("flower_collected", { chapter: Number.parseInt(this.currentChapter) });
                    flowerUnlocked = true;
                }

                // unlock part
                CollectibleUnlockInterface.instance.unlockObject(function () {
                    this._onWinAnimationDone(replayingLevel, flowerUnlocked);
                }.bind(this), currentWorldPartsAssets.partModel, amountOfParts, totalParts, currentWorldPartsAssets.completedModel);
                this.app.fire('LevelManager:unlockNewPage', this.currentLevel, true);
            } else {
                // show win if flower not needed
                var values = {
                    replayingLevel: replayingLevel,
                    currentLevel: this.currentLevel,
                    currentChapter: parseInt(this.currentChapter),
                    flowerUnlocked: false,
                    newScore: ScoreManager.instance.getScore(),
                    newStars: ScoreManager.instance.getStars(),
                };

                this.app.fire('UIManager:showUI', 'Win', values);
                LevelDataManager.instance.endLevel(this.currentLevel, 'win');
                LevelDataManager.instance.saveLevelData(this.currentChapter, this.currentLevel, ScoreManager.instance.getScore(), ScoreManager.instance.getStars());
            }
            FirstTimeUserManager.instance.checkEntities();
            this.app.fire("GameInput:toggleGameInput", true);
        }, this);
    },
    _onWinAnimationDone: function (replayingLevel, flowerUnlocked) {
        var values = {
            replayingLevel: replayingLevel,
            currentLevel: this.currentLevel,
            currentChapter: parseInt(this.currentChapter),
            flowerUnlocked: flowerUnlocked,
            newScore: ScoreManager.instance.getScore(),
            newStars: ScoreManager.instance.getStars(),
        };

        if (flowerUnlocked) {
            WorldUnlockManager.instance.setWorldUnlocked(parseInt(this.currentChapter));
        } else {
            BookUI.instance.showNextPageUnlock = true;
        }

        this.app.fire('UIManager:hideAll');
        this.app.fire('UIManager:showUI', 'Win', values);

        LevelDataManager.instance.saveLevelData(this.currentChapter, this.currentLevel, ScoreManager.instance.getScore(), ScoreManager.instance.getStars());
    },

    onLose: async function () {
        Wrapper.instance.sendGAEvent(Wrapper.GA_EVENT_TYPE.DESIGN, { eventId: 'level:fail:game' });

        this.playing = false;
        this.app.fire('LevelManager:levelComplete', false);
        TrackingManager.instance.levelEnd(false);
        this.app.fire('UIManager:hideAll');

        await GameManager.instance.trackEventEnd("fail");

        // this.app.fire('UIManager:showUI', 'FloatingUI');
        LevelDataManager.instance.endLevel(this.currentLevel, 'lose');

        this.reset();
        this.app.fire('UIManager:showUI', 'Lose');

        //this.app.fire('AudioManager:stopBgm');

        //CameraAnimations.instance.playRandomOutro();
    },

    onQuit: function () {
        this.playing = false;
        Wrapper.instance.sendGAEvent(Wrapper.GA_EVENT_TYPE.DESIGN, { eventId: 'level:fail:quit' });

        this.app.fire("Audio:bgm", "main_ost.mp3");
        this.app.fire('ParticleManager:disableParticles', this.currentChapter);
        this.app.fire('CustomizeBackgroundParticles:resetParticles');
    },

    onMoveDone: function () {
        if (ObjectiveManager.instance.isObjectivesCompleted()) {
            return true;
        }

        if (MovesManager.instance.getMoves() <= 0) {
            if (GameManager.instance.forcedMode) {
                GameManager.instance.trackEventLevelFail();

                return false;
            }

            this.app.fire('LevelManager:noMoreMoves');


            this.app.fire('UIManager:hideAll');

            if (GameManager.instance.hasAddMovesAttempts()) {
                this.app.fire('Audio:sfx', 'goals_failed.mp3');
                this.app.fire('UIManager:showUI', 'AddMoves');

                return false;
            } else {
                this.showLoseScreen();

                return false;
            }
        }

        if (GridManager.instance.hasExploderTriggered()) {

            if (GameManager.instance.forcedMode) {
                GameManager.instance.trackEventLevelFail();
                return false;
            }

            this.app.fire('Audio:sfx', 'goals_failed.mp3');
            this.app.fire('UIManager:hideAll');

            if (GameManager.instance.hasAddExploderTimerAttempts()) {
                this.app.fire('Audio:sfx', 'goals_failed.mp3');
                this.app.fire('UIManager:showUI', 'addExploderTimer');
            } else {
                this.app.fire('ExploderParticleAnimation:startAnim');
            }

            return false;
        }
        return null;
    },

    showLoseScreen: async function () {
        await GameManager.instance.trackEventEnd("fail");
        this.app.fire('UIManager:showUI', 'FloatingUI');
        this.app.fire('UIManager:showUI', 'Lose');
    },

    onIntroDone: function () {
        this.app.fire('UIManager:hideAll');
        this.app.fire('UIManager:showUI', 'Game');
        this.app.fire('Audio:bgm', 'ingame_ost_world' + this.currentChapter + '.mp3');

        TutorialManager.instance.startLevel(this.currentLevel);

        this.app.off('TutorialManager:stopTutorial', this._spawnPreGameBoostersOnCascade, this);
        this.app.off('SwapMode:onCascadeDone', BoosterManager.instance.spawnPreGameBoosters, BoosterManager.instance);

        if (!TutorialManager.instance.active) {
            BoosterManager.instance.spawnPreGameBoosters();
        } else {
            this.app.on('TutorialManager:stopTutorial', this._spawnPreGameBoostersOnCascade, this);
        }

        // DialogManager.instance.showDialog("garden_tutorial", this._showGameUi);
    },

    _spawnPreGameBoostersOnCascade: function () {
        this.app.once('SwapMode:onCascadeDone', BoosterManager.instance.spawnPreGameBoosters, BoosterManager.instance);
    },

    _showGameUi: function () {
        this.app.fire('UIManager:hideAll');
        this.app.fire('UIManager:showUI', 'Game');
    },

    reset: async function () {
        this.playing = false;
        pc.pickerFrameBuffer.setInputBetweenGamesEnabled(true);

        SwapMode.instance.setState(matchStates.WAIT);
        await pc.utils.delay();
        await GridManager.instance.despawnAll();
        await pc.utils.delay();
        TutorialManager.instance.endTutorial(true);
        await pc.utils.delay();
        ObjectiveManager.instance.reset();
        this.app.fire('LevelManager:reset');
    },

    getCurrentLevelData: function () {
        return this._currentLevelData;
    },

    getCurrentLevelNumber: function () {
        return this.currentLevel;
    },

    getCurrentChapterNumber: function () {
        return this.currentChapter;
    },

    getLevelData: function (id) {
        var name = String(id).padStart(4, '0');

        return this.levelsData.resource[name];
    },
});

// IntroScreen.js
var IntroScreen = pc.createScript('introScreen');

IntroScreen.attributes.add('levelText', { type: 'entity' });
IntroScreen.attributes.add('objectiveTextEntities', { type: 'entity', array: true });
IntroScreen.attributes.add('objectiveIconEntities', { type: 'entity', array: true });
IntroScreen.attributes.add('backDrop', { type: 'entity' });
IntroScreen.attributes.add('screenDuration', { type: 'number' });


pc.extend(IntroScreen.prototype, {
    initialize: function () {
        this.backDrop.script.elementInput.on(inputEvents.CLICK, this.closeScreen, this);
    },

    onUIEntityOpen: function () {
        AssetManager.instance.unloadPreviousAssets();

        this._isCounting = true;
        this.closing = false;
        LocalizationManager.instance.setText(this.levelText, 'LEVEL_NUMBER', LevelManager.instance.currentLevel);
        this._counter = 0;
        // if (!TutorialManager.instance.active) {

        // } else {
        //     this.closeScreen();
        // }

        var objectives = ObjectiveManager.instance.getObjectives();

        for (var i = 0; i < this.objectiveTextEntities.length; i++) {
            var objective = objectives[i];
            if (objective) {
                var sprite = TileLibrary.instance.getTileSprite(objective.orderTypeObject);
                var amount = objective.values.goal;

                this.objectiveTextEntities[i].element.text = amount;
                this.objectiveIconEntities[i].element.spriteAsset = sprite;
                this.objectiveTextEntities[i].enabled = true;
                this.objectiveIconEntities[i].enabled = true;
            } else {
                this.objectiveTextEntities[i].enabled = false;
                this.objectiveIconEntities[i].enabled = false;
            }
        }

        if (GameManager.instance.forcedMode &&
            Array.isArray(GameManager.instance.forcedModeProperties.override.hide_ui) &&
            GameManager.instance.forcedModeProperties.override.hide_ui.includes('objectives')) {
            this.levelText.setLocalPosition(pc.Vec3.ZERO);
            this.objectiveTextEntities.forEach(entity => entity.enabled = false);
            this.objectiveIconEntities.forEach(entity => entity.enabled = false);
        }

    },

    onUIEntityClose: function () {
        this.closing = true;
        Wrapper.instance.playerReady();
    },

    update: function (dt) {
        if (this._isCounting) {
            this._counter += dt;
            if (this._counter > this.screenDuration) {
                this.closeScreen();
            }
        }
    },

    closeScreen: function () {
        if (!this._isCounting) return;

        this.app.fire('UIManager:hideUI', "Intro");

        if (!this.closing) {
            return;
        }

        this._isCounting = false;

        LevelManager.instance.onIntroDone();
        this.app.fire('IntroScreen:introDone');
    }
});

// HoverScore.js
var HoverScore = pc.createScript('hoverScore');

pc.extend(HoverScore.prototype, {
    initialize: function () {
        // this.app.on('OrbitCamera:rotate', this.setRotation, this);
        this.element = this.entity.findComponent('element');
        this.scoreText = this.element.text;
        this.defaultColor = this.element.color.clone();
        this.defaultOutline = this.element.outlineColor.clone();
        this.app.on('GameManager:quit', this.stopAnimation, this);
        this.scoreText = '60';
    },

    awake: function (score, position, parent, tileY, color, outlineColor) {
        if (!this.entity.parent) {
            this.entity.reparent(parent);
        }
        this.app.fire('AsyncScoreManager:setScore', score);
        this._active = true;
        this.camera = this.app.root.findByName('Camera');

        if (this.scoreText !== String(score)) {
            this.element.text = score;
        }
        // colors
        this.element.color = color ? color : this.defaultColor;
        this.element.outlineColor = outlineColor ? outlineColor : this.defaultOutline;
        this.element.shadowColor = outlineColor ? outlineColor : this.defaultOutline;

        this.scoreText = this.element.text;
        this.entity.setPosition(position);
        this.entity.reparent(parent);

        this.startAnimation(tileY);
    },

    setRotation: function () {
        if (!this.entity.enabled) {
            return;
        }

        if (!this.camera) {
            this.camera = this.app.root.findByTag('worldcamera')[0];
        }

        this.entity.setRotation(this.camera.getRotation());
    },

    startAnimation: function (tileY) {
        var distance = 1;
        var endY = tileY + distance;
        this.entity.setLocalScale(0, 0, 0);
        this.appearTween = this.entity.tween(this.entity.getLocalScale()).to({ x: 0.01, y: 0.01, z: 0.01 }, 0.2, pc.Linear);

        var endPos = GridManager.instance.calculatePosition(0, endY, 0);

        this.riseTween = this.entity.tween(this.entity.getLocalPosition()).to({ x: this.entity.getLocalPosition().x, y: endPos.y, z: this.entity.getLocalPosition().z }, 1 * distance, pc.Linear);

        this.riseTween.on('complete', this._recycle, this);
        this.appearTween.chain(this.riseTween);
        this.appearTween.start();
    },

    stopAnimation: function () {
        if (this.riseTween) {
            this.riseTween.stop();
        }

        if (this.appearTween) {
            this.appearTween.stop();
        }

        this._recycle();
    },

    _recycle: function () {
        this.riseTween = null;
        this.appearTween = null;

        if (this._active) {
            GridManager.instance.recycleScore(this.entity);
        }

        this._active = false;
    },
});

// ScoreInterface.js
var ScoreInterface = pc.createScript('scoreInterface');

ScoreInterface.TEXT_COLORS = [
    '#70f2bc',
    '#ffaefb',
    '#fbff5e',
    '#a1ee67',
    '#f071ff',
    '#83ffdd',
    '#83d8ff',
    '#83c0ff',
    '#ffcb15',
    '#ff6e2d'
];

pc.extend(ScoreInterface.prototype, {
    initialize: function() {
        this.app.on('AsyncScoreManager:showScore', this.setScore, this);
        this._update = false;
        this._score = 0;
        this.currentScore = 0;
        this.setScore(0);

        this.app.on('LevelManager:onLevelStart', this._reset, this);
        this.app.on('GameManager:quit', this._reset, this);

        this._color = new pc.Color();
        
        this.setTextColor();
        this.on('enable', this.setTextColor, this);
    },

    _reset: function() {
        this._update = false;
        this._score = 0;
        this.currentScore = 0;
        this.setScore(0);
        this.entity.setLocalScale(1, 1, 1);
        this.stopAnim();
    },

    postUpdate: function() {
        if (this._update) {
            this._update = false;
            this.entity.element.text = String(this._score);
            this.startAnim();
        }
    },

    setScore: function(score) {
        this._update = true;
        this._score = score;
    },

    stopAnim: function() {
        if (this.bobbleTween) {
            this.bobbleTween.stop();
        }
    },

    startAnim: function() {
        this.stopAnim();

        this.bobbleTween = this.entity.tween(this.entity.getLocalScale()).to({x: 1.2, y: 1.2, z: 1.2}, 0.1, pc.SineInOut).yoyo(true).repeat(2).start();
    },

    setTextColor: function() {
        var worldIndex = WorldManager.instance.getWorldIndex();
        
        if (!worldIndex) {
            return;
        }
        
        var tint = ScoreInterface.TEXT_COLORS[WorldManager.instance.getWorldIndexByID(worldIndex)];
        var color = this._color.fromString(tint);

        this.entity.element.color = color;
    }
});

// Entity.js
pc.extend(pc.Entity.prototype, {
    findScriptInParents: function(scriptName) {
        if (this.parent instanceof pc.Entity) {
            if (this.parent.script && this.parent.script.has(scriptName)) {
                return this.parent.script[scriptName];
            } else {
                return this.parent.findScriptInParents(scriptName);
            }
        }
    },

    getUIScale: function(vec3 = new pc.Vec3(1, 1, 1)) {
        const scale = this.getLocalScale();

        vec3.mul(scale);

        if (this.parent instanceof pc.Entity) {
            return this.parent.getUIScale(vec3);
        } else {
            return vec3;
        }
    },
    
    findScripts: function(scriptName, array) {
        array = array || [];

        if (this.script && this.script[scriptName]) {
            array.push(this.script[scriptName]);
        }

        if (this.children) {
            for (var i = 0; i < this.children.length; i++) {
                if (this.children[i] instanceof pc.Entity) {
                    this.children[i].findScripts(scriptName, array);
                }
            }
        }

        return array;
    },

    findLayer: function(layerID, array) {
        array = array || [];

        if (this.element && this.element.layers.indexOf(layerID) !== -1) {
            array.push(this);
        }

        if (this.children) {
            for (var i = 0; i < this.children.length; i++) {
                if (this.children[i] instanceof pc.Entity) {
                    this.children[i].findLayer(layerID, array);
                }
            }
        }

        return array;
    },

    setEulerAnglesComplex: function(x, y, z) {
        pc.Entity.QUAT_1.setFromEulerAngles(x, y, 0);
        pc.Entity.QUAT_2.setFromEulerAngles(0, -z, 0);
        pc.Entity.QUAT_1.mul(pc.Entity.QUAT_2);
        
        this.setLocalRotation(pc.Entity.QUAT_1);
    },

    // Not used atm
    getEulerAnglesComplex: function(x, y, z) {
        var rotateEntity = pc.Entity.STATIC_ENTITY;

        rotateEntity.setEulerAnglesComplex(x, y, z);
        var newRotation = rotateEntity.getEulerAngles();

        return newRotation;
    },

    getUIPosition: function(entity = this, vec3 = new pc.Vec3()) {
        vec3.add(entity.getLocalPosition());
        if (entity.parent instanceof pc.Entity) {
            this.getUIPosition(entity.parent, vec3);
        } 
        return vec3;
    },
});

pc.Entity.QUAT_1 = new pc.Quat();
pc.Entity.QUAT_2 = new pc.Quat();
pc.Entity.STATIC_ENTITY = new pc.Entity();


// ButtonComponentHelper.js
var ButtonComponentHelper = pc.createScript('buttonComponentHelper');

ButtonComponentHelper.attributes.add('defaultTint', { type: 'rgb', default: [1, 1, 1] });
ButtonComponentHelper.attributes.add('hoverTint', { type: 'rgb', default: [0.90, 0.90, 0.90] });
ButtonComponentHelper.attributes.add('pressedTint', { type: 'rgb', default: [0.65, 0.65, 0.65] });
ButtonComponentHelper.attributes.add('inactiveTint', { type: 'rgb', default: [0.5, 0.5, 0.5] });
ButtonComponentHelper.attributes.add('fadeDuration', { type: 'number', default: 100, placeholder: 'ms' });

pc.extend(ButtonComponentHelper.prototype, {
    
    initialize: function() {
        if (!this.entity.button) {
            this._createButtonComponent();
        }
        
        this._setButtonValues();
    },
        
    _createButtonComponent: function() {
        if (this.entity.button) {
            return;
        }
        
        this.entity.addComponent('button', {
            attributes: {

            }
        });
    },
    
    _setButtonValues: function() {
        this.entity.button.defaultTint = this.defaultTint;
        this.entity.button.hoverTint = this.hoverTint;
        this.entity.button.pressedTint = this.pressedTint;
        this.entity.button.inactiveTint = this.inactiveTint;
        this.entity.button.fadeDuration = this.fadeDuration;
        this.entity.button.imageEntity  = this.entity;
    },
});

// AnimationObject.js
var AnimationObject = pc.createScript('animationObject');
// example call:
// pc.gridManager.getTile(0, 0).entity.script.shapeSurfaceTween.moveTo(0, 0, 0, 4, 5, pc.BounceOut, pc.gridManager.radius + 1, true, true, function() {console.log('done')}.bind(this));


AnimationObject.attributes.add('colorMaterials', {
    type: 'json',
    schema: [
        { name: '0', type: 'asset', title: 'none' },
        { name: '1', type: 'asset', title: 'blue' },
        { name: '2', type: 'asset', title: 'yellow' },
        { name: '3', type: 'asset', title: 'red' },
        { name: '4', type: 'asset', title: 'purple' },
        { name: '5', type: 'asset', title: 'green' },
        { name: '6', type: 'asset', title: 'orange' },
    ]
});

pc.extend(AnimationObject.prototype, {
    initialize: function() {
        this._isMoving = false;
        this._isDelaying = false;
    },

    update: function(dt) {
        if (this._isMoving) {
            this._moveTimer += dt;
            this._lerpEntity();
            if (this._moveTimer >= this._tweenData.duration) {
                this._endAnimation();
            }
        } else if (this._isDelaying) {
            this._delayCounter += dt;
            if (this._delayCounter >= this._delay) {
                this._onDelayDone();
            }
        }
    },

    objectInit: function(parent, position, rotation, scale, colorID) {
        parent = GridManager.instance.entity;
        this.entity.enabled = true;
        
        if (parent) this.entity.reparent(parent);

        if (colorID && this.colorMaterials.hasOwnProperty(colorID)) {
            for (var i = 0; i < this.entity.model.model.meshInstances.length; i++) {
                this.entity.model.model.meshInstances[i].material = this.colorMaterials[colorID].resource;
            }
        }
        if (position) this.entity.setPosition(position);
        if (scale) this.entity.setLocalScale(scale);
        
        if (rotation) {
            if (rotation.z === 0) {
                this.entity.setLocalEulerAngles(rotation.x, rotation.y, rotation.z);
                this.objectAngle = 0;
            } else {
                this.entity.setEulerAnglesComplex(rotation.x, rotation.y, rotation.z);
                this.objectAngle = rotation.z;
            }
        }

    },

    moveTo: function(startGridPosition, endGridPosition, startScale, endScale, startRadius, endRadius, duration, easing,  goLeft, followRotation, callback, delay = 0) {
        var startRotation = this.entity.getEulerAngles();
        var endRotation;

        if (followRotation) {
            if (this.objectAngle === 0) {
                endRotation = new pc.Vec3(this.entity.localPosition.x, 360, this.objectAngle);
            } else {
                endRotation = this.entity.getEulerAnglesComplex(90, 360, this.objectAngle);
            }
        }
        
        this._tweenData = {
            startPosition: startGridPosition,
            endPosition: endGridPosition,
            startScale: startScale,
            endScale: endScale,
            duration: duration,
            easing: easing,
            goLeft: goLeft,
            startRadius: startRadius,
            endRadius: endRadius,
            followRotation: followRotation,
            startRotation: startRotation,
            endRotation: endRotation,
            callback: callback
        };

        if (delay === 0) {
            this._isMoving = true;
            this._moveTimer = 0;
        } else {
            this._delayCounter = 0;
            this._isDelaying = true;
            this._delay = delay;
        }
        
        this._lerpEntity();
    },

    _onDelayDone: function() {
        this._isMoving = true;
        this._moveTimer = 0;
        this._isDelaying = false;
        this.entity.enabled = true;
    },

    _lerpEntity: function() {
        var animProgress = this._tweenData.easing(this._moveTimer / this._tweenData.duration);

        if (!this._tweenData.startPosition.equals(this._tweenData.endPosition) || this._tweenData.startRadius !== this._tweenData.endRadius) {
            // radius
            var newRadius = this._tweenData.startRadius + (this._tweenData.endRadius - this._tweenData.startRadius) * animProgress;

            //position
            var dY = this._tweenData.endPosition.y - this._tweenData.startPosition.y;
            var dX = this._tweenData.endPosition.x - this._tweenData.startPosition.x;

            var dGrid = AnimationObject.VEC_2.set(dX, dY).scale(animProgress);

            var gridPosition = AnimationObject.VEC_3.copy(this._tweenData.startPosition).add(dGrid);
            var worldPosition = GridManager.instance.calculatePosition(gridPosition.x, gridPosition.y, newRadius);
            this.entity.setLocalPosition(worldPosition.x, worldPosition.y, worldPosition.z);

        }
        //scale
        if (!this._tweenData.startScale.equals(this._tweenData.endScale)) {
            var newScale = AnimationObject.VEC_3.copy(this._tweenData.startScale).add(AnimationObject.VEC_3_1.copy(this._tweenData.endScale).sub(this._tweenData.startScale).scale(animProgress));        
            this.entity.setLocalScale(newScale);
        }
    },

    _endAnimation: function() {
        this._isMoving = false;
        if (this._tweenData.callback) this._tweenData.callback.call();
        delete this._tweenData;
    }
});

AnimationObject.VEC_2 = new pc.Vec2();
AnimationObject.VEC_3 = new pc.Vec3();
AnimationObject.VEC_3_1 = new pc.Vec3();

// BoosterButton.js
var BoosterButton = pc.createScript('boosterButton');

BoosterButton.boosterEnum = [
    { FREESWAP: boosterEnum.FREESWAP },
    { BREAKER: boosterEnum.BREAKER },
    { CROSSBOMB: boosterEnum.CROSSBOMB }
];

BoosterButton.attributes.add('type', { type: 'number', enum: BoosterButton.boosterEnum });

BoosterButton.attributes.add('inventoryKey', { type: 'string' });
BoosterButton.attributes.add('amountEntity', { type: 'entity' });

BoosterButton.attributes.add('adGroup', { type: 'entity' });
BoosterButton.attributes.add('activeGroup', { type: 'entity' });
BoosterButton.attributes.add('inactiveGroup', { type: 'entity' });
BoosterButton.attributes.add('emptyGroup', { type: 'entity' });

BoosterButton.attributes.add('useRewarded', { type: 'boolean' });

pc.extend(BoosterButton.prototype, {
    initialize: function () {
        this.buttonStates = Object.freeze({
            EMPTY: 0,
            INACTIVE: 1,
            AD: 2,
            WAITFORAD: 3,
            ACTIVE: 4,
            DISABLED: 5,
            SHOP: 6,
        });

        this.tutorialIndicator = this.entity.findByName('Hand');

        this._setState(this.buttonStates.INACTIVE);

        this.entity.script.elementInput.on(inputEvents.CLICK, this._onClick, this);

        this.app.on('LevelManager:onLevelStart', () => this.setAmount(), this);
        this.app.on('BoosterManager:confirmedBooster', this.onBoosterConfirmed, this);
        this.app.on('BoosterButton:disableAll', this.deactivateBooster, this);
        this.app.on('BoosterShopManager:onItemBought', this.setAmount, this);
        this.app.on('LevelManager:noMoreMoves', this.deactivateBooster, this);
        this.app.on('LevelManager:levelComplete', this.deactivateBooster, this);

        this.on('state', function (enabled) {
            if (enabled) {
                if (this._keepDisabled) {
                    setTimeout(() => {
                        this.entity.enabled = false;
                    });

                    return;
                }

                this._setState(this._currentState);
            }
        }.bind(this));
    },

    postInitialize: function () {
        this.setAmount();
    },

    setAmount: function (amount = Inventory.instance.getItem(this.inventoryKey)) {
        this.currentAmount = amount;
        this.setAmountText(this.currentAmount);
        this._checkState();
    },

    _onClick: function () {
        if (!SwapMode.instance.isWaiting()) {
            return;
        }

        switch (this._currentState) {
            case this.buttonStates.EMPTY:
                // TODO go to boostershop

                break;
            case this.buttonStates.INACTIVE:
                // use power-up
                this.doBooster();

                this.fire("use");
                this.enableTutorial(false);

                break;

            case this.buttonStates.AD:
                // ad
                GameManager.instance.doTimeCount = false;
                this._setState(this.buttonStates.WAITFORAD);
                Wrapper.instance.rewardedAd(this.onWatchedAd, this);
                break;
            case this.buttonStates.WAITFORAD:
                // nothing
                break;
            case this.buttonStates.ACTIVE:
                // cancel power
                this.fire("cancel");

                this._setState(this.buttonStates.INACTIVE);
                BoosterManager.instance.cancelBooster(this.type);
                break;
            case this.buttonStates.DISABLED:
                // nothing
                break;
            case this.buttonStates.SHOP:
                if (TutorialManager.instance.active) {
                    break;
                }
                this.app.fire('UIManager:showUI', 'BoosterShop');
                this.app.fire('BoosterButton:disableAll');
                this.app.fire('BoosterShopInterface:setBooster', this.inventoryKey);
                break;
        }

        this._checkState();
    },

    onWatchedAd: function (result) {
        if (result.rewardGranted) {
            GameManager.instance.doTimeCount = true;
            Inventory.instance.addItem(this.inventoryKey, 1, 'reward', 'rewardedAd');
            this.doBooster();
            this._checkState();
        } else {
            this._setState(this.buttonStates.AD);
            GameManager.instance.doTimeCount = true;
        }
    },

    _onReset: function () {
        this._checkState();
    },

    _setState: function (state) {
        this._currentState = typeof state === 'number' ? state : this.buttonStates.ACTIVE;

        this.adGroup.enabled = this._currentState === this.buttonStates.AD;
        this.emptyGroup.enabled = this._currentState === this.buttonStates.SHOP;
        this.activeGroup.enabled = this._currentState === this.buttonStates.ACTIVE;
        this.inactiveGroup.enabled = this._currentState === this.buttonStates.INACTIVE || this._currentState === this.buttonStates.EMPTY;
        this.entity.enabled = this._currentState !== this.buttonStates.DISABLED;

        // active animation 
        if (this._currentState === this.buttonStates.ACTIVE) {
            this.app.fire('ActivePowerUpeffect:toggleActivation', true);
            this.entity.script.activePowerUpeffect.toggleUI(true);
            this.entity.setLocalEulerAngles(0, 0, -5);

            if (this.shakeTween) {
                this.shakeTween.stop();
            }

            this.shakeTween = this.entity.tween(this.entity.getLocalRotation())
                .rotate(new pc.Vec3(0, 0, 5), 0.1, pc.SineInOut)
                .loop(true)
                .yoyo(true)
                .start(true);
        } else {
            if (this.shakeTween) {
                this.shakeTween.stop();
            }
            BoosterManager.instance.cancelBooster(this.type);
            this.entity.setLocalEulerAngles(0, 0, 0);
            this.entity.script.activePowerUpeffect.toggleUI(false);
            // this.app.fire('ActivePowerUpeffect:toggleActivation', false);
        }
    },

    _checkState: function () {
        if (this._currentState === this.buttonStates.WAITFORAD || this._currentState === this.buttonStates.ACTIVE) return;

        var hasRewarded = Wrapper.instance.hasFeature('rewarded');

        if (this.currentAmount > 0 || this._tutorial) {
            this._setState(this.buttonStates.INACTIVE);
        } else if (this.currentAmount <= 0 && (!hasRewarded || !this.useRewarded)) {
            if (GameManager.instance.forcedMode) {
                this._setState(this.buttonStates.EMPTY);
            } else {
                this._setState(this.buttonStates.SHOP);
            }
        } else if (this.currentAmount <= 0 && hasRewarded) {
            this._setState(this.buttonStates.AD);
        }
    },

    setAmountText: function (amount) {
        this.amountEntity.element.text = String(amount);
    },

    doBooster: function () {
        SwapMode.instance.deselect();

        if (this.type === boosterEnum.BREAKER || this.type === boosterEnum.FREESWAP || this.type === boosterEnum.CROSSBOMB) {
            // boosters that need confirmation

            BoosterManager.instance.activateBooster(this.type);
            this.app.fire('BoosterButton:disableAll');
            this._setState(this.buttonStates.ACTIVE);
        } else {
            // instant activate boosters
            Inventory.instance.tryPayItem(this.inventoryKey, 1, 'boost', 'consumeBooster');
            this.setAmount();
        }

        this._checkState();
    },

    _updateBoosterStatistics: function () {
        // StatisticsManager.instance.incrementStatistic("boosters_used");
        if (this.type === boosterEnum.FREESWAP) {
            StatisticsManager.instance.incrementStatistic("booster_used", { type: 'swap' });
            this.app.fire('TrackingManager:freeSwap');
        }
        if (this.type === boosterEnum.BREAKER) {
            StatisticsManager.instance.incrementStatistic("booster_used", { type: 'shovel' });
            this.app.fire('TrackingManager:breaker');
        }
        if (this.type === boosterEnum.CROSSBOMB) {
            StatisticsManager.instance.incrementStatistic("booster_used", { type: 'beehive' });
            this.app.fire('TrackingManager:crossbomb');
        }
    },

    onBoosterConfirmed: function (type) {
        if (type !== this.type) return;

        this._updateBoosterStatistics();

        if (!this._tutorial) {
            if (Xsolla.instance.loggedIn) {
                Xsolla.instance.consumeItem(Inventory.instance.getXsollaSKU(this.inventoryKey), 1);
            }
            Inventory.instance.tryPayItem(this.inventoryKey, 1, 'booster', 'consumeBooster');
        } else {
            this.setTutorial(false);
        }
        this.setAmount();
        this._setState(this.buttonStates.INACTIVE);
        this._checkState();
    },

    setActiveIfUsable: function () {
        if (this.disabledForTutorial) {
            return;
        }

        if (this._currentState !== 5) {
            this.entity.enabled = true;
        }
    },

    deactivateBooster: function () {
        if (this._currentState === this.buttonStates.ACTIVE) {
            this._setState(this.buttonStates.INACTIVE);
        }
    },

    enableInput: function (value) {
        this.entity.element.useInput = value;
    },

    enableTutorial: function (value) {
        this.tutorialIndicator.enabled = value;
    },

    activate: function (value) {
        this._active = value;
        if (value) {
            this.entity.element.useInput = true;


            var elements = this.entity.findComponents("element");
            for (var j = 0; j < elements.length; j++) {
                elements[j].opacity = 1; // 3E3E3E
                elements[j].color = new pc.Color().fromString("#FFFFFF");
            }

        } else {
            this.entity.element.useInput = false;
            // this.entity.element.opacity = this.disableOpacity;
            // this.entity.element.color = new pc.Color().fromString("#3E3E3E");
            var elements = this.entity.findComponents("element");
            for (var j = 0; j < elements.length; j++) {
                elements[j].opacity = BoosterButton.DISABLE_OPACITY; // 
                elements[j].color = new pc.Color().fromString("#3E3E3E");
            }

        }
    },

    setTutorial: function (isTutorial) {
        this._tutorial = isTutorial;

        if (this._tutorial) {
            this.setAmountText(this.currentAmount + 1);
            this._setState(this.buttonStates.INACTIVE);
        }
    },

    disable: function () {
        this.entity._keepDisabled = true;

        this.entity.enabled = false;
    },

    enable: function () {
        this.entity._keepDisabled = false;

        this.entity.enabled = true;
    },
});


BoosterButton.DISABLE_OPACITY = 0.5;

// PowerAnimationManager.js
var PowerAnimationManager = pc.createScript('powerAnimationManager');

PowerAnimationManager.attributes.add('lineAnimationObjectPool', { type: 'entity' });
PowerAnimationManager.attributes.add('colorbombAnimationObjectPool', { type: 'entity' });
PowerAnimationManager.attributes.add('bombAnimationObjectPool', { type: 'entity' });

PowerAnimationManager.attributes.add('PowerCombinationParticleObjectPool', { type: 'entity' });
PowerAnimationManager.attributes.add('PowerCombinationMaterial', { type: "asset", assetType: 'material' });
PowerAnimationManager.attributes.add('shinePoolEntity', { type: "entity", });

var powerAnimationTypes = Object.freeze({
    BOMB: 1,
    COLORBOMB: 2,
    LINES: 3,
});

pc.extend(PowerAnimationManager.prototype, {
    initialize: function () {
        PowerAnimationManager.instance = this;

        this.linePool = this.lineAnimationObjectPool.script.objectPool;
        this.colorbombPool = this.colorbombAnimationObjectPool.script.objectPool;
        this.bombPool = this.bombAnimationObjectPool.script.objectPool;
        this.particlePool = this.PowerCombinationParticleObjectPool.script.objectPool;
        this.shinePool = this.shinePoolEntity.script.objectPool;
        this.app.on('PowerAnimationManager:afterMove', this.startRotateAnimation, this);
    },

    recycleLineObject: function (entity) {
        entity.enabled = false;
        entity.reparent(null);
        this.linePool.recycle(entity);
    },

    recycleColorObject: function (entity) {
        entity.enabled = false;
        entity.reparent(null);
        this.colorbombPool.recycle(entity);
    },

    recycleBombObject: function (entity) {
        entity.enabled = false;
        entity.reparent(null);
        this.bombPool.recycle(entity);
    },

    recycleParticleObject: function (entity) {
        entity.enabled = false;
        entity.reparent(null);
        this.particlePool.recycle(entity);
    },

    createLineAnimation: function (tile, durationValues, isVertical, goLeft, endX, endY, tileAngle, colorID, delay) {
        var dX = Math.abs(endX - tile.x);
        var dY = Math.abs(endY - tile.y);
        var duration = (isVertical ? dY * durationValues.y : dX * durationValues.y);

        var entity = this.linePool.use();

        entity.script.animationObject.objectInit(
            this.entity, // parent
            tile.entity.getLocalPosition(), // position
            new pc.Vec3(90, 0, tileAngle), // rotation
            pc.Vec3.ONE, // scale
            colorID // material
        );

        // start anim
        entity.animation.play('bee_animated.json', 0);
        var disappearTween = entity.tween(entity.getLocalScale()).to({ x: 0, y: 0, z: 0 }, 0.2, pc.Linear);
        disappearTween.on('complete', function () {
            entity.animation.play('bee_idle.json', 0);
            this.recycleLineObject(entity);
        }.bind(this));

        entity.script.animationObject.moveTo(
            isVertical ? new pc.Vec2(endX, tile.y) : new pc.Vec2(tile.x, endY), // start pos
            new pc.Vec2(endX, endY), // end pos
            new pc.Vec3(0.8, 0.8, 0.8), // start scale
            pc.Vec3.ONE, // end scale
            GridManager.instance.radius + 1, // start radius
            GridManager.instance.radius + 1, // end radius
            duration, // duration
            pc.SineInOut,  // easing
            goLeft, // go left
            !isVertical, // follow rotation
            function () { // callback
                disappearTween.start();
            }.bind(this)
        );
    },

    createColorBombAnimation: function (tile, duration) {
        var entity = this.colorbombPool.use();
        entity.script.animationObject.objectInit(
            this.entity, // parent
            tile.entity.getLocalPosition(), // position
            new pc.Vec3(90, 0, 0), // rotation
            pc.Vec3.ONE, // scale
            null // material
        );

        // start anim#
        entity.animation.play('butterfly_animated.json', 0);

        var disappearTween = entity.tween(entity.getLocalScale()).to({ x: 0, y: 0, z: 0 }, 0.2, pc.BackIn);
        disappearTween.on('complete', function () {
            entity.animation.play('butterfly_idle.json', 0);
            this.recycleColorObject(entity);
        }.bind(this));
        entity.script.animationObject.moveTo(
            new pc.Vec2(tile.x, tile.y), // start pos
            new pc.Vec2(tile.x, tile.y), // end pos
            pc.Vec3.ONE, // start scale
            new pc.Vec3(1.5, 1.5, 1.5), // end scale
            GridManager.instance.radius + 0, // start radius
            GridManager.instance.radius + 1, // end radius
            duration, // duration
            pc.SineIn,  // easing
            false, // go left
            false, // follow rotation
            function () { // callback
                disappearTween.start();
            }.bind(this)
        );
    },

    createBombAnimation: function (tile, durationValues, isVertical, goLeft, endX, endY, tileAngle, distance, colorID, playSound, delay) {
        var duration = durationValues.y * distance;
        var entity = this.bombPool.use();

        entity.script.animationObject.objectInit(
            this.entity, // parent
            tile.entity.getLocalPosition(), // position
            new pc.Vec3(90, 0, tileAngle), // rotation
            pc.Vec3.ONE, // scale
            colorID // material
        );
        // start anim
        entity.animation.play('ladybug_animated.json', 0);
        var disappearTween = entity.tween(entity.getLocalScale()).to({ x: 0, y: 0, z: 0 }, 0.2, pc.Linear);
        disappearTween.on('complete', function () {
            entity.animation.play('ladybug_idle.json', 0);
            this.recycleBombObject(entity);
        }.bind(this));
        entity.script.animationObject.moveTo(
            new pc.Vec2(tile.x, tile.y), // start pos
            new pc.Vec2(endX, endY), // end pos
            new pc.Vec3(0.4, 0.4, 0.4), // start scale
            pc.Vec3.ONE, // end scale
            GridManager.instance.radius + 1, // start radius
            GridManager.instance.radius + 1, // end radius
            duration, // duration
            pc.SineInOut,  // easing
            goLeft, // go left
            !isVertical, // follow rotation
            function () { // callback
                disappearTween.start();
                if (playSound) {
                    GridManager.instance.playSFX('bomb_hit_flowers.mp3');
                }
            }.bind(this)
        );
    },

    createColorBombParticleAnimation: function (positionTile, durationValues, isVertical, goLeft, endX, endY, tileAngle, distance, colorID, affectedTile, type) {
        var entity = null;
        var animationJSON = null;
        var idleJSON = null;

        switch (type) {
            case powerAnimationTypes.BOMB:
                entity = this.bombPool.use();
                animationJSON = 'ladybug_animated.json';
                idleJSON = 'ladybug_idle.json';
                break;
            case powerAnimationTypes.COLORBOMB:
                entity = this.colorbombPool.use();
                animationJSON = 'butterfly_animated.json';
                idleJSON = 'butterfly_idle.json';
                break;
            case powerAnimationTypes.LINES:
                entity = this.linePool.use();
                animationJSON = 'bee_animated.json';
                idleJSON = 'bee_idle.json';
                break;
        }

        var tilePos = positionTile.entity ? positionTile.entity.getLocalPosition() : GridManager.instance.calculatePosition(positionTile.x, positionTile.y);

        entity.script.animationObject.objectInit(
            this.entity, // parent
            tilePos, // position
            new pc.Vec3(90, 0, tileAngle), // rotation
            pc.Vec3.ONE, // scale
            colorID // material
        );

        // start anim
        entity.animation.play(animationJSON, 0);
        var disappearTween = entity.tween(entity.getLocalScale()).to({ x: 0, y: 0, z: 0 }, 0.2, pc.Linear);

        disappearTween.on('complete', function () {
            entity.animation.play(idleJSON, 0);
            switch (type) {
                case powerAnimationTypes.BOMB:
                    this.recycleBombObject(entity);
                    break;
                case powerAnimationTypes.COLORBOMB:
                    this.recycleColorObject(entity);
                    break;
                case powerAnimationTypes.LINES:
                    this.recycleLineObject(entity);
                    break;
            }
        }.bind(this));


        // rotate the butterfly while it flies
        var rotation = entity.getLocalEulerAngles().clone();
        entity.setLocalEulerAngles(180, rotation.y, rotation.z);
        entity.tween(entity.getLocalRotation()).rotate({ x: 90, y: rotation.y, z: rotation.z }, durationValues / 2, pc.SineIn).start(true).on('complete', function () {
            entity.tween(entity.getLocalRotation()).rotate({ x: 0, y: rotation.y, z: rotation.z }, durationValues / 2, pc.SineOut).start(true);
        });

        // enlarge the butterfly
        entity.tween(entity.getLocalPosition()).to({ z: 25 }, durationValues / 2, pc.SineInOut).yoyo(true).repeat(2).start().on('complete', function () {
            affectedTile.stopAffectedTweens();
        });

        entity.enabled = true;
        entity.script.animationObject.moveTo(
            new pc.Vec2(positionTile.x, positionTile.y), // start pos
            new pc.Vec2(endX, endY), // end pos
            new pc.Vec3(0.4, 0.4, 0.4), // start scale
            pc.Vec3.ONE, // end scale
            GridManager.instance.radius + 1, // start radius
            GridManager.instance.radius + 1, // end radius
            durationValues, // duration
            pc.SineInOut,  // easing
            goLeft, // go left
            !isVertical, // follow rotation
            function () { // callback
                disappearTween.start();
            }.bind(this)
        );
    },


    preboosterSpawnAnimation: function (positionTile, durationValues, isVertical, goLeft, endX, endY, tileAngle, distance, colorID, affectedTile, type) {
        var entity = null;
        var animationJSON = null;
        var idleJSON = null;

        switch (type) {
            case powerAnimationTypes.BOMB:
                entity = this.bombPool.use();
                animationJSON = 'ladybug_animated.json';
                idleJSON = 'ladybug_idle.json';
                break;
            case powerAnimationTypes.COLORBOMB:
                entity = this.colorbombPool.use();
                animationJSON = 'butterfly_animated.json';
                idleJSON = 'butterfly_idle.json';
                break;
            case powerAnimationTypes.LINES:
                entity = this.linePool.use();
                animationJSON = 'bee_animated.json';
                idleJSON = 'bee_idle.json';
                break;
        }

        var tilePos = positionTile.entity ? positionTile.entity.getLocalPosition() : GridManager.instance.calculatePosition(positionTile.x, positionTile.y);

        entity.script.animationObject.objectInit(
            this.entity, // parent
            tilePos, // position
            new pc.Vec3(90, 0, tileAngle), // rotation
            pc.Vec3.ONE, // scale
            colorID // material
        );

        // start anim
        entity.animation.play(animationJSON, 0);
        var disappearTween = entity.tween(entity.getLocalScale()).to({ x: 0, y: 0, z: 0 }, 0.2, pc.Linear);

        disappearTween.on('complete', function () {
            entity.animation.play(idleJSON, 0);
            switch (type) {
                case powerAnimationTypes.BOMB:
                    this.recycleBombObject(entity);
                    break;
                case powerAnimationTypes.COLORBOMB:
                    this.recycleColorObject(entity);
                    break;
                case powerAnimationTypes.LINES:
                    this.recycleLineObject(entity);
                    break;
            }
        }.bind(this));


        // rotate the butterfly while it flies
        var rotation = entity.getLocalEulerAngles().clone();
        // entity.setLocalEulerAngles(180, rotation.y, rotation.z);
        entity.tween(entity.getLocalRotation()).rotate({ x: 90, y: rotation.y, z: rotation.z }, durationValues / 2, pc.SineIn).start(true).on('complete', function () {
            entity.tween(entity.getLocalRotation()).rotate({ x: 0, y: rotation.y, z: rotation.z }, durationValues / 2, pc.SineOut).start(true);
        });

        // enlarge the butterfly
        entity.setLocalPosition(entity.getLocalPosition().x, entity.getLocalPosition().y, 25);
        entity.tween(entity.getLocalPosition()).to({ z: 0 }, durationValues, pc.SineInOut).yoyo(true).start().on('complete', function () {
            affectedTile.stopAffectedTweens();
        });

        entity.enabled = true;
        entity.script.animationObject.moveTo(
            new pc.Vec2(positionTile.x, positionTile.y), // start pos
            new pc.Vec2(endX, endY), // end pos
            new pc.Vec3(0.4, 0.4, 0.4), // start scale
            pc.Vec3.ONE, // end scale
            GridManager.instance.radius + 1, // start radius
            GridManager.instance.radius + 1, // end radius
            durationValues, // duration
            pc.SineInOut,  // easing
            goLeft, // go left
            !isVertical, // follow rotation
            function () { // callback
                disappearTween.start();
            }.bind(this)
        );
    },

    spawnAnimationByType: function (tile) {
        var entity = null;
        var animationJSON = null;
        var idleJSON = null;
        var tileAngle;

        switch (tile.typeID) {
            case foregroundTileEnum.BOMB:
                entity = this.bombPool.use();
                break;
            case foregroundTileEnum.COLORBOMB:
                entity = this.colorbombPool.use();
                break;
            case foregroundTileEnum.LINE_V:
                tileAngle = 0;
                entity = this.linePool.use();
                break;
            case foregroundTileEnum.LINE_H:
                tileAngle = -90;
                entity = this.linePool.use();
                break;
        }

        entity.script.animationObject.objectInit(
            this.entity, // parent
            tile.entity.getPosition(), // position
            new pc.Vec3(90, 0, tileAngle), // rotation
            pc.Vec3.ONE, // scale
            tile.colorID // material
        );

        // start anim
        return entity;
    },

    despawnAnimationByType: function (animation, tile, tileAnimation) {
        animation.on('complete', function () {
            switch (tile.typeID) {
                case foregroundTileEnum.BOMB:
                    this.recycleBombObject(tileAnimation);
                    break;
                case foregroundTileEnum.COLORBOMB:
                    this.recycleColorObject(tileAnimation);
                    break;
                case foregroundTileEnum.LINE_V:
                case foregroundTileEnum.LINE_H:
                    this.recycleLineObject(tileAnimation);
                    break;
            }
        }.bind(this));
    },

    changeMesh: function (animation, meshes) {
        var meshInstances = animation.model.meshInstances;
        var meshBackup = [];
        for (var i = 0; i < meshInstances.length; ++i) {
            var mesh = meshInstances[i];
            meshBackup[i] = mesh.material;
            mesh.material = (meshes !== undefined) ? meshes[i] : this.PowerCombinationMaterial.resource;
        }

        return meshBackup;
    },

    createPowerCombinationAnimation: function (tile, matchedTile, duration, callback) {
        // tile = meeting location
        var tileAnimation = this.spawnAnimationByType(tile);
        var matchedAnimation = this.spawnAnimationByType(matchedTile);

        var matchedMeshBackup = this.changeMesh(matchedAnimation);
        var tileMeshBackup = this.changeMesh(tileAnimation);

        var particleEffect = this.particlePool.use();

        particleEffect.enabled = true;
        particleEffect.reparent(this.app.root);
        particleEffect.script.PowerCombinationAnimation.play(duration);
        particleEffect.setLocalPosition(tile.entity.getLocalPosition().x, tile.entity.getLocalPosition().y, 0.8);

        this.app._tweenManager.removeAll(tileAnimation);
        this.app._tweenManager.removeAll(matchedAnimation);


        var disappearTile = tileAnimation.tween(tileAnimation.getLocalScale()).to({ x: 0, y: 0, z: 0 }, 0, pc.Linear);
        var disappearMatched = matchedAnimation.tween(matchedAnimation.getLocalScale()).to({ x: 0, y: 0, z: 0 }, 0, pc.Linear);

        this.despawnAnimationByType(disappearTile, tile, tileAnimation);
        this.despawnAnimationByType(disappearMatched, matchedTile, matchedAnimation);

        matchedAnimation.tween(matchedAnimation.getLocalScale()).to({ x: matchedAnimation.getLocalScale().x / 2, y: matchedAnimation.getLocalScale().y / 2, z: matchedAnimation.getLocalScale().z / 2 }, duration * 0.75, pc.Linear).start();
        tileAnimation.tween(tileAnimation.getLocalScale()).to({ x: tileAnimation.getLocalScale().x / 2, y: tileAnimation.getLocalScale().y / 2, z: tileAnimation.getLocalScale().x / 2 }, duration * 0.75, pc.Linear).start();

        var position = tileAnimation.getLocalPosition().clone();

        matchedAnimation.tween(matchedAnimation.getLocalPosition()).to(position, duration, pc.CubicOut).start().on('complete', () => {

            disappearTile.start();
            disappearMatched.start().on('complete', () => {
                callback(tile, matchedTile);
                this.recycleParticleObject(particleEffect);
                this.changeMesh(matchedAnimation, matchedMeshBackup);
                this.changeMesh(tileAnimation, tileMeshBackup);
            });
        });
    },

    createLineAnimationBomb: function (tile, durationValues, isVertical, goLeft, endX, endY, tileAngle, colorID) {
        var dX = Math.abs(endX - tile.x);
        var dY = Math.abs(endY - tile.y);
        var duration = isVertical ? dY * durationValues.y : dX * durationValues.y;

        var entity = this.bombPool.use();
        entity.script.animationObject.objectInit(
            this.entity, // parent
            tile.entity.getLocalPosition(), // position
            new pc.Vec3(90, 0, tileAngle), // rotation
            pc.Vec3.ONE, // scale
            colorID// material
        );

        // start anim
        entity.animation.play('ladybug_animated.json', 0);
        var disappearTween = entity.tween(entity.getLocalScale()).to({ x: 0, y: 0, z: 0 }, 0.2, pc.Linear);

        disappearTween.on('complete', function () {
            entity.animation.play('ladybug_idle.json', 0);
            this.recycleBombObject(entity);
        }.bind(this));

        entity.script.animationObject.moveTo(
            isVertical ? new pc.Vec2(endX, tile.y) : new pc.Vec2(tile.x, endY), // start pos
            new pc.Vec2(endX, endY), // end pos
            new pc.Vec3(0.8, 0.8, 0.8), // start scale
            pc.Vec3.ONE, // end scale
            GridManager.instance.radius + 1, // start radius
            GridManager.instance.radius + 1, // end radius
            duration, // duration
            pc.SineInOut,  // easing
            goLeft, // go left
            !isVertical, // follow rotation
            function () { // callback
                disappearTween.start();
            }.bind(this)
        );
    },


    createLineAnimationCrossbomb: function (startX, startY, durationValues, isVertical, goLeft, endX, endY, tileAngle, colorID, delay) {
        var dX = Math.abs(endX - startX);
        var dY = Math.abs(endY - startY);
        var duration = (isVertical ? dY * durationValues.y : dX * durationValues.y);

        var entity = this.linePool.use();

        entity.script.animationObject.objectInit(
            this.entity, // parent
            GridManager.instance.calculatePosition(startX, startY, 0), // position
            new pc.Vec3(90, 0, tileAngle), // rotation
            pc.Vec3.ONE, // scale
            colorID // material
        );
        // start anim
        entity.animation.play('bee_animated.json', 0);
        var disappearTween = entity.tween(entity.getLocalScale()).to({ x: 0, y: 0, z: 0 }, 0.2, pc.Linear);
        disappearTween.on('complete', function () {
            entity.animation.play('bee_idle.json', 0);
            this.recycleLineObject(entity);
        }.bind(this));

        entity.script.animationObject.moveTo(
            isVertical ? new pc.Vec2(endX, startY) : new pc.Vec2(startX, endY), // start pos
            new pc.Vec2(endX, endY), // end pos
            new pc.Vec3(0.8, 0.8, 0.8), // start scale
            pc.Vec3.ONE, // end scale
            GridManager.instance.radius + 1, // start radius
            GridManager.instance.radius + 1, // end radius
            duration, // duration
            pc.SineInOut,  // easing
            goLeft, // go left
            !isVertical, // follow rotation
            function () { // callback
                disappearTween.start();
            }.bind(this),
            delay
        );
        entity.setLocalScale(0, 0, 0);
    },
});

// ActivePowerUpEffect.js
var ActivePowerUpeffect = pc.createScript('activePowerUpeffect');

ActivePowerUpeffect.attributes.add('UIToActivate', { type: 'entity', array: true });
ActivePowerUpeffect.attributes.add('UIToDeactivate', { type: 'entity', array: true });

pc.extend(ActivePowerUpeffect.prototype, {

    initialize: function () {
        // this.app.on('ActivePowerUpeffect:toggleActivation', this.toggleUI, this);
        this.toggleUI(false);
    },

    toggleUI: function (doActive) {
        for (var i = 0; i < this.UIToActivate.length; i++) {
            const entity = this.UIToActivate[i];
            if (entity._keepDisabled && doActive) {
                continue;
            }

            entity.enabled = doActive;
        }

        for (var j = 0; j < this.UIToDeactivate.length; j++) {
            const entity = this.UIToDeactivate[j];
            if (entity.tags.has('Booster') && !doActive) {
                //entity.script.boosterButton.setActiveIfUsable();
            }
            else {
                if (entity._keepDisabled && !doActive) {
                    continue;
                }
                entity.enabled = !doActive;
            }
        }
    },
});

// ScaleElementToScreenSize.js
var ScaleElementToscreenSize = pc.createScript('scaleElementToscreenSize');

pc.extend(ScaleElementToscreenSize.prototype, {
    
    initialize: function() {
        this._onResize(ViewportManager.instance.getOrientation(), ViewportManager.instance.width, ViewportManager.instance.height, ViewportManager.instance.getDevice());
        this.app.on('ViewportManager:onResize', this._onResize, this);
    },
    
    _onResize: function(orientation, width, height, device) {
        var scale = UIManager.instance.getReferenceResolution().y / height;
        this.entity.element.width = width * scale;
        this.entity.element.height = height * scale;
    },
});

// TileParticle.js
var TileParticle = pc.createScript('tileParticle');

TileParticle.attributes.add('sprite', { type: 'asset' });
TileParticle.attributes.add('color', { type: 'rgb',  });

pc.extend(TileParticle.prototype, {
    getColor: function() {
        return this.color;
    },
    
    getTexture: function() {
        return this.sprite.resource;
    }
});

// HamburgerMenu.js
var HamburgerMenu = pc.createScript('hamburgerMenu');

HamburgerMenu.attributes.add('menuButton', { type: 'entity' });
HamburgerMenu.attributes.add('content', { type: 'entity', array: true });
HamburgerMenu.attributes.add('buttons', { type: 'entity', array: true });

HamburgerMenu.attributes.add('unfoldDirectionType', {
    type: 'number', enum: [
        { 'top': 0 },
        { 'bottom': 1 },
        { 'left': 2 },
        { 'right': 3 }
    ]
});
HamburgerMenu.attributes.add('unfoldDistance', { type: 'number', default: 10 });
HamburgerMenu.attributes.add('unfoldDuration', { type: 'number', default: 1 });
HamburgerMenu.attributes.add('autoCloseTimer', { type: 'number' });
HamburgerMenu.attributes.add('closeOnUIChange', { type: 'boolean' });

pc.extend(HamburgerMenu.prototype, {
    initialize: function () {
        this.unfoldDirection = HamburgerMenu.DIRECTIONS[this.unfoldDirectionType];

        this.countdown = false;
        this.counter = 0;
        this.isOpen = false;

        this.menuButton.script.elementInput.on(inputEvents.CLICK, this._onClick, this);
        this.on('state', function (enabled) {
            if (enabled) {
                //this.toggleMenu(true, false);
            }
        }.bind(this));

        for (var i = 0; i < this.buttons.length; i += 1) {
            const button = this.buttons[i];

            if (!button.script.elementInput) {
                console.warn('No elementInput on settings content: ', this.content[i]);
                continue;
            }
            button.script.elementInput.on(inputEvents.CLICK, this.resetCloseTimer, this);
            button.script.on('state', this.checkButtonStates, this);
        }

        if (this.closeOnUIChange) this.app.on('UIManager:showUI', () => {
            this.toggleMenu(true, false);
        }, this);
    },

    postInitialize: function () {
        this.checkButtonStates();

        this.on('state', this.onState, this);
        pc.timer.add(0.01, () => {
            this.toggleMenu(true, false);
        });
    },

    onState: function () {
        if (this.entity.enabled) {
            if (this.noButtonsActive) {
                console.log("here?")
                this.entity.enabled = false;
            }
        }
    },

    checkButtonStates: function () {
        for (var i = 0; i < this.buttons.length; i++) {
            if (this.buttons[i]._enabled && !this.buttons[i]._keepDisabled) {
                this.entity.enabled = true;
                this.noButtonsActive = false;
                this.entity._keepDisabled = false;
                return;
            }
        }

        this.noButtonsActive = true;
        this.entity.enabled = false;
        this.entity._keepDisabled = true;
    },

    update: function (dt) {
        if (this.countdown) {
            this.counter -= dt;

            if (this.counter <= 0) {
                this.countdown = false;
                this.counter = 0;
                this.toggleMenu(false, false);
            }
        }
    },

    _onClick: function () {
        this.toggleMenu();
        this.app.fire('Audio:playSFX', 'button.mp3');
    },

    resetCloseTimer: function () {
        this.counter = this.autoCloseTimer;
    },

    /*
     * Open or close hamburger menu
     * par isIntant: use tween to open content or not
     * par isOpen: force to certain position, leave undefined to toggle
     */
    toggleMenu: function (isInstant, isOpen) {
        if (isOpen === undefined) {
            this.isOpen = !this.isOpen;
        } else {
            this.isOpen = isOpen;
        }

        if (this.isOpen && this.autoCloseTimer && this.autoCloseTimer !== 0) {
            this.countdown = true;
            this.counter = this.autoCloseTimer;
        }

        var counter = 1;
        for (var i = 0; i < this.content.length; i += 1) {
            const content = this.content[i];
            const button = this.buttons[i];

            if (!button) {
                console.warn(this, i, button);
                continue;
            }

            if (!button._enabled) {
                continue;
            }

            if (button._keepDisabled) {
                continue;
            }

            const success = this._setItemPosition(content, this.isOpen ? this.unfoldDirection.clone().scale(this.unfoldDistance * counter) : pc.Vec3.ZERO, isInstant);

            if (!success) {
                continue;
            }

            if (this.content[i].parent !== null) counter += 1;
        }
        this.fire('MenuToggle', this.isOpen);
    },

    _setItemPosition: function (item, position, isInstant) {
        if (isInstant) {
            item.setLocalPosition(position);
            item.enabled = this.isOpen;
        } else {
            if (this.isOpen) {
                item.enabled = true;
            }

            if (item._enabled) {
                item.tween(item.getLocalPosition()).to(position, this.unfoldDuration, pc.SineOut).start().on('complete', function () {
                    if (!this.isOpen) {
                        item.enabled = false;
                    }
                }.bind(this));
            }
        }
        return item._enabled;
    }
});

HamburgerMenu.DIRECTIONS = [new pc.Vec3(0, 1, 0), new pc.Vec3(0, -1, 0), new pc.Vec3(-1, 0, 0), new pc.Vec3(1, 0, 0)];

// VibrateButton.js
var VibrateButton = pc.createScript('vibrateButton');

VibrateButton.attributes.add('icon', { type: 'entity' });
/**
 * For feed forward: on icon sprite first
 * For feed back: off icon sprite first
 **/
VibrateButton.attributes.add('iconSprites', { type: 'asset', assetType: 'sprite', array: true });

pc.extend(VibrateButton.prototype, {
    initialize: function() {
        this.entity.script.elementInput.on(inputEvents.CLICK, this._onClick, this);

        this.entity._keepDisabled = !VibrationManager.instance.isVibrationSupported();
    },

    postInitialize: function() {
        var visible = this.setVisibility();

        if (!visible) {
            this.entity.destroy();
            return;
        }

        this.on('state', function(enabled) {
            this.setButtonState();
        }.bind(this));

        this.setButtonState();
    },
    
    _onClick: function() {
        this.app.fire('Audio:playSFX', 'button.mp3');
        this.vibrate = !this.vibrate;   
        this.setActive(this.vibrate, true);
    },

    setVisibility: function() {
        this.entity.enabled = VibrationManager.instance.isVibrationSupported();

        return this.entity.enabled;
    },

    setButtonState: function() {
        this.vibrate = StorageManager.instance.get('vibrate'); 
        this.setActive(this.vibrate);
    },

    setActive: function(vibrate, mayVibrate) {
        this.icon.element.spriteAsset = this.iconSprites[+vibrate].id;
        VibrationManager.instance.set(vibrate);

        if (vibrate && mayVibrate) {
            this.app.fire('vibrate');
        }
    },
});

// CascadeIndicatorInterface.js
var CascadeIndicatorInterface = pc.createScript('cascadeIndicatorInterface');

CascadeIndicatorInterface.attributes.add('cascadeTextEntity', { type: 'entity' });
CascadeIndicatorInterface.attributes.add('cascadeImageEntity', { type: 'entity' });
CascadeIndicatorInterface.attributes.add('wordImages', { type: 'asset', assetType: 'sprite', array: true });
CascadeIndicatorInterface.attributes.add('duration', { type: 'number' });
CascadeIndicatorInterface.attributes.add('durationIncreasePerType', { type: 'number' });
CascadeIndicatorInterface.attributes.add('shineImage', { type: 'entity' });

pc.extend(CascadeIndicatorInterface.prototype, {

    initialize: function () {
        this.counter = 0;
        this.isCounting = false;
        this.shouldShow = false;

        this.app.on('CascadeIndicatorInterface:onCascade', this._handleCascadeIndicator, this);
        this.app.on('IntroScreen:introDone', this._onLevelIntroDone, this);
        this.app.on('LevelManager:levelComplete', this._onLevelEnd, this);
    },

    postInitialize: function () {
        this.entity.enabled = false;
    },

    update: function (dt) {

        if (this.isCounting) {
            this.counter += dt;
            if (this.counter >= this.currentDuration) {
                this.onEnd();
            }
        }

    },

    _handleCascadeIndicator: function (cascadeCounter) {
        if (ObjectiveManager.instance.isObjectivesCompleted()) return;
        this.shineImage.enabled = false;
        if (cascadeCounter === 1) {
            // LOVELY
            this.app.fire('Audio:sfx', 'lucy_lovely.mp3');
            this.onStart(this.wordImages[0], 0);
        } else if (cascadeCounter === 2) {
            // DAZZLING
            this.app.fire('Audio:sfx', 'lucy_dazzling.mp3');
            this.onStart(this.wordImages[1], 1);
        } else if (cascadeCounter === 3) {
            // DELIGHTFUL
            this.app.fire('Audio:sfx', 'lucy_delightful.mp3');
            this.onStart(this.wordImages[2], 2);
        } else if (cascadeCounter === 4) {
            // STUNNING
            this.app.fire('Audio:sfx', 'lucy_stunning.mp3');
            this.onStart(this.wordImages[3], 3);
        } else if (cascadeCounter === 5) {
            // MAJESTIC
            this.app.fire('Audio:sfx', 'lucy_majestic.mp3');
            this.onStart(this.wordImages[4], 4);
            this.shineImage.enabled = true;
        } else if (cascadeCounter >= 6) {
            // KABLOOM
            this.app.fire('Audio:sfx', 'lucy_kabloom.mp3');
            this.onStart(this.wordImages[5], 5);
            this.shineImage.enabled = true;
        }
    },

    onStart: function (cascadeWord, durationIndex) {
        if (!this.shouldShow) {
            return;
        }

        var imageSize = cascadeWord.resource.atlas.frames[cascadeWord.resource.frameKeys[0]].rect;
        this.cascadeImageEntity.element.spriteAsset = cascadeWord.id;
        this.cascadeImageEntity.element.width = imageSize.z;
        this.cascadeImageEntity.element.height = imageSize.w;
        // this.cascadeTextEntity.element.text = cascadeWord;
        this.counter = 0;
        this.isCounting = true;
        this.currentDuration = this.duration + this.durationIncreasePerType * durationIndex;
        this.entity.setLocalScale(pc.Vec3.ZERO);
        this.entity.enabled = true;
        this.appearTween = this.entity.tween(this.entity.getLocalScale()).to({ x: 1, y: 1, z: 1 }, 0.1, pc.BackOut).start();
    },

    onEnd: function () {
        this.isCounting = false;
        this.disappearTween = this.entity.tween(this.entity.getLocalScale()).to({ x: 0, y: 0, z: 0 }, 0.1, pc.BackIn).start()
        this.disappearTween.on('complete', function () {
            this.entity.enabled = false;
        }.bind(this));
    },

    _onLevelIntroDone: function () {
        this.isCounting = false;
        this.entity.enabled = false;
        this.shouldShow = true;
    },

    _onLevelEnd: function () {
        this.shouldShow = false;
    },
});

// ShufflingInterface.js
var ShufflingInterface = pc.createScript('shufflingInterface');

pc.extend(ShufflingInterface.prototype, {
    initialize: function () {
        this.app.on('GridManager:onShuffleStart', this.onShuffleStart, this);
        this.app.on('GridManager:onShuffleEnd', this.onShuffleEnd, this);
    },

    postInitialize: function () {
        this.entity.enabled = false;
    },

    onShuffleStart: function () {
        if (this.disappearTween) {
            this.disappearTween.stop();
            this.disappearTween = null;
        }

        this.entity.setLocalScale(pc.Vec3.ZERO);
        this.entity.enabled = true;
        this.appearTween = this.entity.tween(this.entity.getLocalScale()).to({ x: 1, y: 1, z: 1 }, 0.1, pc.BackOut).start();
    },

    onShuffleEnd: function () {
        if (this.appearTween) {
            this.appearTween.stop();
            this.appearTween = null;
        }

        this.disappearTween = this.entity.tween(this.entity.getLocalScale()).to({ x: 0, y: 0, z: 0 }, 0.1, pc.BackIn).start();

        this.disappearTween.on('complete', function () {
            this.entity.enabled = false;
        }.bind(this));
    },
});

// EndStateInterface.js
var EndStateInterface = pc.createScript('endStateInterface');

EndStateInterface.attributes.add('duration', { type: 'number' });

pc.extend(EndStateInterface.prototype, {
    initialize: function () {
        this.app.on('SwapMode:onEndStart', this.onStart, this);
        this.app.on('LevelManager:onLevelStart', this.onEnd, this);
        this.counter = 0;
        this.isCounting = false;
    },

    postInitialize: function () {
        this.entity.enabled = false;
    },

    update: function (dt) {
        if (this.isCounting) {
            this.counter += dt;
            if (this.counter >= this.duration) {
                this.onEnd();
            }
        }
    },

    onStart: function () {
        this.app.fire('Audio:sfx', 'goals_completed.mp3');
        this.counter = 0;
        this.isCounting = true;
        this.entity.setLocalScale(pc.Vec3.ZERO);
        this.entity.enabled = true;
        this.appearTween = this.entity.tween(this.entity.getLocalScale()).to({ x: 1, y: 1, z: 1 }, 0.1, pc.BackOut).start();
    },

    onEnd: function () {
        this.isCounting = false;
        this.disappearTween = this.entity.tween(this.entity.getLocalScale()).to({ x: 0, y: 0, z: 0 }, 0.1, pc.BackIn).start()
        this.disappearTween.on('complete', function () {
            this.entity.enabled = false;
        }.bind(this));
    }
});

// MusicButton.js
var MusicButton = pc.createScript('musicButton');

MusicButton.attributes.add('icon', { type: 'entity' });
/**
 * For feed forward: on icon sprite first
 * For feed back: off icon sprite first
 **/
MusicButton.attributes.add('iconSprites', { type: 'asset', assetType: 'sprite', array: true });


pc.extend(MusicButton.prototype, {
    initialize: function() {
        this.entity.script.elementInput.on(inputEvents.CLICK, this._onClick, this);

        this.on('state', function(enabled) {
            this.setButtonState();
        }.bind(this));

        this.entity._keepDisabled = Wrapper.instance.hasFeature("external_mute");
    },

    postInitialize: function() {
        this.bgmKey = AudioManager.instance.bgmSettingKey;
        this.setButtonState();
        
        this.entity.enabled = !this.entity._keepDisabled;
    },

    setButtonState: function() {
        if (!this.bgmKey) return;
        this.useBgm = StorageManager.instance.get(this.bgmKey); 
        this.setIcon(this.useBgm);
    },

    // update code called every frame
    _onClick: function() {
        this.app.fire('Audio:playSFX', 'button.mp3');
        this.useBgm = !this.useBgm;

        this.setIcon(this.useBgm);
        this.setSettings(this.useBgm);
    },

    setIcon: function(isActive) {
        this.icon.element.spriteAsset = this.iconSprites[isActive ? 1 : 0].id;
    },
    
    setSettings: function(isActive) {
        StorageManager.instance.set(this.bgmKey, isActive ? 1 : 0);
        AudioManager.instance.setBGMSetting(isActive);
        
        GameManager.instance.trackEventVolumeChange();
    }
});

// LevelInterface.js
var LevelInterface = pc.createScript('levelInterface');

pc.extend(LevelInterface.prototype, {
    initialize: function() {
        this.app.on('LevelManager:onLevelStart', this.setLevel, this);
        this.setLevel();
    },

    setLevel: function() {
        if (!TutorialManager.instance.active) {
            LocalizationManager.instance.setText(this.entity, "IN_GAME_LEVEL", [String(LevelManager.instance.currentLevel)]);
            this.startAnim();
        }
    },

    startAnim: function() {
        this.bobbleTween = this.entity.tween(this.entity.getLocalScale()).to({x: 1.2, y: 1.2, z: 1.2}, 0.1, pc.SineInOut).yoyo(true).repeat(2).start();
    }
});

// SoundButton.js
var SoundButton = pc.createScript('soundButton');

SoundButton.attributes.add('icon', { type: 'entity' });
/**
 * For feed forward: on icon sprite first
 * For feed back: off icon sprite first
 **/
SoundButton.attributes.add('iconSprites', { type: 'asset', assetType: 'sprite', array: true });

pc.extend(SoundButton.prototype, {
    initialize: function() {
        this.entity.script.elementInput.on(inputEvents.CLICK, this._onClick, this);

        this.on('state', function(enabled) {
            this.setButtonState();
        }.bind(this));

        this.entity._keepDisabled = Wrapper.instance.hasFeature("external_mute");
    },

    postInitialize: function() {
        this.sfxKey = AudioManager.instance.sfxSettingKey;
        this.setButtonState();
        
        this.entity.enabled = !this.entity._keepDisabled;
    },

    setButtonState: function() {
        if (!this.sfxKey) return;
        this.useSFX = StorageManager.instance.get(this.sfxKey); 
        this.setIcon(this.useSFX);
    },

    _onClick: function() {
        this.useSFX = !this.useSFX;

        this.setIcon(this.useSFX);
        this.setSettings(this.useSFX);
        this.app.fire('Audio:playSFX', 'button.mp3');
    },

    setIcon: function(isActive) {
        this.icon.element.spriteAsset = this.iconSprites[isActive ? 1 : 0].id;
    },

    setSettings: function(isActive) {
        StorageManager.instance.set(this.sfxKey, isActive ? 1 : 0);
        AudioManager.instance.setSFXSetting(isActive);
        
        GameManager.instance.trackEventVolumeChange();
    },
});



// SkipOrderTutorialStep.js
var SkipOrderTutorialStep = pc.createScript('skipOrderTutorialStep');

pc.extend(SkipOrderTutorialStep.prototype, {
    initialize: function() {
        this.entity.script.elementInput.on(inputEvents.CLICK, this._onClick, this);
    },
    
    _onClick: function() {
        this.app.fire('TutorialManager:skipStep');
    }
});

// TutorialToggleElement.js
var TutorialToggleElement = pc.createScript('tutorialToggleElement');

pc.extend(TutorialToggleElement.prototype, {
    initialize: function() {
        this.app.on('TutorialManager:startTutorial', this.toggleOff, this);
        this.app.on('TutorialManager:stopTutorial', this.toggleOn, this);
    },
    
    toggleOff: function() {
        this.entity.enabled = false;
    },
    
    toggleOn: function() {
        this.entity.enabled = true;
    }
});

// DynamicLayoutGroup.js
var DynamicLayoutGroup = pc.createScript('dynamicLayoutGroup');

var OrientationPreset = Object.freeze([
    { VERTICAL: '1' },
    { HORIZONTAL: '0' }
]);

var defaultString = "------------------------------------------------------";

DynamicLayoutGroup.attributes.add('a', { type: 'string', title: 'Desktop Landscape', default: defaultString });

DynamicLayoutGroup.attributes.add('desktopLandscapePreset', { type: 'string', enum: OrientationPreset, title: 'Preset' });
DynamicLayoutGroup.attributes.add('desktopLandscapeAlignment', { type: 'vec2', default: [ -1, -1 ] , title: 'Alignment'});
DynamicLayoutGroup.attributes.add('desktopLandscapePadding', { type: 'vec4', default: [ -1, -1, -1, -1 ], title: 'Padding' });
DynamicLayoutGroup.attributes.add('desktopLandscapeSpacing', { type: 'vec2', default: [ -1, -1 ], title: 'Spacing' });

DynamicLayoutGroup.attributes.add('b', { type: 'string', title: 'Desktop Portrait', default: defaultString });

DynamicLayoutGroup.attributes.add('desktopPortraitPreset', { type: 'string', enum: OrientationPreset, title: 'Preset' });
DynamicLayoutGroup.attributes.add('desktopPortraitAlignment', { type: 'vec2', default: [ -1, -1 ], title: 'Alignment' });
DynamicLayoutGroup.attributes.add('desktopPortraitPadding', { type: 'vec4', default: [ -1, -1, -1, -1 ], title: 'Padding' });
DynamicLayoutGroup.attributes.add('desktopPortraitSpacing', { type: 'vec2', default: [ -1, -1 ], title: 'Spacing' });

DynamicLayoutGroup.attributes.add('c', { type: 'string', title: 'Mobile Landscape', default: defaultString });

DynamicLayoutGroup.attributes.add('mobileLandscapePreset', { type: 'string', enum: OrientationPreset, title: 'Preset' });
DynamicLayoutGroup.attributes.add('mobileLandscapeAlignment', { type: 'vec2', default: [ -1, -1 ], title: 'Alignment' });
DynamicLayoutGroup.attributes.add('mobileLandscapePadding', { type: 'vec4', default: [ -1, -1, -1, -1 ], title: 'Padding' });
DynamicLayoutGroup.attributes.add('mobileLandscapeSpacing', { type: 'vec2', default: [ -1, -1 ], title: 'Spacing' });

DynamicLayoutGroup.attributes.add('d', { type: 'string', title: 'Mobile Portrait', default: defaultString });

DynamicLayoutGroup.attributes.add('mobilePortraitPreset', { type: 'string', enum: OrientationPreset, title: 'Preset' });
DynamicLayoutGroup.attributes.add('mobilePortraitAlignment', { type: 'vec2', default: [ -1, -1 ], title: 'Alignment' });
DynamicLayoutGroup.attributes.add('mobilePortraitPadding', { type: 'vec4', default: [ -1, -1, -1, -1 ], title: 'Padding' });
DynamicLayoutGroup.attributes.add('mobilePortraitSpacing', { type: 'vec2', default: [ -1, -1 ], title: 'Spacing' });

DynamicLayoutGroup.attributes.add('debug', { type: 'boolean'});


pc.extend(DynamicLayoutGroup.prototype, {
    initialize: function() {
        this._onResize(ViewportManager.instance.getOrientation(), ViewportManager.instance.width, ViewportManager.instance.height, ViewportManager.instance.getDevice());
        this.app.on('ViewportManager:onResize', this._onResize, this);
    },
    
    _onResize: function(orientation, width, height, device) {
        if (device === deviceEnum.DESKTOP) {
            if (orientation === orientationEnum.LANDSCAPE) {
                this._applyOrientation(this.desktopLandscapePreset, this.desktopLandscapeAlignment, this.desktopLandscapePadding, this.desktopLandscapeSpacing);
                return;
            }

            if (orientation === orientationEnum.PORTRAIT) {
                this._applyOrientation(this.desktopPortraitPreset, this.desktopPortraitAlignment, this.desktopPortraitPadding, this.desktopPortraitSpacing);
                return;
            }

            console.warn('Orientation', this._orientation, 'is not recognized!');
            return;
        }

        if (device === deviceEnum.MOBILE) {
            if (orientation === orientationEnum.LANDSCAPE) {
                this._applyOrientation(this.mobileLandscapePreset, this.mobileLandscapeAlignment, this.mobileLandscapePadding, this.mobileLandscapeSpacing);
                return;
            }

            if (orientation === orientationEnum.PORTRAIT) {
                this._applyOrientation(this.mobilePortraitPreset, this.mobilePortraitAlignment, this.mobilePortraitPadding, this.mobilePortraitSpacing);
                return;
            }

            console.warn('Orientation', this._orientation, 'is not recognized!');
            return;
        }

    },
    
    _applyOrientation: function(preset, alignment, padding, spacing) {
        this.entity.layoutgroup.orientation = parseInt(preset);

        if (!alignment.equals(pc.Vec2.MINUS_ONE)) {
            this.entity.layoutgroup.alignment = alignment;
            if (this.debug) {
                console.log(this.entity.layoutgroup.alignment)
            }
        }

        if (!padding.equals(pc.Vec4.MINUS_ONE)) {
            this.entity.layoutgroup.padding = padding;
            if (this.debug) {
                console.log(this.entity.layoutgroup.padding)
            }
        }

        if (!spacing.equals(pc.Vec2.MINUS_ONE)) {
            this.entity.layoutgroup.spacing = spacing;
            if (this.debug) {
                console.log(this.entity.layoutgroup.spacing)
            }
        }
    }
}); 

// PickerRayCast.js
var PickerRaycast = pc.createScript('pickerRaycast');

pc.extend(PickerRaycast.prototype, {
    initialize: function() {

        pc.pickerFrameBuffer = this;
        // Create a frame buffer picker with a resolution of 1024x1024

        this._layer = this.app.scene.layers.getLayerByName(this.layerName);
        this._position = new pc.Vec2();

        this._inputBetweenGames = false;

        this._selectedEntity = null;

        this._isTileInput = false;
        this._mouseMovementSet = false;

        this.app.on('GameInput:' + inputEvents.DOWN, this._onDown, this);
        this.app.on('GameInput:' + inputEvents.MOVE, this._onMove, this);
        this.app.on('GameInput:' + inputEvents.UP, this._onUp, this);

        this.on('destroy', this._onDestroy, this);
    },

    _onDown: function(event) {        
        if (event instanceof pc.ElementMouseEvent) {
            this._onMouseDown(event);
        } else if (event instanceof pc.ElementTouchEvent) {
            this._onTouchStart(event);
        } else if (event instanceof TouchEvent) {
            this._onTouchStart(event);
        } else if (event instanceof MouseEvent) {
            this._onMouseDown(event);
        } else {
            console.warn("something went wrong", event);
        }
    },

    _onUp: function(event) {
        if (event instanceof pc.ElementMouseEvent) {
            this._onMouseUp(event);
        } else if (event instanceof pc.ElementTouchEvent) {
            this._onTouchEnd(event);
        } else if (event instanceof TouchEvent) {
            this._onTouchEnd(event);
        } else if (event instanceof MouseEvent) {
            this._onMouseUp(event);
        } else {
            console.warn("something went wrong", event);
        }
    },

    _onMove: function(event) {
        if (event instanceof pc.ElementMouseEvent) {
            this._onMouseMove(event);
        } else if (event instanceof pc.ElementTouchEvent) {
            this._onTouchMove(event);
        } else if (event instanceof TouchEvent) {
            this._onTouchMove(event);
        } else if (event instanceof MouseEvent) {
            this._onMouseMove(event);
        } else {
            console.warn("something went wrong", event);
        }
    },

    _onDestroy: function() {
        this.app.off('GameInput:' + inputEvents.DOWN, this._onDown, this);
        this.app.off('GameInput:' + inputEvents.MOVE, this._onMove, this);
        this.app.off('GameInput:' + inputEvents.UP, this._onUp, this);
    },

    _destroyMouseInput: function() {
        if(this._mouseMovementSet === true) {
            this._mouseMovementSet = false;
            this.app.mouse.off(pc.EVENT_MOUSEDOWN, this._onMouseDown, this);
            this.app.mouse.off(pc.EVENT_MOUSEMOVE, this._onMouseMove, this);
            this.app.mouse.off(pc.EVENT_MOUSEUP, this._onMouseUp, this);
        }
    },

    _onMouseDown: function(event) {
        this._position.set(event.x, event.y);

        this._selectedEntity = this._onSelect('start');

        this.checkTileInput();

        this.app.fire('PickerRaycast:onClick', this._selectedEntity);

        if (this._selectedEntity && this._selectedEntity) this._checkEntitySelect(this._selectedEntity);
    },

    _onMouseMove: function(event) {
        if (!this.app.mouse.isPressed(pc.MOUSEBUTTON_LEFT)) {
            return;
        }
        this._position.set(event.x, event.y);

        if (!this._isTileInput) return;
        
        this._selectedEntity = this._onSelect();

        if (this._selectedEntity) this._checkEntitySelect(this._selectedEntity);
    },

    _onMouseUp: function(event) {
        this._position.set(event.x, event.y);

        this._selectedEntity = this._onSelect();

        if (this._selectedEntity) this._checkEntitySelect(this.selectedEntity);
        this._isTileInput = false;

        this.app.fire('SwapMode:inputStopped', false);
    },

    _onTouchStart: function(event) {
        this._destroyMouseInput();
        var touch = event.touches[0];

        this._position.set(touch.x || touch.clientX, touch.y || touch.clientY);

        this._selectedEntity = this._onSelect('start');

        this.checkTileInput();

        if (this._selectedEntity && this._selectedEntity) this._checkEntitySelect(this._selectedEntity);
    },

    _onTouchMove: function(event) {
        var touch = event.touches[0];
        this._position.set(touch.x || touch.clientX, touch.y || touch.clientY);
        if (!this._isTileInput) return;
        this._selectedEntity = this._onSelect();
        if (this._selectedEntity && this._selectedEntity) this._checkEntitySelect(this._selectedEntity);
    },

    _onTouchEnd: function(event) {
        var selectedEntity = this._onSelect();

        if (this._selectedEntity && this._selectedEntity) this._checkEntitySelect(selectedEntity);
        this._isTileInput = false;

        this.app.fire('SwapMode:inputStopped', false);
    },

    _checkEntitySelect: function(entity) {
        if (entity && this._selectedEntity && this._inputBetweenGames) {
            if (entity === this._selectedEntity) {
                if (entity.script && entity.script.foregroundTile && entity.script.foregroundTile.swappable) {
                    GameManager.instance.onSelect(entity.script.foregroundTile);
                } else if (entity.script && entity.script.backgroundTile && entity.script.backgroundTile.backgroundSelectable) {
                    GameManager.instance.onSelect(entity.script.backgroundTile); 
                }
            }  
        }

        this._selectedEntity = null;

    },

    _onSelect: function () {
        var from = this.entity.camera.screenToWorld(this._position.x, this._position.y, this.entity.camera.nearClip);
        var to = this.entity.camera.screenToWorld(this._position.x, this._position.y, this.entity.camera.farClip);

        var ray = new pc.Ray(from, to.clone().sub(from).normalize());

        var result = GridManager.instance.intersectsRay(ray, this.entity.getPosition());

        if (result) {
            var pickedEntity = result.entity;
            return pickedEntity;
        }

        return null;
    },

    checkTileInput: function() {
        if (!!this._selectedEntity) {
            this._isTileInput = this._selectedEntity.tags.has('tile');
        } else {
            this._isTileInput = false;
        }
    },

    isTileInput: function() {
        return this._isTileInput;
    },

    setInputBetweenGamesEnabled: function(value) {
        this._inputBetweenGames = value;
    },
});


// BrandingButton.js
var BrandingButton = pc.createScript('brandingButton');

pc.extend(BrandingButton.prototype, {

    initialize: function() {
        var imageUrl = window.famobi.getBrandingButtonImage();

        var asset = new pc.Asset("famobi_branding_button", "texture", {
            url: imageUrl
        });

        this.app.assets.add(asset);

        LazyLoader.instance.lazyLoad(asset, this.onLoadedAsset, this);

        // mouse events
        this.entity.element.on('mouseup', this.onRelease, this);

        // touch events
        this.entity.element.on('touchend', this.onRelease, this);
    },

    onLoadedAsset: function(asset) {
        this.entity.element.enabled = true;
        
        this.entity.element.texture = asset.resource;
    },

    onRelease: function() {
        window.famobi.openBrandingLink();
    },
    
});

// TutorialBoosterToggle.js
var TutorialBoosterToggle = pc.createScript('tutorialBoosterToggle');

TutorialBoosterToggle.attributes.add('buttonsInOrderOfType', { type: 'entity', array: true });

pc.extend(TutorialBoosterToggle.prototype, {
    initialize: function () {
        this.app.on('TutorialManager:enableBooster', this.toggleOn, this);
        this.app.on('TutorialManager:enableBoosters', this.toggleAll, this);
        this.app.on('TutorialManager:disableBoosters', this.toggleOff, this);
    },

    toggleOff: function () {


        for (var i = 0; i < this.buttonsInOrderOfType.length; i++) {
            this.buttonsInOrderOfType[i].script.boosterButton.disableForTutorial();
        }

        //this.entity.enabled = false;
    },

    toggleOn: function (typeToActivate) {
        for (var i = 0; i < this.buttonsInOrderOfType.length; i++) {
            var active = i === typeToActivate;
            this.buttonsInOrderOfType[i].script.boosterButton.enableInput(active);
            this.buttonsInOrderOfType[i].script.boosterButton.enableTutorial(active);
            if (active) {
                this.buttonsInOrderOfType[i].script.boosterButton.setTutorial(true);
                TutorialManager.instance.setBoosterEntity(this.buttonsInOrderOfType[i]);
            } else {
                this.buttonsInOrderOfType[i].script.boosterButton.setTutorial(false);
            }
        }

        this.entity.enabled = true;
    },

    toggleAll: function () {
        for (var i = 0; i < this.buttonsInOrderOfType.length; i++) {
            if (this.buttonsInOrderOfType[i].script.boosterButton._active) {
                this.buttonsInOrderOfType[i].script.boosterButton.enableInput(true);
            }

            this.buttonsInOrderOfType[i].script.boosterButton.setTutorial(false);
            this.buttonsInOrderOfType[i].script.boosterButton.enableTutorial(false);
        }
    },

    setForcedModeProperties: function (hasSwap = true, hasShovel = true, hasBeehive = true) {
        if (!hasSwap) {
            this.buttonsInOrderOfType[0].script.boosterButton.disable();
        }

        if (!hasShovel) {
            this.buttonsInOrderOfType[1].script.boosterButton.disable();
        }

        if (!hasBeehive) {
            this.buttonsInOrderOfType[2].script.boosterButton.disable();
        }
    }
});

// Confetti.js
var Confetti = pc.createScript('confetti');

Confetti.attributes.add('confettiParticles', {type: 'entity', array: true});

pc.extend(Confetti.prototype, {
    initialize: function() {
        for(var i = 0; i < this.confettiParticles.length; i++) {
            var ps = this.confettiParticles[i].particlesystem;
            ps.reset();
        }
        
        //this.app.on('ConfirmLeaveGameButton:leave', this.stop, this);
        //this.app.on('SwapMode:onEndStart', this.play, this);
        //this.app.on('WinScreen:close', this.stop, this);  
    },
    
    play: function() {
        for(var i = 0; i < this.confettiParticles.length; i++) {
            var ps = this.confettiParticles[i].particlesystem;
            ps.reset();
            ps.play();
        }
    },
    
    pause: function() {
        for(var i = 0; i < this.confettiParticles.length; i++) {
            var ps = this.confettiParticles[i].particlesystem;
            ps.pause();
        }
    },
    
    stop: function() {
        for(var i = 0; i < this.confettiParticles.length; i++) {
            var ps = this.confettiParticles[i].particlesystem;
            ps.reset();
            ps.stop();
        }
    },
});

// MatchLogic.js
var MatchLogic = {};

Object.defineProperty(MatchLogic, 'columns', {
    get: function () {
        return this._columns;
    },
});

Object.defineProperty(MatchLogic, 'rows', {
    get: function () {
        return this._rows;
    },
});

pc.extend(MatchLogic, {
    initialize: function () {
        this.app = pc.Application.getApplication();

        // Layers
        this._foreground = null;
        this._background = null;
        this._exits = null;

        this._columns = 0;
        this._rows = 0;

        this.app = pc.Application.getApplication();
    },

    /* -------------------------------------
     * Set and remove grid
     *-------------------------------------- */

    setGridSize: function (columns, rows) {
        this._columns = columns;
        this._rows = rows;
    },

    setGrid: function (foreground, background, exits) {
        this._foreground = foreground;
        this._background = background;
        this._exits = exits;
    },

    removeGrid: function () {
        this._foreground = null;
        this._columns = 0;
        this._rows = 0;
    },


    /* -------------------------------------
     * Functions to get different matches
     *-------------------------------------- */

    getMatch: function (tile, minimalLength) {
        if (tile.typeID === foregroundTileEnum.DROPPER) {
            return [];
        }

        var x = tile.x;
        var y = tile.y;

        var backgroundArray = this._getLayerArray(tileLayerEnum.BACKGROUND);

        if (!backgroundArray[x][y].canForegroundMatch) {
            return [];
        }

        var arrayHorizontal = this._getMatchHorizontal(tile, tileLayerEnum.FOREGROUND);
        var arrayVertical = this._getMatchVertical(tile, tileLayerEnum.FOREGROUND);
        var array = [];

        var sinkerAmount = 0;

        if (arrayHorizontal.length >= minimalLength) {
            arrayHorizontal.forEach((_tile) => {
                _tile.setHitByMatch();
            });

            var sinkers = this.getSinkerMatches(arrayHorizontal);

            pc.utils.fuseUniqueArray(array, sinkers);
            sinkerAmount += array.length;

            pc.utils.fuseUniqueArray(array, arrayHorizontal);
        }

        if (arrayVertical.length >= minimalLength) {
            arrayVertical.forEach((_tile) => {
                _tile.setHitByMatch();
            });

            var sinkers = this.getSinkerMatches(arrayVertical);

            sinkerAmount -= array.length;

            pc.utils.fuseUniqueArray(array, sinkers);
            sinkerAmount += array.length;
            pc.utils.fuseUniqueArray(array, arrayVertical);
        }

        if (this.hasCoat(array)) {
            this.setCoat(array);
        }

        GridManager.instance.setTileDespawnDelay(array);

        this.app.fire('ScoreManager:onTileMatch', array.length - sinkerAmount, tile);

        // powerup logic
        array = this.getChainedPowerTileMatches(array);
        this._checkPowerTileChange(tile, arrayHorizontal, arrayVertical);
        return array;
    },

    getSinkerMatches: function (array) {
        var sinkers = [];
        for (var i = 0; i < array.length; i++) {
            var tile = array[i];

            var neighbours = this._getNeighbours(tile, 0, tileLayerEnum.FOREGROUND);

            for (var j = 0; j < neighbours.length; j++) {
                var neighbour = neighbours[j];

                if (neighbour.isSinker()) {
                    sinkers.push(neighbour);
                }
            }
        }

        return sinkers;
    },

    hasCoat(array) {
        for (var i = 0; i < array.length; i++) {
            if (array[i].hasCoat()) {
                return true;
            }
        }

        return false;
    },

    setCoat(array) {
        for (var i = 0; i < array.length; i++) {
            var x = array[i].x;
            var y = array[i].y;

            this._background[x][y].changeToCoat();
        }
    },

    getDropperMatches: function () {
        var droppers = [];

        var layerArray = this._getLayerArray(tileLayerEnum.FOREGROUND);

        for (var i = 0; i < this._exits.length; i++) {
            var exit = this._exits[i];

            var tile = layerArray[exit.x][exit.y];
            if (tile && (tile.typeID === foregroundTileEnum.DROPPER || tile.typeID === foregroundTileEnum.DROPPER_COLLECTION) && tile.isActive() && tile.isSwappable()) {
                droppers.push(tile);
            }
        }

        return droppers;
    },

    getCascadeMatches: function (minimalLength, ignore) {
        var movedTiles = this._getMovedTiles(tileLayerEnum.FOREGROUND);

        var allNewMatches = [];
        var matchTiles = [];

        var horizontalMatches = [];
        var verticalMatches = [];

        for (var h = 0; h < movedTiles.length; h += 1) {

            var horizontalMatch = this._getMatchHorizontal(movedTiles[h], tileLayerEnum.FOREGROUND);
            if (horizontalMatch.length >= minimalLength && (!pc.utils.isDuplicateIn2DArrayAndArray(horizontalMatches, horizontalMatch) || horizontalMatches.length === 0)) {
                horizontalMatches.push(horizontalMatch);

                horizontalMatch.forEach(tile => tile.setHitByMatch());

                pc.utils.fuseUniqueArray(matchTiles, horizontalMatch);

                // the tile on which the match will be made, in case of powerup: this one will be powerup
                while (true) {
                    var randomMatchTileH = Math.floor(Math.random() * horizontalMatch.length);

                    var tile = horizontalMatch[randomMatchTileH];

                    if (GridManager.instance.canExplode(tile.x, tile.y)) {
                        allNewMatches.push({ matchTile: tile, horizontalMatch: horizontalMatch, verticalMatch: [] });
                        break;
                    }
                }

            }
        }

        //prevents infinite loop
        var allNewMatchesCopy = pc.utils.duplicateArray(allNewMatches);

        for (var v = 0; v < movedTiles.length; v += 1) {
            var verticalMatch = this._getMatchVertical(movedTiles[v], tileLayerEnum.FOREGROUND);
            if (verticalMatch.length >= minimalLength && (!pc.utils.isDuplicateIn2DArrayAndArray(verticalMatches, verticalMatch) || verticalMatches.length === 0)) {
                verticalMatches.push(verticalMatch);
                verticalMatch.forEach(tile => tile.setHitByMatch());

                pc.utils.fuseUniqueArray(matchTiles, verticalMatch);

                // check if match with this tile already existed
                var doubleMatch = this._getDuplicateInCascadeMatches(allNewMatchesCopy, verticalMatch);
                if (doubleMatch !== null) {
                    // add macth to existing data
                    allNewMatches[doubleMatch.matchID].verticalMatch = verticalMatch;
                    // switch tile on which the match will be made so the powerup will appear on this tile
                    allNewMatches[doubleMatch.matchID].matchTile = allNewMatches[doubleMatch.matchID].horizontalMatch[doubleMatch.tileID];
                } else {
                    while (true) {
                        // add match as new match to array
                        var randomMatchTileV = Math.floor(Math.random() * verticalMatch.length);

                        var tile = verticalMatch[randomMatchTileV];

                        if (GridManager.instance.canExplode(tile.x, tile.y)) {
                            allNewMatches.push({ matchTile: tile, horizontalMatch: [], verticalMatch: verticalMatch });
                            break;
                        }
                    }

                }
            }
        }

        var sinkers = this.getSinkerMatches(matchTiles);

        pc.utils.fuseUniqueArray(matchTiles, sinkers);

        if (!ignore) {
            GridManager.instance.setTileDespawnDelay(matchTiles);

            for (var i = 0; i < allNewMatches.length; i += 1) {
                GridManager.instance.addScoreForEachTileInMatch(allNewMatches[i]);
            }
        }

        var droppers = this.getDropperMatches();

        for (var i = 0; i < droppers.length; i++) {
            matchTiles.push(droppers[i]);
        }

        return { tiles: matchTiles, matches: allNewMatches };
    },

    triggerPowerTiles: function (matchTiles, allNewMatches) {
        var newArray = [];

        for (var i = 0; i < allNewMatches.length; i++) {
            pc.utils.fuseUniqueArray(newArray, this._getChainedPowerTileMatches(matchTiles));
            this._checkPowerTileChange(allNewMatches[i].matchTile, allNewMatches[i].horizontalMatch, allNewMatches[i].verticalMatch);
        }

        if (newArray.length > 0) {
            pc.utils.fuseUniqueArray(newArray, this.triggerChainPowerTiles(newArray));
        }

        return newArray;
    },

    triggerChainPowerTiles: function (array) {

        var lengthBefore = array.length;

        pc.utils.fuseUniqueArray(array, this._getChainedPowerTileMatches(array));

        if (array.length > lengthBefore) {
            return this.triggerChainPowerTiles(array);
        }

        return array;
    },

    _getChainedPowerTileMatches: function (array) {
        var affectedTileArray = PowerTileManager.instance.checkForPoppers(array);

        for (var i = 0; i < array.length; i++) {
            powerMatchArray = PowerTileManager.instance.onTileMatch(array[i]);
            if (powerMatchArray.length > 0) {
                pc.utils.fuseArray(affectedTileArray, powerMatchArray);
            }
        }
        return affectedTileArray;
    },

    getChainedPowerTileMatches: function (array) {
        return this.getChainedPowerTileMatchesLoop(array);
    },

    /**
     * Add all tiles affected by powerup to array
     */
    _getPowerTileMatches: function (array, layer) {
        var affectedTileArray = PowerTileManager.instance.checkForPoppers(array);

        for (var i = 0; i < array.length; i++) {
            powerMatchArray = PowerTileManager.instance.onTileMatch(array[i]);
            if (powerMatchArray.length > 0) {
                pc.utils.fuseArray(affectedTileArray, powerMatchArray);
            }
        }
        pc.utils.fuseUniqueArray(array, affectedTileArray);
        return array;
    },

    getChainedPowerTileMatchesLoop: function (array) {
        var arrayLengthBefore, arrayLengthAfter;
        do {
            arrayLengthBefore = array.length;
            array = this._getPowerTileMatches(array);
            arrayLengthAfter = array.length;
        } while (arrayLengthBefore !== arrayLengthAfter);

        return array;
    },


    _getDuplicateInCascadeMatches: function (allMatches, verticalMatch) {
        for (var x = 0; x < allMatches.length; x++) {
            var horizontalMatch = allMatches[x].horizontalMatch;
            for (var y = 0; y < horizontalMatch.length; y++) {
                if (verticalMatch.indexOf(horizontalMatch[y]) !== -1) {
                    return { matchID: x, tileID: y };
                }
            }
        }
        return null;
    },

    getAllPossibleMatches: function () {
        var layerArray = this._getLayerArray(tileLayerEnum.FOREGROUND);

        var array = [];

        // Go through the whole tileArray
        for (var x = 0; x < this._columns; x++) {
            for (var y = 0; y < this._rows; y++) {

                if (!layerArray[x][y]) {
                    continue;
                }

                // For each tile search for possible matches
                var newMatches = this.getPossibleMatches(layerArray[x][y]);

                // For each new matches, check if no identical matches are found.
                for (var j = 0; j < newMatches.length; j++) {
                    var sameMatch = false;

                    for (var k = 0; k < array.length; k++) {
                        sameMatch = this.isSameMatch(array[k], newMatches[j]);

                        if (sameMatch) {
                            // Don't add it if a same match is found.
                            break;
                        }
                    }

                    if (!sameMatch) {
                        array.push(newMatches[j]);
                    }
                }
            }
        }

        // Also debug purposes
        //         for (var i = 0; i < array.length; i++) {
        //             if (array[i].matchTiles.hasDuplicate()) {
        //                 console.warn("something went wrong", array[i].matchTiles.map(function(tileScript) {
        //                     return {x : tileScript.x, y: tileScript.y, type: tileScript.id }; 
        //                 }), array[i].switchTiles.map(function(tileScript) {
        //                     return {x : tileScript.x, y: tileScript.y, type: tileScript.id }; 
        //                 }));

        //             }
        //         }

        // For debugging purposes.
        // console.log(array.map(function(object) {
        //     return object.matchTiles.map(function(tileScript) {
        //         return {x : tileScript.x, y: tileScript.y, type: tileScript.typeID }; 
        //     });
        // }));

        return array;
    },

    getPossibleMatches: function (tile) {
        var possibleMatches = [];

        var backgroundArray = this._getLayerArray(tileLayerEnum.BACKGROUND);
        if (!backgroundArray[tile.x][tile.y].canForegroundMatch) {
            return possibleMatches;
        }

        var length = 3;
        var colorID = tile.colorID;

        if (!colorID) {
            return possibleMatches;
        }

        // Get all directions arrays with a lenght of 3.
        var leftArray = this._getNeighboursLeft(tile, length, tileLayerEnum.FOREGROUND);
        var rightArray = this._getNeighboursRight(tile, length, tileLayerEnum.FOREGROUND);
        var upArray = this._getNeighboursUp(tile, length, tileLayerEnum.FOREGROUND);
        var downArray = this._getNeighboursDown(tile, length, tileLayerEnum.FOREGROUND);

        var differentIdTile = null;
        var left = null;
        var right = null;
        var up = null;
        var down = null;
        var index = -1;

        if (leftArray.length === 3 && this.sumOfIdEqualToTwo(leftArray, colorID)) {
            index = this.getTileIndexNotEqualId(leftArray, colorID);

            if (index !== -1) {
                differentIdTile = leftArray[index];
                if (differentIdTile.isSwappable()) {
                    left = index === 0 ? this._getNeighboursLeft(differentIdTile, 2, tileLayerEnum.FOREGROUND)[0] : null;
                    right = index === length - 1 ? this._getNeighboursRight(differentIdTile, 2, tileLayerEnum.FOREGROUND)[1] : null;
                    up = this._getNeighboursUp(differentIdTile, 2, tileLayerEnum.FOREGROUND)[0];
                    down = this._getNeighboursDown(differentIdTile, 2, tileLayerEnum.FOREGROUND)[1];
                    if (leftArray.indexOf(up) !== -1) {
                        console.warn("something went wrong, leftArray", up, leftArray);
                    }

                    if (leftArray.indexOf(down) !== -1) {
                        console.warn("something went wrong, leftArray", down, leftArray);
                    }

                    // match
                    if (left && left.colorID === colorID && this._columns >= length && left.isSwappable()) {
                        var matchTiles = this._increaseMatchHorizontal(leftArray, colorID, left, tileLayerEnum.FOREGROUND);
                        matchTiles.push(left);
                        var switchTiles = [differentIdTile, left];
                        possibleMatches.push({ matchTiles: matchTiles, switchTiles: switchTiles });
                    }

                    if (right && right.colorID === colorID && this._columns >= length + 1 && right.isSwappable()) {
                        var matchTiles = this._increaseMatchHorizontal(leftArray, colorID, right, tileLayerEnum.FOREGROUND);
                        matchTiles.push(right);
                        var switchTiles = [differentIdTile, right];
                        possibleMatches.push({ matchTiles: matchTiles, switchTiles: switchTiles });
                    }

                    if (up && up.colorID === colorID && up.isSwappable()) {
                        var matchTiles = this._increaseMatchHorizontal(leftArray, colorID, up, tileLayerEnum.FOREGROUND);
                        matchTiles.push(up);
                        var switchTiles = [differentIdTile, up];
                        possibleMatches.push({ matchTiles: matchTiles, switchTiles: switchTiles });
                    }

                    if (down && down.colorID === colorID && down.isSwappable()) {
                        var matchTiles = this._increaseMatchHorizontal(leftArray, colorID, down, tileLayerEnum.FOREGROUND);
                        matchTiles.push(down);
                        var switchTiles = [differentIdTile, down];
                        possibleMatches.push({ matchTiles: matchTiles, switchTiles: switchTiles });
                    }
                }
            }
        }

        // right
        if (rightArray.length === 3 && this.sumOfIdEqualToTwo(rightArray, colorID)) {
            index = this.getTileIndexNotEqualId(rightArray, colorID);

            if (index !== -1) {
                differentIdTile = rightArray[index];
                if (differentIdTile.isSwappable()) {
                    left = index === 0 ? this._getNeighboursLeft(differentIdTile, 2, tileLayerEnum.FOREGROUND)[0] : null;
                    right = index === length - 1 ? this._getNeighboursRight(differentIdTile, 2, tileLayerEnum.FOREGROUND)[1] : null;
                    up = this._getNeighboursUp(differentIdTile, 2, tileLayerEnum.FOREGROUND)[0];
                    down = this._getNeighboursDown(differentIdTile, 2, tileLayerEnum.FOREGROUND)[1];

                    if (rightArray.indexOf(up) !== -1) {
                        console.warn("something went wrong, rightArray", up, rightArray);
                    }

                    if (rightArray.indexOf(down) !== -1) {
                        console.warn("something went wrong, rightArray", down, rightArray);
                    }

                    // match
                    if (left && left.colorID === colorID && this._columns >= length && left.isSwappable()) {
                        var matchTiles = this._increaseMatchHorizontal(rightArray, colorID, left, tileLayerEnum.FOREGROUND);
                        matchTiles.push(left);
                        var switchTiles = [differentIdTile, left];
                        possibleMatches.push({ matchTiles: matchTiles, switchTiles: switchTiles });
                    }

                    if (right && right.colorID === colorID && this._columns >= length + 1 && right.isSwappable()) {
                        var matchTiles = this._increaseMatchHorizontal(rightArray, colorID, right, tileLayerEnum.FOREGROUND);
                        matchTiles.push(right);
                        var switchTiles = [differentIdTile, right];
                        possibleMatches.push({ matchTiles: matchTiles, switchTiles: switchTiles });
                    }

                    if (up && up.colorID === colorID && up.isSwappable()) {
                        var matchTiles = this._increaseMatchHorizontal(rightArray, colorID, up, tileLayerEnum.FOREGROUND);
                        matchTiles.push(up);
                        var switchTiles = [differentIdTile, up];
                        possibleMatches.push({ matchTiles: matchTiles, switchTiles: switchTiles });
                    }

                    if (down && down.colorID === colorID && down.isSwappable()) {
                        var matchTiles = this._increaseMatchHorizontal(rightArray, colorID, down, tileLayerEnum.FOREGROUND);
                        matchTiles.push(down);
                        var switchTiles = [differentIdTile, down];
                        possibleMatches.push({ matchTiles: matchTiles, switchTiles: switchTiles });
                    }
                }
            }
        }

        // up
        if (upArray.length === 3 && this.sumOfIdEqualToTwo(upArray, colorID)) {
            index = this.getTileIndexNotEqualId(upArray, colorID);

            if (index !== -1) {
                differentIdTile = upArray[index];

                if (differentIdTile.isSwappable()) {
                    up = index === 0 ? this._getNeighboursUp(differentIdTile, 2, tileLayerEnum.FOREGROUND)[0] : null;
                    down = index === length - 1 ? this._getNeighboursDown(differentIdTile, 2, tileLayerEnum.FOREGROUND)[1] : null;

                    left = this._getNeighboursLeft(differentIdTile, 2, tileLayerEnum.FOREGROUND)[0];
                    right = this._getNeighboursRight(differentIdTile, 2, tileLayerEnum.FOREGROUND)[1];

                    if (upArray.indexOf(up) !== -1) {
                        console.warn("something went wrong", up, upArray);
                    }

                    if (upArray.indexOf(down) !== -1) {
                        console.warn("something went wrong", down, upArray);
                    }

                    // match
                    if (left && left.colorID === colorID && this._columns >= length && left.isSwappable()) {
                        var matchTiles = this._increaseMatchVertical(upArray, colorID, left, tileLayerEnum.FOREGROUND);
                        matchTiles.push(left);
                        var switchTiles = [differentIdTile, left];
                        possibleMatches.push({ matchTiles: matchTiles, switchTiles: switchTiles });
                    }

                    if (right && right.colorID === colorID && this._columns >= length + 1 && right.isSwappable()) {
                        var matchTiles = this._increaseMatchVertical(upArray, colorID, right, tileLayerEnum.FOREGROUND);
                        matchTiles.push(right);
                        var switchTiles = [differentIdTile, right];
                        possibleMatches.push({ matchTiles: matchTiles, switchTiles: switchTiles });
                    }

                    if (up && up.colorID === colorID && up.isSwappable()) {
                        var matchTiles = this._increaseMatchVertical(upArray, colorID, up, tileLayerEnum.FOREGROUND);
                        matchTiles.push(up);
                        var switchTiles = [differentIdTile, up];
                        possibleMatches.push({ matchTiles: matchTiles, switchTiles: switchTiles });
                    }

                    if (down && down.colorID === colorID && down.isSwappable()) {
                        var matchTiles = this._increaseMatchVertical(upArray, colorID, down, tileLayerEnum.FOREGROUND);
                        matchTiles.push(down);
                        var switchTiles = [differentIdTile, down];
                        possibleMatches.push({ matchTiles: matchTiles, switchTiles: switchTiles });
                    }
                }
            }
        }

        // down
        if (downArray.length === 3 && this.sumOfIdEqualToTwo(downArray, colorID)) {
            index = this.getTileIndexNotEqualId(downArray, colorID);
            if (index !== -1) {
                differentIdTile = downArray[index];
                if (differentIdTile.isSwappable()) {

                    up = index === 0 ? this._getNeighboursUp(differentIdTile, 2, tileLayerEnum.FOREGROUND)[0] : null;
                    down = index === length - 1 ? this._getNeighboursDown(differentIdTile, 2, tileLayerEnum.FOREGROUND)[1] : null;
                    left = this._getNeighboursLeft(differentIdTile, 2, tileLayerEnum.FOREGROUND)[0];
                    right = this._getNeighboursRight(differentIdTile, 2, tileLayerEnum.FOREGROUND)[1];


                    if (downArray.indexOf(up) !== -1) {
                        console.warn("something went wrong, down", up, downArray);
                    }

                    if (downArray.indexOf(down) !== -1) {
                        console.warn("something went wrong, down", down, downArray);
                    }
                    // match
                    if (left && left.colorID === colorID && this._columns >= length && left.isSwappable()) {
                        var matchTiles = this._increaseMatchVertical(downArray, colorID, left, tileLayerEnum.FOREGROUND);
                        matchTiles.push(left);
                        var switchTiles = [differentIdTile, left];
                        possibleMatches.push({ matchTiles: matchTiles, switchTiles: switchTiles });
                    }

                    if (right && right.colorID === colorID && this._columns >= length + 1 && right.isSwappable()) {
                        var matchTiles = this._increaseMatchVertical(downArray, colorID, right, tileLayerEnum.FOREGROUND);
                        matchTiles.push(right);
                        var switchTiles = [differentIdTile, right];
                        possibleMatches.push({ matchTiles: matchTiles, switchTiles: switchTiles });
                    }

                    if (up && up.colorID === colorID && up.isSwappable()) {
                        var matchTiles = this._increaseMatchVertical(downArray, colorID, up, tileLayerEnum.FOREGROUND);
                        matchTiles.push(up);
                        var switchTiles = [differentIdTile, up];
                        possibleMatches.push({ matchTiles: matchTiles, switchTiles: switchTiles });
                    }

                    if (down && down.colorID === colorID && down.isSwappable()) {
                        var matchTiles = this._increaseMatchVertical(downArray, colorID, down, tileLayerEnum.FOREGROUND);
                        matchTiles.push(down);
                        var switchTiles = [differentIdTile, down];
                        possibleMatches.push({ matchTiles: matchTiles, switchTiles: switchTiles });
                    }
                }
            }
        }

        // Power tiles
        if (tile.isPowerTile() && tile.isSwappable()) {
            var neighbours = null;
            if (tile.isColorPowerTile()) {
                neighbours = this._getNeighbours(tile, null, tileLayerEnum.FOREGROUND);

                for (var i = 0; i < neighbours.length; i++) {
                    var neighbour = neighbours[i];

                    if (neighbour.isSwappable()) {
                        possibleMatches.push({ matchTiles: [tile, neighbours[i]], switchTiles: [tile, neighbours[i]] });
                    }
                }

            } else {
                neighbours = this._getNeighbours(tile, null, tileLayerEnum.FOREGROUND);

                for (var j = 0; j < neighbours.length; j++) {
                    var neighbour = neighbours[j];

                    if (neighbour.isPowerTile() && !neighbour.isColorPowerTile() && neighbour.isSwappable()) {
                        possibleMatches.push({ matchTiles: [tile, neighbour], switchTiles: [tile, neighbour] });
                    }
                }
            }
        }

        return possibleMatches;
    },

    isSameMatch: function (match1, match2) {
        // If the length is not the same, it's not the same match.
        if (match1.matchTiles.length !== match2.matchTiles.length) {
            return false;
        }

        // Check if a matchTiles is duplicate.
        for (var i = 0; i < match1.matchTiles.length; i++) {
            var sameTile = false;

            for (var j = 0; j < match2.matchTiles.length; j++) {
                var match1Tile = match1.matchTiles[i];
                var match2Tile = match2.matchTiles[j];

                if (match1Tile.x === match2Tile.x && match1Tile.y === match2Tile.y) {
                    sameTile = true;
                    break;
                }
            }

            if (!sameTile) {
                return false;
            }
        }

        // TODO there might be a chance that the switchTiles needs to be checked too.

        return true;
    },





    /* -------------------------------------
     * Algoritmes to get other tiles
     *-------------------------------------- */

    /**
     * Get all matches in the horizontal direction with the selected tile and return an array.
     * The array includes the selected tile.
     */
    _getMatchHorizontal: function (tile, layer) {
        var layerArray = this._getLayerArray(layer);
        var backgroundArray = this._getLayerArray(tileLayerEnum.BACKGROUND);

        var array = [tile];

        var colorID = tile.colorID;

        if (tile.colorID === tileColorEnum.NONE) {
            return array;
        }

        var x = tile.x;
        var y = tile.y;

        var _tile = null;

        do {
            if (!this._isXInRange(--x)) {
                break;
            }

            _tile = layerArray[x][y];

            if (_tile && _tile.colorID === colorID && _tile.isActive() && backgroundArray[x][y].canForegroundMatch) {
                array.push(_tile);
            } else {
                break;
            }

        } while (true);

        x = tile.x;

        do {
            if (!this._isXInRange(++x)) {
                break;
            }

            _tile = layerArray[x][y];


            if (_tile && _tile.colorID === colorID && _tile.isActive() && backgroundArray[x][y].canForegroundMatch) {
                array.push(_tile);
            } else {
                break;
            }

        } while (true);

        return array;
    },

    /**
     * Get all matches in the vertical direction with the selected tile and return an array.
     * The array includes the selected tile.
     */
    _getMatchVertical: function (tile, layer) {
        var layerArray = this._getLayerArray(layer);
        var backgroundArray = this._getLayerArray(tileLayerEnum.BACKGROUND);

        var array = [tile];

        var colorID = tile.colorID;

        if (tile.colorID === tileColorEnum.NONE) {
            return array;
        }

        var x = tile.x;
        var y = tile.y;

        var _tile = null;

        // Check down
        do {
            if (!this._isYInRange(--y)) {
                break;
            }

            _tile = layerArray[x][y];

            if (_tile && _tile.colorID === colorID && _tile.isActive() && backgroundArray[x][y].canForegroundMatch) {
                array.push(_tile);
            } else {
                break;
            }

        } while (true);

        y = tile.y;

        // Check up
        do {
            if (!this._isYInRange(++y)) {
                break;
            }

            _tile = layerArray[x][y];


            if (_tile && _tile.colorID === colorID && _tile.isActive() && backgroundArray[x][y].canForegroundMatch) {
                array.push(_tile);
            } else {
                break;
            }

        } while (true);

        return array;
    },

    /**
     * Check if powerups should spawn based on horizontal and vertical match lengths, if so dont despawn tile but change to powerup
     */
    _checkPowerTileChange: function (tile, arrayHorizontal, arrayVertical) {
        var typeID = PowerTileManager.instance.checkPowerTileSpawn(arrayHorizontal.length, arrayVertical.length);
        if (PowerTileManager.instance.isPowerTile(typeID)) {
            if (tile.isFlower()) {
                GridManager.instance.powerTileArray.push({ x: tile.x, y: tile.y, colorID: tile.colorID, typeID: typeID });
                GridManager.instance.setTileConvergencePoint(tile.x, tile.y, arrayHorizontal, arrayVertical);
                StatisticsManager.instance.incrementStatistic('special_created', { special: TileLibrary.instance.getPowerTileName(typeID), color: TileLibrary.instance.getColorName(tile.colorID) });

            } else {
                var array = [];

                pc.utils.fuseUniqueArray(array, arrayHorizontal);
                pc.utils.fuseUniqueArray(array, arrayVertical);

                for (var i = array.length - 1; i >= 0; i--) {
                    if (!array[i].isFlower()) {
                        array.splice(i, 1);
                    }
                }

                if (array.length > 0) {
                    pc.utils.shuffleArray(array);

                    var tile = array[0];
                    StatisticsManager.instance.incrementStatistic('special_created', { special: TileLibrary.instance.getPowerTileName(typeID), color: TileLibrary.instance.getColorName(tile.colorID) });

                    GridManager.instance.powerTileArray.push({ x: tile.x, y: tile.y, colorID: tile.colorID, typeID: typeID });
                    GridManager.instance.setTileConvergencePoint(tile.x, tile.y, arrayHorizontal, arrayVertical);
                }
            }
        }
    },

    /**
     * Find all possible matches in a horizontal matches including new matches in the vertical direction.
     */
    _increaseMatchHorizontal: function (array, colorID, switchTile, layer) {
        var layerArray = this._getLayerArray(layer);
        var backgroundArray = this._getLayerArray(tileLayerEnum.BACKGROUND);

        var step = -1;
        var x = -1;
        var y = -1;

        // Remove the tile script, which has a different colorID. But keep the reference.
        var idNotEqualindex = this.getTileIndexNotEqualId(array, colorID);
        var notEqualTile = array[idNotEqualindex];

        // Check if other new match is made in the vertical range
        var vertical = [];

        x = notEqualTile.x;
        y = notEqualTile.y;

        while (true) {
            if (!this._isYInRange(--y)) {
                break;
            }

            var down = layerArray[x][y];

            if (down && down.colorID === colorID && backgroundArray[x][y].canForegroundMatch) {
                if (down !== switchTile) {
                    // expand
                    vertical.push(down);
                } else {
                    break;
                }

            } else {
                break;
            }
        }

        x = notEqualTile.x;
        y = notEqualTile.y;

        while (true) {
            if (!this._isYInRange(++y)) {
                break;
            }

            var up = layerArray[x][y];

            if (up && up.colorID === colorID && backgroundArray[x][y].canForegroundMatch) {
                if (up !== switchTile) {
                    // expand
                    vertical.push(up);
                } else {
                    break;
                }
            } else {
                break;
            }
        }

        var newArray = array.filter(function (tile) {
            return tile.colorID === colorID;
        });

        // Prevents going all the way around.
        // Check left 
        step = 0;

        x = newArray[0].x;
        y = newArray[0].y;

        while (step < this._columns) {
            step++;

            if (!this._isXInRange(--x)) {
                break;
            }

            var left = layerArray[x][y];

            if (left === notEqualTile) {
                // Continue
            } else if (left && left.colorID === colorID && backgroundArray[x][y].canForegroundMatch) {
                if (newArray.indexOf(left) === -1 && switchTile !== left) {
                    // Expand
                    newArray.unshift(left);
                } else {
                    // duplicate
                    break;
                }
            } else {
                break;
            }
        }

        // Check right
        step = 0;

        x = newArray[newArray.length - 1].x;
        y = newArray[newArray.length - 1].y;

        while (step < this._columns) {
            step++;

            if (!this._isXInRange(++x)) {
                break;
            }

            var right = layerArray[x][y];

            if (right === notEqualTile) {
                // Continue
            } else if (right && right.colorID === colorID && backgroundArray[x][y].canForegroundMatch) {
                if (newArray.indexOf(right) === -1 && switchTile !== right) {
                    // expand
                    newArray.push(right);
                } else {
                    // duplicate
                    break;
                }
            } else {
                break;
            }
        }


        // Add vertical if length is greater than 2
        if (vertical.length >= 2) {
            for (var i = 0; i < vertical.length; i++) {
                newArray.push(vertical[i]);
            }
        }

        if (newArray.hasDuplicate()) {
            console.error("has duplicate post horizontal");
        }

        return newArray;
    },

    /**
     * Find all possible matches in a vertical matches including new matches in the horizontal direction.
     */
    _increaseMatchVertical: function (array, colorID, switchTile, layer) {
        var layerArray = this._getLayerArray(layer);
        var backgroundArray = this._getLayerArray(tileLayerEnum.BACKGROUND);

        var step = -1;
        var x = -1;
        var y = -1;

        // Remove the tile script, which has a different colorID. But keep the reference.
        var idNotEqualindex = this.getTileIndexNotEqualId(array, colorID);
        var notEqualTile = array[idNotEqualindex];

        // Check if other new match is made in the vertical range
        var horizontal = [];

        x = notEqualTile.x;
        y = notEqualTile.y;

        while (true) {
            if (!this._isXInRange(--x)) {
                break;
            }

            var left = layerArray[x][y];

            if (left && left.colorID === colorID && backgroundArray[x][y].canForegroundMatch) {
                if (horizontal.indexOf(left) === -1 && left !== switchTile) {
                    // expand
                    horizontal.push(left);
                } else {
                    // duplicate
                    break;
                }
            } else {
                break;
            }

        }

        x = notEqualTile.x;
        y = notEqualTile.y;

        while (true) {
            if (!this._isXInRange(++x)) {
                break;
            }

            var right = layerArray[x][y];

            if (right && right.colorID === colorID && backgroundArray[x][y].canForegroundMatch) {
                if (horizontal.indexOf(right) === -1 && right !== switchTile) {
                    // expand
                    horizontal.push(right);
                } else {
                    // duplicate
                    break;
                }
            } else {
                break;
            }
        }


        var newArray = array.filter(function (tile) {
            return tile.colorID === colorID;
        });

        // Check up 
        step = 0;

        x = newArray[0].x;
        y = newArray[0].y;

        while (step < this._rows) {
            step++;

            if (!this._isYInRange(++y)) {
                break;
            }

            var up = layerArray[x][y];

            if (newArray.indexOf(up) !== -1) {
                console.warn("Something went wrong", up);
            }

            if (up === notEqualTile) {
                // Continue
            } else if (up && up.colorID === colorID && switchTile !== up && backgroundArray[x][y].canForegroundMatch) {
                newArray.unshift(up);
            } else {
                break;
            }
        }

        // Check down
        step = 0;

        x = newArray[newArray.length - 1].x;
        y = newArray[newArray.length - 1].y;

        while (step < this._rows) {
            step++;

            if (!this._isYInRange(--y)) {
                break;
            }

            var down = layerArray[x][y];

            if (newArray.indexOf(down) !== -1) {
                console.warn("Something went wrong", down);
            }

            if (down === notEqualTile) {
                // Continue
            } else if (down && down.colorID === colorID && switchTile !== down && backgroundArray[x][y].canForegroundMatch) {
                newArray.push(down);
            } else {
                break;
            }
        }

        // Add horizontal if length is greater than 2
        if (horizontal.length >= 2) {
            for (var i = 0; i < horizontal.length; i++) {
                newArray.push(horizontal[i]);
            }
        }

        if (newArray.hasDuplicate()) {
            console.error("has duplicate post Vertical");
        }

        return newArray;
    },

    /**
     * Get all neighbours left of the selected tile.
     * Does not include itself.
     */
    _getNeighboursLeft: function (tile, distance, layer, swappable) {
        var layerArray = this._getLayerArray(layer);
        var backgroundArray = this._getLayerArray(tileLayerEnum.BACKGROUND);

        var array = [];

        if (!tile) {
            console.warn("something went wrong");
            return [];
        }

        var x = tile.x;
        var y = tile.y;

        for (var i = distance - 1; i >= 0; i--) {
            var leftX = x - i;

            if (!this._isXInRange(leftX)) {
                break;
            }

            var _tile = layerArray[leftX][y];

            if (!_tile) {
                break;
            }

            if (!backgroundArray[leftX][y].canForegroundMatch) {
                return [];
            }

            if (swappable && !this._background[leftX][y].foregroundSwappable) {
                break;
            }

            array.push(_tile);
        }

        return array;
    },

    /**
     * Get all neighbours right of the selected tile.
     * Does not include itself.
     */
    _getNeighboursRight: function (tile, distance, layer, swappable) {
        var layerArray = this._getLayerArray(layer);
        var backgroundArray = this._getLayerArray(tileLayerEnum.BACKGROUND);

        var array = [];

        var x = tile.x;
        var y = tile.y;

        for (var i = 0; i < distance; i++) {
            var rightX = x + i;

            if (!this._isXInRange(rightX)) {
                break;
            }

            var _tile = layerArray[rightX][y];

            if (!_tile) {
                break;
            }

            if (!backgroundArray[rightX][y].canForegroundMatch) {
                break;
            }

            if (swappable && !this._background[rightX][y].foregroundSwappable) {
                break;
            }

            array.push(_tile);
        }

        return array;
    },

    /**
     * Get all neighbours up of the selected tile.
     * Does not include itself.
     */
    _getNeighboursUp: function (tile, distance, layer, swappable) {
        var layerArray = this._getLayerArray(layer);
        var backgroundArray = this._getLayerArray(tileLayerEnum.BACKGROUND);

        var array = [];

        var x = tile.x;
        var y = tile.y;

        for (var i = distance - 1; i >= 0; i--) {
            var upY = y + i;

            if (!this._isYInRange(upY)) {
                break;
            }

            var _tile = layerArray[x][upY];

            if (!_tile) {
                break;
            }

            if (!backgroundArray[x][upY].canForegroundMatch) {
                return [];
            }

            if (swappable && !this._background[x][upY].foregroundSwappable) {
                break;
            }

            array.push(_tile);
        }

        return array;
    },


    /**
     * Get all neighbours down of the selected tile.
     * Does not include itself.
     */
    _getNeighboursDown: function (tile, distance, layer, swappable) {
        var layerArray = this._getLayerArray(layer);
        var backgroundArray = this._getLayerArray(tileLayerEnum.BACKGROUND);

        var array = [];

        var x = tile.x;
        var y = tile.y;

        for (var i = 0; i < distance; i++) {
            var downY = y - i;

            if (!this._isYInRange(downY)) {
                break;
            }

            var _tile = layerArray[x][downY]

            if (!_tile) {
                break;
            }

            if (!backgroundArray[x][downY].canForegroundMatch) {
                break;
            }

            if (swappable && !this._background[x][downY].foregroundSwappable) {
                break;
            }

            array.push(_tile);
        }

        return array;
    },

    getNeighbours: function (tile, colorID, layer, getEmptySpaces) {
        return this._getNeighbours(tile, colorID, layer, getEmptySpaces);
    },


    /**
     * Get all adjacent neighbours
     * Does not include itself.
     */
    _getNeighbours: function (tile, colorID, layer, getEmptySpaces) {
        var layerArray = this._getLayerArray(layer);

        var array = [];

        var x = tile.x;
        var y = tile.y;

        var leftX = x - 1;
        var rightX = x + 1;
        var upY = y + 1;
        var downY = y - 1;

        if (this._isXInRange(leftX)) {
            if ((colorID && colorID === layerArray[leftX][y].colorID) || !colorID) {
                if (layerArray[leftX][y]) {
                    array.push(layerArray[leftX][y]);
                } else if (getEmptySpaces) {
                    array.push({ x: leftX, y: y });
                }
            }
        }

        if (this._isXInRange(rightX)) {
            if ((colorID && colorID === layerArray[rightX][y].colorID) || !colorID) {
                if (layerArray[rightX][y]) {
                    array.push(layerArray[rightX][y]);
                } else if (getEmptySpaces) {
                    array.push({ x: rightX, y: y });
                }
            }
        }

        if (this._isYInRange(upY)) {
            if ((colorID && colorID === layerArray[x][upY].colorID) || !colorID) {
                if (layerArray[x][upY]) {
                    array.push(layerArray[x][upY]);
                } else if (getEmptySpaces) {
                    array.push({ x: x, y: upY });
                }
            }
        }

        if (this._isYInRange(downY)) {
            if ((colorID && colorID === layerArray[x][downY].colorID) || !colorID) {
                if (layerArray[x][downY]) {
                    array.push(layerArray[x][downY]);
                } else if (getEmptySpaces) {
                    array.push({ x: x, y: downY });
                }
            }
        }

        return array;
    },

    /* -------------------------------------
     * Other small useful unctions 
     *-------------------------------------- */

    /**
     * Check if tiles neighbours of each other
     */
    areNeighbours: function (tile1, tile2) {
        var deltaX = Math.abs(tile1.x - tile2.x);
        var deltaY = Math.abs(tile1.y - tile2.y);

        // Next to each other
        if (deltaX === 1 && deltaY === 0) {
            return true;
        }

        // Above each other
        if (deltaX === 0 && deltaY === 1) {
            return true;
        }

        return false;
    },

    _getLayerArray: function (layer) {
        if (typeof layer !== 'number') {
            console.warn("No layer is selected: ", layer, '. Set to foreground');

            return this._foreground;
        }

        // TODO add new layers here
        switch (layer) {
            case tileLayerEnum.FOREGROUND:
                return this._foreground;

            case tileLayerEnum.BACKGROUND:
                return this._background;

            default:
                console.error("Cannot find this layer", layer, 'Here are the available layers:', MatchLogic.Layers);
                break;
        }

        return null;
    },

    //     _getTrueX: function(x) {
    //         if (x < 0) {
    //             x += this._columns;
    //         }

    //         if (x >= this._columns) {
    //             x -= this._columns;
    //         }

    //         return x;
    //     },

    _isXInRange: function (x) {
        if (x < 0) {
            return false;
        }

        if (x >= this._columns) {
            return false;
        }

        return true;
    },

    _isYInRange: function (y) {
        if (y < 0) {
            return false;
        }

        if (y >= this._rows) {
            return false;
        }

        return true;
    },

    sumOfIdEqualToTwo: function (array, colorID) {
        return 2 === array.reduce(function (accumulator, tile) {
            return tile && tile.colorID === colorID ? accumulator + 1 : accumulator;
        }, 0);
    },

    getTileIndexNotEqualId: function (array, colorID) {
        return array.findIndex(function (tile) {
            return tile instanceof ForegroundTile && tile.colorID !== colorID;
        });
    },

    _getMovedTiles: function (layer) {
        var layerArray = this._getLayerArray(layer);

        var movedTiles = [];

        for (var x = 0; x < layerArray.length; x++) {
            for (var y = 0; y < layerArray[x].length; y++) {
                if (layerArray[x][y] && layerArray[x][y].isMovedTile) {
                    movedTiles.push(layerArray[x][y]);
                    layerArray[x][y].isMovedTile = false;
                }
            }
        }

        return movedTiles;
    },

    getAmountOfNeighbours: function (tile, swappable) {
        var left = this._getNeighboursLeft(tile, 2, tileLayerEnum.FOREGROUND, swappable);
        var right = this._getNeighboursRight(tile, 2, tileLayerEnum.FOREGROUND, swappable);
        var up = this._getNeighboursUp(tile, 2, tileLayerEnum.FOREGROUND, swappable);
        var down = this._getNeighboursDown(tile, 2, tileLayerEnum.FOREGROUND, swappable);

        var leftLength = pc.math.clamp(left.length - 1, 0, Number.POSITIVE_INFINITY);
        var rightLength = pc.math.clamp(right.length - 1, 0, Number.POSITIVE_INFINITY);
        var upLength = pc.math.clamp(up.length - 1, 0, Number.POSITIVE_INFINITY);
        var downLength = pc.math.clamp(down.length - 1, 0, Number.POSITIVE_INFINITY);

        return leftLength + rightLength + upLength + downLength;
    },
});


MatchLogic.initialize();

// This method is used for debugging.
pc.extend(Array.prototype, {
    hasDuplicate: function () {
        for (var i = 0; i < this.length; i++) {
            for (var j = 0; j < this.length; j++) {
                if (i === j) {
                    continue;
                }

                if (this[i] === this[j]) {
                    return true;
                }
            }
        }

        return false;
    },
});

// Application.js
var Application = {};

pc.extend(Application, {
    app: null,
    currentScene: 'Init',
    dontDestroyOnLoad: null,
    loadLevelAsync: function(sceneName, callback, context) {  
        if (!this.app) {
            this.app = pc.Application.getApplication();
        }
        
        var sceneItem = this.app.scenes.find(sceneName);
        
        this.sceneName = sceneName;
        
        // console.warn(this.sceneName)
        
        if (!sceneItem) {
            console.error("Scene with the name", sceneName, "does not exists. Available scenes are: ", this.app.scenes.list().map(function(a) { return a.name; }));
            return;
        }

        var oldScene = this.app.root.findByName('Root');

        var dontDestroyOnLoad = this.app.root.findByTag('dontdestroyonload')[0];
        this.dontDestroyOnLoad = dontDestroyOnLoad;

        oldScene.removeChild(dontDestroyOnLoad);
        this.app.fire('Application:destroyScene');

        this.currentScene = sceneName;

        oldScene.destroy();
        
        this._loadScene(sceneItem.url, function(newScene) {
            if (dontDestroyOnLoad) {
                newScene.addChild(dontDestroyOnLoad);
            }

            if (callback) {
                callback.call(context);
            }
        });
    },

    _loadScene: function(url, callback) {
        this.app.scenes.loadSceneHierarchy(url, function(error, parent) {
            if (!error) {
                Application.app.fire('Application:loadScene');

                callback(parent);
            } else {
                console.error(error);
            }
        });  
    },
});

// PlayerData.js
var PlayerData = function(initNew) {    
    this.initialize(initNew);
};

Object.defineProperty(PlayerData, 'instance', {
    get: function() {
        if (!PlayerData._instance) {
            PlayerData._instance = PlayerData.load();
        }  

        return PlayerData._instance;
    },
});

Object.defineProperty(PlayerData, 'doingTutorial', {
    get: function() {
        return this._doingTutorial;
    },

    set: function(value) {
        this._doingTutorial = value;
    },

});

Object.defineProperty(PlayerData, 'tutorialCameraLocked', {
    get: function() {
        return this._tutorialCameraLocked;
    },

    set: function(value) {
        this._tutorialCameraLocked = value;
    },

});

Object.defineProperty(PlayerData, 'inputBetweenGames', {
    get: function() {
        return this._inputBetweenGames;
    },

    set: function(value) {
        this._inputBetweenGames = value;
    },

});

pc.extend(PlayerData.prototype, {

    initialize: function(initNew) {
        PlayerData._instance = this;

        this._doingTutorial = false;

        this._tutorialCameraLocked = false;

        this._inputBetweenGames = false;
    },
});

pc.extend(PlayerData, {
    load: function(){
        var playerData = new PlayerData(false);

        return playerData;
    },
});

// HouseKeeper.js
var HouseKeeper = pc.createScript('houseKeeper');

//HouseKeeper.lastLandscapeDeviceOrientation = DeviceOrientation.Unknown;
HouseKeeper.IsKindle = true;
HouseKeeper.disableAd = false;

pc.extend(HouseKeeper.prototype, {

    initialize: function() {
        //Strings.Language = "english";

    }, 

    postInitialize: function() {
        GameManager.startUp();

    },
});

// ObjectHandler.js
//There could be a chance that the model will break if the lazy loader is still loading the object options when clicking on a different option. 
//very slim chance because the object options should be loaded during the loading screen.

class ObjectHandler extends pc.ScriptType {
    static addAttributes() {
        this.attributes.add('holdingStages', { type: 'asset', assetType: 'texture', array: true, title: 'The images that you see when you hold an object' });
        this.attributes.add('totalAnimationSeconds', {
            type: 'number',
            default: 2,
            title: 'Animation time',
            description: 'Amount of seconds the animation takes'
        });

        this.attributes.add('maxDistanceInterupt', { type: 'number', title: 'The maximum distance your mouse travels before you deselect (in screen pixels)' });
        this.attributes.add('optionImages', { type: 'entity' });
        this.attributes.add('holdingImage', { type: 'entity' });
        this.attributes.add('accept', { type: 'entity' });
        this.attributes.add('cancel', { type: 'entity' });
    }

    init() {
        // variables
        ObjectHandler.instance = this;

        this.inEditMode = false; // boolean: if in edit mode, edit mode is when you selected an object
        this.selectedEntity = null; // entity
        this.defaultAsset = null;
        this.selectedEntityStartsBroken = false;
        // stage settings

        this.app.on('HoldCounter:finish', this.selectEntity, this);

        this.firePostDialog = false;

        this.editedObjects = [];
    }
    selectEntity(entity) {
        if (this.selectedEntity) {
            this._deselectObject(true);
        }

        this.selectedEntity = entity;
        this.selectedEntity.script.objectOptions.updateCurrentIndex();
        this.selectedEntityStartsBroken = this.selectedEntity.script.objectOptions.getCurrentIndex() === ObjectHandler.BROKEN_STATE;

        //load possible costumizations
        this.lazyloadObjectOptions();

        GardenCamera.instance.focusObject(this.selectedEntity);

        this.app.fire('UIManager:hideUI', 'Garden');

        this.checkForPreDialog(this.initUI, this);
    }

    switchEntity(entity) {
        if (entity && entity.script.objectOptions.objectState === ObjectOptions.states.Locked) return;
        if (this.selectedEntityStartsBroken || entity.script.objectOptions.getCurrentIndex() === ObjectHandler.BROKEN_STATE) return;
        if (entity.script.objectOptions.world !== this.selectedEntity.script.objectOptions.world) return;



        var found = false;

        for (var i = 0; i < this.editedObjects.length; i++) {
            if (this.editedObjects[i].entity.name === this.selectedEntity.name) {
                found = true;
                break;
            }
        }

        if (!found) {
            this.editedObjects.push({
                entity: this.selectedEntity,
                name: this.selectedEntity.name,
                selectedOption: this.selectedEntity.script.objectOptions.selectedOption,
                defaultCollider: this.defaultCollider,
                defaultAsset: this.defaultAsset,
                defaultID: this.defaultID,
                changed: typeof this.selectedEntity.script.objectOptions.selectedOption === 'number' && this.selectedEntity.script.objectOptions.selectedOption !== this.defaultID,
            });
        } else {
            this.editedObjects[i].selectedOption = this.selectedEntity.script.objectOptions.selectedOption;
            this.editedObjects[i].changed = typeof this.selectedEntity.script.objectOptions.selectedOption === 'number' && this.editedObjects[i].defaultID !== this.selectedEntity.script.objectOptions.selectedOption;
        }

        this._deselectObject(false);
        this.selectedEntity = entity;

        //load possible costumizations
        this.lazyloadObjectOptions();
        GardenCamera.instance.focusObject(this.selectedEntity);
        // console.log(this.selectedEntity.script.objectOptions.currentIndex)
        this.initUI();
    }

    lazyloadObjectOptions() {
        this.selectedEntity.script.objectOptions.lazyLoadAll();
    }

    // reset the entire object selecter
    reset() {
        // console.log('reset')
        this.selectedEntity = null;
        this.editedObjects.length = 0;
        this.selectedEntityStartsBroken = false;
    }

    // init the selection buttons if you selected an item
    initUI(isForced) {
        this.app.fire('UIManager:hideUI', 'Garden');
        this.app.fire('UIManager:showUI', 'Garden Edit');

        this.inEditMode = true;
        this.optionImages.enabled = true;

        const editedObject = this.editedObjects.find(obj => obj.entity === this.selectedEntity);
        if (editedObject) {
            this.defaultAsset = editedObject.defaultAsset;
            this.defaultCollider = editedObject.defaultCollider;
            this.defaultID = editedObject.defaultID;
        } else {
            this.defaultAsset = this.selectedEntity.model.asset;
            this.defaultCollider = this.selectedEntity.script.objectOptions.getColliderId();
            this.defaultID = this.selectedEntity.script.objectOptions.currentIndex;
        }

        this.currentName = this.selectedEntity.name;
        this.defaultID = this.selectedEntity.script.objectOptions.currentIndex;
        this._highlightObject(true);

        this.cancel.enabled = !this.selectedEntityStartsBroken;
        this.accept.enabled = this.hasChangedObject(); //!this.selectedEntityStartsBroken;

        // make the option buttons in the ui
        for (var i = 0; i < this.optionImages._children.length; i++) {
            var child = this.optionImages._children[i];
            if (child.tags.has("OptionButton")) {
                if (this.selectedEntity.script.objectOptions.objectImages[i]) {
                    var sprite = this.selectedEntity.script.objectOptions.objectImages[i];
                    var imageSize = sprite.resource.atlas.frames[sprite.resource.frameKeys[0]].rect;
                    child._children[0].element.sprite = sprite.resource;
                    child._children[0].element.width = imageSize.z;
                    child._children[0].element.height = imageSize.w;
                }

            } else {
                child.enabled = !isForced ? true : false;
            }
        }

        this.select(this.selectedEntity.script.objectOptions.getCurrentIndex());
    }

    hasChangedObject(name) {
        for (var i = 0; i < this.editedObjects.length; i++) {

            if (this.editedObjects[i].changed && this.editedObjects[i].name !== name) {
                return true;
            }
        }

        return false;
    }

    select(index) {
        for (var i = 0; i < this.optionImages.children.length; i++) {
            var child = this.optionImages.children[i];

            if (child.tags.has("OptionButton")) {
                var spriteName = index === i ? '002_ui_box_gardenitem_selected.png' : '003_ui_box_gardenitem_unselected.png';
                child.element.sprite = this.app.assets.find(spriteName).resource;
            }
        }
    }

    // init the options you have when you selected an object
    changeSelectedObject(event, id) {
        let changeFocusPoint = false;

        var objectOptions = this.selectedEntity.script.objectOptions;
        if (objectOptions.objectOptions.length > 0) {
            if (!objectOptions.objectOptions[id]) {
                console.log(objectOptions.objectOptions, id)
            }
            if (objectOptions.objectOptions[id]._id !== this.selectedEntity.model.asset) {
                this.selectedEntity.model.asset = objectOptions.objectOptions[id];
                this.selectedEntity.script.objectOptions.currentIndex = id;
                objectOptions.setCollider(id);
                //this.accept.enabled = true;
                if (objectOptions.objectOptions[id].resource) {
                    changeFocusPoint = true;
                    this.rebatch(this.selectedEntity);
                    this.app.fire('Audio:sfx', 'change_object_fast.mp3');
                } else {
                    this.app.fire("UIManager:showUI", 'loading');
                    objectOptions.objectOptions[id].ready(() => {
                        this.rebatch(this.selectedEntity);
                        this.app.fire("UIManager:hideUI", 'loading');
                        this.app.fire('Audio:sfx', 'change_object_fast.mp3');
                    }, this);
                }
            }
        } else {
            var meshInstances = this.selectedEntity.model.meshInstances;
            for (var i = 0; i < meshInstances.length; ++i) {
                meshInstances[i].material = objectOptions.materialOptions[id].resource;
            }
            //this.accept.enabled = false;
        }

        objectOptions.selectedOption = id;
        GardenCamera.instance.focusObject(this.selectedEntity);

        if (changeFocusPoint) {
            this._showGardenSelectAnim(objectOptions);
        }

        var found = false;

        for (var j = 0; j < this.editedObjects.length; j++) {
            if (this.editedObjects[j].entity.name === this.selectedEntity.name) {
                found = true;
                break;
            }
        }

        var same = false;

        if (found) {
            same = id === this.editedObjects[j].defaultID;
        } else {
            same = id === this.defaultID;
        }

        this.accept.enabled = !same || this.hasChangedObject(this.currentName);

        this._highlightObject(true);

        this.select(id);
    }
    rebatch(entity, getReturnValue = false) {
        if (entity.model.batchGroupId !== -1) {
            this.app.batcher.markGroupDirty(entity.model.batchGroupId);
            if (getReturnValue) {
                return entity.model.batchGroupId;
            }
        } else {
            if (getReturnValue) {
                return -1;
            }
        }
    }
    // when changing an object and pressing the cancel button
    cancelObject() {
        var previousBatch = -1;

        var currentEntityEdited = false;

        // deselect the object, remove the ui and enable camera movement
        GardenCamera.instance.blockCamera = false;
        // this.selectedEntity.script.objectOptions.setCollider(this.defaultCollider);
        // this.selectedEntity.model.asset = this.defaultAsset;
        // this.selectedEntity.script.objectOptions.updateCurrentIndex();

        previousBatch = this.rebatch(this.selectedEntity, true);

        for (var i = 0; i < this.editedObjects.length; i++) {
            if (this.editedObjects[i].entity === this.selectedEntity) {
                currentEntityEdited = true;
            }
            this.editedObjects[i].entity.script.objectOptions.setCollider(this.editedObjects[i].defaultCollider);
            this.editedObjects[i].entity.model.asset = this.editedObjects[i].defaultAsset;
            this.editedObjects[i].entity.script.objectOptions.updateCurrentIndex();
            delete this.editedObjects[i].entity.script.objectOptions.selectedOption;

            if (previousBatch !== this.editedObjects[i].entity.model.batchGroupId) {
                previousBatch = this.rebatch(this.editedObjects[i].entity, true);
            }
        }

        if (!currentEntityEdited) {
            this.selectedEntity.script.objectOptions.setCollider(this.defaultCollider);
            this.selectedEntity.model.asset = this.defaultAsset;
            this.selectedEntity.script.objectOptions.updateCurrentIndex();
            delete this.selectedEntity.script.objectOptions.selectedOption;
        }

        this._deselectObject(true);
        this.reset();

        this.app.fire('UIManager:hideUI', 'Garden Edit');
        this.app.fire('UIManager:showUI', 'Garden');
        this.app.fire('ObjectHandler:cancelObject');
        this.app.fire('GardenManager:light');
    }

    // when changing an object and pressing the accept button
    acceptObject() {
        var previousBatch = -1;
        // update values
        // GardenManager.instance.updateSpecificOption(this.selectedEntity);

        if (this.selectedEntityStartsBroken) {
            this.sendProgressionEvent(this.selectedEntity.script.objectOptions, this.selectedEntity.script.objectOptions.world, 'Complete');
        }

        if (typeof this.selectedEntity.script.objectOptions.selectedOption === 'number' && this.defaultID !== this.selectedEntity.script.objectOptions.selectedOption) {
            this.selectedEntity.script.objectOptions.objectState = 1;
            // this.selectedEntity.script.objectOptions.currentIndex = this.selectedEntity.script.objectOptions.selectedOption;
            this.selectedEntity.script.objectOptions.setAssetToSelection(this.selectedEntity.script.objectOptions.currentIndex);
        }

        if (this.selectedEntityStartsBroken && this.selectedEntity.script.objectOptions.world === 1 && this.selectedEntity.script.objectOptions.step === 1) {
            Wrapper.instance.sendGAEvent(Wrapper.GA_EVENT_TYPE.DESIGN, { eventId: 'tutorialFunnel:placedFlowerBed' })
        }

        for (let i = 0; i < this.editedObjects.length; i++) {
            const object = this.editedObjects[i];

            if (object.changed) {
                object.entity.script.objectOptions.setAssetToSelection(object.selectedOption);
            }
        }


        if (this.selectedEntity.model.batchGroupId !== -1) {
            this.app.batcher.markGroupDirty(this.selectedEntity.model.batchGroupId);
            previousBatch = this.selectedEntity.model.batchGroupId;
        }

        var areaScript = GardenManager.instance.getAreaScriptByAreaNumber(this.selectedEntity.script.objectOptions.world);

        if (this.selectedEntityStartsBroken) {
            areaScript.payStars(this.selectedEntity.script.objectOptions.objectCostInStars);
        }

        if (this.selectedEntityStartsBroken) {
            this._showGardenUpgradeAnim();

            const soundInstance = AudioManager.instance._playSFX('change_object_music.mp3');

            if (soundInstance) {
                GardenMusicManager.instance.fadeOutMusic();
                soundInstance.on('end', () => {
                    GardenMusicManager.instance.fadeInMusic();
                    GardenMusicManager.instance.fadeOutAmbient();
                });
            }
        }

        this.app.fire('GardenManager:light');

        this._deselectObject();

        this.app.fire('ObjectHandler:acceptButton', this.selectedEntity.script.objectOptions.world);
        GardenCamera.instance.blockCamera = false;

        const duration = this.selectedEntityStartsBroken ? 5 : 0.1;

        pc.timer.add(duration, () => {
            try {
                this.checkForPostDialog(this.afterAcceptBehaviour, this);
            } catch (e) {
                console.log(e);
            }
        });

        this.app.fire('UIManager:hideUI', 'Garden Edit');
    }

    afterAcceptBehaviour() {
        if (this.selectedEntityStartsBroken) {
            const worldId = this.selectedEntity.script.objectOptions.world
            var areaScript = GardenManager.instance.getAreaScriptByAreaNumber(worldId);

            if (!this.selectedEntity.script.objectOptions.lastObject) {
                var obj = GardenUIEntity.instance.getLastUnlock(areaScript);

                if (obj.found) {
                    if (obj.step > 1) {
                        this.sendProgressionEvent(obj, worldId);

                        // TODO show other feedback when the maxSteps is not reached.
                    } else if (obj.worldTask) {
                        TodoCardHandler.instance.setTodoValues(obj.data.key, null, obj.data.sprite, obj.areaNumber);
                        this.app.fire('ObjectHandler:showNewToDo');
                    } else {
                        // New todo

                        this.sendProgressionEvent(obj, worldId);

                        TodoCardHandler.instance.setTodoValues(obj.nextUnlockableEntity.script.objectOptions.descriptionText,
                            "" + obj.starsToUnlock,
                            obj.nextUnlockableEntity.script.objectOptions.brokenObjectImage,
                            obj.nextUnlockableEntity.script.objectOptions.world
                        );
                        this.app.fire('ObjectHandler:showNewToDo');
                    }
                }
            }
        }

        if (this.selectedEntityStartsBroken && this.selectedEntity.script.gardenUpgradeDialog && this.selectedEntity.script.gardenUpgradeDialog.PostUpgradeKey === 'garden-area-1-object-2-part-2') {
            this.app.fire('ObjectHandler:changeObjectTutorial');
        } else {
            this.app.fire('UIManager:showUI', 'Garden');
        }

        this.reset();
    }

    sendProgressionEvent(obj, worldId, status = 'Start') {
        Wrapper.instance.sendGAEvent(Wrapper.GA_EVENT_TYPE.PROGRESSION, {
            progressionStatus: status,
            progression01: `task_area_${worldId}`,
            progression02: `task_${obj.group + 1}`,
            progression03: `step_${obj.step}`
        });
    }

    checkForPreDialog(callback, context) {
        DialogManager.instance.setInterface(dialogTypes.CONVERSATION);

        var objIndex = this.selectedEntity.script.objectOptions.getCurrentIndex();

        if (objIndex === ObjectHandler.BROKEN_STATE && // Broken state
            this.selectedEntity.script.gardenUpgradeDialog && // Has gardenUpgradeDialog
            DialogManager.instance._getDialog(this.selectedEntity.script.gardenUpgradeDialog.PreUpgradeKey)[0]) // Dialog exists
        {

            DialogManager.instance.showDialog(this.selectedEntity.script.gardenUpgradeDialog.PreUpgradeKey, callback, context, dialogTypes.CONVERSATION, false);
            this.firePostDialog = true;
        } else {
            if (this.selectedEntity.script.gardenUpgradeDialog && objIndex === ObjectHandler.BROKEN_STATE) {
                // console.log('no pre dialog key')
                this.firePostDialog = true;
            }

            callback.call(context);
        }
    }

    checkForPostDialog(callback, context) {
        DialogManager.instance.setInterface(dialogTypes.CONVERSATION);

        if (this.firePostDialog && this.selectedEntity.script.gardenUpgradeDialog && DialogManager.instance._getDialog(this.selectedEntity.script.gardenUpgradeDialog.PostUpgradeKey)[0]) {
            const key = this.selectedEntity.script.gardenUpgradeDialog.PostUpgradeKey;

            if (key === 'garden-area-1-object-1-part-2') {
                Wrapper.instance.sendGAEvent(Wrapper.GA_EVENT_TYPE.DESIGN, { eventId: 'tutorialFunnel:finishedDialog' });
            }

            DialogManager.instance.showDialog(key, callback, context, dialogTypes.CONVERSATION, false);
        } else {
            if (this.firePostDialog && this.selectedEntity.script.gardenUpgradeDialog && !DialogManager.instance._getDialog(this.selectedEntity.script.gardenUpgradeDialog.PostUpgradeKey)[0]) {
                // console.log('no post dialog key')
            }
            callback.call(context);
        }
        this.firePostDialog = false;
    }

    // deselect the current object
    _deselectObject(toDefault) {
        if (toDefault) {
            this.selectedEntity.script.objectOptions.setCollider(this.defaultCollider);
            this.selectedEntity.model.asset = this.defaultAsset;
            this.rebatch(this.selectedEntity);
        }
        this.inEditMode = false;
        this.optionImages.enabled = false;
    }

    // swap the texture for a highlighted one (if it exists)
    _highlightObject(isHighlighted) {
        var meshInstances = this.selectedEntity.model.meshInstances;

        if (!meshInstances) {
            const asset = this.app.assets.get(this.selectedEntity.model.asset);

            if (!asset) {
                Sentry.captureMessage("No asset found with id: " + this.selectedEntity.model.asset);
                return;
            }

            asset.ready(this._highlightObject.bind(this, is_highlighted));
            return;
        }
        return;
        for (var i = 0; i < meshInstances.length; ++i) {
            var mesh = meshInstances[i];

            var meshName = mesh.material.name;

            // TODO kinda hacky. Need to refactored when we have real highlighted materials.
            console.log("here", meshName)
            if (meshName.includes(" Highlighted"))
                mmeshName.replace(" Highlighted", "");

            var asset = this.app.assets.find((isHighlighted ? meshName + " Highlighted" : meshName), "material");

            if (!asset) {
                // console.warn("Object Handler: Asset with the name", meshName, "couldn't be found");
                return;
            }

            this.setMeshMaterialOnReady(mesh, asset);
        }
    }

    setMeshMaterialOnReady(mesh, asset) {
        asset.ready(function () {
            mesh.material = asset.resource;
        });
    }

    _showGardenAnimation(string) {
        //select the entity with tag animationgroup from selected entity
        var animationGroup = this.selectedEntity.findByTag('AnimationEntityGroup')[0];

        if (animationGroup) {
            animationGroup.children.forEach(function (entity) {
                var position = entity.getPosition();
                var item = TilePrefabManager.instance.getObjectPool(string).use();
                item.enabled = true;
                item.script.upgradeGardenItemAnim.startUpgradeAnim();
                item.setPosition(position);
            });
        } else {
            console.warn('No Animationgroup found, add tag and entities for locations');
        }
    }

    _createAnimation(string) {
        if (!this.selectedEntity) {
            console.warn("Nothing selected!")
            return;
        }
        //select the entity with tag animationgroup from selected entity
        var animationGroup = this.selectedEntity.findByTag('AnimationEntityGroup')[0];

        var array = [];

        if (animationGroup) {
            animationGroup.children.forEach((entity) => {
                var position = entity.getPosition();
                var item = TilePrefabManager.instance.getObjectPool(string).use();
                item.enabled = true;
                item.reparent(this.app.root)
                item.setPosition(position);
                array.push(item);

            });

            return array;
        } else {
            console.warn('No Animationgroup found, add tag and entities for locations');
        }

        return array;
    }

    _showGardenSelectAnim(objectOptions) {
        if (objectOptions.tweenWhenSelected) {
            this.app.fire('GardenManager:light', pc.SHADOWUPDATE_REALTIME);

            const entity = objectOptions.entity;
            entity.setLocalScale(1, 0, 1);
            entity.tween(entity.getLocalScale()).to(pc.Vec3.ONE, 0.3, pc.BackOut).start().on('complete', () => {
                this.app.fire('GardenManager:light', pc.SHADOWUPDATE_THISFRAME);
            });
        } else {
            this.app.fire('GardenManager:light', pc.SHADOWUPDATE_THISFRAME);
        }

        // var array = this._createAnimation("UpgradeGardenSelectObjectPool");

        // if (!array) {
        //     console.warn("Something went wrong");
        //     return;
        // }

        // array.forEach(item => item.script.upgradeGardenSelectAnim.startAnim());
    }

    _showGardenUpgradeAnim() {
        var array = this._createAnimation("UpgradeGardenAnimationObjectPool");

        if (!array) {
            console.warn("Something went wrong");
            return;
        }

        this._hammer = 0;
        this._saw = 0;

        array.forEach(item => item.script.upgradeGardenItemAnim.startUpgradeAnim());

        try {
            if (array.length > 2) {
                this.createSawSequence(array);
                this.createHammerSequence(array);
            } else {
                this.createSawSequence(array);

            }
        } catch (e) {
            console.log(e)
        }


    }

    createSawSequence(array, currentIndex) {
        let randomIndex = null;
        let times = 0;
        do {
            randomIndex = Math.floor(Math.random() * array.length);
            times++;
        } while (randomIndex === currentIndex && times < 30);

        const object = array[randomIndex];

        object.script.upgradeGardenItemAnim.startSawAnim();

        if (array.length > 2) {
            if (this._saw < ObjectHandler.TIMES_TO_PLAY) {
                object.script.upgradeGardenItemAnim.once('stopped', () => {
                    this.createSawSequence(array, randomIndex);
                });
            }

            this._saw++;
        } else {
            if (this._saw < ObjectHandler.TIMES_TO_PLAY) {
                object.script.upgradeGardenItemAnim.once('stopped', () => {
                    this.createHammerSequence(array);
                });
            }

            this._saw++;
            this._hammer++;
        }


    }

    createHammerSequence(array, currentIndex) {
        let randomIndex = null;
        let times = 0;
        do {
            randomIndex = Math.floor(Math.random() * array.length);
            times++
        } while (randomIndex === currentIndex && times < 30);

        const object = array[randomIndex];

        object.script.upgradeGardenItemAnim.startHammerAnim();
        if (array.length > 2) {
            if (this._hammer < ObjectHandler.TIMES_TO_PLAY) {
                object.script.upgradeGardenItemAnim.once('stopped', () => {
                    this.createHammerSequence(array, randomIndex);
                });
            }

            this._hammer++;
        } else {
            if (this._hammer < ObjectHandler.TIMES_TO_PLAY) {
                object.script.upgradeGardenItemAnim.once('stopped', () => {
                    this.createSawSequence(array);
                });
            }

            this._saw++;
            this._hammer++;
        }

    }
}

pc.registerScript(ObjectHandler, 'objectHandler');
ObjectHandler.addAttributes();

ObjectHandler.BROKEN_STATE = 3;
ObjectHandler.TIMES_TO_PLAY = 2;


// BackgroundTile.js
var BackgroundTile = pc.createScript('backgroundTile');

// var backgroundTileEnum = Object.freeze({
//     EMPTY: 0,
//     WALL: 1,
//     PANEL: 2,
//     BLOCKER: 3,
//     LOCKER: 4,
//     VIRUS: 5,
//     COAT: 6,
//     SINKER: 7,
//     CHEST: 8,
//     COPYER: 9,
//     POPPER: 10
// });

BackgroundTile.backgroundType = [
    { WALL: backgroundTileEnum.WALL },
    { PANEL: backgroundTileEnum.PANEL },
    { BLOCKER: backgroundTileEnum.BLOCKER },
    { LOCKER: backgroundTileEnum.LOCKER },
    { VIRUS: backgroundTileEnum.VIRUS },
    { COAT: backgroundTileEnum.COAT },
    { SINKER: backgroundTileEnum.SINKER },
    { CHEST: backgroundTileEnum.CHEST },
    { COPYER: backgroundTileEnum.COPYER },
    { POPPER: backgroundTileEnum.POPPER },
];

BackgroundTile.ExplodeMethodEnum = Object.freeze({
    CANNOT_EXPLODE: 0,
    EXPLODES_IF_HIT: 1,
    EXPLODES_IF_ADJACENT: 2,
    EXPLODES_IF_ADJACENT_MATCH: 3,
});

BackgroundTile.attributes.add('scriptName', { type: 'string' });
BackgroundTile.attributes.add('backgroundType', { type: 'number', enum: BackgroundTile.backgroundType, title: 'Type' });
BackgroundTile.attributes.add('explodeMethod', { type: 'number', enum: [{ CANNOT_EXPLODE: 0 }, { EXPLODES_IF_HIT: 1 }, { EXPLODES_IF_ADJACENT: 2 }, { EXPLODES_IF_ADJACENT_MATCH: 3 }], title: 'Explode Method' });
BackgroundTile.attributes.add('backgroundSelectable', { type: 'boolean', title: 'Background Selectable' });
BackgroundTile.attributes.add('backgroundSwappable', { type: 'boolean', title: 'Background Swappable' });
BackgroundTile.attributes.add('foregroundSwappable', { type: 'boolean', title: 'Foreground Swappable' });
BackgroundTile.attributes.add('hasForeground', { type: 'boolean', default: true, title: 'Has Foreground' });
BackgroundTile.attributes.add('maxLayers', { type: 'number', default: 1, title: 'Max Layers' });
BackgroundTile.attributes.add('onlyBackgroundExplodes', { type: 'boolean', title: 'Only Background Explodes' });
BackgroundTile.attributes.add('canForegroundMatch', { type: 'boolean', title: 'Can Foreground Match', default: true });

BackgroundTile.attributes.add('hasGravity', { type: 'boolean', title: 'Has Gravity' });
BackgroundTile.attributes.add('backgroundHasGravity', { type: 'boolean', title: 'Background has Gravity', default: false });

BackgroundTile.attributes.add('regrow', { type: 'boolean', title: 'Regrow' });

BackgroundTile.attributes.add('customScoreColor', { type: 'boolean' });
BackgroundTile.attributes.add('scoreColorId', { type: 'rgb' });
BackgroundTile.attributes.add('scoreOutlineColorId', { type: 'rgb' });

pc.extend(BackgroundTile.prototype, {
    initialize: function () {
        this.on('destroy', this._onDestroy, this);
        this.subClass = this.entity.script.get(this.scriptName);

        //         this.isDefault = false;

        //         if (!this.subClass && this.scriptName.length > 0) {
        //             console.warn("No script is found with the name", this.scriptName);
        //             this.isDefault = true;
        //             return;
        //         }

        this._aabb = new pc.BoundingBox(new pc.Vec3(), new pc.Vec3(0.6, 0.6, 0.6));

        this.showModelToUI = true;

        this._timer = 0;
        this._coatDelay = 999;

        this.recycled = true;

        this._fallTweens = [];

        this.typeID = backgroundTileEnum.EMPTY;
        this.colorID = tileColorEnum.NONE;

        this.isDestroyed = false;
        this.currentLayer = this.maxLayers;
        this.hasExploded = false;

        this._powerTriggered = false;
        this._isDamaged = false;

        this.scoreValue = 0;
        this._isObjective = null;

        this._model = this.entity.findByName('ModelEntity');
        this._modelComponent = this.entity.findComponent('model');

        this._startModelScale = pc.Vec3.ONE;
        if (this._modelComponent !== null) this._startModelScale = this._modelComponent.entity.getLocalScale().clone();

        this.app.on('ObjectiveManager:onObjectiveSet', this._onObjectiveSet, this);

        if (this.subClass && !this.entity.script.has('impulseHandler')) {
            this.entity.script.create('impulseHandler');
        }
    },

    isDefault: function () {
        return this.scriptName.length === 0;
    },

    isCoat: function () {
        return this.typeID === backgroundTileEnum.COAT;
    },

    isSinker: function () {
        return this.typeID === backgroundTileEnum.SINKER;
    },

    isCopyer: function () {
        return this.typeID === backgroundTileEnum.COPYER;
    },

    isPopper: function () {
        return this.typeID === backgroundTileEnum.POPPER;
    },

    postInitialize: function () {
        if (this.subClass) this.subClass.init(this);
    },

    awake: function (position, parent, layers) {
        if (!this.entity.parent) {
            this.entity.reparent(parent.entity);
        }

        this.stopAllTweens();
        this.recycled = false;

        this._coatDelay = 999;
        this._timer = 0;

        if (position instanceof pc.Vec3) {
            this.entity.setLocalPosition(position);
            this._aabb.center.copy(position);
            this.setBoundingBox();
        }

        this._changeToCoat = false;

        this._isDamaged = false;
        this._powerTriggered = false;
        this.isDestroyed = false;
        this.setLayers(layers || this.maxLayers);
        this.entity.setLocalScale(pc.Vec3.ONE);
        this.parent = parent;

        if (this._modelComponent !== null) {
            this._modelComponent.entity.setLocalScale(this._startModelScale.x, this._startModelScale.y, this._startModelScale.y);
        }

        if (this._isObjective === null) {
            this._onObjectiveSet();
        }

        if (this.subClass && typeof this.subClass.awake === 'function') this.subClass.awake(this);
    },

    postAwake: function () {
        if (this.subClass && typeof this.subClass.postAwake === 'function') {
            return this.subClass.postAwake();
        }
    },

    _onObjectiveSet: function () {
        this._isObjective = ObjectiveManager.instance.isTileOneOfObjectives(tileLayerEnum.BACKGROUND, this.typeID, this.colorID);
    },
    _onDestroy: function () {
        console.error(this);
    },

    setProperties: function (x, y) {
        this.x = x;
        this.y = y;
    },

    intersectsRay: function (ray) {
        if (!this.backgroundSelectable) {
            return;
        }

        this.setBoundingBox();
        return this._aabb.intersectsRay(ray);
    },

    setBoundingBox: function () {
        this._aabb.center.copy(this.entity.getPosition());
    },

    despawnInstant: function () {
        if (this.subClass && typeof this.subClass.despawnInstant === 'function') {
            return this.subClass.despawnInstant();
        }

        this.recycled = true;
    },

    explode: function (delay, tile) {
        if (this.subClass && typeof this.subClass.explode === 'function') {
            return this.subClass.explode(delay, tile);
        }

        // if (this.explodeMethod === BackgroundTile.ExplodeMethodEnum.CANNOT_EXPLODE) {
        //     console.error("This tile should not explode");
        // }

        this.hasExploded = true;
        this._isDamaged = true;
        this.currentLayer--;

        //this.subClass.explode();

        var destroyed = this.currentLayer === 0;

        this._onExplode(destroyed);

        if (destroyed) {
            StatisticsManager.instance.incrementStatistic('obstacle_destroyed', {
                obstacle_type: TileLibrary.instance.getObstacleName(this.typeID),
            });
            this.stopAllTweens();
            this.isDestroyed = true;
        }

        return destroyed;
    },

    explodeAll: function (delay, tile) {
        if (this.subClass && typeof this.subClass.explodeAll === 'function') {
            return this.subClass.explodeAll(delay, tile);
        }
    },

    _onExplode: function (isLastLayer, delay, ignoreTween) {
        if (this.subClass && typeof this.subClass._onExplode === 'function') {
            return this.subClass._onExplode(isLastLayer, delay, ignoreTween);
        }

        var modelComponent = this.entity.findComponent('model');

        if (!modelComponent) {
            return;
        }

        var tweenEntity = modelComponent.entity;

        if (!tweenEntity) {
            return;
        }

        var scaleIncreaseTween = tweenEntity.tween(tweenEntity.getLocalScale()).to(this._startModelScale.clone().scale(1.2), 0.1, pc.SineInOut);
        var scaleDownTween;

        if (isLastLayer) {
            this.app.fire('BackgroundTile:onExplode', tileLayerEnum.BACKGROUND, this.typeID);
            if (this.showModelToUI && this._isObjective) {
                if (!ObjectiveManager.instance.isObjectiveCompleted(tileLayerEnum.BACKGROUND, this.typeID, this.colorID)) {
                    this.app.fire('ModelToUIManager:showAnimation', this.entity.getLocalPosition(), { layerID: tileLayerEnum.BACKGROUND, typeID: this.typeID, colorID: this.colorID }, 0);
                }
            }
            if (!ignoreTween) {
                scaleDownTween = tweenEntity.tween(tweenEntity.getLocalScale()).to(pc.Vec3.ZERO, 0.15, pc.SineInOut);
            }
        } else {
            scaleDownTween = tweenEntity.tween(tweenEntity.getLocalScale()).to(this._startModelScale.clone(), 0.1, pc.SineInOut);
        }

        if (this.scoreValue) {
            GridManager.instance.showScore(this, this.scoreValue);
            this.scoreValue = 0;
        }

        scaleIncreaseTween.chain(scaleDownTween);
        scaleIncreaseTween.start();
    },

    _onLayerExplode: function () {
        var scoreTile = null;
        var foregroundTile = this.getForegroundTile();
        if (foregroundTile !== null && foregroundTile !== 0 && !this.onlyBackgroundExplodes) {
            scoreTile = foregroundTile;
        } else {
            scoreTile = this;
        }
        this.app.fire('ScoreManager:scoreBackgroundTile', this.typeID, this._isObjective, scoreTile);
    },

    getForegroundTile: function () {
        return GridManager.instance.getTile(this.x, this.y);
    },

    setLayers: function (layers) {
        this.maxLayers = layers;
        this.currentLayer = this.maxLayers;
    },

    canExplode: function () {
        return this.explodeMethod !== BackgroundTile.ExplodeMethodEnum.CANNOT_EXPLODE;
    },

    setScoreAfterDelay: function (score) {
        this.scoreValue += score;
    },

    stopAllTweens: function () {
        if (!this.subClass) return;

        if (typeof this.subClass.stopAllTweens === 'function') {
            this.subClass.stopAllTweens();
        }
    },

    doHintAnimation: function () {
        if (!this.subClass) return;

        if (typeof this.subClass.doHintAnimation === 'function') {
            return this.subClass.doHintAnimation();
        }
    },

    stopHintAnimation: function () {
        if (!this.subClass) return;

        if (typeof this.subClass.stopHintAnimation === 'function') {
            return this.subClass.stopHintAnimation();
        }
    },

    shakeTile: function () {
        if (!this.subClass) return;

        if (typeof this.subClass.shakeTile === 'function') {
            return this.subClass.shakeTile();
        }
    },

    getDespawnDelay: function (withoutEndDelay) {
        if (this.subClass && typeof this.subClass.getDespawnDelay === 'function') {
            return this.subClass.getDespawnDelay(withoutEndDelay);
        }

        return 0;
    },

    setDespawnDelay: function (value) {
        this.despawnDelay = value;

        if (this.subClass && typeof this.subClass.setDespawnDelay === 'function') {
            return this.subClass.setDespawnDelay(value);
        }
    },

    pulse: function (deltaX, deltaY, amplitude, delay, duration) {
        if (!this._model) {
            return;
        }

        if (this.ignorePulse) {
            return;
        }

        // if (this._state === ForegroundTile._States.INACTIVE) {
        //     return;
        // }

        if (!this.entity.script.impulseHandler) {
            console.warn(this);
            return;
        }

        this.entity.script.impulseHandler.impulse(deltaX, deltaY, amplitude, delay, duration);
    },

    playAnimation: function (name, delay, eventStart, eventEnd, priority, loop) {
        if (typeof this.subClass.playAnimation === 'function') {
            return this.subClass.playAnimation(name, delay, eventStart, eventEnd, priority, loop);
        }
    },

    changeToCoat: function (delay) {
        if (!this.isDefault()) {
            return;
        }

        if (typeof delay !== 'number') {
            delay = 0;
        }

        this._changeToCoat = true;

        if (this.coatTimer) {
            if (this.coatTimer.secsLeft > delay) {
                this.coatTimer.secsLeft = delay;
            }
        } else {
            this.coatTimer = pc.timer.add(delay || 0.01, this._doChangeToCoat, this);
        }
    },

    _doChangeToCoat: function () {
        GridManager.instance.changeToCoat(this);
        delete this.coatTimer;
    },

    applyGravity: function (fromX, fromY, toX, toY, duration, delay) {
        delay = delay || 0;

        if (this.subClass && typeof this.subClass.applyGravity === 'function') {
            this.subClass.applyGravity(fromX, fromY, toX, toY, duration, delay);
        }

        var toPosition = GridManager.instance.calculatePosition(toX, toY, this.entity.getLocalPosition().z);

        this._deltaY += fromY - toY;

        var startDuration = this._fallTweens.length === 0 ? GridManager.instance.startFallDuration : 0;

        var tween = this.entity.tween(this.entity.getLocalPosition()).to({ x: toPosition.x, y: toPosition.y, z: toPosition.z }, duration + startDuration, pc.QuadraticIn, delay);

        this.x = toX;
        this.y = toY;

        if (this._fallTweens.length === 0) {
            tween.start();
        } else {
            this._fallTweens[this._fallTweens.length - 1].chain(tween).off('complete', this._onFallComplete, this);
        }

        tween.on('complete', this._onFallComplete, this);

        this._fallTweens.push(tween);

        this.falling = true;

        return this._getFallTweenDuration();
    },

    _onFallComplete: function () {
        this._bounce();
    },

    _bounce: function () {
        var currentPosition = this.entity.getLocalPosition();

        var duration = this._calculateBounceDuration();

        this.bounceTween = this.entity.tween(this.entity.getLocalPosition()).to({ x: currentPosition.x, y: currentPosition.y + this._calculateBounceHeight(), z: currentPosition.z }, duration, pc.Bounce);
        this.bounceTween.start();
        this.bounceTween.on('complete', function () {
            this.falling = false;
            this._deltaY = 0;
        }, this);

        //GridManager.instance.playSFX('tile_drop_flowers.mp3');

        //         var dur = 0;

        //         this.bounceTween.on('update', function(dt) {
        //             dur += dt;

        //             if (dur >= this.bounceDuration / 2) {
        //                 GridManager.instance.playSFX('tile_drop_flowers.mp3');
        //                 dur = 0;
        //             }
        //         }, this);

        this._fallTweens.length = 0;
    },

    _calculateBounceDuration: function () {
        return this.bounceDuration || 0.5;
    },

    _getFallTweenDuration: function () {
        if (this._fallTweens.length === 0) {
            return 0;
        }

        var totalDuration = this._calculateBounceDuration();

        for (var i = 0; i < this._fallTweens.length; i++) {
            totalDuration += this._fallTweens[i].duration + this._fallTweens[i]._delay;
        }

        return totalDuration;
    },

    _calculateBounceHeight: function () {
        return Math.min(this._deltaY, 3) * 0.1 || 0.1;
    },

    isSwappable: function () {
        return this.backgroundSwappable;
    },

    setHighlight: function (value) {
        if (this.subClass && typeof this.subClass.setHighlight === 'function') {
            this.subClass.setHighlight(value);
        }
    },

    move: function (x, y, duration, delay) {
        if (typeof this.subClass.move === 'function') {
            this.subClass.move(x, y, duration);
        }

        if (!duration) duration = GridManager.instance.moveDuration;
        this.x = x;
        this.y = y;
        var newPosition = GridManager.instance.calculatePosition(x, y, this.entity.getLocalPosition().z);

        if (this._moveTween) {
            this._moveTween.stop();
        }
        this.moving = true;

        this.moveTween = this.entity
            .tween(this.entity.getLocalPosition())
            .to({ x: newPosition.x, y: newPosition.y, z: newPosition.z }, duration, pc.QuadraticInOut, delay || 0)
            .start();

        this.moveTween.on('complete', () => {
            this.moving = false;
        }, this)
    },

    triggerPower: function () {
        this._powerTriggered = true;
    },

    isPowerTriggered: function () {
        return this._powerTriggered;
    },

    activateRegrow: function () {
        if (this.regrow & !this._isDamaged && this.currentLayer < this.maxLayers) {
            this.previousLayer = this.currentLayer;
            this.currentLayer = this.maxLayers;

            if (this.subClass && typeof this.subClass.activateRegrow === 'function') {
                this.subClass.activateRegrow();
            }
        }

        this._isDamaged = false;
    },

    setPowerAnimation: function (data) {
        this.powerAnimation = data;
    },

    getPowerAnimation: function () {
        return this.powerAnimation;
    }
});


// GardenMouseInput.js
class GardenMouseInput extends pc.ScriptType {
    static addAttributes(){
        this.attributes.add('moveSensitivity', {
            type: 'number', 
            default: 0.5, 
            title: 'Move Sensitivity', 
            description: 'How fast the camera moves around the orbit. Higher is faster'
        });
        this.attributes.add('scrollSensitivity', {
            type: 'number', 
            default: 0.3, 
            title: 'Scroll Sensitivity', 
            description: 'How fast the camera moves in and out. Higher is faster'
        });
        this.attributes.add('deadzoneMargin', {
            type: 'number', 
            default: 3, 
            title: 'Deadzone Margin', 
            description: 'Margin of mousemovement untill interaction cancels'
        });
    }
    initialize() {
        this.velocity = new pc.Vec3(0,0,0);
        //this.picker = new pc.Picker(this.app, 512, 512);
        this._position = new pc.Vec2(0,0);

        var self = this;
        this.selectedObject = null;
        
        this._down = false;

        var onMouseOut = function (e) {
            self.onMouseOut(e);
        };
        
        this.app.on('GardenInput:setMouseWheel', this.onSetMouseWheel, this);
        
        if (GardenCamera.instance) {
            // this.app.on('Element:onmousedown',this.onMouseDown,this)
            this.app.on('GardenInput:onMouseDown', this.onMouseDown, this);
            this.app.on('GardenInput:onMouseMove', this.onMouseMove, this);
            this.app.on('GardenInput:onMouseUp', this.onMouseUp, this);
            this.app.on('GardenInput:onMouseLeaveElement', this.onMouseOut, this);
            
            // this.app.mouse.on(pc.EVENT_MOUSEDOWN, this.onMouseDown, this);
            // this.app.mouse.on(pc.EVENT_MOUSEUP, this.onMouseUp, this);
            // this.app.mouse.on(pc.EVENT_MOUSEMOVE, this.onMouseMove, this);
            this.app.mouse.on(pc.EVENT_MOUSEWHEEL, this.onMouseWheel, this);  
            
            // Listen to when the mouse travels out of the window
            window.addEventListener('mouseout', onMouseOut, false);
            

            // Remove the listeners so if this entity is destroyed
            this.on('destroy', function() {
                this.app.off('GardenInput:onMouseDown', this.onMouseDown, this);
                this.app.off('GardenInput:onMouseMove', this.onMouseMove, this);
                this.app.off('GardenInput:onMouseUp', this.onMouseUp, this);
                this.app.off('GardenInput:onMouseLeaveElement', this.onMouseOut, this);
                this.app.mouse.off(pc.EVENT_MOUSEWHEEL, this.onMouseWheel, this);

                window.removeEventListener('mouseout', onMouseOut, false);
            });
        }

        // Disabling the context menu stops the browser displaying a menu when
        // you right-click the page
        this.app.mouse.disableContextMenu();

        this.lookButtonDown = false;
    }

    // check mouse when you are pressing the button
    onMouseDown (event) {
        // console.log('GM:onMouseDown',event)
        // if(UIManager && !UIManager.instance.getScreen("Garden").enabled) return;
        this._position.set(event.x, event.y);
        this._down = true;

        this.lookButtonDown = event.button == pc.MOUSEBUTTON_LEFT ? true : pc.MOUSEBUTTON_LEFT; 
        // GardenCamera.instance.setPointerPos(event.x, event.y);
        //GardenCamera.instance.onMouseDown();
        if(this.selectedObject === null){
            //this.selectedObject = this._onSelect();
            var bb = BoundingBoxRaycast.instance.doRayCast(event);
            if(bb !== null){
                this.selectedObject = bb;
            }
            //console.log(this.selectedObject);
        }
        GardenCamera.instance.onInputDown(this.selectedObject, event.x, event.y);

    }

    // check mouse when you let go of the button
    onMouseUp (event) {
        this._down = false;
        this.lookButtonDown = event.button == pc.MOUSEBUTTON_LEFT ? false : pc.MOUSEBUTTON_LEFT; 
        GardenCamera.instance.stopHold();
        // ObjectHandler.instance.onMouseUp(event);
        GardenCamera.instance.onInputUp(event.x, event.y);
        this.selectedObject = null;
    }

    // check the movement of the mouse
    onMouseMove (event) {    
        // var mouse = pc.app.mouse;
        if (this.lookButtonDown) {
            // this.velocity.x = event.dx * this.moveSensitivity;movementX
            // this.velocity.y = event.dy * this.moveSensitivity;
            this.velocity.x = event.movementX * this.moveSensitivity;
            this.velocity.y = event.movementY * this.moveSensitivity;
            GardenCamera.instance.updateVelocity(this.velocity);
            
            GardenCamera.instance.setPointerPos(event.x, event.y);
        }

         // this.lastPoint.set(event.x, event.y);
        if (this._down) {
            //set selectedObject to null if player is moving outside the deadzone margin speed.
            if(this.velocity.length() >= this.deadzoneMargin){
                this.selectedObject = null;
                this.app.fire('GardenCamera:stopHold');
            }
            //console.log(this.velocity.length());
            //var entity = this._onSelect();
            GardenCamera.instance.onInputMove(this.selectedObject, event.x, event.y);
        }
    }

    // check if the mouse is out of the screen
    onMouseOut (event) {
        this._down = false;
        this.lookButtonDown = false;
    }

    // when the mouse scrollwheel is used
    onMouseWheel (event) {
        if (!this.useMouseWheel) {
            return;
        }
        this.distance = event.wheel * this.scrollSensitivity;
        GardenCamera.instance.zoom(this.distance);
    }

    onSetMouseWheel(value) {
        this.useMouseWheel = value;
    }
}
pc.registerScript(GardenMouseInput, 'gardenMouseInput');
GardenMouseInput.addAttributes();

// GardenTouchInput.js
class GardenTouchInput extends pc.ScriptType {
    static addAttributes(){
        GardenTouchInput.attributes.add('moveSensitivity', {
            type: 'number', 
            default: 1, 
            title: 'Move Sensitivity', 
            description: 'How fast the camera moves around the orbit. Higher is faster'
        });

        GardenTouchInput.attributes.add('distanceSensitivity', {
            type: 'number', 
            default: 0.5, 
            title: 'Distance Sensitivity', 
            description: 'How fast the camera moves in and out. Higher is faster'
        });

        GardenTouchInput.attributes.add('deadzoneMargin', {
            type: 'number', 
            default: 3, 
            title: 'Deadzone Margin', 
            description: 'Margin of touchmovement untill interaction cancels'
        });
    }
    
    initialize() {
        this.velocity = new pc.Vec2(0, 0);

        this.selectedObject = null;
        
        // Store the position of the touch so we can calculate the distance moved
        this.lastTouchPoint = new pc.Vec2();
        this.lastPinchDistance = 0;  

         if (GardenCamera.instance && this.app.touch) {
            // Use the same callback for the touchStart, touchEnd and touchCancel events as they 
            // all do the same thing which is to deal the possible multiple touches to the screen
             this.app.on('GardenInputElement:touchStart', this.onTouchStartEndCancel, this);
             this.app.on('GardenInputElement:touchEnd', this.onTouchStartEndCancel, this);
             this.app.on('GardenInputElement:touchLeave', this.onTouchStartEndCancel, this);
             this.app.on('GardenInputElement:touchMove', this.onTouchMove, this);
             
             this.on('destroy', this._onDestroy, this);
        }
        this.lookButtonDown = false;
    }
    _onDestroy(){
        this.app.off('GardenInputElement:touchStart', this.onTouchStartEndCancel, this);
        this.app.off('GardenInputElement:touchEnd', this.onTouchStartEndCancel, this);
        this.app.off('GardenInputElement:touchLeave', this.onTouchStartEndCancel, this);
        this.app.off('GardenInputElement:touchMove', this.onTouchMove, this);
    }
    // check touchstart and touchend
    onTouchStartEndCancel(event) {
        // if(UIManager && !UIManager.instance.getScreen("Garden").enabled) return;
        var touches = event.touches;
        // console.log("GTI:", event)
        this.lookButtonDown = true; 

        // check only one or 2 fingers, ignore 3 or more
        if (touches.length === 1) {
            
            GardenCamera.instance.setPointerPos(touches[0].x, touches[0].y);
            //GardenCamera.instance.onMouseDown();
            this.lastTouchPoint.set(touches[0].x, touches[0].y);
            
            //if player didnt select an object yet search for one
            if (this.selectedObject === null) {
                var bb = BoundingBoxRaycast.instance.doRayCast(touches[0]);
                if (bb !== null) {
                    this.selectedObject = bb;
                }
            }
            
            GardenCamera.instance.onInputDown(this.selectedObject, touches[0].x, touches[0].y);  
        } else if (touches.length == 2) {
            this.app.fire('GardenCamera:stopHold');
            this.lastPinchDistance = this._getPinchDistance(touches[0], touches[1]);
        } else {            
            this.lookButtonDown = false; 
            GardenCamera.instance.stopHold();
            GardenCamera.instance.onInputUp(event.x, event.y);
            this.selectedObject = null; //Set selected object back to null when player releases
        }
    }

    // check when a finger is on the screen and moving
    onTouchMove(event) {
        if (UIManager && !UIManager.instance.getScreen("Garden").enabled) return;
        var touches = event.touches;
        if (touches.length === 1) {
            // use the touch drag to move the camera
            var touch = touches[0];
            this.velocity.set(((touch.x - this.lastTouchPoint.x) * this.moveSensitivity), ((touch.y - this.lastTouchPoint.y) * this.moveSensitivity));
            
            GardenCamera.instance.updateVelocity(this.velocity);
            this.lastTouchPoint.set(touch.x, touch.y);
            //set selectedObject to null if player is moving outside the deadzone margin speed.
            if (this.velocity.length() >= this.deadzoneMargin) {
                this.selectedObject = null;
                this.app.fire('GardenCamera:stopHold');
            }
            
            GardenCamera.instance.onInputMove(this.selectedObject,touches[0].x, touches[0].y);
            
        } else if (touches.length === 2) {
            // use the pinch to zoom in or out.            
            var currentPinchDistance = this._getPinchDistance(touches[0], touches[1]);
            var diffInPinchDistance = currentPinchDistance - this.lastPinchDistance;
            GardenCamera.instance.zoom((diffInPinchDistance * this.distanceSensitivity));
            this.lastPinchDistance = currentPinchDistance;
        }
       // event.event.preventDefault();
    }

    // get the pinch distance of 2 fingers
    _getPinchDistance (pointA, pointB) {
        // Return the distance between the two points
        var dx = pointA.x - pointB.x;
        var dy = pointA.y - pointB.y;    

        return Math.sqrt((dx * dx) + (dy * dy));
    }
}
pc.registerScript(GardenTouchInput, 'GardenTouchInput');
GardenTouchInput.addAttributes();

// MovesManager.js
var MovesManager = pc.createScript('movesManager');

pc.extend(MovesManager.prototype, {
    initialize: function () {
        MovesManager.instance = this;
        this._currentMoves = 0;
        this._startMoves = 1;

        this.app.on('SwapMode:onMoveStart', this._onMove, this);
    },

    _onMove: function () {
        if (this.hasInfiniteMoves()) {
            return;
        }

        this._currentMoves -= 1;
        this.app.fire('MovesManager:setMoves', this._currentMoves);
        TrackingManager.instance.onMove(this._currentMoves);
    },

    setMoveAmount: function (amount) {
        this._startMoves = amount;

        this._currentMoves = this._startMoves;
        this.app.fire('MovesManager:setMoves', this._currentMoves);
    },

    addMoves: function (amount) {
        this._currentMoves += amount;
        this.app.fire('MovesManager:setMoves', this._currentMoves);
    },

    getMoves: function () {
        if (this.hasInfiniteMoves()) {
            return 10;
        }

        return this._currentMoves;
    },

    getStartMoves: function () {
        return this._startMoves;
    },

    hasInfiniteMoves: function () {
        return this._startMoves === 0;
    },
});

// ForegroundTile.js
var ForegroundTile = pc.createScript('foregroundTile');

ForegroundTile.attributes.add('scriptName', { type: 'string', default: 'colorTile' });

ForegroundTile.attributes.add('hasColor', { type: 'boolean', default: true });
ForegroundTile.attributes.add('swappable', { type: 'boolean', default: true });
ForegroundTile.attributes.add('canExplode', { type: 'boolean', default: true });
ForegroundTile.attributes.add('countDown', { type: 'boolean', default: false });

ForegroundTile.attributes.add('bounceHeightPerCell', { type: 'number', default: 0.1, min: 0, max: 1, });
ForegroundTile.attributes.add('maxBounceDeltaCell', { type: 'number', default: 3, step: 1, min: 1, max: 10, precision: 0 });
ForegroundTile.attributes.add('bounceDuration', { type: 'number', default: 0.5, min: 0, max: 1, });
ForegroundTile.attributes.add('customScoreColor', { type: 'boolean', default: false });

ForegroundTile.attributes.add('scoreColorId', { type: 'rgb' });
ForegroundTile.attributes.add('scoreOutlineColorId', { type: 'rgb' });

ForegroundTile._States = Object.freeze({
    INACTIVE: 0,
    ACTIVE: 1
});

ForegroundTile._PowerStates = Object.freeze({
    ACTIVE: 0,
    IMMUNE: 1,
    TRIGGERED: 2,
});

pc.extend(ForegroundTile.prototype, {
    initialize: function () {
        var subClass = this.entity.script.get(this.scriptName);

        this._aabb = new pc.BoundingBox(new pc.Vec3(), new pc.Vec3(0.6, 0.6, 0.6));

        if (!subClass) {
            console.warn("No script is found with the name", this.scriptName, "Could be a default script");
            return;
        }

        this._defaultRotation = this.entity.getLocalEulerAngles().clone();

        //this.powerTileHandler = this.entity.script.powerTileHandler;

        this.typeID = 0; // tile type
        this.colorID = 0; // Color id

        this.subClass = subClass;
        this.subClass.init(this);

        this.x = null;
        this.y = null;

        // States stuff
        this._state = ForegroundTile._States.INACTIVE;
        this._powerState = ForegroundTile._PowerStates.INACTIVE;
        this.hasMoved = false;
        this.falling = false;
        this.moving = false;
        this.isMovedTile = false;
        this._preventDelay = false;
        this._hitByPower = false;
        this._hitByMatch = false;

        this._inChest = false;

        this.isDestroyed = false;

        this._ignoreDespawnStats = false;

        this._recycled = true;
        this.hintMoveLoops = 2; // amount of times the hinttween scales up and down to move

        // Tweens
        this._moveTween = null;
        this._fallTweens = [];

        this._deltaY = 0;

        this.powerAnimation = null;

        if (this.shinePoolEntity) {
            this.shinePool = this.shinePoolEntity.script.objectPool;
        }

        this.shinePool = PowerAnimationManager.instance.shinePool;

        // Highlight 
        this._model = this.entity.findByName('ModelEntity');
        this._highlightModel = this.entity.findByName('Highlight');

        this._highlightModel.enabled = false;

        if (this._model) {
            this._defaultModelRotation = this._model.getLocalRotation().clone();
            this._defaultModelScale = this._model.getLocalScale().clone();
        }

        // Delay
        this._isCountingDelay = false;

        // Others
        this.scoreValue = 0;
        this._isObjective = null;

        this._predefined = false;

        this.tileParticle = this.entity.script.get('tileParticle');
        this.app.on('ObjectiveManager:onObjectiveSet', this._onObjectiveSet, this);

        if (!this.entity.script.has('impulseHandler')) {
            this.entity.script.create('impulseHandler');
        }
    },

    // update: function(dt) {
    //     //this.app.renderLine(this._aabb.center.clone().add(new pc.Vec3(0, 0, 1)), this._aabb.center.clone().add(new pc.Vec3(0.5, 0.5, 0.5)), pc.Color.BLACK)

    //     if (this._isCountingDelay) {
    //         this._delayCounter += dt;
    //         if (this._delayCounter >= this.despawnDelay) {
    //             this._isCountingDelay = false;
    //             this._onDelayDone();
    //         }
    //     }
    // },

    _onDelayDone: function () {
        delete this.despawnTimer;

        if (typeof this.subClass._onDelayDone === 'function') {
            return this.subClass._onDelayDone();
        }

        if (!this._ignoreDespawnStats) {
            if (this.scoreValue) {
                GridManager.instance.showScore(this, this.scoreValue);
                this.scoreValue = 0;
            }

            if (this._isObjective && this._state === ForegroundTile._States.INACTIVE) {
                if (!ObjectiveManager.instance.isObjectiveCompleted(tileLayerEnum.FOREGROUND, this.typeID, this.colorID)) {
                    this.app.fire('ModelToUIManager:showAnimation', this.entity.getLocalPosition(), { layerID: tileLayerEnum.FOREGROUND, typeID: this.typeID, colorID: this.colorID }, 0 /*this.despawnDelay*/);
                    this.app.fire('ForegroundTile:onExplode', tileLayerEnum.FOREGROUND, this.typeID, this.colorID);
                }
            }
        }

        if (this._state === ForegroundTile._States.INACTIVE) {
            this.despawnAnimation();

            if (this.tileParticle) {
                GridManager.instance.showParticle(this.x, this.y, this.tileParticle.getTexture(), this.tileParticle.getColor());
            }
        }
    },

    explode: function () {
        if (!GridManager.instance.canExplode(this.x, this.y)) {
            // this.app.fire('ScoreManager:scoreForegroundTile', this.typeID, this._isObjective, this);
            return false;
        }

        this.entity.script.impulseHandler.stopTween();

        if (typeof this.subClass.explode === 'function') {
            return this.subClass.explode();
        }

        if (this.canExplode) {
            this.app.fire('ScoreManager:scoreForegroundTile', this.typeID, this._isObjective, this);
            this.despawn();
            return true;
        }
    },

    intersectsRay: function (ray) {
        this.setBoundingBox();
        if (!this.swappable) { return false; }
        return this._aabb.intersectsRay(ray);
    },

    setBoundingBox: function () {
        this._aabb.center.copy(this.entity.getPosition());
    },

    _onObjectiveSet: function () {
        this._isObjective = ObjectiveManager.instance.isTileOneOfObjectives(tileLayerEnum.FOREGROUND, this.typeID, this.colorID);
    },

    awake: function (position, parent, timer) {
        if (!this.entity.parent) {
            this.entity.reparent(parent.entity);
        }

        this.isDestroyed = false;

        if (this.subClass && typeof this.subClass.awake === 'function') {
            this.subClass.awake(timer);
        }

        if (position instanceof pc.Vec3) {
            this.entity.setLocalPosition(position);
            this._aabb.center.copy(position);
            this.setBoundingBox();
        }

        this.despawnDelay = 0;
        this._powerState = ForegroundTile._PowerStates.ACTIVE;
        this.entity.setLocalScale(pc.Vec3.ONE);
        this.parent = parent;
        this._preventDelay = false;
        this.despawnCause = null;
        this._hitByPower = false;
        this._hitByMatch = false;
        this._ignoreDespawnStats = false;
        this._recycled = false;
        this.powerAnimation = null;
        this._inChest = false;

        if (this._model) {
            this._model.setLocalPosition(0, 0, 0);
            this._model.setLocalScale(this._defaultModelScale);
            this._model.setLocalRotation(this._defaultModelRotation);
            this.entity.script.impulseHandler.setWiggle(false);
        }

        if (this._isObjective === null) {
            this._onObjectiveSet();
        }

        this._predefined = false;
        this.setHighlight(false);

        if (typeof this.subClass.onAwake === 'function') {
            this.subClass.onAwake();
            return;
        }

        this.entity.script.impulseHandler.reset();
    },

    setProperties: function (x, y) {
        this.x = x;
        this.y = y;
        this._state = ForegroundTile._States.ACTIVE;
        //this.entity.script.powerTileHandler.reset();
        this.entity.setLocalScale(1, 1, 1);
    },

    isSwappable: function () {
        // console.log(this.swappable, GridManager.instance.getBackgroundTile(this.x,this.y).foregroundSwappable,  GridManager.instance.getBackgroundTile(this.x,this.y))
        return this.swappable && GridManager.instance.getBackgroundTile(this.x, this.y).foregroundSwappable;
    },

    isSelectable: function () {
        return this.isSwappable() && GridManager.instance.getBackgroundTile(this.x, this.y).canForegroundMatch;
    },

    hasCoat: function () {
        return GridManager.instance.getBackgroundTile(this.x, this.y).isCoat() || GridManager.instance.getBackgroundTile(this.x, this.y)._changeToCoat;
    },

    getBackgroundTile() {
        return GridManager.instance.getBackgroundTile(this.x, this.y);
    },

    setHighlight: function (doHighlight) {
        try {
            this._highlightModel.enabled = doHighlight;

            if (doHighlight && this.subClass && typeof this.subClass.setHighlight === 'function') {
                this.subClass.setHighlight();
            }
        } catch (e) {
            console.log(e);
        }
    },

    spawnAnimation: function (duration, delay, doShine) {
        doShine = doShine || false;
        delay = delay || 0;
        if (duration === undefined) duration = GridManager.instance.despawnDuration;
        this.entity.setLocalScale(pc.Vec3.ZERO);
        this.stopHintAnimation();
        if ([foregroundTileEnum.LINE_H, foregroundTileEnum.LINE_V, foregroundTileEnum.BOMB, foregroundTileEnum.COLORBOMB].includes(this.typeID) && doShine) {
            this.shineAnimation(duration, delay);
        }
        this.appearTween = this.entity.tween(this.entity.getLocalScale()).to({ x: 1, y: 1, z: 1 }, duration, pc.BounceOut, delay).start();
    },

    shineAnimation: function (duration, delay) {
        this.shine = this.shinePool.use();
        this.shine.enabled = true;
        this.shine.reparent(this.entity);
        this.shine.setPosition(0, 0.2, 0);
        this.shineTween = this.shine.tween(this.shine.getLocalScale()).to({ x: 0, y: 0, z: 0 }, 0.2, pc.BounceOut, 1).start()
        this.shineTween.on('complete', this.stopShine, this);
    },

    stopShine: function () {
        if (!this.shine) return;
        this.shine.reparent(null);
        this.shine.enabled = false;
        this.shine.setLocalScale(0.01, 0.01, 0.01);
        this.shinePool.recycle(this.shine);
        if (this.shineTween) {
            this.shineTween.stop();
            this.shineTween = null;
        }

        this.shine = null;
    },

    despawnAnimation: function (duration) {
        if (typeof this.subClass.despawnAnimation === 'function') {
            return this.subClass.despawnAnimation();
        }

        if (duration === undefined) duration = GridManager.instance.despawnDuration;

        if (this.despawnEndPosition) duration = GridManager.instance.powerTileCreationDuration;

        this.disappearTween = this.entity.tween(this.entity.getLocalScale()).to({ x: 0, y: 0, z: 0 }, duration, pc.BackIn).start();

        this.stopHintAnimation();

        if (this.despawnEndPosition) {
            this.move(this.despawnEndPosition.x, this.despawnEndPosition.y, duration);
            this.despawnEndPosition = null;
        }

        GridManager.instance.playSFX('flower_destroy.mp3');
        this.disappearTween.on('complete', this._recycle, this);
    },

    appear: function (fromX, fromY, duration, delay) {
        if (typeof this.subClass.appear === 'function') {
            this.subClass.appear();
        }

        this._deltaY += fromY - this.y;

        var currentPosition = GridManager.instance.calculatePosition(fromX, fromY, this.entity.getLocalPosition().z);
        this.entity.setLocalPosition(currentPosition);
        this.isMovedTile = true;

        this.applyGravity(this.x, this.y, this.x, this.y, duration, delay);

        return this._getFallTweenDuration() + this._calculateBounceDuration();
    },

    move: function (x, y, duration, delay) {
        if (typeof this.subClass.move === 'function') {
            this.subClass.move(x, y, duration);
        }

        if (!duration) duration = GridManager.instance.moveDuration;
        this.x = x;
        this.y = y;
        var newPosition = GridManager.instance.calculatePosition(x, y, this.entity.getLocalPosition().z);

        if (this._moveTween) {
            this._moveTween.stop();
        }
        this.moving = true;

        this.moveTween = this.entity
            .tween(this.entity.getLocalPosition()).to({ x: newPosition.x, y: newPosition.y, z: newPosition.z }, duration, pc.QuadraticInOut, delay || 0)
            .start();
        this.moveTween.on('complete', () => {
            this.moving = false;
        })
    },

    applyGravity: function (fromX, fromY, toX, toY, duration, delay) {
        delay = delay || 0;

        if (typeof this.subClass.applyGravity === 'function') {
            this.subClass.applyGravity(fromX, fromY, toX, toY, duration, delay);
        }

        var toPosition = this.parent.calculatePosition(toX, toY, this.entity.getLocalPosition().z);
        this.isMovedTile = true;

        this._deltaY += fromY - toY;

        var startDuration = this._fallTweens.length === 0 ? GridManager.instance.startFallDuration : 0;

        var tween = this.entity.tween(this.entity.getLocalPosition()).to({ x: toPosition.x, y: toPosition.y, z: toPosition.z }, duration + startDuration, pc.QuadraticIn, delay);

        this.x = toX;
        this.y = toY;

        if (this._fallTweens.length === 0) {
            tween.start();
        } else {
            this._fallTweens[this._fallTweens.length - 1].chain(tween).off('complete', this._onFallComplete, this);
        }

        tween.on('complete', this._onFallComplete, this);

        this._fallTweens.push(tween);

        this.falling = true;

        return this._getFallTweenDuration();
    },

    stopHintAnimation: function () {
        if (this._isPlayingHint) {
            this._isPlayingHint = false;
            this.hintTween.stop();
            this.entity.setLocalScale(pc.Vec3.ONE);

            if (this.hintMoveTween) {
                this.hintMoveTween.stop();
                this.hintMoveTween = null;
            }
        }
    },

    unableToExplode: function () {
        GridManager.instance.getBackgroundTile(this.x, this.y);

        return GridManager.instance.getBackgroundTile(this.x, this.y).onlyBackgroundExplodes;
    },

    isFlower: function () {
        return this.typeID === foregroundTileEnum.DEFAULT;
    },

    isPowerTile: function () {
        return PowerTileManager.instance.isPowerTile(this.typeID);
    },

    isActive: function () {
        return this._state === ForegroundTile._States.ACTIVE;
    },

    isPowerActive: function () {
        return this._powerState === ForegroundTile._PowerStates.ACTIVE;
    },

    setHitByMatch: function () {
        this._hitByMatch = true;
    },

    setHitByPower: function () {
        if (GridManager.instance.canExplode(this.x, this.y)) {
            this._hitByPower = true;
        }

        return this._hitByPower;
    },

    isHitByPower: function () {
        return this._hitByPower;
    },

    isHitByMatch: function () {
        return this._hitByMatch;
    },

    doHintAnimation: function () {
        this.stopHintAnimation();
        this._isPlayingHint = true;
        var hintCounter = 0;
        this.hintTween = this.entity.tween(this.entity.getLocalScale()).to({ x: 1.1, y: 1, z: 1.1 }, 0.5, pc.SineInOut).loop(true).yoyo(true).start();

        this.hintTween.on('loop', function () {
            if (this.hintMoveTween) {
                hintCounter++;
                if (hintCounter % (this.hintMoveLoops * 2) === 0) {
                    this.repeatHintMove();
                }
            }

            // extra check because the tween gets stuck randomly some times 
            if (!this._isPlayingHint) {
                this.hintTween.stop();
                if (this.hintMoveTween) {
                    this.hintMoveTween.stop();
                    this.hintMoveTween = null;
                }
            }
        }.bind(this));
    },

    repeatHintMove: function () {
        this.hintMoveTween.start();
    },

    makeHintMoveAnimation: function (x, y) {
        var xMove = x * 0.1;
        var yMove = y * 0.1;
        var position = this.entity.getLocalPosition();
        this.hintMoveTween = this.entity.tween(this.entity.getLocalPosition())
            .to({ x: position.x - xMove, y: position.y - yMove, z: position.z }, 0.2, pc.SineInOut)
            .yoyo(true)
            .repeat(4)
            .delay(0.1).start();
    },

    setDespawnDelay: function (delay) {
        if (this.subClass.setDespawnDelay) {
            this.subClass.setDespawnDelay(delay);
        }

        if (!GridManager.instance.canExplode(this.x, this.y)) {
            // this.despawnDelay = delay;
            this.setTimerDespawnDelay(delay);
            return;
        }

        if (!this._preventDelay) {
            this._preventDelay = true;

            if (typeof delay !== 'number' || isNaN(delay)) {
                console.warn("Despawn delay is not a number", delay);

                this.setTimerDespawnDelay(0.01);
            } else {
                this.setTimerDespawnDelay(delay);
            }
        }
    },

    setDespawnCause: function (powerID) {
        // only give the despawnCause to powerTiles
        this.despawnCause = powerID;
    },

    getDespawnCause: function () {
        return this.despawnCause;
    },

    setScoreAfterDelay: function (score) {
        this.scoreValue += score;

        //this._startDelayCountdown();
    },

    getDespawnDelay: function (withoutEndDelay) {
        if (typeof this.subClass.getDespawnDelay === 'function') {
            return this.subClass.getDespawnDelay(withoutEndDelay);
        }

        return this.despawnTimer ? (this.despawnTimer.secsLeft || 0) : 0;
    },

    despawn: function () {
        this._state = ForegroundTile._States.INACTIVE;
        this._startDelayCountdown();
        if (this.despawnCause !== null) {
            this.despawnCause = null;
        }
    },

    hasExploded: function () {
        if (typeof this.subClass.hasExploded === "function") {
            return this.subClass.hasExploded();
        }

        return this._state === ForegroundTile._States.INACTIVE;
    },

    resetTileOrientation: function () {
        this.entity.setLocalEulerAngles(this._defaultRotation);
    },

    shakeTile: function (delay) {
        if (this.shakeTween) {
            return;
        }

        delay = delay ? delay : 0;
        var rotation = this.entity.getLocalEulerAngles().clone();
        this.entity.setLocalEulerAngles(rotation.x, rotation.y, rotation.z - 5);

        this.shakeTween = this.entity.tween(this.entity.getLocalEulerAngles())
            .rotate({ x: rotation.x, y: rotation.y, z: rotation.z + 5 }, 0.1, pc.SineInOut)
            .loop(true)
            .yoyo(true)
            .delay(delay)
            .start();
    },


    enlargeTile: function () {
        this.enlargeTween = this.entity.tween(this.entity.getLocalScale())
            .to({ x: 1.2, y: 1.2, z: 1.2 }, 0.2, pc.SineInOut).start().yoyo().repeat(2);
    },

    _startDelayCountdown: function () {
        this._isCountingDelay = true;
        if (!this.despawnTimer) {
            this.despawnTimer = pc.timer.add(0.01, this._onDelayDone, this);
        }
        this._delayCounter = 0;
    },

    ignoreDespawnStats: function () {
        this._ignoreDespawnStats = true;
    },

    updateFlowerStatistics: function () {
        if (typeof this.subClass.updateFlowerStatistics === 'function') {
            this.subClass.updateFlowerStatistics();
            return;
        }
    },

    _getFallTweenDuration: function () {
        if (this._fallTweens.length === 0) {
            return 0;
        }

        var totalDuration = this._calculateBounceDuration();

        for (var i = 0; i < this._fallTweens.length; i++) {
            totalDuration += this._fallTweens[i].duration + this._fallTweens[i]._delay;
        }

        return totalDuration;
    },

    _onFallComplete: function () {
        this._bounce();
    },

    _bounce: function () {
        var currentPosition = this.entity.getLocalPosition();

        var duration = this._calculateBounceDuration();

        this.bounceTween = this.entity.tween(this.entity.getLocalPosition()).to({ x: currentPosition.x, y: currentPosition.y + this._calculateBounceHeight(), z: currentPosition.z }, duration, pc.Bounce);
        this.bounceTween.start();
        this.bounceTween.on('complete', function () {
            this.falling = false;
            this._deltaY = 0;
        }, this);

        //GridManager.instance.playSFX('tile_drop_flowers.mp3');

        //         var dur = 0;

        //         this.bounceTween.on('update', function(dt) {
        //             dur += dt;

        //             if (dur >= this.bounceDuration / 2) {
        //                 GridManager.instance.playSFX('tile_drop_flowers.mp3');
        //                 dur = 0;
        //             }
        //         }, this);

        this._fallTweens.length = 0;
    },

    _calculateBounceHeight: function () {
        return Math.min(this._deltaY, this.maxBounceDeltaCell) * this.bounceHeightPerCell || this.bounceHeightPerCell;
    },

    _calculateBounceDuration: function () {
        return this.bounceDuration;
    },

    setDespawnEndPosition: function (x, y) {
        this.despawnEndPosition = { x: x, y: y };
    },

    _recycle: function () {
        this.stopAllTweens();

        // For batching, removing this
        // this.entity.enabled = false;
        this.entity.reparent(null);
        this._recycled = true;
        this.isDestroyed = true;

        if (typeof this.subClass.recycle === 'function') {
            this.subClass.recycle();
        }

        TileLibrary.instance.returnObject(this.entity, tileLayerEnum.FOREGROUND, this.typeID, this.colorID);
    },

    stopAllTweens: function () {
        this._stopDelayCountdown();

        if (this.hintMoveTween) {
            this.hintMoveTween.stop();
            this.hintMoveTween = null;
        }

        if (this.shine) {
            this.stopShine();
        }

        if (this.fallTween) {
            this.fallTween.stop();
        }

        if (this.appearTween) {
            this.appearTween.stop();
        }

        if (this.moveTween) {
            this.moveTween.stop();
        }

        if (this.rotateTween) {
            this.rotateTween.stop();
        }

        if (this.fallOutOfLevelTween) {
            this.fallOutOfLevelTween.stop();
        }

        if (this._pulseTween) {
            this._pulseTween.stop();
        }

        this.stopAffectedTweens();

        for (var i = 0; i < this._fallTweens.length; i++) {

            this._fallTweens[i].stop();
        }

        this._fallTweens.length = 0;

        if (this.bounceTween) {
            this.bounceTween.stop();
        }

        this.stopHintAnimation();
    },

    stopAffectedTweens: function () {
        if (this.shakeTween) {
            this.resetTileOrientation();
            this.shakeTween.stop();
            delete this.shakeTween;
        }

        if (this.enlargeTween) {
            this.enlargeTween.stop();
            this.entity.setLocalScale(1, 1, 1);
        }
    },

    _stopDelayCountdown: function () {
        this._isCountingDelay = false;
        this._delayCounter = 0;
    },

    pulse: function (deltaX, deltaY, amplitude, delay, duration) {
        if (!this._model) {
            return;
        }

        if (this._state === ForegroundTile._States.INACTIVE) {
            return;
        }

        this.entity.script.impulseHandler.impulse(deltaX, deltaY, amplitude, delay, duration);
    },

    isColorPowerTile: function () {
        return this.typeID === foregroundTileEnum.COLORBOMB;
    },

    setPowerState: function (state) {
        this._powerState = state;
    },

    isPowerState: function (state) {
        return this._powerState === state;
    },

    setPredefined: function () {
        this._predefined = true;
    },

    isPredefined: function () {
        return this._predefined;
    },

    isSinker: function () {
        return this.typeID === foregroundTileEnum.SINKER_1; // || this.typeID === foregroundTileEnum.SINKER_2 || this.typeID === foregroundTileEnum.SINKER_3;  
    },

    isSwitcher: function () {
        return this.typeID === foregroundTileEnum.SWITCHER;
    },

    setCoatSize: function () {
        if (this._model) {
            var hasCoat = this.hasCoat();

            this.entity.script.impulseHandler.setWiggle(hasCoat);

            if (this.hasCoat()) {
                this._setTileSize(ForegroundTile.COAT_SIZE);
            } else {
                this._setTileSize(ForegroundTile.NO_COAT_SIZE);
                this._model.setLocalRotation(this._defaultModelRotation);
            }
        }
    },

    canGetPointsFromDestroyedPowerTile: function () {
        if (this.subClass && this.subClass.canGetPointsFromDestroyedPowerTile) {
            return this.subClass.canGetPointsFromDestroyedPowerTile();
        }

        return true;
    },

    setPowerAnimation: function (data) {
        this.powerAnimation = data;
    },

    getPowerAnimation: function () {
        return this.powerAnimation;
    },

    putTileInChest: function (value) {
        this._inChest = value;
    },

    _setTileSize: function (scale) {
        if (this._inChest) {
            return;
        }

        this._model.setLocalScale(
            this._defaultModelScale.x * scale,
            this._defaultModelScale.y * scale,
            this._defaultModelScale.z * scale
        );
    },

    tweenSize: function (scale, duration) {
        var coatMultiplier = 1;

        if (GridManager.instance.hasCoat) {
            coatMultiplier = this.hasCoat() ? ForegroundTile.COAT_SIZE : ForegroundTile.NO_COAT_SIZE;
        }

        this._model.tween(this._model.getLocalScale())
            .to({ x: this._defaultModelScale.x * scale * coatMultiplier, y: this._defaultModelScale.y * scale * coatMultiplier, z: this._defaultModelScale.z * scale * coatMultiplier }, duration, pc.BackOut)
            .start();
    },

    setTimerDespawnDelay: function (delay) {
        this.despawnDelay = delay;
        if (this.despawnTimer) {
            pc.timer.adjustSecsLeft(this.despawnTimer, delay);
        } else {
            this.despawnTimer = pc.timer.add(delay || 0.01, this._onDelayDone, this);
        }
    }
});

ForegroundTile.COAT_SIZE = 1.05;
ForegroundTile.NO_COAT_SIZE = 0.95;


// LoadSceneController.js
var LoadSceneController = pc.createScript('loadSceneController');

pc.extend(LoadSceneController.prototype, {
    initialize: function () {
        this._loading = false;
        this._scene = null;
        this._currentState = -1;
        this._sceneLoaded = false;
        this._noInitialFade = false;

        this._totalAssetsToLoad = 0;
        this._assetsLoaded = 0;

        this._tagsToExclude = ['level', 'sfx'];
    },

    _resetLoadingStats: function () {
        this._totalAssetsToLoad = 0;
        this._assetsLoaded = 0;
    },

    startLoadCoroutine: function (scene, noInitialFade, loadSceneText, musicToSetWhenLoading) {
        this._loading = true;
        this._sceneLoaded = false;
        this._assetFinishedLoading = false;

        this._currentState = LoadSceneController._States.START;

        this._scene = scene;
        this._noInitialFade = noInitialFade;

        this._resetLoadingStats();

        this._goToNextState();
    },

    _goToNextState: function () {
        this._currentState++;

        //current State behaviour
        switch (this._currentState) {
            case LoadSceneController._States.FADEOUT:

                if (!this._noInitialFade) {
                    this.app.fire('UIManager:showUI', 'LoadingScreen', LoadSceneController.TYPE);
                }

                LoadingScreen.instance.once('fadeInComplete', this._waitForFadeIsDone, this);

                break;

            case LoadSceneController._States.PRELOADSCENE:
                //TODO: UNLOAD ASSETS FROM VRAM
                this._startPreLoadScene();
                break;

            case LoadSceneController._States.LOADSCENE:
                this._startLoadScene();
                break;

            case LoadSceneController._States.POSTLOADSCENE:
                //TODO: RELOAD NECESSARY ASSETS FROM VRAM
                this._startPostLoadScene();
                break;

            case LoadSceneController._States.FINISH:
                //console.log('fire FINISH')
                this._wait(2);
                this._startFinish();

                break;
        }
    },

    update: function (dt) {
        if (!this._loading) {
            return;
        }

        // console.log(this.app.assets._loader._requests)

        switch (this._currentState) {
            case LoadSceneController._States.FADEOUT:
                break;

            case LoadSceneController._States.PRELOADSCENE:
                this._wait(2);
                break;

            case LoadSceneController._States.POSTLOADSCENE:
                this._waitForFadeIsDone();
                break;
        }
    },

    _waitForFadeIsDone: function () {
        this._goToNextState();
    },

    _wait: function (duration) {
        // TODO Add a delay
        this._goToNextState();
    },

    _startPreLoadScene: function () {
        this._timer = 0;
    },

    _startLoadScene: function () {
        Application.loadLevelAsync(this._scene, this._onSceneLoaded, this);
    },

    _onSceneLoaded: function () {
        this._sceneLoaded = true;

        var assetsToLoad = this.filterAssetsLoading2();

        this._totalAssetsToLoad = assetsToLoad.length;
        this._assetsLoaded = 0;

        var loaded = 0;

        // console.log(this._totalAssetsToLoad)

        for (var i = 0; i < assetsToLoad.length; i++) {
            assetsToLoad[i].ready(this._updateProgress, this);
            assetsToLoad[i].on('error', this._updateProgress, this);
        }

        this.app.fire('loadSceneController:progress', this._assetsLoaded, this._totalAssetsToLoad);

        this.app.assets.on('load:begin', this._addMoreAssets, this);

        if (this._totalAssetsToLoad === 0) {
            this._goToNextState();
        }
    },

    _addMoreAssets: function (asset) {
        if (asset.tags.has(...this._tagsToExclude)) {
            return;
        }

        this._totalAssetsToLoad++;

        asset.ready(this._updateProgress, this);

        this.app.fire('loadSceneController:progress', this._assetsLoaded, this._totalAssetsToLoad);
    },

    filterAssetsLoading2() {
        const array = [];

        this.app.assets._assets.forEach(asset => {
            if (asset.loading && !asset.tags.has(...this._tagsToExclude)) {
                array.push(asset)
            }
        });

        return array;
    },

    filterAssetsLoading() {
        const array = [];

        this.app.assets._assets.forEach(asset => {
            if (asset.loading) {
                array.push(asset)
            }
        });

        return array;
    },

    _updateProgress: function () {
        this._assetsLoaded++;

        var assetsToLoad = this.filterAssetsLoading();

        this.app.fire('loadSceneController:progress', this._assetsLoaded, this._totalAssetsToLoad);

        // console.log(this._assetsLoaded)

        if (this._assetsLoaded >= this._totalAssetsToLoad) {
            this._goToNextState();
        }
    },

    _startPostLoadScene: function () {
        this.app.lightmapper.bake();
        // TODO fade out.
    },

    _startFinish: function () {
        // TODO Rebatch
        const loadDuration = (Date.now() - LoadSceneController.loadDuration) / 1000;

        if (this._scene === 'Garden') {
            Wrapper.instance.sendGAEvent(Wrapper.GA_EVENT_TYPE.DESIGN, {
                eventId: 'garden:load:start',
                value: loadDuration,
            });
        }

        LoadSceneController.endFTUEEvent(loadDuration);

        //this.app.fire('UIManager:hideAll');
        this.app.fire('switchedScene');
        // Hide loadscreen

        //this.app.fire('UIManager:showUI', 'Menu');

        // Let GameManager know if it is instanced
        if (GameManager.instance) {
            GameManager.instance.loadSceneDone();
        }

        // Destroy self
        this.entity.destroy();



        LoadSceneController.isLoading = false;

        this.app.assets.off('load:begin', this._addMoreAssets, this);

        this.fire('finish');
    },
});

pc.extend(LoadSceneController, {
    isLoading: false,
    ftue: false,
    loadDuration: 0,
    _States: Object.freeze({
        START: 0,
        FADEOUT: 1,
        PRELOADSCENE: 2,
        LOADSCENE: 3,
        POSTLOADSCENE: 4,
        FINISH: 5,
    }),
    load: function (scene, noInitialFade, type = LoadingScreen.BACKGROUND.GARDEN) {
        if (LoadSceneController.isLoading) {
            console.error("Already loading, please wait.");
        }
        else {
            LoadSceneController.isLoading = true;
            LoadSceneController.TYPE = type;
            // Instantiate LoadSceneController
            var controllerGO = new pc.Entity("LoadSceneController");
            controllerGO.reparent(pc.Application.getApplication().root);
            // GameObject.DontDestroyOnLoad(controllerGO);
            controllerGO.addComponent('script');
            var controller = controllerGO.script.create('loadSceneController');
            controller.startLoadCoroutine(scene, noInitialFade);

            this.loadDuration = Date.now();

            if (scene === 'Garden') {
                Wrapper.instance.sendGAEvent(Wrapper.GA_EVENT_TYPE.DESIGN, {
                    eventId: 'garden:load:start',
                });

                if (WorldUnlockManager.instance.unlocked) {
                    this.doFTUEEvent();
                }
            }

            return controller;
        }
    },

    doFTUEEvent: function () {
        this.ftue = true;

        Wrapper.instance.sendGAEvent(Wrapper.GA_EVENT_TYPE.DESIGN, {
            eventId: 'tutorialFunnel:gardenLoadStart',
        });
    },

    endFTUEEvent: function (loadDuration) {
        if (this.ftue) {
            this.ftue = false;
            Wrapper.instance.sendGAEvent(Wrapper.GA_EVENT_TYPE.DESIGN, {
                eventId: 'tutorialFunnel:gardenLoadComplete',
                value: loadDuration,
            });
        }
    },
});



// ColorTile.js
var ColorTile = pc.createScript('colorTile');

// if you are gonna parse, uncomment this en comment it when you are done
// var tileColorEnum = Object.freeze({
//     NONE: 0,
//     BLUE: 1,
//     YELLOW: 2,
//     RED: 3,
//     PURPLE: 4,
//     GREEN: 5,
//     ORANGE: 6,
// });

ColorTile.colorEnum = [
    { NONE: tileColorEnum.NONE },
    { BLUE: tileColorEnum.BLUE },
    { YELLOW: tileColorEnum.YELLOW },
    { RED: tileColorEnum.RED },
    { PURPLE: tileColorEnum.PURPLE },
    { GREEN: tileColorEnum.GREEN },
    { ORANGE: tileColorEnum.ORANGE }
];

ColorTile.attributes.add('colorId', { type: 'number', enum: ColorTile.colorEnum });

pc.extend(ColorTile.prototype, {
    initialize: function () {
        this._fallTweens = [];

    },

    init: function (superClass) {
        this.superClass = superClass;

        this.superClass.typeID = foregroundTileEnum.DEFAULT;
        this.superClass.colorID = this.colorId;
    },

    updateFlowerStatistics: function () {
        this.app.fire('EndScreen:addFlower');

        StatisticsManager.instance.incrementStatistic("flower_destroyed", { color: TileLibrary.instance.getColorName(this.superClass.colorID) }, 1);


        // if (this.superClass.colorID === tileColorEnum.BLUE) StatisticsManager.instance.incrementStatistic("blue_flowers_destroyed", 1);
        // if (this.superClass.colorID === tileColorEnum.YELLOW) StatisticsManager.instance.incrementStatistic("yellow_flowers_destroyed", 1);
        // if (this.superClass.colorID === tileColorEnum.RED) StatisticsManager.instance.incrementStatistic("red_flowers_destroyed", 1);
        // if (this.superClass.colorID === tileColorEnum.PURPLE) StatisticsManager.instance.incrementStatistic("purple_flowers_destroyed", 1);
        // if (this.superClass.colorID === tileColorEnum.GREEN) StatisticsManager.instance.incrementStatistic("green_flowers_destroyed", 1);
        // if (this.superClass.colorID === tileColorEnum.ORANGE) StatisticsManager.instance.incrementStatistic("orange_flowers_destroyed", 1);
    },
});


// GardenObjectColliderList.js
class GardenObjectColliderList extends pc.ScriptType {
    static addAttributes(){
        this.attributes.add('optionBroken', {type: 'entity', title: 'Colliders for brokenModel'});
        this.attributes.add('option1', {type: 'entity', title: 'Colliders for option 1'});
        this.attributes.add('option2', {type: 'entity', title: 'Colliders for option 2'});
        this.attributes.add('option3', {type: 'entity', title: 'Colliders for option 3'});
    }
}
pc.registerScript(GardenObjectColliderList, 'gardenObjectColliderList');
GardenObjectColliderList.addAttributes();

// objectOptions.js
class ObjectOptions extends pc.ScriptType {
    static addAttributes() {
        // object parameters
        this.selectedOption = undefined;

        this.states = Object.freeze({
            Locked: 0,
            Unlocked: 1,
            ToSelect: 2
        });

        this.attributes.add('objectCostInStars', { type: 'number', default: 3, title: 'payment in stars' });
        this.attributes.add('amountOfZoomOnFocus', { type: 'number', default: 0, title: 'amount of zoom when the object is focused' });
        this.attributes.add('focusPoint', { type: 'entity' });
        this.attributes.add('firstObject', { type: 'boolean', default: false });
        this.attributes.add('objectState', { type: 'number', enum: [{ 'Locked': ObjectOptions.states.Locked }, { 'Unlocked': ObjectOptions.states.Unlocked }, { 'ToSelect': ObjectOptions.states.ToSelect }], default: 0 });
        this.attributes.add('baseModel', { type: 'asset', title: 'The base model / broken state of the object' });
        this.attributes.add('objectOptions', { type: 'asset', array: true, title: 'The objects that can be placed here' });
        this.attributes.add('materialOptions', { type: 'asset', assetType: 'material', array: true, title: 'Instead of objects you can also use materials' });
        this.attributes.add('objectImages', { type: 'asset', assetType: 'sprite', array: true, title: 'Images of the buildings' });
        this.attributes.add('brokenObjectImage', { type: 'asset', assetType: 'sprite', title: 'Images of the broken object' });
        this.attributes.add('descriptionText', { type: 'string' });
        this.attributes.add('tweenWhenSelected', { type: 'boolean', default: true });
    }

    initialize() {
        if (!this.descriptionText || this.descriptionText.length === 0) {
            console.error("No descriptionText found!", this);
        }

        this.lastObject = false;

        this.amountOfStars = this.amountOfStars || 0;//to unlock
        // this.app.on('AreaManager:reset', this.setModel, this);
        this.app.on('GardenUIEntity:cheatFired', this.cheatFunction, this);

        if (this.world === 1 && this.firstObject) {
            this.app.on('ObjectHandler:getFirstUnlock', this.sendSelf, this);
        }

        this.app.on('rebatch', this.rebatch, this);
        this.on('destroy', this._onDestroy, this);

        this.activeCollider = 0;
        this.selectedModel = 0;
        this.colliders = [];
        this.currentIndex = this.objectOptions.findIndex(asset => asset && asset.id === this.entity.model.asset);

        // this.checkState();

        // if (this.objectState === ObjectOptions.states.Unlocked) {
        //     this.lazyLoadAll();
        // }
    }

    checkCulling() {
        if (this.focusPoint) {
            var focusPointInsideOccluder = Occluder.instance.isInside(this.focusPoint);

            if (focusPointInsideOccluder && this.entity.model.enabled) {
                this.entity.model.enabled = false;
            } else if (!focusPointInsideOccluder && !this.entity.model.enabled) {
                this.entity.model.enabled = true;
            }
        } else {
            var entityInsideOccluder = Occluder.instance.isInside(this.entity);

            if (entityInsideOccluder && this.entity.model.enabled) {
                this.entity.model.enabled = false;
            } else if (!entityInsideOccluder && !this.entity.model.enabled) {
                this.entity.model.enabled = true;
            }
        }
    }

    _onDestroy() {
        this.app.off('GardenUIEntity:cheatFired', this.cheatFunction, this);
        this.app.off('rebatch', this.rebatch, this);

        if (this.world === 1 && this.firstObject) {
            this.app.off('ObjectHandler:getFirstUnlock', this.sendSelf, this);
        }
    }

    cheatFunction() {
        this.checkState();
    }

    sendSelf() {
        this.app.fire('ObjectOptions:sendSelf', this);
    }

    updateCurrentIndex() {
        this.currentIndex = this.objectOptions.findIndex(asset => asset && asset.id === this.entity.model.asset);
    }

    getCurrentIndex() {
        if ((this.currentIndex + 1) > 0) {
            return this.currentIndex;
        } else {
            return 3;
        }
    }

    setState(value) {
        this.objectState = value;
    }

    checkState() {
        console.warn("Check state is deprecated.")
        var world = this.world - 1;
        if (world < 0) return;

        if (Object.values(LevelDataManager.instance._starData)[world] < this.amountOfStars) { //if you want area stars
            this.setState(ObjectOptions.states.Locked);
            this.setAssetToSelection(3);
        } else {
            this.setState(ObjectOptions.states.Unlocked);
        }
    }

    rebatch() {
        if (!this.entity.model) {
            console.warn("no model found", this.entity);
            return;
        }
        this.batchGroupID = this.entity.model.batchGroupId;
        if (this.batchGroupID !== -1) {
            this.app.batcher.markGroupDirty(this.batchGroupID);
        }
    }

    setAssetToSelection(id) {
        if (id === 3) {
            if (this.baseModel) {
                this.entity.model.asset = this.baseModel;
                this.setCollider(id);
            }
        } else if (this.objectOptions.length > 0) {
            this.entity.model.asset = this.objectOptions[id];
            this.setCollider(id);
        } else {
            var meshInstances = this.entity.model.meshInstances;
            for (var i = 0; i < meshInstances.length; ++i) {
                meshInstances[i].material = objectOptions.materialOptions[id].resource;
            }
        }

        this.currentIndex = id;

        this.currentModel = this.app.assets.get(this.entity.model.asset);
        this.currentMaterial = [];
        this.currentTexture = [];

        if (this.currentModel instanceof pc.Asset) {
            this.currentModel.ready((asset) => {
                for (let i = 0; i < asset.resource.meshInstances.length; i++) {
                    var meshInstance = asset.resource.meshInstances[i];

                    if (meshInstance.material._assetReferences.diffuseMap) {
                        this.currentTexture.push(meshInstance.material._assetReferences.diffuseMap.asset);

                        if (meshInstance.material._assetReferences.diffuseMap.parent) {
                            this.currentMaterial.push(meshInstance.material._assetReferences.diffuseMap.parent);
                        }
                    }

                    if (meshInstance.material._assetReferences.opacity) {
                        this.currentTexture.push(meshInstance.material._assetReferences.opacity.asset);
                    }
                }
            });
        }

    }
    // handleStateChange: function(){
    //     this.entity.model.layers = this.objectState === 0 ? [this.lockedLayer] : [this.unlockedLayer];
    // },


    getColliderId() {
        var id = 0;
        var list = this.boundingBoxOptions.script.gardenObjectColliderList;

        if (list.option1.enabled) {
            id = 0;
        }
        if (list.option2.enabled) {
            id = 1;
        }
        if (list.option3.enabled) {
            id = 2;
        }
        if (list.optionBroken.enabled) {
            id = 3;
        }
        return id;
    }

    setCollider(index) {
        if (!this.boundingBoxOptions) {
            this.boundingBoxOptions = this.entity.findByTag('BBOptions')[0];
            if (!this.boundingBoxOptions) {
                console.log('object has no bounding box')
                return;
            }
        }

        var list = this.boundingBoxOptions.script.gardenObjectColliderList;

        if (!list.optionBroken || !list.option2 || !list.option3 || !list.option1) {
            console.warn("No collider found for the entity", list.name, list);
            return;
        }

        switch (index) {
            case 0: //option 1
                list.optionBroken.enabled = false;
                list.option2.enabled = false;
                list.option3.enabled = false;
                list.option1.enabled = true;
                break;
            case 1: // option 2
                list.optionBroken.enabled = false;
                list.option1.enabled = false;
                list.option3.enabled = false;
                list.option2.enabled = true;
                break;
            case 2: // option 3
                list.optionBroken.enabled = false;
                list.option1.enabled = false;
                list.option2.enabled = false;
                list.option3.enabled = true;
                break;
            case 3: // broken
                list.option1.enabled = false;
                list.option2.enabled = false;
                list.option3.enabled = false;
                list.optionBroken.enabled = true;
                break;
            default:
                list.option1.enabled = false;
                list.option2.enabled = false;
                list.option3.enabled = false;
                list.optionBroken.enabled = true;
                break;
        }
    }

    lazyLoadAll() {
        LazyLoader.instance.lazyLoadParallel(this.objectOptions);
    }
}

pc.registerScript(ObjectOptions, 'objectOptions');
ObjectOptions.addAttributes();

// circleFill.js
var CircleFill = pc.createScript('circleFill');

CircleFill.attributes.add('vs', {
    type: 'asset',
    assetType: 'shader',
    title: 'Vertex Shader'
});

CircleFill.attributes.add('fs', {
    type: 'asset',
    assetType: 'shader',
    title: 'Fragment Shader'
});

CircleFill.attributes.add('cutoutMap', {
    type: 'asset',
    assetType: 'texture',
    title: 'Cutout Map'
});


CircleFill.attributes.add('circleColor', { type: 'rgba', title: 'Circle Color' });

pc.extend(CircleFill.prototype, {
    initialize: function() {
        this.onAttributeChange();
        this.time = 0;

        var app = this.app;
        var gd = app.graphicsDevice;

        var heightTexture = this.cutoutMap.resource;
        
        var vertexShader = this.vs.resource;
        var fragmentShader = "precision " + gd.precision + " float;\n";
        fragmentShader = fragmentShader + this.fs.resource;

        // A shader definition used to create a new shader.
        var shaderDefinition = {
            attributes: {
                aPosition: pc.SEMANTIC_POSITION,
                aUv0: pc.SEMANTIC_TEXCOORD0
            },
            vshader: vertexShader,
            fshader: fragmentShader
        };

        // Create the shader from the definition
        this.shader = new pc.Shader(gd, shaderDefinition);

        // Create a new material and set the shader
        this.material = new pc.Material();
        this.material.blendType = pc.BLEND_PREMULTIPLIED;
        
        this.entity.element.material = this.material;

        this.material.shader = this.shader;
        this.material.setParameter('uTime', 0);

        this.material.setParameter('cutoutMap', heightTexture);
        this.material.setParameter('baseColor', [this.circleColor.r, this.circleColor.g, this.circleColor.b, 1.0]);
        
        this.on('destroy', this.onDestroy, this);
    },
    
    onDestroy: function() {
        this.material.destroy();
        delete this.material;
        
        this.shader.destroy();
        delete this.shader;
    },
    
    onAttributeChange: function() {          
        this.on('attr:circleColor', function (value, prev) {
            this.material.setParameter('baseColor', [this.circleColor.r, this.circleColor.g, this.circleColor.b, 1.0]);
        });
    },
    
    updateValue: function(percentage) {
        this.material.setParameter('uTime', percentage);
    },
    
    updateColor: function(color) {
        this.material.setParameter('baseColor', [color.r, color.g, color.b, 1.0]);
    }
});

// Wall.js
var Wall = pc.createScript('wall');

pc.extend(Wall.prototype, {
    initialize: function() {
        
    },
    
    init: function(superClass) {
        this.superClass = superClass;
        
        this.superClass.colorID = tileColorEnum.NONE;
        this.superClass.typeID = backgroundTileEnum.WALL;
    },
    
    explode: function() {
        
    },
});


// MovesInterface.js
var MovesInterface = pc.createScript('movesInterface');

MovesInterface.attributes.add('movesText', { type: 'entity' });

pc.extend(MovesInterface.prototype, {
    initialize: function() {
        this.app.on('MovesManager:setMoves', this.setMoves, this);
        this.app.on('PowerTileManager:onEndModePowerSpawn', this.reduceCounter, this);
        
        this.setMoves(MovesManager.instance._currentMoves);
    },

    setMoves: function(moves) {
        this.currentValue = moves;

        this.movesText.element.text = moves;
        this.movesText.script.tweenScale.startTween();
        
        var percentage = moves / MovesManager.instance.getStartMoves();
    },
    
    reduceCounter: function() {
        this.currentValue = (this.currentValue ? this.currentValue : MovesManager.instance.getMoves()) - 1;
        this.setMoves(this.currentValue);
    }
});

// GardenManager.js
class GardenManager extends pc.ScriptType {
    static addAttributes() {
        this.attributes.add('camera', { type: 'entity' });
        this.attributes.add('objectManager', { type: 'entity' });
        this.attributes.add('useTotalStarsToUnlock', { type: 'boolean' });
        this.attributes.add('changeObjectTutorialHand', { type: 'entity' });
        this.attributes.add('lightEntities', { type: 'entity', array: true });
    }
    // initialize code called once per entity
    initialize() {
        GardenManager.instance = this;
        LoadingScreen.instance.on('done', this.openTaskScreen, this);
        this.app.on('UIManager:showUI', this.setLoadedValue, this);
        this.app.on('GardenManager:light', this.updateLight, this);

        this.on('destroy', this._onDestroy, this);
        this.app.on('HoldCounter:ObjectLocked', this.openNotEnoughStarsScreen, this);

        this.stars = []; // arrays

        // this.objectSaveData = {};
        this._unlockedItems = [];

        this.totalAmountOfStars = 0;
        this.objects = this.app.root.findByTag("object");
        this.areas = this.app.root.findByTag('area');

        this.gardenCamera = this.camera.script.gardenCamera;
        this.objectHandler = ObjectHandler.instance;


        this.amountOfWorlds = Object.keys(WorldManager.instance.getWorldList()).length;
        this.UItoggle = true;

        this.gardenInput = true;
    }

    updateLight(type = pc.SHADOWUPDATE_THISFRAME) {
        this.lightEntities.forEach(entity => entity.light.shadowUpdateMode = type);
    }

    enableGardenInput(value) {
        this.gardenInput = value;

        this.app.fire('GardenManager:gardenInput', this.gardenInput);
    }

    getAreaScriptByAreaNumber(index) {
        var area = null;
        this.areas.forEach((element) => {
            if (element.script.areaManager.areaNumber === index) {
                area = element.script.areaManager;
            }
        });
        return area;
    }

    getAreaScriptByAreaNumber(index) {
        var area = null;
        this.areas.forEach((element) => {
            if (element.script.areaManager.areaNumber === index) {
                area = element.script.areaManager;
            }
        });
        return area;
    }
    setLoadedValue(args) {
        if (args === 'Garden' && !GardenUIEntity.instance.loadedFirstTime) {
            GardenUIEntity.instance.loadedFirstTime = true;
        }
    }
    _onDestroy() {
        this.app.off('UIManager:showUI', this.setLoadedValue, this);
        this.app.off('HoldCounter:ObjectLocked', this.openNotEnoughStarsScreen, this);
        this.app.off('GardenManager:light', this.updateLight, this);
    }
    openNotEnoughStarsScreen(entity, data) {
        // console.log('false now, ', entity)
        GardenCamera.instance.blockCamera = false;
        this.app.fire('UIManager:hideAll');
        this.app.fire('UIManager:showUI', 'NotEnoughStars', data);
        this.app.fire('GardenManager:lockedObject', entity);
    }
    openTaskScreen() {
        if (!GardenUIEntity.instance.args) return;
        if (GardenUIEntity.instance.args.OpenTaskScreen) {
            GardenUIEntity.instance.args.OpenTaskScreen = false;

            const areaData = GardenDataManager.instance.areaData;
            //CODEREVIEW: A: why do we only get area data from area 1? 
            const areaObjectsSaveValues = areaData['Area 1'].areaObjectsSaveValues

            const flowerBedFixed = areaObjectsSaveValues[0].currentObject !== 3;

            if (!flowerBedFixed) {
                Wrapper.instance.sendGAEvent(Wrapper.GA_EVENT_TYPE.DESIGN, { eventId: 'tutorialFunnel:enteredArea2' });
            }

            this.app.fire('UIManager:hideAll');
            this.app.fire('UIManager:showUI', 'Garden Tasks');
        }
    }
    postInitialize() {
        this._getStarData();
        // this._getObjectData();
        this._getAreaData();

    }
    update() {
        if (UIManager.instance.getScreen("Garden").enabled != this.UItoggle) {
            this.UItoggle = UIManager.instance.getScreen("Garden").enabled;
            if (this.UItoggle === false) return;
            this._getStarData();
            this.app.fire('GardenManager:checkStates');
        }
    }

    // Areas
    unlockArea(number) {
        for (var i = 0; i < this.areas.length; i++) {
            if (this.areas[i].script.areaManager.areaNumber === number) {
                this.areas[i].script.areaManager.changeAreaState(1); // Using a '1' is weird. Better to use an enumerator.
                this.areaSaveData[this.areas[i].name].state = 1;
            }
        }
        this._updateAreaData();
    }

    _getAreaData(retry = false) {
        this.areaSaveData = GardenDataManager.instance.areaData; //StorageManager.instance.get("areaData");

        if (this.areaSaveData !== undefined && Object.keys(this.areaSaveData).length > 0) {
            for (var i = 0; i < this.areas.length; i++) {
                if (this.areaSaveData[this.areas[i].name]) {
                    this.areas[i].script.areaManager.regionState = this.areaSaveData[this.areas[i].name].state;

                    this.checkAreaObjectsSaveValues(this.areaSaveData[this.areas[i].name].areaObjectsSaveValues, i);
                } else {
                    this.areaSaveData[this.areas[i].name] = {};
                    this.areaSaveData[this.areas[i].name].state = this.areas[i].script.areaManager.regionState;
                    this.areaSaveData[this.areas[i].name].area = this.areas[i].script.areaManager.areaNumber;
                    this.areaSaveData[this.areas[i].name].areaObjectsSaveValues = this.areas[i].script.areaManager.areaObjectsSaveValues;
                    this.areaSaveData[this.areas[i].name].starsSpent = this.areas[i].script.areaManager.starsSpent;
                }
            }
        } else {
            this._generateAreaData();
        }
    }

    checkAreaObjectsSaveValues(areaObjectsSaveValues, index) {
        if (!areaObjectsSaveValues) {
            console.log("Something went wrong", areaObjectsSaveValues);
        }

        const keys = Object.keys(areaObjectsSaveValues);

        keys.forEach(key => {
            const object = areaObjectsSaveValues[key];
            if (!this.areas[index].script.areaManager.hasObjectName(object.name)) {
                console.log("no key found", object.name);
                delete areaObjectsSaveValues[key];
            }

            if (object.cost === 0 || typeof object.cost !== 'number') {
                object.cost = this.areas[index].script.areaManager.areaEntities[key].script.objectOptions.amountOfStars;
            }
        });
    }

    _generateAreaData() {
        this.areaSaveData = {};
        for (var i = 0; i < this.areas.length; i++) {
            this.areaSaveData[this.areas[i].name] = {};
            this.areaSaveData[this.areas[i].name].state = this.areas[i].script.areaManager.regionState;
            this.areaSaveData[this.areas[i].name].area = this.areas[i].script.areaManager.areaNumber;
            this.areaSaveData[this.areas[i].name].areaObjectsSaveValues = this.areas[i].script.areaManager.areaObjectsSaveValues;
            this.areaSaveData[this.areas[i].name].starsSpent = this.areas[i].script.areaManager.starsSpent;
        }

        this._updateAreaData();
    }

    updateSpecificArea(script) {
        this.areaSaveData[script.entity.name] = {};
        this.areaSaveData[script.entity.name].state = script.regionState;
        this.areaSaveData[script.entity.name].area = script.areaNumber;
        this.areaSaveData[script.entity.name].areaObjectsSaveValues = script.areaObjectsSaveValues;
        this.areaSaveData[script.entity.name].starsSpent = script.starsSpent;

        this._updateAreaData();
    }

    resetAreaData(area) {
        const data = this.areaSaveData[this.areas[area - 1].name];

        data.state = AreaManager.states.Locked;
        data.starsSpent = 0;
        Object.keys(data.areaObjectsSaveValues).forEach(i => {
            const values = data.areaObjectsSaveValues[i]
            values.objectState = 1;
            values.currentObject = 3;
            values.cost = 0;
        });
    }

    _updateAreaData() {
        GardenDataManager.instance.setAreaData(this.areaSaveData);
    }

    // Objects
    // updateSpecificOption(entity) {
    //     var currentObject = this.objectSaveData[entity.name];
    //     if(currentObject !== undefined) { 
    //         var objectOptions = entity.script.objectOptions;
    //         currentObject.selectedOption = objectOptions.selectedOption;
    //         currentObject.objectState = 1;
    //         this._updateObjectData();
    //     }
    // }

    //     _getObjectData() {
    //         this.objectSaveData = GardenDataManager.instance.objectData;

    //         if(this.objectSaveData !== undefined && Object.keys(this.objectSaveData).length > 0 && this.objects.length == Object.keys(this.objectSaveData).length) {
    //             for (var i = 0; i < this.objects.length; i++) {
    //                 // add parameters of save to file
    //                 var objectOptions = this.objects[i].script.objectOptions;
    //                 var currentObject = this.objectSaveData[this.objects[i].name];

    //                 if(currentObject.selectedOption !== null && currentObject.selectedOption !== undefined) {
    //                     objectOptions.selectedOption = currentObject.selectedOption;
    //                     if(objectOptions.objectOptions.length > 0) {
    //                         this.objects[i].model.asset = objectOptions.objectOptions[objectOptions.selectedOption]; 
    //                     } else {
    //                         var meshInstances = this.objects[i].model.meshInstances;
    //                         for (var j = 0; j < meshInstances.length; ++j) { 
    //                             meshInstances[j].material = objectOptions.materialOptions[objectOptions.selectedOption].resource;
    //                         }
    //                     }

    //                 } 
    //                 objectOptions.objectState = currentObject.objectState;
    //                 this._checkObject(i);
    //             }
    //         } else {
    //             this._generateObjectData();
    //         }
    //     }

    _checkObject(index) {
        var objectOptions = this.objects[index].script.objectOptions;
        if (this.objects[index].parent.script.areaManager.regionState !== 0 && ((this.stars[objectOptions.world] >= objectOptions.amountOfStars && objectOptions.objectState === 0) || objectOptions.objectState === 2)) {
            // check if an object needs to be saved
            objectOptions.objectState = 2;
            this._unlockedItems.push(index);
        }
    }

    // Stars 
    _getStarData() {
        this.totalAmountOfStars = 0;

        for (var i = 0; i < Object.keys(LevelDataManager.instance._starData).length; i++) {
            this.totalAmountOfStars += Object.values(LevelDataManager.instance._starData)[i];
        }
    }

    // find an element in an array with first key
    _findInArray(array, value) {
        return array.filter(function (item) { return item[0] == value; });
    }


}
pc.registerScript(GardenManager, 'gardenManager');
GardenManager.addAttributes();

// StarBar.js
var StarBar = pc.createScript('starBar');

StarBar.attributes.add('barShader', { type: 'entity' });
StarBar.attributes.add('barRounder', { type: 'entity' });
StarBar.attributes.add('startValue', {type: 'number'});
StarBar.attributes.add('endValue', {type: 'number'});
StarBar.attributes.add('maxStarValue', {type: 'number'});
StarBar.attributes.add('starTemplate', { type: 'asset', assetType: 'template' });
StarBar.attributes.add('nStars', {type: 'number'});
StarBar.attributes.add('lerpTime', { type: 'number', default: 1 });

StarBar.COLORS = [
    '#1eeb98',
    '#ff7cf7',
    '#fdd700',
    '#bbfd00',
    '#e600fd',
    '#1af5c5',
    '#3ba7ff',
    '#3b66ff',
    '#ff7702',
    '#ff1d45'
];

pc.extend(StarBar.prototype, {
    initialize: function() {
        this.currentValue = this.startValue;
        this.createStars();
        this.app.on('ScoreManager:setStarValues', this.setStarPositions, this);    
        this.app.on('AsyncScoreManager:showScore', this.setFillValue, this);
        this.currentScore = 0;
        this._lerpValue = this.lerpTime;

        this._multipleLerp = false;

        this._color = new pc.Color();

        this.setBarColor();
        this.on('enable', this.setBarColor, this);
    },

    postInitialize: function() {
        this.setStarPositions(ScoreManager.instance.star1Value, ScoreManager.instance.star2Value, ScoreManager.instance.star3Value);
    },

    update: function(dt) {
        if (this.lerpValue < this.lerpTime) {
            this.lerpBarValue(dt);
        }
    },

    createStars: function() {
        this.stars = [];
        for (var i =0; i < this.nStars; i += 1) {
            var star = this.starTemplate.resource.instantiate();
            this.entity.addChild(star);
            this.stars.push(star);
        }
    },

    setStarPositions: function(firstStarScore, secondStarScore, thirdStarScore) {
        this.setFillValue(this.startValue);
        this.currentValue = this.startValue;

        var deltaValue = this.endValue - this.startValue;

        var thirdStarValue = this._calculateValue(thirdStarScore);
        var secondStarValue = this._calculateValue(secondStarScore);
        var firstStarValue = this._calculateValue(firstStarScore);

        this.stars[0].script.starBarStar.setRotation(firstStarValue);
        this.stars[1].script.starBarStar.setRotation(secondStarValue);
        this.stars[2].script.starBarStar.setRotation(thirdStarValue);

        this.resetStars();
        this._multipleLerp = false;
        this.lerpBarValue(1);

    },

    setFillValue: function(score) {
        var fillPercentage = this._calculateValue(score);
        this.startCurrentValue = this.currentValue;

        if (this.lerpValue < this.lerpTime) {
            this._multipleLerp = true;
        }

        this.lerpValue = 0;
        this.goalValue = fillPercentage;
    },

    _calculateValue: function(value) {
        return this.startValue +  value / ScoreManager.instance.star3Value * (this.endValue - this.startValue) * this.maxStarValue;
    },

    lerpBarValue: function(dt) {
        this.lerpValue += dt;
        this.currentValue = pc.math.lerp(this.startCurrentValue, this.goalValue, this._multipleLerp ? pc.CubicOut(this.lerpValue) : pc.CubicInOut(this.lerpValue));
        this.barShader.script.circleFill.updateValue(this.currentValue);
        this.barRounder.setLocalEulerAngles(0, 0, this.currentValue * -360);
        this.checkStarActive(this.currentValue);

        if (this.lerpValue >= this.lerpTime) {
            this._multipleLerp = false;
        }
    },

    checkStarActive: function(currentVal) {
        for (var i = 0; i < this.stars.length; i += 1) {
            this.stars[i].script.starBarStar.checkActivate(currentVal);
        }
    },

    resetStars: function() {
        for (var i = 0; i < this.stars.length; i += 1) {
            this.stars[i].script.starBarStar.setInactive();
        }
    },

    setBarColor: function() {
        var worldIndex = WorldManager.instance.getWorldIndex();

        var tint = StarBar.COLORS[WorldManager.instance.getWorldIndexByID(worldIndex)];
        
        if (!tint) {
            return;
        }
        
        var color = this._color.fromString(tint);

        this.barRounder.children[0].element.color = color;
        this.barShader.script.circleFill.circleColor = color;
    }
});


// AreaManager.js
class AreaManager extends pc.ScriptType {
    static addAttributes() {
        //states used for unlocking/locking areas and objects
        this.states = Object.freeze({
            Locked: 0,
            Unlocked: 1,
            ToSelect: 2
        });
        this.attributes.add('regionState', { type: 'number', enum: [{ 'Locked': AreaManager.states.Locked }, { 'Unlocked': AreaManager.states.Unlocked }, { 'current': AreaManager.states.ToSelect }], default: 0 });
        this.attributes.add('areaNumber', { type: 'number', default: 1 });
        this.attributes.add('areaFillEntities', { type: 'entity', array: true, title: 'The entities inside this area that cant be customized' });
        this.attributes.add('areaFocusPoint', { type: 'entity' });
        this.attributes.add('areaFocusZoomAmount', { type: 'number', default: 0 });
        this.attributes.add('customizableObjectGroups', {
            type: 'json',
            schema: [{
                name: "steps",
                type: 'entity',
                array: true
            }],
            array: true
        });

        this.attributes.add('worldTaskData', {
            type: 'json', schema: [
                {
                    name: 'sprite',
                    type: 'asset',
                    assetType: 'sprite',
                },
                {
                    name: 'key',
                    type: 'string',
                },
            ]
        });

    }
    // initialize this region with its current parameters, has to be run after the garden manager in script order
    initialize() {
        this.setAreaEntities();
        this.starsSpent = 0;
        this.objects = this.entity.children;

        this.intensity = 0;

        this.app.on('ObjectHandler:acceptButton', this.updateSavedata, this);
        this.app.on('GardenUIEntity:cheatFired', this.cheatFunction, this);
        LoadingScreen.instance.on('startFadeOut', this.updateState, this);
        LoadingScreen.instance.on('done', this.afterSceneTransition, this);
        this.app.on('GardenTaskScreen:populateMe', this.populateGardenTaskscreen, this);
        this.app.on('AreaManager:loadAssets', this.getAssets, this);

        this.on('destroy', this._onDestroy, this);

        this.trigger = false;
        this.lockedLayers = [this.app.scene.layers.getLayerByName("Locked").id];
        this.unlockedLayers = [this.app.scene.layers.getLayerByName("Unlocked").id];

    }
    postInitialize() {
        this.areaSaveValues = GardenManager.instance.areaSaveData[this.entity.name];
        this.starsSpent = this.areaSaveValues.starsSpent;

        this.areaObjectsSaveValues = this.areaSaveValues.areaObjectsSaveValues;

        this.setObjectsWorld();
        this.setObjectModels();
        this.updateState();

        var objects = {};
        for (let i = 0; i < this.areaEntities.length; i++) {
            var id = 43680000;
            try {
                id = this.areaEntities[i].script.objectOptions.brokenObjectImage.id;
            } catch (error) {

            }
            objects["" + this.areaEntities[i].script.objectOptions.entity.name] = {
                spriteId: id,
                descriptionKey: this.areaEntities[i].script.objectOptions.descriptionText,
                cost: this.areaEntities[i].script.objectOptions.objectCostInStars
            };
        }
        var areaObject = {
            index: this.areaNumber,
            objects: objects
        };

        GardenDataManager.instance.pushArea(areaObject);
    }

    hasObjectName(name) {
        return !!this.areaEntities.find(area => area.script.objectOptions.entity.name === name);
    }

    getAssets() {
        var assets = [];

        for (var i = 0; i < this.areaEntities.length; i++) {
            var objectOptions = this.areaEntities[i].script.get("objectOptions");

            if (objectOptions.currentModel) {
                assets.push(objectOptions.currentModel);
            }

            if (objectOptions.currentMaterial) {

                for (let j = 0; j < objectOptions.currentMaterial.length; j++) {
                    assets.push(objectOptions.currentMaterial[i]);
                }
            }

            if (objectOptions.currentTexture) {
                for (let j = 0; j < objectOptions.currentTexture.length; j++) {
                    assets.push(objectOptions.currentTexture[i]);
                }
            }
        }

        this.app.fire('AssetManager:extraAssets', assets);
    }

    setAreaEntities() {
        this.areaEntities = [];
        var amountOfStars = 0;
        for (let i = 0; i < this.customizableObjectGroups.length; i++) {
            for (let j = 0; j < this.customizableObjectGroups[i].steps.length; j++) {
                amountOfStars += this.customizableObjectGroups[i].steps[j].script.objectOptions.objectCostInStars;
                this.customizableObjectGroups[i].steps[j].script.objectOptions.group = i;
                this.customizableObjectGroups[i].steps[j].script.objectOptions.step = j + 1;
                this.customizableObjectGroups[i].steps[j].script.objectOptions.maxSteps = this.customizableObjectGroups[i].steps.length;
                this.customizableObjectGroups[i].steps[j].script.objectOptions.amountOfStars = amountOfStars;
                this.areaEntities.push(this.customizableObjectGroups[i].steps[j]);
            }
        }

        if (this.areaEntities[this.areaEntities.length - 1] !== undefined) {
            this.areaEntities[this.areaEntities.length - 1].script.objectOptions.lastObject = true;
        }
    }
    payStars(amount) {
        this.setAreaEntities();
        this.areaSaveValues.starsSpent += amount;
        this.starsSpent = this.areaSaveValues.starsSpent;

        // this.updateSavedata(this.areaNumber);
    }

    setObjectsWorld() {
        for (var index = 0; index < this.areaEntities.length; index++) {
            if (this.areaEntities[index].script) {
                this.areaEntities[index].script.objectOptions.world = this.areaNumber;
            }
        }
    }
    cheatFunction() {
        // GardenManager.instance._getAreaData();
        // this.areaSaveValues = GardenManager.instance.areaSaveData[this.entity.name];
        // this.areaObjectsSaveValues = this.areaSaveValues.areaObjectsSaveValues;
        // this.starsSpent = this.areaSaveValues.starsSpent;
        this.updateState();
        this.updateSavedata(this.areaNumber);
    }

    returnSelf(value) {
        if (value === areaNumber) {
            return this;
        }
    }

    _onDestroy() {
        this.app.off('ObjectHandler:acceptButton', this.updateSavedata, this);
        this.app.off('GardenUIEntity:cheatFired', this.cheatFunction, this);
        LoadingScreen.instance.off('startFadeOut', this.updateState, this);
        LoadingScreen.instance.off('done', this.afterSceneTransition, this);
        this.app.off('GardenTaskScreen:populateMe', this.populateGardenTaskscreen, this);
        this.app.off('AreaManager:loadAssets', this.getAssets, this);
    }

    populateGardenTaskscreen() {
        this.updateState();
        this.setTaskScreenValues();
    }

    afterSceneTransition() {
        this.batched = [];
        this.areaEntities.forEach(this.handleRebatching, this);
        this.batched = [];
    }
    handleRebatching(element) {
        if (element && element.model && element.model.batchGroupId && !this.batched.includes(element.model.batchGroupId)) {
            element.script.objectOptions.rebatch();
            this.batched.push(element.model.batchGroupId);
        }
    }
    updateSavedata(world) {
        if (this.areaNumber !== world) return;
        if (!this.areaObjectsSaveValues) {
            this.areaObjectsSaveValues = {};
        }

        for (var index = 0; index < this.areaEntities.length; index++) {
            if (this.areaEntities[index].script) {
                this.areaObjectsSaveValues[index] = {
                    name: this.areaEntities[index].name,
                    objectState: this.areaEntities[index].script.objectOptions.objectState,
                    currentObject: this.areaEntities[index].script.objectOptions.getCurrentIndex(),
                    cost: this.areaEntities[index].script.objectOptions.amountOfStars
                };
            }
        }

        GardenManager.instance.updateSpecificArea(this);
    }

    // unlock this area
    changeAreaState(state) {
        this.regionState = state;
        this.updateState();
    }

    setObjectModels() {
        for (var index = 0; index < this.areaEntities.length; index++) {
            if (!this.areaObjectsSaveValues) {
                this.updateSavedata(this.areaNumber);
            }

            const areaEntity = this.areaEntities[index];

            if (!areaEntity) {
                console.warn(this.entity.name, areaEntity, index);
                continue;
            }

            if (!this.areaEntities[index]) {
                console.warn(this.entity.name, "Not found!", this.areaEntities, index);
                continue;
            }

            if (!this.areaObjectsSaveValues[index]) {
                console.warn(this.entity.name, "Not found!", this.areaObjectsSaveValues, index);
                continue;
            }

            this.areaEntities[index].script.get("objectOptions").setAssetToSelection(this.areaObjectsSaveValues[index].currentObject + 1 - 1);//in case of 0
        }
    }

    updateState() {
        if (AssetManager.instance.currentWorld !== 'Garden') {
            return;
        }

        if (WorldManager.instance.getCurrentWorld() < (this.areaNumber)) {
            this.regionState = AreaManager.states.Locked;
            GardenManager.instance.areaSaveData[this.entity.name].state = this.regionState;
        } else {
            this.regionState = AreaManager.states.Unlocked;
            GardenManager.instance.areaSaveData[this.entity.name].state = this.regionState;
        }

        for (var i = 0; i < this.areaEntities.length; i++) {
            if (!this.areaEntities[i]) {
                continue;
            }

            if (this.areaEntities[i].script && this.areaEntities[i].script.get("objectOptions")) {
                if (this.regionState === AreaManager.states.Locked) {
                    this.areaEntities[i].model.layers = this.lockedLayers;
                    this.areaEntities[i].script.objectOptions.setState(ObjectOptions.states.Locked);
                    this.areaEntities[i].script.objectOptions.setAssetToSelection(3);
                } else {
                    this.areaEntities[i].model.layers = this.unlockedLayers;
                    this.areaEntities[i].script.objectOptions.setState(ObjectOptions.states.Unlocked);
                }

                //batch last entity within current area so all entities within area get rebatched
                // if ((i + 1) === this.areaEntities.length) {
                //     this.areaEntities[i].script.objectOptions.rebatch();
                // }
            }
        }


        for (var j = 0; j < this.areaFillEntities.length; j++) {
            if (!this.areaFillEntities[j]) {
                continue;
            }

            var models = this.areaFillEntities[j].findComponents('model');

            models.forEach(model => model.layers = this.regionState === AreaManager.states.Locked ? this.lockedLayers : this.unlockedLayers);
        }

        if (this.regionState === AreaManager.states.Locked) {
            this.lock()
        } else {
            this.unlock();
        }
    }
    getUnlockProgress() {
        var length = Object.keys(this.areaObjectsSaveValues).length;
        var progress = 0;
        for (var i = 0; i < length; i++) {
            // console.log(this.areaObjectsSaveValues[i].currentObject)

            if (this.areaObjectsSaveValues[i].currentObject !== 3) {
                progress++;
            }
        }
        var areaProgress = {
            amountUnlocked: progress,
            maxUnlockables: length
        };
        return areaProgress;
    }
    setTaskScreenValues() {
        var obj = GardenUIEntity.instance.getLastUnlock(this);

        if (obj.found) {
            const worldTask = obj.worldTask;

            var starStringValue = worldTask ? null : "" + obj.nextUnlockableEntity.script.objectOptions.objectCostInStars;

            var areaStars = obj.currentAreaStars - this.starsSpent;

            if (!isFinite(areaStars)) {
                areaStars = 0;
            }

            var task = {
                explanationText: worldTask ? obj.data.key : obj.nextUnlockableEntity.script.objectOptions.descriptionText,
                starText: starStringValue,
                sprite: worldTask ? obj.data.sprite : obj.nextUnlockableEntity.script.objectOptions.brokenObjectImage,
                area: this.areaNumber,
                currentAreaStars: areaStars,
                entity: obj.nextUnlockableEntity,
                step: worldTask ? 1 : obj.nextUnlockableEntity.script.objectOptions.step,
                maxSteps: worldTask ? 1 : obj.nextUnlockableEntity.script.objectOptions.maxSteps,
                worldTask: obj.worldTask,

            };
            this.app.fire('AreaManager:addTask', task, this.areaNumber);
        }

        this.app.fire('AreaManager:checkedForLast');
    }

    lockAll() {
        this.app.root.findComponents("model").forEach(model => model.layers = this.lockedLayers);

        this.app.fire("rebatch");
    }

    lock() {
        var models = this.entity.findComponents("model");
        for (let i = 0; i < models.length; i++) {
            const model = models[i];

            if (model.batchGroupId !== -1) {
                const batch = this.app.batcher.getGroupById(model.batchGroupId);
                let batchGroup = null;
                if (batch.name.includes("Static")) {
                    batchGroup = this.app.batcher.getGroupByName(`Area_${this.areaNumber}_Static_Locked`);
                } else {
                    batchGroup = this.app.batcher.getGroupByName(`Area_${this.areaNumber}_Locked`);
                }

                model.batchGroupId = batchGroup.id;
            }

            model.layers = this.lockedLayers;

            if (model.asset) {
                this.setModelToLock(model);
            }
        }

        this.app.fire('rebatch');
    }

    setModelToLock(model) {
        if (model.model) {
            model.model.meshInstances.forEach(meshInstance => {
                meshInstance.material.ambientTint = true;
                meshInstance.material.ambient = AreaManager.LOCKED_COLOR;
                meshInstance.material.update();

            });
        }
    }

    unlock() {
        var models = this.entity.findComponents("model");

        for (let i = 0; i < models.length; i++) {
            const model = models[i];

            if (model.batchGroupId !== -1) {
                const batch = this.app.batcher.getGroupById(model.batchGroupId);

                let batchGroup = null;
                if (batch.name.includes("Static")) {
                    batchGroup = this.app.batcher.getGroupByName(`Area_${this.areaNumber}_Static`);
                } else {
                    batchGroup = this.app.batcher.getGroupByName(`Area_${this.areaNumber}`);
                }

                model.batchGroupId = batchGroup.id;
            }

            model.layers = this.unlockedLayers;

            if (!model.model) {
                // console.warn(model.entity.name, model.entity);
            } else {
                model.model.meshInstances.forEach(meshInstance => meshInstance.material.ambientTint = false);
            }
        }
    }


    getAllMaterials() {
        var materials = [];

        for (let i = 0; i < this.areaFillEntities.length; i++) {
            const entity = this.areaFillEntities[i];

            const models = entity.findComponents('model');

            models.forEach(model => {
                if (Array.isArray(model.meshInstances)) {
                    for (let j = 0; j < model.meshInstances.length; j++) {
                        materials.push(model.meshInstances[j].material);
                    }
                } else {
                    console.log("No meshInstances found", model);
                }
            });
        }

        var baseModels = this.entity.findComponents('model').filter(model => !model.entity.name.includes('Collider'));

        for (let i = 0; i < baseModels.length; i++) {
            const model = baseModels[i];

            if (!Array.isArray(model.meshInstances)) {
                console.log("No meshInstances found", model);

                continue;
            }

            for (let j = 0; j < model.meshInstances.length; j++) {
                var material = model.meshInstances[j].material;
                if (material.name === "Default Material") {
                    continue;
                }
                materials.push(model.meshInstances[j].material);
            }
        }
        var scripts = this.entity.findScripts("objectOptions");

        for (let i = 0; i < scripts.length; i++) {
            const script = scripts[i];

            if (!script.currentMaterial) {
                continue;
            }

            for (let j = 0; j < script.currentMaterial.length; j++) {
                const material = script[j];

                if (!material) {
                    continue;
                }
                materials.push(material);
            }
        }

        return materials;
    }

    changeBatchGroups(state) {
        var models = this.entity.findComponents("model");
        for (let i = 0; i < models.length; i++) {
            const model = models[i];

            if (!model._typeModel) {
                const batch = this.app.batcher.getGroupById(model.batchGroupId);

                if (!batch) {
                    model._typeModel = 'none';
                } else {
                    model._typeModel = batch.name.includes("Static") ? 'static' : 'dynamic';
                }
            }

            let batchGroup = null;

            switch (state) {
                case AreaManager.BATCH_STATE.LOCKED:
                    if (model._typeModel === 'static') {
                        batchGroup = this.app.batcher.getGroupByName(`Area_${this.areaNumber}_Static_Locked`);
                    } else if (model._typeModel === 'dynamic') {
                        batchGroup = this.app.batcher.getGroupByName(`Area_${this.areaNumber}_Locked`);
                    }

                    break;

                case AreaManager.BATCH_STATE.UNLOCKED:
                    if (model._typeModel === 'static') {
                        batchGroup = this.app.batcher.getGroupByName(`Area_${this.areaNumber}_Static`);
                    } else if (model._typeModel === 'dynamic') {
                        batchGroup = this.app.batcher.getGroupByName(`Area_${this.areaNumber}`);
                    }

                    break;

                case AreaManager.BATCH_STATE.NONE:
                    try {
                        model.batchGroupId = -1;
                    } catch (e) {
                        console.log(e);
                    }
                    break;

                default:
                    console.warn("no state found");
                    break;
            }

            if (batchGroup) {
                model.batchGroupId = batchGroup.id;
            }
        }
    }

    unlockAnimation() {
        const soundInstance = AudioManager.instance._playSFX('unlock_new_area.mp3');

        if (soundInstance) {
            GardenMusicManager.instance.fadeOutMusic();
            soundInstance.on('end', () => {
                GardenMusicManager.instance.fadeInMusic();
                GardenMusicManager.instance.fadeOutAmbient();
            });
        }

        var materials = this.getAllMaterials();
        this.materials = pc.utils.removeArrayDuplicates(materials);
        this.changeBatchGroups(AreaManager.BATCH_STATE.NONE);

        this.intensity = 0;

        return new Promise((resolve, reject) => {
            for (let i = 0; i < materials.length; i++) {
                const material = materials[i];
                material.emissive = AreaManager.AREA_UNLOCK_COLOR;
                material.emissiveIntensity = this.intensity;
                material.update();
            }



            var fadeOut = this.entity
                .tween(this)
                .to({ intensity: 0 }, 1, pc.Linear);

            fadeOut.on('update', this.updateMaterialEmissive, this);
            fadeOut.on('complete', () => {
                resolve();
                this.changeBatchGroups(AreaManager.BATCH_STATE.UNLOCKED);
            });

            var fadeIn = this.entity
                .tween(this)
                .to({ intensity: 1 }, 1, pc.Linear)
                .start();

            fadeIn.on('update', this.updateMaterialEmissive, this)
            fadeIn.on('complete', () => {
                this.unlock();

                pc.timer.add(0.01, () => {
                    fadeOut.start();
                });
            });
        });
    }

    updateMaterialEmissive() {
        const materials = this.materials;

        for (let i = 0; i < materials.length; i++) {
            const material = materials[i];
            material.emissiveIntensity = this.intensity;
            material.update();
        }
    }
}
pc.registerScript(AreaManager, 'areaManager');
AreaManager.addAttributes();
AreaManager.LOCKED_COLOR = new pc.Color(48 / 255, 29 / 255, 29 / 255);
AreaManager.AREA_UNLOCK_COLOR = new pc.Color(255 / 255, 255 / 255, 255 / 255);
AreaManager.BATCH_STATE = Object.freeze({
    LOCKED: 'locked',
    UNLOCKED: 'unlocked',
    NONE: 'none',
});




// ObjectiveManager.js
var ObjectiveManager = pc.createScript('objectiveManager');

var objectiveTypesEnum = Object.freeze({
    SCORE: 0,
    ORDER: 1,
    COAT: 2
});

var objectiveStatesEnum = Object.freeze({
    ACTIVE: 0,
    COMPLETED: 1,
});

ObjectiveManager.attributes.add('objectiveSlots', { type: 'number' });

pc.extend(ObjectiveManager.prototype, {
    initialize: function () {
        ObjectiveManager.instance = this;

        this._objectiveSlots = [];

        this._defaultObjective = Object.freeze({
            objectiveType: objectiveTypesEnum.ORDER,
            orderTypeObject: { layerID: 0, typeID: 0, colorID: 0 },
            values: { current: 0, goal: 0, currentVisible: 0 },
            state: objectiveStatesEnum.ACTIVE
        });

        this.app.on('GameManager:quit', this.removeObjectives, this);
        this.app.on('ScoreManager:setScore', this.onScoreAdd, this);
        this.app.on('ForegroundTile:onExplode', this.onTileDestroy, this);
        this.app.on('BackgroundTile:onExplode', this.onTileDestroy, this);
        this.app.on('BackgroundTile:OnSpawn', this.onTileRegrow, this);
    },

    getObjectives: function () {
        return this._objectiveSlots;
    },

    setObjectives: function (objectives) {
        for (var i = 0; i < objectives.length; i += 1) {
            ObjectiveManager.instance.addObjective(objectives[i].objectiveType, objectives[i].goal, objectives[i].orderTypeObject);
        }
        this.app.fire('ObjectiveManager:onObjectiveSet');
    },

    removeObjectives: function () {
        this._objectiveSlots.length = 0;
    },

    addObjective: function (objectiveType, goalValue, orderTypeObject) {
        if (this._objectiveSlots.length >= this.objectiveSlots) return;

        var newObjective = JSON.parse(JSON.stringify(this._defaultObjective));
        newObjective.objectiveType = objectiveType;
        newObjective.values.goal = goalValue;
        newObjective.values.current = 0;
        newObjective.values.currentVisible = 0;
        newObjective.state = objectiveStatesEnum.ACTIVE;

        if (objectiveType === objectiveTypesEnum.ORDER) {
            newObjective.orderTypeObject.layerID = orderTypeObject.layerID;
            newObjective.orderTypeObject.typeID = orderTypeObject.typeID;
            newObjective.orderTypeObject.colorID = orderTypeObject.colorID;

            // Set all sinker objectives to layerID of sinker 1
            if (orderTypeObject.layerID === tileLayerEnum.FOREGROUND && (orderTypeObject.typeID === foregroundTileEnum.SINKER_2 || orderTypeObject.typeID === foregroundTileEnum.SINKER_3)) {
                newObjective.orderTypeObject.typeID = foregroundTileEnum.SINKER_1;
            }
        }

        if (orderTypeObject.layerID === tileLayerEnum.BACKGROUND && orderTypeObject.typeID === backgroundTileEnum.COAT) {
            var numberOfCoats = GridManager.instance.getNumberOfCoats();
            newObjective.values.current = numberOfCoats;
            newObjective.values.currentVisible = numberOfCoats;
        }

        this._objectiveSlots.push(Object.assign({}, newObjective));
        this.app.fire('ObjectiveManager:onObjectiveAdd', newObjective);
    },

    onTileDestroy: function (layerID, typeID, colorID) {
        if (!LevelManager.instance.playing) {
            return;
        }

        for (var i = 0; i < this._objectiveSlots.length; i += 1) {
            var objective = this._objectiveSlots[i];
            if (this._objectiveSlots[i].objectiveType === objectiveTypesEnum.ORDER) {
                if (this._isCorrectOrderTile(objective.orderTypeObject, layerID, typeID, colorID)) {
                    if (objective.orderTypeObject.layerID === tileLayerEnum.BACKGROUND && objective.orderTypeObject.typeID === backgroundTileEnum.COAT) {
                        objective.values.current -= 1;
                        objective.values.currentVisible -= 1;
                        this.app.fire('ObjectiveManager:onObjectiveChange', i, objective);
                    } else {
                        objective.values.current += 1;
                    }
                    //this.app.fire('ObjectiveManager:onObjectiveChange', i, objective);

                    if (objective.values.current >= objective.values.goal) {
                        objective.state = objectiveStatesEnum.COMPLETED;
                        //this.app.fire('ObjectiveManager:onObjectiveComplete', i);
                    }
                }
            }
        }
    },

    onTileRegrow: function (layerID, typeID, colorID) {
        if (GameManager.instance.forcedMode && GameManager.instance.gameMode === "endless") {
            return false;
        }

        for (var i = 0; i < this._objectiveSlots.length; i += 1) {
            var objective = this._objectiveSlots[i];
            if (this._objectiveSlots[i].objectiveType === objectiveTypesEnum.ORDER) {
                if (this._isCorrectOrderTile(objective.orderTypeObject, layerID, typeID, colorID)) {
                    if (objective.orderTypeObject.layerID === tileLayerEnum.BACKGROUND && objective.orderTypeObject.typeID === backgroundTileEnum.COAT) {
                        objective.values.current += 1;
                        objective.values.currentVisible += 1;
                        if (objective.values.current >= objective.values.goal) {
                            objective.state = objectiveStatesEnum.COMPLETED;

                            this.app.fire('ObjectiveManager:onObjectiveComplete', i);

                            if (objective.values.currentVisible === objective.values.goal) {
                                this.app.fire('Audio:sfx', 'goal_completed.mp3');
                            }
                        }
                    } else {
                        objective.values.current -= 1;
                    }
                    this.app.fire('ObjectiveManager:onObjectiveChange', i, objective);
                }
            }
        }
    },

    onScoreAdd: function () {
        if (GameManager.instance.forcedMode && GameManager.instance.gameMode === "endless") {
            return false;
        }

        for (var i = 0; i < this._objectiveSlots.length; i += 1) {
            var objective = this._objectiveSlots[i];
            if (objective.objectiveType === objectiveTypesEnum.SCORE) {
                objective.values.current = ScoreManager.instance.getScore();
                objective.values.currentVisible = objective.values.current;
                this.app.fire('ObjectiveManager:onObjectiveChange', i, objective);

                if (objective.values.current >= objective.values.goal && objective.state !== objectiveStatesEnum.COMPLETED) {
                    this.app.fire('ObjectiveManager:onObjectiveComplete', i);
                    objective.state = objectiveStatesEnum.COMPLETED;
                }
            }
        }
    },

    _isCorrectOrderTile: function (order, layerID, typeID, colorID) {
        var isSameTile = order.layerID === layerID && order.typeID === typeID;
        if (TileLibrary.instance.isTileColored(layerID, typeID)) {
            isSameTile = isSameTile && (order.colorID === colorID || order.colorID === -1);
        }
        return isSameTile;
    },

    _updateOrderStatistics: function (layerID, colorId, typeID) {
        return;
        StatisticsManager.instance.incrementStatistic("orders_completed", 1);

        if (layerID === tileLayerEnum.FOREGROUND && typeID === foregroundTileEnum.SWITCHER) {
            StatisticsManager.instance.incrementStatistic("switcher_orders_completed", 1);
        } else if (layerID === tileLayerEnum.FOREGROUND) {
            StatisticsManager.instance.incrementStatistic("flower_orders_completed", 1);

            switch (colorId) {
                case tileColorEnum.BLUE:
                    StatisticsManager.instance.incrementStatistic("blue_flower_orders_completed", 1);
                    break;
                case tileColorEnum.YELLOW:
                    StatisticsManager.instance.incrementStatistic("yellow_flower_orders_completed", 1);
                    break;
                case tileColorEnum.RED:
                    StatisticsManager.instance.incrementStatistic("red_flower_orders_completed", 1);
                    break;
                case tileColorEnum.PURPLE:
                    StatisticsManager.instance.incrementStatistic("purple_flower_orders_completed", 1);
                    break;
                case tileColorEnum.GREEN:
                    StatisticsManager.instance.incrementStatistic("green_flower_orders_completed", 1);
                    break;
                case tileColorEnum.ORANGE:
                    StatisticsManager.instance.incrementStatistic("orange_flower_orders_completed", 1);
                    break;
            }
        } else if (layerID === tileLayerEnum.BACKGROUND) {
            switch (typeID) {
                case backgroundTileEnum.PANEL:
                    StatisticsManager.instance.incrementStatistic("panels_orders_completed", 1);
                    break;
                case backgroundTileEnum.BLOCKER:
                    StatisticsManager.instance.incrementStatistic("blocker_orders_completed", 1);
                    break;
                case backgroundTileEnum.LOCKER:
                    StatisticsManager.instance.incrementStatistic("locker_orders_completed", 1);
                    break;
                case backgroundTileEnum.VIRUS:
                    StatisticsManager.instance.incrementStatistic("virus_orders_completed", 1);
                    break;
                case backgroundTileEnum.SINKER:
                    StatisticsManager.instance.incrementStatistic("sinker_orders_completed", 1);
                    break;
                case backgroundTileEnum.COPYER:
                    StatisticsManager.instance.incrementStatistic("sticker_orders_completed", 1);
                    break;
                case backgroundTileEnum.POPPER:
                    StatisticsManager.instance.incrementStatistic("popper_orders_completed", 1);
                    break;
            }
        }
    },

    isTileOneOfObjectives: function (layerID, typeID, colorID) {
        if (GameManager.instance.forcedMode && GameManager.instance.gameMode === "endless") {
            return false;
        }

        for (var i = 0; i < this._objectiveSlots.length; i += 1) {
            if (this._isCorrectOrderTile(this._objectiveSlots[i].orderTypeObject, layerID, typeID, colorID)) return true;
        }
        return false;
    },

    isObjectiveCompleted: function (layerID, typeID, colorID) {
        for (var i = 0; i < this._objectiveSlots.length; i += 1) {
            var objective = this._objectiveSlots[i];
            if (this._isCorrectOrderTile(objective.orderTypeObject, layerID, typeID, colorID)) {
                this._updateOrderStatistics(layerID, colorID, typeID);

                return objective.values.goal <= objective.values.currentVisible;
            }
        }
        return null;
    },

    onObjectiveAdd: function (layerID, typeID, colorID) {
        if (!LevelManager.instance.playing) {
            return;
        }

        for (var i = 0; i < this._objectiveSlots.length; i += 1) {
            var objective = this._objectiveSlots[i];
            if (this._isCorrectOrderTile(objective.orderTypeObject, layerID, typeID, colorID)) {
                objective.values.currentVisible++;

                if (objective.values.currentVisible > objective.values.current) {
                    console.warn("something went wrong", objective);
                }

                if (objective.values.currentVisible >= objective.values.goal) {
                    this.app.fire('ObjectiveManager:onObjectiveComplete', i);

                    if (objective.values.currentVisible === objective.values.goal) {
                        this.app.fire('Audio:sfx', 'goal_completed.mp3');
                    }
                } else {
                    this.app.fire('ObjectiveManager:onObjectiveChange', i, objective);
                }
            }
        }
    },

    isObjectivesCompleted: function () {
        for (var i = 0; i < this._objectiveSlots.length; i += 1) {
            var objective = this._objectiveSlots[i];

            if (objective.state !== objectiveStatesEnum.COMPLETED) {
                if (objective.values.current < objective.values.goal) {
                    if (objective.values.currentVisible < objective.values.goal) {
                        return false;
                    } else {
                        console.error("Something went wrong", objective);
                    }
                } else {
                    console.error("Something went wrong", objective, objective.values.current, objective.values.goal);
                }
            }
        }

        return true;
    },

    reset: function () {
        this._objectiveSlots.length = 0;
        this.app.fire('ObjectiveManager:onReset');
    },

    increaseVirusObjective: function () {
        for (var i = 0; i < this._objectiveSlots.length; i += 1) {
            var objective = this._objectiveSlots[i];

            if (objective.orderTypeObject.layerID === 1 && objective.orderTypeObject.typeID === 5) {
                objective.values.goal++;
                this.app.fire('ObjectiveManager:onObjectiveChange', i, objective);
            }
        }
    },
});

// Inventory.js
var Inventory = pc.createScript('inventory');

Inventory.attributes.add('itemSprites', {
    type: 'json', array: true, schema: [
        {
            name: "key",
            type: "string",
            assetType: "sprite"
        },
        {
            name: "sprite",
            type: "asset",
            assetType: "sprite"
        },
    ]
});

pc.extend(Inventory.prototype, {
    initialize: function () {
        if (Singleton.instance.canCreateInstance(this)) {
            Inventory.instance = this;
        }

        this.storageKey = 'inventory';
        this.invoicesKey = 'invoices';

        this.items = Object.freeze([
            'COINS',
            'PREBOOSTER_1',
            'PREBOOSTER_2',
            'PREBOOSTER_3',
            'BOOSTER_1',
            'BOOSTER_2',
            'BOOSTER_3'
        ]);

        this.app.on("StorageManager:changedStorage", this._onStorageChange, this);

        this.inventory = this._getSaveData();
        this.invoices = this._getInvoices();
    },

    _onStorageChange: function () {
        this.inventory = this._getSaveData();
        this.invoices = this._getInvoices();
    },

    setFakeBoosters(swap = 0, shovel = 0, beehive = 0) {
        this.useFakeBoosters = true;

        this.fakeSwaps = swap;
        this.fakeShovels = shovel;
        this.fakeBeehives = beehive;
    },

    getItem: function (item) {
        if (!this.inventory.hasOwnProperty(item)) {
            console.error("No inventory found with the key", item);
            return;
        }

        if (this.useFakeBoosters) {
            if (item === "BOOSTER_1") {
                return this.fakeSwaps;
            }

            if (item === "BOOSTER_2") {
                return this.fakeShovels;
            }

            if (item === "BOOSTER_3") {
                return this.fakeBeehives;
            }
        }

        return this.inventory[item];
    },

    getItemSprite: function (key) {
        return this.itemSprites.find(item => item.key === key).sprite;
    },

    addItem: function (item, amount, itemType, itemId, ignoreSaving) {
        if (isNaN(amount)) {
            amount = 1; // Default value
        }

        if (!this.inventory.hasOwnProperty(item)) {
            console.error("No inventory found with the key", item);
            return;
        }

        this.inventory[item] += amount;

        if (this.ignoreSaving) {
            return;
        }

        if (itemType) {
            Wrapper.instance.sendGAEvent(Wrapper.GA_EVENT_TYPE.RESOURCE, {
                flowType: 'Source',
                resourceCurrency: this.toStringForGA(item),
                amount,
                itemType,
                itemId,
            });
        }

        this._saveInventory();
    },

    addInvoice: function (invoice) {
        this.invoices.push(invoice);

        this._saveInvoices();
    },

    hasInvoice: function (invoiceID) {
        return this.invoices.includes(invoiceID);
    },

    updateInventory: function (inventory, invoices) {
        for (const property in inventory) {
            const delta = inventory[property] - this.inventory[property];

            if (delta > 0) {
                this.addItem(property, delta, null, null, true);
            } else if (delta < 0) {
                console.warn("Something went wrong", property, delta);
            }
        }

        this._invoices = invoices;

        this._saveInvoices(true);

        this._saveInventory(true);
    },

    tryPayItem: function (item, amount = 1, itemType, itemId) {
        if (!this.inventory.hasOwnProperty(item)) {
            console.error("No inventory found with the key", item);
            return false;
        }

        if (this.useFakeBoosters) {
            if (item === "BOOSTER_1") {
                if (this.fakeSwaps < amount) {
                    return false;
                } else {
                    this.fakeSwaps -= amount;
                    return true;
                }
            }

            if (item === "BOOSTER_2") {
                if (this.fakeShovels < amount) {
                    return false;
                } else {
                    this.fakeShovels -= amount;
                    return true;
                }
            }

            if (item === "BOOSTER_3") {
                if (this.fakeBeehives < amount) {
                    return false;
                } else {
                    this.fakeBeehives -= amount;
                    return true;
                }
            }
        }

        if (this.inventory[item] < amount) {
            // console.error("Not enough", this.inventory, amount, item )
            return false;
        }

        if (item === 'COINS') {
            // Do nothing
        }
        else {
            if (Xsolla.instance.loggedIn) {
                // Consume it
            }
        }


        this.inventory[item] -= amount;

        if (itemType) {
            Wrapper.instance.sendGAEvent(Wrapper.GA_EVENT_TYPE.RESOURCE, {
                flowType: 'Sink',
                resourceCurrency: this.toStringForGA(item),
                amount,
                itemType,
                itemId,
            });
        }


        // StatisticsManager.instance.incrementStatistic("bees_pre_booster_bought", 1);
        this._saveInventory();
        return true;
    },

    _saveInventory: function (localStorageOnly) {
        StorageManager.instance.set(this.storageKey, this.inventory, false, 'localStorage', localStorageOnly);
    },


    _saveInvoices: function (localStorageOnly) {
        StorageManager.instance.set(this.invoicesKey, this.invoices, false, 'localStorage', localStorageOnly);
    },

    _getSaveData: function () {
        var inventoryData = StorageManager.instance.get(this.storageKey);

        inventoryData = this._validateData(inventoryData);

        return inventoryData;
    },

    _getInvoices: function () {
        var invoices = StorageManager.instance.get(this.invoicesKey) || [];

        return invoices;
    },

    _validateData: function (inventoryData) {
        // Change to object if it's an array
        if (Array.isArray(inventoryData)) {
            inventoryData = {};
        }

        // Change to object if it's not an object
        if (typeof inventoryData !== 'object') {
            inventoryData = {};
        }

        var keys = Object.keys(inventoryData);

        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];

            // delete keys which are not used.
            if (!this.items.includes(key)) {
                delete inventoryData[key];
            }
        }

        var updateData = false;

        for (var j = 0; j < this.items.length; j++) {
            var item = this.items[j];

            // Check if the object has the key. Else set default data.
            if (!inventoryData.hasOwnProperty(item)) {
                inventoryData[item] = this._createInventoryData(item);
                updateData = true;
            }
        }

        // Only update if necessary
        if (updateData) {
            StorageManager.instance.set(this.storageKey, inventoryData);
        }

        return inventoryData;
    },

    toStringForGA(name) {
        switch (name) {
            case 'COINS':
                return 'coins';
            case 'BOOSTER_1':
                return 'gloves';
            case 'BOOSTER_2':
                return 'shovel';
            case 'BOOSTER_3':
                return 'beehive';
            case 'PREBOOSTER_1':
                return 'bees';
            case 'PREBOOSTER_2':
                return 'ladybugs';
            case 'PREBOOSTER_3':
                return 'butterfly';
        }

        console.warn(name, 'is not found')

        return name;
    },

    _createInventoryData: function (item) {
        switch (item) {
            case Inventory.ITEMS.COINS:
                return 2000;
            case Inventory.ITEMS.BEES:
                return 3;
            case Inventory.ITEMS.LADYBUGS:
                return 3;
            case Inventory.ITEMS.BUTTERFLY:
                return 3;
            case Inventory.ITEMS.GLOVES:
                return 3;
            case Inventory.ITEMS.SHOVEL:
                return 3;
            case Inventory.ITEMS.BEEHIVE:
                return 3;
            default:
                return 0;
        }
    },

    getXsollaSKU: function (key) {
        return Inventory.XSOLLA_KEYS[key];
    },
});

Inventory.ITEMS = Object.freeze({
    COINS: 'COINS',
    GLOVES: 'BOOSTER_1',
    SHOVEL: 'BOOSTER_2',
    BEEHIVE: 'BOOSTER_3',
    BEES: 'PREBOOSTER_1',
    LADYBUGS: 'PREBOOSTER_2',
    BUTTERFLY: 'PREBOOSTER_3',
});

Inventory.XSOLLA_KEYS = Object.freeze({
    BOOSTER_1: 'booster_gloves',
    BOOSTER_2: 'booster_shovel',
    BOOSTER_3: 'booster_beehive',
    PREBOOSTER_1: 'prebooster_bees',
    PREBOOSTER_2: 'prebooster_ladybugs',
    PREBOOSTER_3: 'prebooster_butterflies',
    COINS: 'coins',
});


// GardenCamera.js
class GardenCamera extends pc.ScriptType {
    static addAttributes() {
        this.attributes.add('distanceMax', { type: 'number', default: 50, title: 'Distance Max', description: 'Maximum distance your camera can zoom out' });
        this.attributes.add('distanceMin', { type: 'number', default: 10, title: 'Distance Min', description: 'Minimum distance your camera can zoom out' });
        this.attributes.add('movementScalar', { type: 'number', default: 2, description: 'Multiply the touch and mouse movement by this much when zoomed out' });
        this.attributes.add('movementSpeed', { type: 'number', default: 0.003, title: 'Movement Multiplier', description: 'Multiply the touch and mouse movement by this much' });
        this.attributes.add('focusSpeed', { type: 'number', default: 1, title: 'focus speed', description: 'The speed at which an object get focussed' });
        this.attributes.add('holdingHeightAddition', { type: 'number', default: 75, title: 'Holding image offset', description: 'the holdingImage offset' });
        this.attributes.add('screen', { type: 'entity' });
        this.attributes.add('home', { type: 'entity', });

    }
    // initialize code called once per entity
    initialize() {
        GardenCamera.instance = this;
        this.initialCameraAspectRatio = 0;
        this.velocity = new pc.Vec3(0, 0, 0);
        this.hundredPercent = 100;
        this.tempEntity = new pc.Entity();
        this.blockCamera = false;
        this.holdingTimer = 0;
        this.selectedLocation = undefined;
        this.selectedEntity = null;
        this.lerpedPosition = new pc.Vec3(0, 0, 0);
        this.targetPosition = new pc.Vec3(0, 0, 0);
        this.pointerUIPos = new pc.Vec2();
        this.clampValues = null;
        this.waiting = false;
        this.pointerLastPos = new pc.Vec2();
        this.batchGroupID = -1;
        this.currentZoom = this.entity.getPosition().y - this.distanceMin;
        this.time = 0;
        this.FTUTutorial = false;

        this.tweening = true;

        this.objectHandler = ObjectHandler.instance;
        this.handle = ObjectHandler.instance.holdingImage;
        this.anchorPos = this.handle.getLocalPosition().clone();
        LoadingScreen.instance.on('startFadeOut', this.checkCameraRatio, this);

        this.app.on('ObjectHandler:cancelObject', this.refreshBatch, this);
        this.app.on('GardenCameraClamp:setClamp', this.setClamp, this);
        this.app.on('ViewportManager:onResize', this._onResize, this);
        this.app.on('UIManager:showUI', this.handleEnabledState, this);
        this.app.on('HoldCounter:ObjectLocked', this.disableBlockedCamera, this);
        this.on('destroy', this._onDestroy, this);

        this.moved = 0;
    }
    postInitialize() {
        // if (GardenDataManager.instance.firstTimeGarden()) {
        //     this.setPositionToHome();
        // }
    }

    setPositionToHome() {
        this.entity.setPosition(this.home.getPosition());
        this.currentZoom = this.entity.getPosition().y - this.distanceMin;

        GardenCamera.instance.focusPosition(this.entity.getPosition());
    }

    // update the camera position
    update(dt) {
        // console.log(this.time)

        if (this.velocity.x !== 0 || this.velocity.z !== 0) {
            this._moveCamera(dt);

            this.checkUpdateLight();
        }

        if (!this.tweening) {
            return;
        }
        // if (UIManager && !UIManager.instance.getScreen("Garden").enabled && !UIManager.instance.getScreen("Garden Edit").enabled) return;


        if (this.blockCamera) {
            if (this.targetPosition.distance(this.entity.getPosition()) > 0.1) {
                this.currentZoom = this.entity.getPosition().y - this.distanceMin;
                this.lerpedPosition.lerp(this.entity.getPosition(), this.targetPosition, this.focusSpeed * dt);

                const dx = this.lerpedPosition.x - this.entity.getPosition().x;
                const dy = this.lerpedPosition.y - this.entity.getPosition().y;
                const dz = this.lerpedPosition.z - this.entity.getPosition().z;

                this.moved += Math.sqrt(dx * dx + dy * dy + dz * dz);

                this.entity.setPosition(this.lerpedPosition);

                this.checkUpdateLight();
            }

            if (this.entity.getPosition().distance(this.targetPosition) < 1 && this.waiting) {
                this.waiting = false;
                this.app.fire('GardenCamera:CloseToObject');
            }
        }

        if (this.entity.getPosition().distance(this.targetPosition) < 0.1) {
            this.tweening = false;
        }
    }

    checkUpdateLight() {
        if (this.moved > 30) {
            this.app.fire('GardenManager:light');
            this.moved = 0
        }
    }

    _onResize() {
        this.clampEntity.clampCamera(this);
        let tries = 0;
        while (this.clampEntity.tohigh && !this.blockCamera) {
            this.zoom(0.25);

            tries++;

            if (tries > 30) {
                console.log("Too many times trying to zoom in")
                break;
            }
        }
    }

    disableBlockedCamera() {
        this.blockCamera = false;
    }

    _onDestroy() {
        this.app.off('ViewportManager:onResize', this._onResize, this);
        this.app.off('ObjectHandler:cancelObject', this.refreshBatch, this);
        this.app.off('GardenCameraClamp:setClamp', this.setClamp, this);
        this.app.off('UIManager:showUI', this.handleEnabledState, this);
        this.app.off('HoldCounter:ObjectLocked', this.disableBlockedCamera, this);
        LoadingScreen.instance.off(' startFadeOut', this.checkCameraRatio, this);
    }

    handleEnabledState(args) {
        this.app.fire('GardenCamera:stopHold');

        switch (args) {
            case 'InputDisabler':
            case 'Shop':
            case 'FloatingUI':
            case 'IAPSuccess':
            case 'IAPFail':
            case 'IAPWarning':
            case 'IAPClosedWhileProcessing':
                break;
            case 'Garden':
            case 'Garden Edit':
            case 'Garden Tasks':
            case 'Garden Cheats':
            case 'Dialog':
            case 'loading':
            case 'Book Unlock':
            case 'LoadingScreen':
            case 'NotEnoughStars':
            case 'NoMoreLivesScreen':
            case 'gardenInput':
            case 'finalImage':
                if (!this.entity.camera.enabled) {
                    this.entity.camera.enabled = true;
                    // this.app.fire('rebatch');
                }
                break;
            default:
                if (this.entity.camera.enabled) {
                    this.entity.camera.enabled = false;
                }
                break;
        }
    }
    // update the speed to move the camera with
    updateVelocity(velocity) {
        if (!this.blockCamera) {
            this.velocity.x += velocity.x;
            this.velocity.z += velocity.y;
        }
    }

    setPointerPos(positionX, positionY) {
        this.pointerLastPos.set(positionX, positionY);
        this.screenSpaceToUISpace();
    }

    screenSpaceToUISpace() {
        var scale = 1 / this.screen.screen.scale;
        var device = this.app.graphicsDevice;

        var xOffs = this.handle.element.anchor.x * ViewportManager.instance.width;
        var yOffs = this.handle.element.anchor.y * ViewportManager.instance.height;

        var screenX = ((this.pointerLastPos.x - xOffs) * scale) * (this.app.graphicsDevice.width / ViewportManager.instance.width);
        var screenY = ((-this.pointerLastPos.y + yOffs) * scale) * (this.app.graphicsDevice.height / ViewportManager.instance.height);

        this.pointerUIPos.set(screenX, screenY + this.holdingHeightAddition);
    }

    onInputDown(entity, x, y) {
        if (ObjectHandler.instance.inEditMode) {
            if (entity && entity.script && entity.script.objectOptions) {
                ObjectHandler.instance.switchEntity(entity);
            }
        }

        this.app.fire('GardenCamera:initHold', x, y);
        this.selectedEntity = entity;

        this.setPointerPos(x, y);

        if (entity && entity.script && entity.script.objectOptions) {
            if ((this.FTUTutorial && entity.script.objectOptions.firstObject) || !this.FTUTutorial) {
                this.app.fire('GardenCamera:startHold', x, y);
                this.checkSelection(entity, x, y);
            }
        }
    }

    onInputMove(entity, x, y) {
        // this.app.fire('GardenCamera:moving', x, y);
        if (!this.selectedEntity) {
            return;
        }

        this.setPointerPos(x, y);

        if (entity !== this.selectedEntity) {
            this.selectedEntity = null;
            this.app.fire('GardenCamera:stopHold');
        } else {
            this.app.fire('GardenCamera:onMove');
        }
    }

    onInputUp(x, y) {
        this.app.fire('GardenCamera:stopHold');

        this.selectedEntity = null;

        this.setPointerPos(x, y);
    }

    // check if the item your selecting could be selected
    checkSelection(entity, x, y) {
        if (entity.script) {
            if (entity.script.get("objectOptions").objectState === ObjectOptions.states.Locked || entity.script.get("objectOptions").getCurrentIndex() === 3) {

                //this.selectedEntity = null;
                // this.app.fire('GardenCamera:stopHold');
                this.app.fire('HoldCounter:setEntity', this.selectedEntity);
                this.app.fire('GardenCamera:holdComplete', false);
                this.selectedEntity = null;
            } else {
                this.app.fire('GardenCamera:holdComplete', true);
            }
        }
    }


    // stop holding an object
    stopHold() {
        if (ObjectHandler.instance.checkingEntity && !ObjectHandler.instance.selectedEntity) {
            ObjectHandler.instance.reset();
            this.holdingTimer = 0;
        }
    }

    // update the zoomdistance of the camera and apply it
    zoom(zoomDistance) {
        if (UIManager.instance.getScreen('Garden Tasks').enabled) {
            return;
        }
        // console.log("zoom", zoomDistance)
        var ratio = pc.app.graphicsDevice.height / pc.app.graphicsDevice.width;

        if (UIManager.instance.getScreen('Shop').enabled || UIManager.instance.getScreen('NoMoreLivesScreen').enabled) {
            return;
        }

        if (!this.blockCamera) {
            //console.log(zoomDistance);
            if (zoomDistance < 0 && this.clampEntity.tohigh) return;
            this.tempEntity.setPosition(this.entity.getPosition());
            this.tempEntity.setRotation(this.entity.getRotation());
            this.tempEntity.translateLocal(0, 0, -zoomDistance);
            if (this.tempEntity.getPosition().y >= this.distanceMin && this.tempEntity.getPosition().y <= (this.distanceMax /* * ratio*/)) {
                this.entity.setPosition(this.tempEntity.getPosition());
            }
            //clamp max zoom
            if (this.tempEntity.getPosition().y > (this.distanceMax /* * ratio*/)) {
                this.entity.setPosition(this.entity.getPosition().x, this.distanceMax /* * ratio*/, this.entity.getPosition().z);
            }
            //clamp min zoom
            if (this.tempEntity.getPosition().y < this.distanceMin) {
                this.entity.setPosition(this.entity.getPosition().x, this.distanceMin, this.entity.getPosition().z);
            }
            this.clampEntity.clampCamera(this);
            this.currentZoom = this.entity.getPosition().y - this.distanceMin;
        }
    }

    // focus the camera on an object
    focusObject(object) {
        // console.log('focus object')
        var objectToFocus = object;
        if (object.script.objectOptions.focusPoint) {
            objectToFocus = object.script.objectOptions.focusPoint;
        }

        if (!objectToFocus) {
            object.script.objectOptions.once('ready', this.focusObject.bind(this, object), this);
            return;
        }

        this.focusPosition(objectToFocus.getPosition(), object.script.objectOptions.amountOfZoomOnFocus);
    }

    // focus the camera on an position
    focusPosition(position, zoom = 0) {
        this.setTargetPosition(position, zoom);
        this.blockCamera = true;
    }

    checkCameraRatio() {
        if (GardenDataManager.instance.firstTimeGarden()) {
            this.setPositionToHome();
        } else {
            this.setPositionToCurrentArea();
        }
    }

    getArea(element) {
        if (this.currentArea) return;
        this.currentWorld = WorldManager.instance.getCurrentWorld();

        if (element.script.areaManager.areaNumber === this.currentWorld) {
            this.currentArea = element.script.areaManager;
        } else {
            this.currentArea = null;
        }
    }

    setPositionToCurrentArea() {
        GardenManager.instance.areas.forEach(this.getArea, this);
        if (this.currentArea) {
            this.entity.setPosition(this.generatePosition(this.currentArea.areaFocusPoint.getPosition(), this.currentArea.areaFocusZoomAmount));
            this.currentZoom = this.entity.getPosition().y - this.distanceMin;
        }
    }

    setTargetPosition(position, zoom = 0) {
        this.targetPosition = this.generatePosition(position, zoom);

        this.tweening = true;
    }

    generatePosition(position, zoom = 0) {
        var pos = position.clone();
        var x = pos.x;
        var y = pos.y + this.distanceMin + zoom;
        var z = pos.z;

        var offset123 = y / Math.tan(this.entity.getEulerAngles().x * Math.PI / 180);

        pos.set(x, y, z + Math.abs(offset123));
        return pos;
    }

    // move the camera if needed
    _moveCamera(deltaTime) {
        this.velocity.x = this.getRealVelocityX();
        this.velocity.z = this.getRealVelocityZ();

        this.moved += this.velocity.length();

        this.entity.translate(this.velocity);

        this.clampEntity.clampCamera(this);

        this.velocity.x = 0;
        this.velocity.z = 0;
    }

    getRealVelocityX() {
        return this.velocity.x * -this.movementSpeed * this.getScalar();
    }

    getRealVelocityZ() {
        return this.velocity.z * -this.movementSpeed * this.getScalar();
    }

    getScalar() {
        return 1 + (this.movementScalar * (((this.currentZoom * 100) / (this.distanceMax - this.distanceMin)) / 100));
    }

    setClamp(clampEntity) {
        this.clampEntity = clampEntity;
        this.clampEntity.clampCamera(this);
    }

    //refresh last selected batchgroup
    refreshBatch() {
        if (this.batchGroupID !== -1) {
            this.app.batcher.markGroupDirty(this.batchGroupID);
        }
    }

    _checkDistance(startLocation, endLocation) {
        return startLocation.distance(endLocation);
    }
}
pc.registerScript(GardenCamera, 'gardenCamera');
GardenCamera.addAttributes();

// BackgroundMeshHandler.js
var BackgroundMeshHandler = pc.createScript('backgroundMeshHandler');

BackgroundMeshHandler.attributes.add('material', { type: 'asset', assetType: 'material' });
BackgroundMeshHandler.attributes.add('tileMaterial', { type: 'asset', assetType: 'material' });
BackgroundMeshHandler.attributes.add('cellWidth', { type: 'number', default: 2 });
BackgroundMeshHandler.attributes.add('cellHeight', { type: 'number', default: 2 });
BackgroundMeshHandler.attributes.add('backgroundMeshTileTemplate', { type: 'asset', assetType: 'template' });
BackgroundMeshHandler.attributes.add('colors', {
    type: 'json', array: true,
    schema: [{
        name: 'backgroundColor',
        type: 'rgb'
    }, {
        name: 'tileColor',
        type: 'rgb'
    }]
});

pc.extend(BackgroundMeshHandler.prototype, {
    initialize: function () {
        BackgroundMeshHandler.instance = this;

        this._grid = null;
        this._vertices = [];
        this._triangles = [];
        this._uvs = [];

        this._mesh = new pc.Mesh();

        this._backgroundMeshTiles = [];

        this.index = pc.math.clamp(WorldManager.instance.getWorldIndex() - 1, 0, this.colors.length - 1);
        this._switchColors();
        this.app.on('WorldManager:setWorld', this.setIndex, this);
        this.app.on('LevelManager:reset', this.reset, this);
        this.on('destroy', this._onDestroy, this);
    },

    _onDestroy: function () {
        this.app.off('WorldManager:setWorld', this.setIndex, this);
        this.app.off('LevelManager:reset', this.reset, this);

        if (this.meshInstance) {
            this.meshInstance.destroy();
            delete this.meshInstance;
        }

        if (this._mesh) {
            this._mesh.destroy();
            delete this._mesh;
        }
    },

    generateMesh: function (grid) {
        this._resetMesh();

        this._grid = grid;
        this._columns = grid.length;
        this._rows = grid[0].length;

        this._createUVs();
        this._createVertices();
        this._createTriangles();
        this._generateMesh();
        this._placeBackgroundMeshTile();
    },

    reset: function () {
        this._resetMesh();
        this._mesh.clear();

        if (this.entity.model) {
            this.entity.model.model = null;
            this.entity.removeComponent('model');
        }
    },

    _resetMesh: function () {
        this._grid = null;
        this._vertices.length = 0;
        this._triangles.length = 0;
        this._uvs.length = 0;

        this._disableBackgroundMeshTiles();
    },

    _createUVs: function () {
        for (var x = 0; x < this._columns + 1; x++) {
            for (var y = 0; y < this._rows + 1; y++) {
                this._uvs.push(x / 2, y / 2);
            }
        }
    },

    _createVertices: function () {
        var centerX = this._columns / 2;
        var centerY = this._rows / 2;

        for (var x = 0; x < this._columns + 1; x++) {
            for (var y = 0; y < this._rows + 1; y++) {
                var xPosition = (x - centerX) * this.cellWidth;
                var yPosition = (y - centerY) * this.cellHeight;

                this._vertices.push(new pc.Vec3(xPosition, yPosition, 0));

            }
        }
    },

    _createTriangles: function () {
        this._squares = 0;

        for (var x = 0; x < this._columns; x++) {
            for (var y = 0; y < this._rows; y++) {
                if (this._grid[x][y].entity.script.get('wall')) {
                    continue;
                }

                var topLeft = (x * (this._rows + 1)) + y;
                var topRight = (x * (this._rows + 1)) + y + 1;
                var bottomLeft = ((x + 1) * (this._rows + 1)) + y;
                var bottomRight = ((x + 1) * (this._rows + 1)) + y + 1;

                this._triangles.push(topRight);
                this._triangles.push(topLeft);
                this._triangles.push(bottomLeft);

                this._triangles.push(bottomRight);
                this._triangles.push(topRight);
                this._triangles.push(bottomLeft);

                this._squares++;
            }
        }
    },

    _placeBackgroundMeshTile: function () {
        this._instantiateBackgroundMeshTiles(this._squares);

        var index = 0;

        var centerX = (this._columns - 1) / 2;
        var centerY = (this._rows - 1) / 2;

        for (var x = 0; x < this._columns; x++) {
            for (var y = 0; y < this._rows; y++) {
                if (this._grid[x][y].entity.script.get('wall')) {
                    continue;
                }

                var instance = this._backgroundMeshTiles[index];

                if (!instance) {
                    continue;
                }

                var xPosition = (x - centerX) * this.cellWidth;
                var yPosition = (y - centerY) * this.cellHeight;

                instance.setLocalPosition(xPosition, yPosition, 0.1);
                instance.setLocalScale(this.cellHeight * 0.67, this.cellHeight * 0.67, this.cellWidth * 0.67);
                instance.enabled = true;

                index++;
            }
        }
    },

    _generateMesh: function () {
        var vertices = [];
        var uvs = [];

        for (var i = 0; i < this._vertices.length; i++) {
            vertices.push(this._vertices[i].x, this._vertices[i].y, this._vertices[i].z);
        }

        var normals = pc.calculateNormals(vertices, this._triangles);


        this._mesh.setPositions(vertices);
        this._mesh.setUvs(0, this._uvs);
        this._mesh.setIndices(this._triangles);
        this._mesh.setNormals(normals);
        this._mesh.update();

        var node = new pc.GraphNode();
        this._material = this.material;
        var meshInstance = new pc.MeshInstance(node, this._mesh, this.material.resource);
        meshInstance.cull = false;
        this.meshInstance = meshInstance;
        // Create a model and add the mesh instance to it
        var model = new pc.Model();
        model.graph = node;
        model.meshInstances = [meshInstance];

        this.entity.addComponent('model', {
            type: 'asset',
        });

        this.entity.model.model = model;

        this.entity.model.receiveShadows = false;
        this.entity.model.castShadows = false;
    },

    _disableBackgroundMeshTiles: function () {
        for (var i = 0; i < this._backgroundMeshTiles.length; i++) {
            this._backgroundMeshTiles[i].enabled = false;
        }
    },

    _instantiateBackgroundMeshTiles: function (amount) {
        for (var i = this._backgroundMeshTiles.length; i < amount; i++) {
            var instance = this.backgroundMeshTileTemplate.resource.instantiate();
            instance.reparent(this.entity);
            instance.enabled = true;

            this._backgroundMeshTiles.push(instance);
        }

        this.app.batcher.markGroupDirty(this.backgroundMeshTileTemplate.resource._templateRoot.model.batchGroupId);
    },

    getAABB: function () {
        return this._mesh.aabb;
    },

    setIndex: function (index) {
        this.index = index - 1;

        if (this.index >= this.colors.length) {
            this.index = pc.math.clamp(index, 0, this.colors.length - 1);
        }

        this._switchColors();
    },

    _switchColors: function () {
        var backgroundColor = this.colors[this.index].backgroundColor;
        this.material.resource.diffuse.set(backgroundColor.r, backgroundColor.g, backgroundColor.b);
        this.material.resource.update();

        var tileColor = this.colors[this.index].tileColor;
        this.tileMaterial.resource.diffuse.set(tileColor.r, tileColor.g, tileColor.b);
        this.tileMaterial.resource.update();
    },
});


// BasicFill.js
var BasicFill = pc.createScript('basicFill');

BasicFill.attributes.add('vs', {
    type: 'asset',
    assetType: 'shader',
    title: 'Vertex Shader'
});

BasicFill.attributes.add('fs', {
    type: 'asset',
    assetType: 'shader',
    title: 'Fragment Shader'
});

BasicFill.attributes.add('difuseMap', {
    type: 'asset',
    assetType: 'texture',
    title: 'Difuse Map'
});

BasicFill.attributes.add('vDirection', {
    type: 'number',
    enum: [
        { 'none': 0 },
        { 'bottomToTop': 1 },
        { 'topToBottom': 2}
    ],
    title: 'Vertical Direction',
    default: 1
});

BasicFill.attributes.add('hDirection', {
    type: 'number',
    enum: [
        { 'none': 0 },
        { 'leftToRight': 1},
        { 'rightToLeft': 2 }
    ],
    title: 'Horizontal Direction',
    default: 0
});

BasicFill.attributes.add('useDiffuseColor', { type: 'boolean', default: false});
BasicFill.attributes.add('fillPercentage', { type: 'number', default: 0.5, min: 0, max: 1 });


BasicFill.attributes.add('silhouetteColor', { type: 'rgba', title: 'Silhouette Color' });
BasicFill.attributes.add('fillColor', { type: 'rgba', title: 'Fill Color' });
BasicFill.attributes.add('addColor', { type: 'rgba', title: 'Add Color' });
BasicFill.attributes.add('addColorCurve', { type: 'curve', curves: [ 'value' ]});

BasicFill.attributes.add('fillSpeed', { type: 'number', default: 500, min: 0, max: 1000 });

pc.extend(BasicFill.prototype, {
    initialize: function(percentage) {
        this.onAttributeChange();
        this.time = 0;

        var app = this.app;
        var gd = app.graphicsDevice;

        var difuseTex = this.difuseMap.resource;
        var vertexShader = this.vs.resource;
        var fragmentShader = "precision " + gd.precision + " float;\n";
        fragmentShader = fragmentShader + this.fs.resource;

        // A shader definition used to create a new shader.
        var shaderDefinition = {
            attributes: {
                aPosition: pc.SEMANTIC_POSITION,
                aUv0: pc.SEMANTIC_TEXCOORD0
            },
            vshader: vertexShader,
            fshader: fragmentShader
        };

        // Create the shader from the definition
        this.shader = new pc.Shader(gd, shaderDefinition);

        // Create a new material and set the shader
        this.material = new pc.Material();
        this.material.blendType = pc.BLEND_PREMULTIPLIED;

        this.entity.element.material = this.material;

        this.material.shader = this.shader;

        this.setFillValues();

        this.material.setParameter('silhouetteColor', [this.silhouetteColor.r, this.silhouetteColor.g, this.silhouetteColor.b, 1.0]);
        this.material.setParameter('fillColor', [this.fillColor.r, this.fillColor.g, this.fillColor.b, 1.0]);
        this.material.setParameter('fillPercentage', percentage);
        this.material.setParameter('vDirection', this.vDirection);
        this.material.setParameter('hDirection', this.hDirection);
        this.material.setParameter('useDiffuseColor', this.useDiffuseColor);

        this.material.setParameter('difuseMap', difuseTex);
        
        this.on('destroy', this.onDestroy, this);
    },
    
    onDestroy: function() {
        this.material.destroy();
        delete this.material;
        
        this.shader.destroy();
    },

    setFillValues: function() {
        this.startFillValue = this.currentValue;
        this.endFillValue = this.currentValue;
        this.startFillTime = 0;
        this.endFillTime = 0;
        this.isFilling = false;
        this.currentLerpColor = new pc.Color();
    },

    update: function() {
        if (!this.isFilling) return;

        var fact = (pc.now() - this.startFillTime) / (this.endFillTime - this.startFillTime);
        if (fact > 1) {
            fact = 1;
            this.isFilling = false;
        }
        var newVal = pc.math.lerp(this.startFillValue, this.endFillValue, fact);
        this.setValue(newVal);

        this.colorFact = this.addColorCurve.value(fact);
        this.currentLerpColor.lerp(this.fillColor, this.addColor, this.colorFact);
        this.updateFillColor(this.currentLerpColor);
    },

    onAttributeChange: function() {          
        this.on('attr:silhouetteColor', function (value, prev) {
            this.material.setParameter('silhouetteColor', [this.silhouetteColor.r, this.silhouetteColor.g, this.silhouetteColor.b, 1.0]);
        });
        this.on('attr:fillColor', function (value, prev) {
            this.material.setParameter('fillColor', [this.fillColor.r, this.fillColor.g, this.fillColor.b, 1.0]);
        });
        this.on('attr:fillPercentage', function (value, prev) {
            this.updateValue(value);
        });
    },

    updateValue: function(val) {
        if (this.fillSpeed <= 0) {
            this.setValue(val);
            return;
        }
        this.startFillValue = this.currentValue || 0;
        this.endFillValue = val;
        this.startFillTime = pc.now();
        this.endFillTime = this.startFillTime + this.fillSpeed;
        this.isFilling = true;
    },

    setValue: function(val) {
        if (!this.material) {
            return;
        }
        this.currentValue = val;
        this.material.setParameter('fillPercentage', val);
    },

    updateFillColor: function(col) {
        if (!this.material) {
            return;
        }
        
        this.material.setParameter('fillColor', [col.r, col.g, col.b, 1.0]);
    },

    setNewTexture: function(texture) {
        var texResource = texture.resource;
        this.material.setParameter('difuseMap', texResource);
        this.material.update();
    },
});

// UibuttonMessage.js
var UibuttonMessage = pc.createScript('uibuttonMessage');
var _Trigger = Object.freeze([
    { OnClick: 0 },
    { OnMouseOver: 1 },
    { OnMouseOut: 2 },
    { OnPress: 3 },
    { OnRelease: 4 },
    { OnDoubleClick: 5 },
    
]);
var Trigger = Object.freeze({
    OnClick: 0,
    OnMouseOver: 1,
    OnMouseOut: 2,
OnPress: 3,
    OnRelease: 4,
    OnDoubleClick: 5,
});

UibuttonMessage.attributes.add('_target', { type: 'entity' });
UibuttonMessage.attributes.add('functionName', { type: 'string' });
UibuttonMessage.attributes.add('trigger', { type: 'number', enum: _Trigger });
UibuttonMessage.attributes.add('includeChildren', { type: 'boolean', default: false });
UibuttonMessage.attributes.add('parameters' , { type : 'number' });
UibuttonMessage.attributes.add('hasSFX' , { type : 'boolean', default: true });

pc.extend(UibuttonMessage.prototype, {
    initialize: function() {
        this.target = this._target;
        this._mStarted = true;
        if (!this.entity.script.elementInput) {
            this.entity.script.create('elementInput');
        }
        
        this.entity.script.elementInput.on(inputEvents.CLICK, this._onClick, this);

        if (!this.hasSFX) {
            this.entity.script.elementInput.clickSFX = null;
        }
    },
    _onPress: function() {
        if (this.entity.enabled) {
            if (this.trigger === Trigger.OnPress) {
                this._send();
            }
        }
    },
    _onRelease: function() {
        if (this.entity.enabled) {
            if (this.trigger === Trigger.OnRelease) {
                this._send();
            }
        }
    },
    _onClick: function() {
        if (this.entity.enabled) {
            if (this.trigger === Trigger.OnClick) {
                this._send();
            }
        }
    },
    _send: function() {
        if (!this.functionName) return;
        if (!this.target) this.target = this.entity;
        if (this.includeChildren) {
//             Transform[] transforms = target.GetComponentsInChildren<Transform>();
//             for (int i = 0, imax = transforms.Length; i < imax; ++i)
//             {
//                 Transform t = transforms[i];
//                 Debug.Log("Send() -> name:" + t.gameObject.name);
//                 t.gameObject.SendMessage(functionName, gameObject, SendMessageOptions.DontRequireReceiver);
//             }
        }
        else {
            var send = false;
            
            for (var i = 0; i < this.target.script.scripts.length; i++) {
                if (typeof this.target.script.scripts[i][this.functionName] === 'function') {
                    this.target.script.scripts[i][this.functionName](this.entity, this.parameters);
                    send = true;
                }
            }
            
            if (!send) {
                console.warn("No function found with the name", this.functionName);
            }
        }
    },
});

// CrossBombBehaviour.js
var CrossBombBehaviour = function() {
    this.initialize();  
};

CrossBombBehaviour.duration = new pc.Vec2(0.5, 0.1);

pc.extend(CrossBombBehaviour.prototype, {
    initialize: function() {
        this.app = pc.Application.getApplication();

        this.firstNineDelay = 0.5;
        this.gridOvershoot = 2;
        this.lineStartDistance = 1;
    },

    getAffectedTiles: function(tile) {
        var array = [];

        var hasCoat = tile.hasCoat();
        var animationData = {
            left: null,
            right: null,
            top: null,
            bottom: null,
        };

        // first 9 tiles
        for (var x = tile.x - 1; x <= tile.x + 1; x += 1) {
            for (var y = tile.y - 1; y <= tile.y + 1; y += 1) {
                if (x === tile.x && y === tile.y) {
                    continue;
                }

                var _backgroundTile = GridManager.instance.getBackgroundTile(x, y);

                if (!_backgroundTile) {
                    continue;
                }

                var d = 0;

                if (_backgroundTile.isPopper()) {
                    if (!_backgroundTile.isPowerTriggered()) {
                        _backgroundTile.explode(this.firstNineDelay, tile);

                        if (_backgroundTile.isDestroyed) {
                            var popperArray = PowerTileManager.instance.explodePopper(_backgroundTile);

                            pc.utils.fuseArray(array, popperArray);
                        }
                    }
                }
                else if (_backgroundTile.canExplode()) {
                    _backgroundTile.explode(this.firstNineDelay + tile.getDespawnDelay(), tile);
                }

                if (_backgroundTile.onlyBackgroundExplodes) {
                    continue;
                }

                if (hasCoat) {
                    _backgroundTile.changeToCoat(this.firstNineDelay + tile.getDespawnDelay());
                }

                var _tile = GridManager.instance.getTile(x, y);

                if (!_tile) {
                    continue;
                }

                if (!_tile.canExplode) {
                    continue;
                }

                if (_tile.isHitByPower()) {
                    continue;
                }

                array.push(_tile);
                _tile.setHitByPower();

                _tile.setDespawnDelay(this.firstNineDelay);
            }
        }

        // horizontal line
        for (var x = tile.x; x < MatchLogic.columns; x += 1) {
            var _backgroundTile = GridManager.instance.getBackgroundTile(x, tile.y);

            var dX = Math.abs(x - tile.x) - this.lineStartDistance;

            if (_backgroundTile.isPopper()) {
                if (_backgroundTile.isPowerTriggered()) {
                    _backgroundTile.explode(PowerTileManager.instance.calculateDespawnDelay(dX, CrossBombBehaviour.duration.x, CrossBombBehaviour.duration.y), tile);

                    if (_backgroundTile.isDestroyed) {
                        var popperArray = PowerTileManager.instance.explodePopper(_backgroundTile);

                        pc.utils.fuseArray(array, popperArray);
                    }
                }
            }
            else if (_backgroundTile.canExplode()) {
                _backgroundTile.explode(PowerTileManager.instance.calculateDespawnDelay(dX, CrossBombBehaviour.duration.x, CrossBombBehaviour.duration.y), tile);
            }

            if (hasCoat) {
                _backgroundTile.changeToCoat(PowerTileManager.instance.calculateDespawnDelay(dX, CrossBombBehaviour.duration.x, CrossBombBehaviour.duration.y));
            }

            if (_backgroundTile.onlyBackgroundExplodes) {
                continue;
            }

            var _tile = GridManager.instance.getTile(x, tile.y);

            if (!_tile) {
                continue;
            }

            if (!_tile.canExplode) {
                continue;
            }

            if (_tile.isHitByPower()) {
                continue;
            }

            array.push(_tile);
            _tile.setHitByPower();

            // set tile despawn if powerup
            if(_tile.typeID !== foregroundTileEnum.NONE && _tile.typeID !== foregroundTileEnum.DEFAULT) {
                _tile.setDespawnCause(foregroundTileEnum.LINE_H);
            }

            _tile.setDespawnDelay(CrossBombBehaviour.duration.x + dX * CrossBombBehaviour.duration.y);
            
            if (_tile.isSinker()) {
                animationData.right = x;
                break;
            }
        }

        for (var x = tile.x - 1; x >= 0; x--) {
            var _backgroundTile = GridManager.instance.getBackgroundTile(x, tile.y);

            var dX = Math.abs(x - tile.x) - this.lineStartDistance;

            if (_backgroundTile.isPopper()) {
                if (_backgroundTile.isPowerTriggered()) {
                    _backgroundTile.explode(PowerTileManager.instance.calculateDespawnDelay(dX, CrossBombBehaviour.duration.x, CrossBombBehaviour.duration.y), tile);

                    if (_backgroundTile.isDestroyed) {
                        var popperArray = PowerTileManager.instance.explodePopper(_backgroundTile);

                        pc.utils.fuseArray(array, popperArray);
                    }
                }
            }
            else if (_backgroundTile.canExplode()) {
                _backgroundTile.explode(PowerTileManager.instance.calculateDespawnDelay(dX, CrossBombBehaviour.duration.x, CrossBombBehaviour.duration.y), tile);
            }

            if (hasCoat) {
                _backgroundTile.changeToCoat(PowerTileManager.instance.calculateDespawnDelay(dX, CrossBombBehaviour.duration.x, CrossBombBehaviour.duration.y));
            }

            if (_backgroundTile.onlyBackgroundExplodes) {
                continue;
            }

            var _tile = GridManager.instance.getTile(x, tile.y);

            if (!_tile) {
                continue;
            }

            if (!_tile.canExplode) {
                continue;
            }

            if (_tile.isHitByPower()) {
                continue;
            }

            array.push(_tile);
            _tile.setHitByPower();

            // set tile despawn if powerup
            if(_tile.typeID !== foregroundTileEnum.NONE && _tile.typeID !== foregroundTileEnum.DEFAULT) {
                _tile.setDespawnCause(foregroundTileEnum.LINE_H);
            }

            _tile.setDespawnDelay(CrossBombBehaviour.duration.x + dX * CrossBombBehaviour.duration.y);
            
            if (_tile.isSinker()) {
                animationData.left = x;
                break;
            }
        }

        // vertical line
        for (var y = tile.y; y < MatchLogic.rows; y += 1) {
            var _backgroundTile = GridManager.instance.getBackgroundTile(tile.x, y);

            var dY = Math.abs(y - tile.y)  - this.lineStartDistance;
            if (_backgroundTile.isPopper()) {
                if (_backgroundTile.isPowerTriggered()) {
                    _backgroundTile.explode(PowerTileManager.instance.calculateDespawnDelay(dY, CrossBombBehaviour.duration.x, CrossBombBehaviour.duration.y), tile);

                    if (_backgroundTile.isDestroyed) {
                        var popperArray = PowerTileManager.instance.explodePopper(_backgroundTile);

                        pc.utils.fuseArray(array, popperArray);
                    }
                }
            }
            else if (_backgroundTile.canExplode()) {
                _backgroundTile.explode(PowerTileManager.instance.calculateDespawnDelay(dY, CrossBombBehaviour.duration.x, CrossBombBehaviour.duration.y), tile);
            }

            if (hasCoat) {
                _backgroundTile.changeToCoat(PowerTileManager.instance.calculateDespawnDelay(dX, CrossBombBehaviour.duration.x, CrossBombBehaviour.duration.y));
            }

            if (_backgroundTile.onlyBackgroundExplodes) {
                continue;
            }

            var _tile = GridManager.instance.getTile(tile.x, y);

            if (!_tile) {
                continue;
            }

            if (!_tile.canExplode) {
                continue;
            }

            if (_tile.isHitByPower()) {
                continue;
            }

            array.push(_tile);
            _tile.setHitByPower();

            // set tile despawn if powerup
            if(_tile.typeID !== foregroundTileEnum.NONE && _tile.typeID !== foregroundTileEnum.DEFAULT) {
                _tile.setDespawnCause(foregroundTileEnum.LINE_V);
            }

            _tile.setDespawnDelay(CrossBombBehaviour.duration.x + dY * CrossBombBehaviour.duration.y);

            if (_tile.isSinker()) {
                animationData.top = y;
                break;
            }
        }

        for (var y = tile.y - 1; y >= 0; y--) {
            var _backgroundTile = GridManager.instance.getBackgroundTile(tile.x, y);

            var dY = Math.abs(y - tile.y)  - this.lineStartDistance;
            
            if (_backgroundTile.isPopper()) {
                if (_backgroundTile.isPowerTriggered()) {
                    _backgroundTile.explode(PowerTileManager.instance.calculateDespawnDelay(dY, CrossBombBehaviour.duration.x, CrossBombBehaviour.duration.y), tile);

                    if (_backgroundTile.isDestroyed) {
                        var popperArray = PowerTileManager.instance.explodePopper(_backgroundTile);

                        pc.utils.fuseArray(array, popperArray);
                    }
                }
            }
            else if (_backgroundTile.canExplode()) {
                _backgroundTile.explode(PowerTileManager.instance.calculateDespawnDelay(dY, CrossBombBehaviour.duration.x, CrossBombBehaviour.duration.y), tile);
            }

            if (hasCoat) {
                _backgroundTile.changeToCoat(PowerTileManager.instance.calculateDespawnDelay(dX, CrossBombBehaviour.duration.x, CrossBombBehaviour.duration.y));
            }

            if (_backgroundTile.onlyBackgroundExplodes) {
                continue;
            }

            var _tile = GridManager.instance.getTile(tile.x, y);

            if (!_tile) {
                continue;
            }

            if (!_tile.canExplode) {
                continue;
            }

            if (_tile.isHitByPower()) {
                continue;
            }

            array.push(_tile);
            _tile.setHitByPower();

            // set tile despawn if powerup
            if(_tile.typeID !== foregroundTileEnum.NONE && _tile.typeID !== foregroundTileEnum.DEFAULT) {
                _tile.setDespawnCause(foregroundTileEnum.LINE_V);
            }

            _tile.setDespawnDelay(CrossBombBehaviour.duration.x + dY * CrossBombBehaviour.duration.y);

            if (_tile.isSinker()) {
                animationData.bottom = y;
                break;
            }
        }

        tile.setPowerAnimation(animationData);


        ImpulseManager.applyPulse(tile.x, tile.y, 5, 0.5, 0.05 + tile.despawnDelay, 0.2);

        return array;
    },

    doActivateAnimation: function(tile) {
        var animationData = tile.getPowerAnimation();

        GridManager.instance.playSFX('bomb_detonate_flowers.mp3');

        // vertical
        var topY = animationData && typeof animationData.top === 'number' ? animationData.top : MatchLogic.rows - 1 + this.gridOvershoot;
        var bottomY = animationData && typeof animationData.bottom === 'number' ? animationData.bottom : 0 - this.gridOvershoot;

        PowerAnimationManager.instance.createLineAnimationCrossbomb(tile.x, tile.y - this.lineStartDistance, CrossBombBehaviour.duration, true, true, tile.x, bottomY, 180, tile.colorID, CrossBombBehaviour.duration.x);
        PowerAnimationManager.instance.createLineAnimationCrossbomb(tile.x, tile.y + this.lineStartDistance, CrossBombBehaviour.duration, true, true, tile.x, topY, 0, tile.colorID, CrossBombBehaviour.duration.x);

        // find opposite side x
        var leftX = animationData && typeof animationData.left === 'number' ? animationData.left : 0 - this.gridOvershoot;
        var rightX = animationData && typeof animationData.right === 'number' ? animationData.right : MatchLogic.columns - 1 + this.gridOvershoot;

        //start anim
        GridManager.instance.playSFX('line_flowers.mp3');
        PowerAnimationManager.instance.createLineAnimationCrossbomb(tile.x - this.lineStartDistance, tile.y, CrossBombBehaviour.duration, false, true, leftX, tile.y, 270, tile.colorID, CrossBombBehaviour.duration.x);
        PowerAnimationManager.instance.createLineAnimationCrossbomb(tile.x + this.lineStartDistance, tile.y, CrossBombBehaviour.duration, false, false, rightX, tile.y, 90, tile.colorID, CrossBombBehaviour.duration.x);
    },

    calculateAngle: function(x, y, centerx, centery) {
        var deltaX =  x - centerx;
        var deltaY =  y - centery;
        var degrees = Math.atan2(deltaY, deltaX) * 180.0 / Math.PI;
        return degrees * -1 + 90;
    }
});


// BackgroundBorderHandler.js
var BackgroundBorderHandler = pc.createScript('backgroundBorderHandler');

BackgroundBorderHandler.attributes.add('material', { type: 'asset', assetType: 'material' });

BackgroundBorderHandler.attributes.add('cellWidth', { type: 'number', default: 1 });
BackgroundBorderHandler.attributes.add('cellHeight', { type: 'number', default: 1 });

BackgroundBorderHandler.attributes.add('radius', { type: 'number', default: 0.1 });
BackgroundBorderHandler.attributes.add('colors', {
    type: 'json', array: true,
    schema: [{
        name: 'borderColor',
        type: 'rgb'
    }]
});


// initialize code called once per entity
pc.extend(BackgroundBorderHandler.prototype, {
    initialize: function () {
        BackgroundBorderHandler.instance = this;

        this._grid = null;
        this._vertices = [];
        this._triangles = [];
        this._uvs = [];

        this._mesh = new pc.Mesh(this.app.graphicsDevice);

        this.index = pc.math.clamp(WorldManager.instance.getWorldIndex() - 1, 0, this.colors.length - 1);
        this._switchColors();
        this.app.on('WorldManager:setWorld', this.setIndex, this);
        this.app.on('LevelManager:reset', this.reset, this);

        this.on('destroy', this._onDestroy, this);
    },

    _onDestroy: function () {
        this.app.off('WorldManager:setWorld', this.setIndex, this);
        this.app.off('LevelManager:reset', this.reset, this);

        if (this.meshInstance) {
            this.meshInstance.destroy();
            delete this.meshInstance;
        }

        if (this._mesh) {
            this._mesh.destroy();
            delete this._mesh;
        }
    },

    generateMesh: function (grid) {
        this._resetMesh();

        this._grid = grid;
        this._columns = grid.length;
        this._rows = grid[0].length;

        this._calculateGridBorderEdges();
        this._generateBorders();
        this._generateMesh();
    },

    reset: function () {
        this._resetMesh();
        this._mesh.clear();
        if (this.entity.model) {
            this.entity.model.model = null;
            this.entity.removeComponent('model');
        }
    },

    _resetMesh: function () {
        this._grid = null;
        this._vertices.length = 0;
        this._triangles.length = 0;
        this._uvs.length = 0;
    },

    _generateBorders: function () {
        var walls = this._getAllWallGroups();

        var gridEdges = this._calculateGridBorderEdges();
        var gridBorderWalls = [];


        for (var i = 0; i < walls.length; i++) {
            var atBorder = this._isGroupAtBorder(walls[i]);

            if (!atBorder) {
                this._generateBorder(walls[i]);
            } else {
                gridBorderWalls = gridBorderWalls.concat(walls[i]);
            }
        }

        this._generateBorder(gridBorderWalls, gridEdges);
    },

    _calculateGridBorderEdges: function () {
        var edges = [];

        var x = 0;
        var y = 0;

        for (x = 0; x < this._columns; x++) {
            y = 0;
            if (!this._grid[x][y].entity.script.get('wall')) {
                var bottomLeft = (x * (this._rows + 1)) + y;
                var bottomRight = ((x + 1) * (this._rows + 1)) + y;

                edges.push({ node1: bottomLeft, node2: bottomRight });
            }

            y = this._rows - 1;

            if (!this._grid[x][y].entity.script.get('wall')) {


                var topLeft = (x * (this._rows + 1)) + y + 1;
                var topRight = ((x + 1) * (this._rows + 1)) + y + 1;

                edges.push({ node1: topLeft, node2: topRight });

            }
        }

        for (y = 0; y < this._rows; y++) {
            x = 0;
            if (!this._grid[x][y].entity.script.get('wall')) {
                var topLeft = (x * (this._rows + 1)) + y + 1;
                var bottomLeft = (x * (this._rows + 1)) + y;

                edges.push({ node1: topLeft, node2: bottomLeft });
            }

            x = this._columns - 1;

            if (!this._grid[x][y].entity.script.get('wall')) {
                var bottomRight = ((x + 1) * (this._rows + 1)) + y;
                var topRight = ((x + 1) * (this._rows + 1)) + y + 1;

                edges.push({ node1: bottomRight, node2: topRight });

            }
        }

        return edges;
    },

    _getEdgesFromWalls: function (walls, edge) {

        var edges = edge || [];

        for (var i = 0; i < walls.length; i++) {
            var x = walls[i].x;
            var y = walls[i].y;

            this._getEdges(x, y, edges);
        }

        return edges;
    },

    _sortEdges: function (edges) {
        var sortedEdges = [edges.shift()];

        while (edges.length !== 0) {
            var length = edges.length;
            var lastNode = sortedEdges[sortedEdges.length - 1].node2;

            for (var j = edges.length - 1; j >= 0; j--) {
                var edge = edges[j];

                if (edge.node1 === lastNode) {
                    sortedEdges.push(edges.splice(j, 1)[0]);
                    break;
                } else if (edge.node2 === lastNode) {
                    var removedEdge = edges.splice(j, 1)[0];

                    sortedEdges.push({ node1: removedEdge.node2, node2: removedEdge.node1 });
                    break;
                }
            }
            if (length === edges.length) {
                this._generateBorder([], edges);
                break;
            }
        }

        return sortedEdges;
    },

    _generateBorder: function (walls, edge) {
        var edges = this._getEdgesFromWalls(walls, edge);
        var sortedEdges = this._sortEdges(edges);

        for (var i = 0; i < sortedEdges.length; i++) {
            var edge = sortedEdges[i];

            var positionNode1 = this._numberToPosition(edge.node1);
            var positionNode2 = this._numberToPosition(edge.node2);

            var direction = BackgroundBorderHandler.VEC_3.sub2(positionNode1, positionNode2);

            var radius = this.radius;

            var length = this._vertices.length;

            if (direction.x < 0 && direction.y === 0) { // Left
                this._vertices.push(new pc.Vec3(positionNode1.x - radius, positionNode1.y + radius, positionNode1.z));
                this._vertices.push(new pc.Vec3(positionNode1.x - radius, positionNode1.y - radius, positionNode1.z));
                this._vertices.push(new pc.Vec3(positionNode2.x + radius, positionNode2.y + radius, positionNode1.z));
                this._vertices.push(new pc.Vec3(positionNode2.x + radius, positionNode2.y - radius, positionNode1.z));
            } else if (direction.x > 0 && direction.y === 0) { // Right
                this._vertices.push(new pc.Vec3(positionNode1.x + radius, positionNode1.y - radius, positionNode1.z));
                this._vertices.push(new pc.Vec3(positionNode1.x + radius, positionNode1.y + radius, positionNode1.z));
                this._vertices.push(new pc.Vec3(positionNode2.x - radius, positionNode2.y - radius, positionNode1.z));
                this._vertices.push(new pc.Vec3(positionNode2.x - radius, positionNode2.y + radius, positionNode1.z));
            } else if (direction.y > 0 && direction.x === 0) { // Up
                this._vertices.push(new pc.Vec3(positionNode1.x + radius, positionNode1.y + radius, positionNode1.z));
                this._vertices.push(new pc.Vec3(positionNode1.x - radius, positionNode1.y + radius, positionNode1.z));
                this._vertices.push(new pc.Vec3(positionNode2.x + radius, positionNode2.y - radius, positionNode1.z));
                this._vertices.push(new pc.Vec3(positionNode2.x - radius, positionNode2.y - radius, positionNode1.z));
            } else if (direction.y < 0 && direction.x === 0) { // Down
                this._vertices.push(new pc.Vec3(positionNode1.x - radius, positionNode1.y - radius, positionNode1.z));
                this._vertices.push(new pc.Vec3(positionNode1.x + radius, positionNode1.y - radius, positionNode1.z));
                this._vertices.push(new pc.Vec3(positionNode2.x - radius, positionNode2.y + radius, positionNode1.z));
                this._vertices.push(new pc.Vec3(positionNode2.x + radius, positionNode2.y + radius, positionNode1.z));
            } else {
                console.log("something went wrong", direction);
            }


            this._triangles.push(length + 0);
            this._triangles.push(length + 1);

            this._triangles.push(length + 2);

            this._triangles.push(length + 1);
            this._triangles.push(length + 3);
            this._triangles.push(length + 2);

            this._uvs.push(0, 0, 0, 0, 0, 0, 0, 0)

        }
    },

    _generateMesh: function () {
        var vertices = [];
        var uvs = [];

        for (var i = 0; i < this._vertices.length; i++) {
            vertices.push(this._vertices[i].x, this._vertices[i].y, this._vertices[i].z);
        }

        var normals = pc.calculateNormals(vertices, this._triangles);

        this._mesh.clear();
        this._mesh.setPositions(vertices);
        this._mesh.setUvs(0, this._uvs);
        this._mesh.setIndices(this._triangles);
        this._mesh.setNormals(normals);
        this._mesh.update();

        var node = new pc.GraphNode();
        this._material = this.material;
        var meshInstance = new pc.MeshInstance(node, this._mesh, this.material.resource);
        meshInstance.cull = false;

        this.meshInstance = meshInstance;
        // Create a model and add the mesh instance to it
        var model = new pc.Model();
        model.graph = node;
        model.meshInstances = [meshInstance];

        this.entity.addComponent('model', {
            type: 'asset',
        });

        this.entity.model.model = model;
        this.entity.model.receiveShadows = false;
        this.entity.model.castShadows = false;
    },

    _getEdges: function (x, y, edges) {
        var bottomLeft = (x * (this._rows + 1)) + y;
        var topLeft = (x * (this._rows + 1)) + y + 1;
        var bottomRight = ((x + 1) * (this._rows + 1)) + y;
        var topRight = ((x + 1) * (this._rows + 1)) + y + 1;

        if (this._grid[x - 1]) {
            var neighbourLeft = this._grid[x - 1][y];

            if (!neighbourLeft.entity.script.get('wall')) {
                edges.push({ node1: bottomLeft, node2: topLeft });
            }
        }

        if (this._grid[x + 1]) {

            var neighbourRight = this._grid[x + 1][y];

            if (!neighbourRight.entity.script.get('wall')) {
                edges.push({ node1: bottomRight, node2: topRight });
            }
        }

        if (this._grid[x][y + 1]) {
            var neighbourUp = this._grid[x][y + 1];

            if (!neighbourUp.entity.script.get('wall')) {
                edges.push({ node1: topLeft, node2: topRight });
            }
        }

        if (this._grid[x][y - 1]) {
            var neighbourDown = this._grid[x][y - 1];

            if (!neighbourDown.entity.script.get('wall')) {
                edges.push({ node1: bottomLeft, node2: bottomRight });
            }
        }
    },

    _getNeighbours: function (x, y) {
        var left = x - 1;
        var right = x + 1;
        var up = y + 1;
        var down = y - 1;

        return [this._grid[left][y], this._grid[right][y], this._grid[x][up], this._grid[x][down]];
    },

    _getAllWallGroups: function () {
        var allWallGroups = [];
        for (var x = 0; x < this._columns; x++) {
            for (var y = 0; y < this._rows; y++) {
                if (this._grid[x][y].entity.script.get('wall')) {

                    var found = false;

                    for (var i = 0; i < allWallGroups.length; i++) {
                        if (pc.utils.isElementInArray(this._grid[x][y], allWallGroups[i])) {
                            found = true;
                            break;
                        }
                    }

                    if (!found) {
                        var group = [this._grid[x][y]];

                        this._getWallNeighbours(x, y, group);

                        allWallGroups.push(group);
                    }
                }
            }
        }

        return allWallGroups;
    },

    _isGroupAtBorder: function (group) {
        for (var i = 0; i < group.length; i++) {
            var tile = group[i];

            if (tile.x === 0 || tile.x === this._columns - 1 || tile.y === 0 || tile.y === this._rows - 1) {
                return true;
            }
        }

        return false;
    },

    _getWallNeighbours: function (x, y, group) {
        var left = x - 1;
        var right = x + 1;
        var up = y + 1;
        var down = y - 1;

        // Left
        if (this._grid[left] && this._grid[left][y]) {
            var leftTile = this._grid[left][y];
            if (leftTile.entity.script.get('wall')) {
                if (!pc.utils.isElementInArray(leftTile, group)) {
                    group.push(leftTile);

                    this._getWallNeighbours(left, y, group);
                }
            }
        }

        // Right
        if (this._grid[right] && this._grid[right][y]) {
            var rightTile = this._grid[right][y];
            if (rightTile.entity.script.get('wall')) {
                if (!pc.utils.isElementInArray(rightTile, group)) {
                    group.push(rightTile);

                    this._getWallNeighbours(right, y, group);
                }
            }
        }

        // Up
        if (this._grid[x][up]) {
            var upTile = this._grid[x][up];
            if (upTile.entity.script.get('wall')) {
                if (!pc.utils.isElementInArray(upTile, group)) {
                    group.push(upTile);

                    this._getWallNeighbours(x, up, group);
                }
            }
        }

        // Down
        if (this._grid[x][down]) {
            var downTile = this._grid[x][down];
            if (downTile.entity.script.get('wall')) {
                if (!pc.utils.isElementInArray(downTile, group)) {
                    group.push(downTile);

                    this._getWallNeighbours(x, down, group);
                }
            }
        }
    },

    _numberToPosition: function (number) {
        var y = number % (this._rows + 1);
        var x = Math.floor(number / (this._rows + 1));

        var centerX = (this._columns) / 2;
        var centerY = (this._rows) / 2;
        var xPosition = (x - centerX) * this.cellWidth;
        var yPosition = (y - centerY) * this.cellHeight;

        return new pc.Vec3(xPosition, yPosition, -0.01);
    },

    getAABB: function () {
        return this._mesh.aabb;
    },

    setIndex: function (index) {
        this.index = index - 1;

        if (this.index >= this.colors.length) {
            this.index = pc.math.clamp(index, 0, this.colors.length - 1);
        }

        this._switchColors();
    },

    _switchColors: function () {
        var borderColor = this.colors[this.index].borderColor;
        this.material.resource.diffuse.set(borderColor.r, borderColor.g, borderColor.b);
        this.material.resource.update();
    },
});

BackgroundBorderHandler.VEC_3 = new pc.Vec3();

// ObjectiveInterface.js
var ObjectiveInterface = pc.createScript('objectiveInterface');

ObjectiveInterface.attributes.add('objectivePrefab', { type: 'entity' });
ObjectiveInterface.attributes.add('objectiveDividerPrefab', { type: 'entity' });

pc.extend(ObjectiveInterface.prototype, {
    initialize: function() {
        this.objectives = [];
        this.objectivesAndDividers = [];
        this.app.on('ObjectiveManager:onObjectiveAdd', this.onObjectiveAdd, this);
        this.app.on('ObjectiveManager:onObjectiveChange', this.onObjectiveChange, this);
        this.app.on('ObjectiveManager:onObjectiveComplete', this.onObjectiveComplete, this);
        this.app.on('ObjectiveManager:onReset', this.onReset, this);     
        
        for (var i = 0; i < ObjectiveManager.instance._objectiveSlots.length; i++) {
            this.onObjectiveAdd(ObjectiveManager.instance._objectiveSlots[i]);
        }
    },

    onObjectiveAdd: function(objectiveData) {
        if (this.objectives.length > 0) {
            var divider = this.objectiveDividerPrefab.clone();
            divider.enabled = true;
            divider.reparent(this.entity);
            this.objectivesAndDividers.push(divider);
        }
        var newObjective = this.objectivePrefab.clone();
        newObjective.enabled = true;
        newObjective.reparent(this.entity);
        this.objectives.push(newObjective);
        this.objectivesAndDividers.push(newObjective);

        var sprite = TileLibrary.instance.getTileSprite(objectiveData.orderTypeObject);
        newObjective.script.objectivePrefab.setObjectiveImage(sprite);
        this.onObjectiveChange(this.objectives.length -1, objectiveData);
    },

    onObjectiveChange: function(i, objectiveData) {
        var value = objectiveData.values.goal - objectiveData.values.currentVisible;
        if (value < 0) value = 0;
        
        var doTween = objectiveData.values.currentVisible < objectiveData.values.goal && objectiveData.values.currentVisible > 0;
        this.objectives[i].script.objectivePrefab.changeValueText(value, doTween);
    },

    onObjectiveComplete: function(i) {
        this.objectives[i].script.objectivePrefab.setObjectiveCompleted();
    },

    onReset: function() {
        for (var i = 0; i < this.objectivesAndDividers.length; i += 1) {
            this.objectivesAndDividers[i].destroy();
        }
        this.objectivesAndDividers.length = 0;
        this.objectives.length = 0;
    }
});

// ParticleHandler.js
var ParticleHandler = pc.createScript('particleHandler');

pc.extend(ParticleHandler.prototype, {
    initialize: function () {

        this._sprite = this.entity.sprite;
        this._clip = this.entity.sprite.clip('particle');

        this._active = false;
    },

    update: function () {
        if (this._active && !this._clip.isPlaying) {
            this._recycle();
        }
    },

    awake: function (position, parent, sprite, color) {
        if (!sprite || !color) {
            this._recycle();
            return;
        }

        this.entity.setPosition(position);
        this.entity.reparent(parent);
        this._active = true;


        var clip = this._sprite.play('particle');

        if (!clip.spriteAsset || !clip.sprite) {
            clip.spriteAsset = this.app.assets.find('flower_partical').id;
        }

        this._clip.sprite = sprite;
        this._sprite.color = color;
    },

    _recycle: function () {
        GridManager.instance.recycleParticle(this.entity);
        this._active = false;
        this.entity.enabled = false;
    },
});

// ObjectivePrefab.js
var ObjectivePrefab = pc.createScript('objectivePrefab');

ObjectivePrefab.attributes.add('objectiveIcon', { type: 'entity' });
ObjectivePrefab.attributes.add('valueText', { type: 'entity' });
ObjectivePrefab.attributes.add('checkIcon', { type: 'entity' });

pc.extend(ObjectivePrefab.prototype, {
    initialize: function() {
        this.checkIcon.enabled = false;
    },

    setObjectiveImage: function(image) {
        this.objectiveIcon.element.spriteAsset = image;
    },

    changeValueText: function(value, doTween) {
        this.valueText.element.text = value;
        if (doTween) this.bubbleTween(this.objectiveIcon);
    },
    
    setObjectiveCompleted: function() {
        this.checkIcon.setLocalScale(0, 0, 0);
        this.checkIcon.enabled = true;
        this.bubbleTween(this.checkIcon);
        this.valueText.enabled = false;
    },

    bubbleTween: function(entity) {
        if (this._despawning || this._spawning) return;

        var t1 = entity.tween(entity.getLocalScale()).to({x: 1.5, y: 1.5, z: 1.5}, 0.08, pc.SineInOut);
        var t2 = entity.tween(entity.getLocalScale()).to({x: 0.8, y: 0.8, z: 0.8}, 0.15, pc.SineInOut);
        var t3 = entity.tween(entity.getLocalScale()).to({x: 1.1, y: 1.1, z: 1.1}, 0.05, pc.SineInOut);
        var t4 = entity.tween(entity.getLocalScale()).to({x: 1, y: 1, z: 1}, 0.05, pc.SineInOut);
        t1.chain(t2);
        t2.chain(t3);
        t3.chain(t4);

        t1.start();
    },
});

// BombTile.js
var BombTile = pc.createScript('bombTile');

BombTile.tileColorEnumCopy = Object.freeze({
    NONE: 0,
    BLUE: 1,
    YELLOW: 2,
    RED: 3,
    PURPLE: 4,
    GREEN: 5,
    ORANGE: 6,
});

BombTile.colorEnum = [
    { NONE: BombTile.tileColorEnumCopy.NONE },
    { BLUE: BombTile.tileColorEnumCopy.BLUE },
    { YELLOW: BombTile.tileColorEnumCopy.YELLOW },
    { RED: BombTile.tileColorEnumCopy.RED },
    { PURPLE: BombTile.tileColorEnumCopy.PURPLE},
    { GREEN: BombTile.tileColorEnumCopy.GREEN },
    { ORANGE: BombTile.tileColorEnumCopy.ORANGE }
];

BombTile.attributes.add('colorId', { type: 'number', enum: BombTile.colorEnum });


// initialize code called once per entity
pc.extend(BombTile.prototype, {
    initialize: function() {
        
    },
    
    init: function(superClass) {
        this.superClass = superClass;
        
        this.superClass.colorID = this.colorId;
        this.superClass.typeID = foregroundTileEnum.BOMB;
    }
});





// PowerTileManager.js
var PowerTileManager = pc.createScript('powerTileManager');

pc.extend(PowerTileManager.prototype, {
    initialize: function () {
        if (Singleton.instance.canCreateInstance(PowerTileManager)) {
            PowerTileManager.instance = this;
        }

        this.popperBehaviour = new PopperBehaviour();

        this.powerBehaviourScripts = {
            [foregroundTileEnum.LINE_H]: new LineHBehaviour(),
            [foregroundTileEnum.LINE_V]: new LineVBehaviour(),
            [foregroundTileEnum.COLORBOMB]: new ColorBombBehaviour(),
            [foregroundTileEnum.BOMB]: new BombBehaviour(),
        };
        this._delayedActionQueue = [];

        this.powerStrengthOrder = {
            [foregroundTileEnum.COLORBOMB]: 4,
            [foregroundTileEnum.BOMB]: 3,
            [foregroundTileEnum.LINE_H]: 2,
            [foregroundTileEnum.LINE_V]: 1,
        };
    },

    update: function (dt) {
        for (var i = this._delayedActionQueue.length - 1; i >= 0; i -= 1) {
            this._delayedActionQueue[i].timer += dt;
            if (this._delayedActionQueue[i].timer >= this._delayedActionQueue[i].delay) {
                this._delayedActionQueue[i].action(this._delayedActionQueue[i].delay);
                this._delayedActionQueue.splice(i, 1);
            }
        }
    },

    onTileSwap: function (tile1, tile2) {
        // check if two tiles have a combination power
        var affectedTiles = [];

        if (tile1 instanceof BackgroundTile || tile2 instanceof BackgroundTile) {
            return affectedTiles;
        }
        // in case of color bombs, the match tile is always the color bomb and not the swapped tile like normal
        if (tile2.typeID === foregroundTileEnum.COLORBOMB && tile1.typeID !== foregroundTileEnum.COLORBOMB) {
            affectedTiles = this.checkPowerCombination(tile2, tile1);
        } else {
            affectedTiles = this.checkPowerCombination(tile1, tile2);
        }

        if (affectedTiles.length > 0) {

            var array1 = this.checkIfPopperIsExploded(tile1);
            var array2 = this.checkIfPopperIsExploded(tile1);

            pc.utils.fuseArray(affectedTiles, array1);
            pc.utils.fuseArray(affectedTiles, array2);

            this.app.fire('ScoreManager:scoreEachPowerTile', affectedTiles);
            return affectedTiles;
        }

        // check color bomb actvation
        if (tile1.typeID === foregroundTileEnum.COLORBOMB) {
            var array1 = this.checkIfPopperIsExploded(tile1);
            var array2 = this.checkIfPopperIsExploded(tile1);
            var array3 = this.activatePower(tile1, tile2);
            pc.utils.fuseArray(affectedTiles, array1);
            pc.utils.fuseArray(affectedTiles, array2);
            pc.utils.fuseArray(affectedTiles, array3);

            return affectedTiles;
        }

        if (tile2.typeID === foregroundTileEnum.COLORBOMB) {
            var array1 = this.checkIfPopperIsExploded(tile1);
            var array2 = this.checkIfPopperIsExploded(tile1);
            var array3 = this.activatePower(tile2, tile1);
            pc.utils.fuseArray(affectedTiles, array1);
            pc.utils.fuseArray(affectedTiles, array2);
            pc.utils.fuseArray(affectedTiles, array3);

            return affectedTiles;
        }

        return [];

    },

    checkPowerCombination: function (tile1, tile2) {
        // Normal types
        if (!this.isPowerCombination(tile1, tile2)) {
            return [];
        }
        var powerBehaviour = this.powerBehaviourScripts[tile1.typeID];

        // this._updatePowerStatistics(tile1.typeID);
        // this._updatePowerStatistics(tile2.typeID);

        StatisticsManager.instance.incrementStatistic('special_combination', {
            combination: `${TileLibrary.instance.getPowerTileName(tile1.typeID)}_${TileLibrary.instance.getPowerTileName(tile2.typeID)}`,

            color_combination: `${TileLibrary.instance.getColorName(tile1.colorID)}_${TileLibrary.instance.getColorName(tile2.colorID)}`,
        });

        // get combination behaviour for current power
        var combinationBehaviour = powerBehaviour.getCombinationScript(tile2.typeID);
        if (combinationBehaviour === null) return [];

        tile1.setPowerState(ForegroundTile._PowerStates.TRIGGERED);
        tile2.setPowerState(ForegroundTile._PowerStates.TRIGGERED);

        var affectedTiles = combinationBehaviour.getAffectedTiles(tile1, tile2, tile1.colorID > 0 ? tile1.colorID : tile2.colorID);
        this.startAnimation(tile1, combinationBehaviour, affectedTiles, tile2);
        this.app.fire('Audio:sfx', 'power_combination_fuse.mp3');

        return affectedTiles;

    },

    isPowerCombination: function (tile1, tile2) {
        if (!tile1 || !tile2) {
            return false;
        }

        return this.isPowerTile(tile2.typeID) && this.isPowerTile(tile1.typeID);
    },

    isPowerTile: function (typeID) {
        return typeID === foregroundTileEnum.LINE_H ||
            typeID === foregroundTileEnum.LINE_V ||
            typeID === foregroundTileEnum.BOMB ||
            typeID === foregroundTileEnum.COLORBOMB;
    },

    checkIfPopperIsExploded: function (tile) {
        var array = [];
        var neighbours = MatchLogic.getNeighbours(tile, null, tileLayerEnum.BACKGROUND);

        for (var i = 0; i < neighbours.length; i++) {
            var bgTile = neighbours[i];

            if (bgTile.isPopper()) {
                if (bgTile.currentLayer === 1 && !bgTile.hasExploded && !bgTile.isPowerTriggered()) {
                    bgTile.setDespawnDelay(tile.despawnDelay);
                    var arr = this.activatePower(bgTile, null, tile.despawnDelay);

                    pc.utils.fuseArray(array, arr);
                }
            }
        }

        return array;
    },

    activatePower: function (tile, matchedTile, delay) {
        if (tile instanceof BackgroundTile) {
            if (tile.isPopper()) {
                var array = this.explodePopper(tile, delay);
                return array;
            }
            return [];
        }
        var typeID = tile.typeID;

        // Check if Lines are the same and if they are, alternate them
        if (tile.getDespawnCause() === tile.typeID && (tile.typeID === foregroundTileEnum.LINE_V || tile.typeID === foregroundTileEnum.LINE_H))
            typeID = tile.typeID === foregroundTileEnum.LINE_V ? foregroundTileEnum.LINE_H : foregroundTileEnum.LINE_V;

        var powerBehaviour = this.powerBehaviourScripts[typeID];
        if (!powerBehaviour) {
            console.warn('No power behaviour script for power: ', typeID);
            return [];
        }

        if (matchedTile) {
            if (matchedTile.hasCoat() || tile.hasCoat()) {
                matchedTile.getBackgroundTile().changeToCoat(Object.getPrototypeOf(powerBehaviour).constructor.duration.x);
                tile.getBackgroundTile().changeToCoat(Object.getPrototypeOf(powerBehaviour).constructor.duration.x);
            }
        }

        var affectedTiles = powerBehaviour.getAffectedTiles(tile, matchedTile);

        if (affectedTiles.length === 0 && typeID === foregroundTileEnum.COLORBOMB) {
            // Do nothing
            // TODO check if it's needed for other power tiles.
        } else {
            tile.setPowerState(ForegroundTile._PowerStates.TRIGGERED);

            this.startAnimation(tile, powerBehaviour, affectedTiles, matchedTile);

            this.app.fire('ScoreManager:scoreEachPowerTile', affectedTiles);

            this._updatePowerStatistics(tile);
        }

        return affectedTiles;
    },

    explodePopper(tile, delay) {
        tile.triggerPower();

        var affectedTiles = this.popperBehaviour.getAffectedTiles(tile, delay);

        if (affectedTiles.length > 0) {
            this.startAnimation(tile, this.popperBehaviour, affectedTiles);

            this.app.fire('ScoreManager:scoreEachPowerTile', affectedTiles);

            //this._updatePowerStatistics(typeID);

            return affectedTiles;
        }

        return [];
    },

    isPowerStronger: function (tile1, tile2) {
        if (!this.isPowerTile(tile1) || !this.isPowerTile(tile2)) return false;

        return this.powerStrengthOrder[tile1.typeID] > this.powerStrengthOrder[tile2.typeID];
    },

    checkPowerTileSpawn: function (horizontalLength, verticalLength) {
        // Color bomb 
        if (horizontalLength >= 5 || verticalLength >= 5) {
            return foregroundTileEnum.COLORBOMB;
        }

        // 9 tile bomb
        if (horizontalLength >= 3 && verticalLength >= 3) {
            return foregroundTileEnum.BOMB;
        }

        // Horizontal bomb
        if (verticalLength >= 4) {
            return foregroundTileEnum.LINE_H;
        }

        // Vertical bomb
        if (horizontalLength >= 4) {
            return foregroundTileEnum.LINE_V;
        }

        return foregroundTileEnum.EMPTY;
    },

    checkForPoppers: function (matches) {
        var array = [];

        var poppersExploded = [];

        for (var i = 0; i < matches.length; i++) {
            var tile = matches[i];

            if (!tile.isHitByMatch()) {
                continue;
            }

            var neighbours = MatchLogic.getNeighbours(tile, null, tileLayerEnum.BACKGROUND);

            for (var j = 0; j < neighbours.length; j++) {
                var bgTile = neighbours[j];

                if (bgTile.isPopper()) {
                    if (bgTile.currentLayer === 1 && !bgTile.hasExploded && !bgTile.isPowerTriggered()) {
                        bgTile.setDespawnDelay(tile.despawnDelay);
                        bgTile.triggerPower();
                        bgTile.explode(tile.despawnDelay);

                        poppersExploded.push({ tile: bgTile, delay: tile.despawnDelay });
                    }
                }
            }
        }

        for (var k = 0; k < poppersExploded.length; k++) {
            var data = poppersExploded[k];

            var arr = this.activatePower(data.tile, null, data.delay);

            pc.utils.fuseArray(array, arr);
        }

        return array;
    },

    onTileMatch: function (tile) {
        var array = [];

        if (!this.isPowerTile(tile.typeID) || !tile.isPowerActive()) return array;

        var backgroundTile = GridManager.instance.getBackgroundTile(tile.x, tile.y);

        if (backgroundTile.onlyBackgroundExplodes && !backgroundTile.isDestroyed) {
            return array;
        }

        pc.utils.fuseArray(array, this.activatePower(tile));

        return array;
    },

    calculateDespawnDelay: function (index, durationStart, durationOffset) {
        return durationStart + index * durationOffset;
    },

    setTileDespawnDelay: function (tile1, tile2, index, durationStart, durationOffset) {
        var delay = 0;

        if (!Number.isFinite(durationStart)) {
            delay = index;
        } else {
            delay = this.calculateDespawnDelay(index, durationStart, durationOffset);
        }

        var currentDelay = tile1.getDespawnDelay(true);
        tile2.setDespawnDelay(currentDelay + delay);
    },

    startAnimation: function (tile, powerBehaviour, affectedTiles, matchedTile) {
        if (tile.getDespawnDelay() <= 0) {
            powerBehaviour.doActivateAnimation(tile, affectedTiles, matchedTile);
        } else {
            this._addDelayedAction(tile.getDespawnDelay(), function () {
                powerBehaviour.doActivateAnimation(tile, affectedTiles, matchedTile);
            }.bind(this));
            // this.waitForAnimation = { delay: tile.despawnDelay, timer: 0, powerBehaviour: powerBehaviour, affectedTiles: affectedTiles, matchedTile: matchedTile };
        }
    },

    _addDelayedAction: function (delay, onComplete) {
        this._delayedActionQueue.push({ timer: 0, delay: delay, action: onComplete });
    },

    _updatePowerStatistics: function (tile) {
        StatisticsManager.instance.incrementStatistic("special_triggered", {
            special: TileLibrary.instance.getPowerTileName(tile.typeID),
            color: TileLibrary.instance.getColorName(tile.colorID),
            // triggered_by: TileLibrary.instance.getPowerTileName(tile.getDespawnCause()) || 'swap',
        });

        // if (powerId === foregroundTileEnum.LINE_V || powerId === foregroundTileEnum.LINE_H) StatisticsManager.instance.incrementStatistic("bees_activated", 1);
        // if (powerId === foregroundTileEnum.COLORBOMB) StatisticsManager.instance.incrementStatistic("butterflies_activated", 1);
        // if (powerId === foregroundTileEnum.BOMB) StatisticsManager.instance.incrementStatistic("ladybugs_activated", 1);
    },

    switchTilePower: function (tile, typeID, appearanceDelay) {
        var x = tile.x;
        var y = tile.y;
        var colorID = tile.colorID;

        var newTile = GridManager.instance._spawnForegroundTile(x, y, false, 0, colorID, typeID, false, 0, true);
        GridManager.instance._tileArrayForeground[x][y] = newTile;
        this.setTileState(newTile, ForegroundTile._PowerStates.IMMUNE);
        newTile.isMovedTile = true;
        if (!appearanceDelay || appearanceDelay <= 0) {
            newTile.spawnAnimation(undefined, 0, true);
            if (SwapMode.instance.currentState === matchStates.ENDSPAWN || SwapMode.instance.currentState === matchStates.END) this.app.fire('PowerTileManager:onEndModePowerSpawn', this.currentMove);
        } else {
            tile.setDespawnDelay(appearanceDelay);
            newTile.entity.setLocalScale(pc.Vec3.ZERO);
            this._addDelayedAction(appearanceDelay, function () {
                GridManager.instance.playSFX('power_create.mp3');
                newTile.spawnAnimation(undefined, 0, true);
                if (SwapMode.instance.currentState === matchStates.ENDSPAWN || SwapMode.instance.currentState === matchStates.END) this.app.fire('PowerTileManager:onEndModePowerSpawn', this.currentMove);
            }.bind(this));
        }
        tile.despawn();
        return newTile;
    },

    setTileState: function (tile, state) {
        if (tile.isPowerState(ForegroundTile._PowerStates.TRIGGERED)) return;
        tile.setPowerState(state);
    },
});


// PowerHorizontalTile.js
var PowerHorizontalTile = pc.createScript('powerHorizontalTile');

PowerHorizontalTile.tileColorEnumCopy = Object.freeze({
    NONE: 0,
    BLUE: 1,
    YELLOW: 2,
    RED: 3,
    PURPLE: 4,
    GREEN: 5,
    ORANGE: 6,
});

PowerHorizontalTile.colorEnum = [
    { NONE: PowerHorizontalTile.tileColorEnumCopy.NONE },
    { BLUE: PowerHorizontalTile.tileColorEnumCopy.BLUE },
    { YELLOW: PowerHorizontalTile.tileColorEnumCopy.YELLOW },
    { RED: PowerHorizontalTile.tileColorEnumCopy.RED },
    { PURPLE: PowerHorizontalTile.tileColorEnumCopy.PURPLE},
    { GREEN: PowerHorizontalTile.tileColorEnumCopy.GREEN },
    { ORANGE: PowerHorizontalTile.tileColorEnumCopy.ORANGE }
];

PowerHorizontalTile.attributes.add('colorId', { type: 'number', enum: PowerHorizontalTile.colorEnum });

// initialize code called once per entity
pc.extend(PowerHorizontalTile.prototype, {
    initialize: function() {
        
    },
    
    init: function(superClass) {
        this.superClass = superClass;

        this.superClass.colorID = this.colorId;
        this.superClass.typeID = foregroundTileEnum.LINE_H;
    }
});





// PowerVerticalTile.js
var PowerVerticalTile = pc.createScript('powerVerticalTile');

PowerVerticalTile.tileColorEnumCopy = Object.freeze({
    NONE: 0,
    BLUE: 1,
    YELLOW: 2,
    RED: 3,
    PURPLE: 4,
    GREEN: 5,
    ORANGE: 6,
});

PowerVerticalTile.colorEnum = [
    { NONE: PowerVerticalTile.tileColorEnumCopy.NONE },
    { BLUE: PowerVerticalTile.tileColorEnumCopy.BLUE },
    { YELLOW: PowerVerticalTile.tileColorEnumCopy.YELLOW },
    { RED: PowerVerticalTile.tileColorEnumCopy.RED },
    { PURPLE: PowerVerticalTile.tileColorEnumCopy.PURPLE},
    { GREEN: PowerVerticalTile.tileColorEnumCopy.GREEN },
    { ORANGE: PowerVerticalTile.tileColorEnumCopy.ORANGE }
];

PowerVerticalTile.attributes.add('colorId', { type: 'number', enum: PowerVerticalTile.colorEnum });

// initialize code called once per entity
pc.extend(PowerVerticalTile.prototype, {
    initialize: function() {
        
    },
    
    init: function(superClass) {
        this.superClass = superClass;

        this.superClass.colorID = this.colorId;
        this.superClass.typeID = foregroundTileEnum.LINE_V;
    }
});





// ColorBombTile.js
var ColorBombTile = pc.createScript('colorBombTile');


// initialize code called once per entity
pc.extend(ColorBombTile.prototype, {
    initialize: function() {
        
    },
    
    init: function(superClass) {
        this.superClass = superClass;
        
        this.superClass.colorID = tileColorEnum.NONE;
        this.superClass.typeID = foregroundTileEnum.COLORBOMB;
    }
});





// BackgroundSpriteHandler.js
var BackgroundSpriteHandler = pc.createScript('backgroundSpriteHandler');

pc.extend(BackgroundSpriteHandler.prototype, {
    initialize: function () {
        BackgroundSpriteHandler.instance = this;

        this.sprite = this.entity.sprite;

        this.app.on('ViewportManager:onResize', this._switchSprite, this);
        this.app.on('PerspectiveView:onCameraChange', this._switchSprite, this);
        this.app.on('LevelManager:onLevelStart', this._switchSprite, this);
        this.app.on('WorldManager:setWorld', this._switchSprite, this);
        this.app.on('BackToGardenButton:click', this.onSceneSwitch, this);

        this.on('destroy', this._onDestroy, this);
    },

    onSceneSwitch: function (scene) {
        if (scene === 'World') {
            return;
        }

        this.entity.destroy()
    },

    postInitialize: function () {
        // this._onResize(null, innerWidth, innerHeight);
    },

    _onDestroy: function () {
        this.app.off('ViewportManager:onResize', this._switchSprite, this);
        this.app.off('PerspectiveView:onCameraChange', this._switchSprite, this);
        this.app.off('LevelManager:onLevelStart', this._switchSprite, this);
        this.app.off('WorldManager:setWorld', this._switchSprite, this);
    },

    _switchSprite: function () {
        this.spriteAsset = WorldManager.instance.getBlurredWorldBackgroundImage();
        this.spriteAtlasAsset = this.app.assets.get(this.spriteAsset.data.textureAtlasAsset);

        if (!this.spriteAsset) {
            console.warn("No sprite asset");
            return;
        }

        if (!this.spriteAtlasAsset) {
            console.warn("No sprite atlas asset");
            return;
        }

        if (this.spriteAsset.loaded && this.spriteAtlasAsset.loaded) {
            this._onResize();
        } else if (!this.spriteAsset.loading && !this.spriteAtlasAsset.loading) {
            const assets = [
                this.spriteAsset,
                this.spriteAtlasAsset,
            ];
            LazyLoader.instance.lazyLoadParallel(assets, this._onResize, this);
        } else {
            console.log("waiting");
        }
    },

    _onResize: function (orientation, width, height) {
        if (!this.entity.enabled) {
            return;
        }

        if (!this.spriteAsset) {
            console.warn("no sprite asset")
            return;
        }

        if (!width) {
            width = ViewportManager.instance.width;
        }

        if (!height) {
            height = ViewportManager.instance.height;
        }

        // if (this.entity.script.blurShader.uDiffuseMap !== this.spriteAsset) {
        //     this.entity.script.blurShader.uDiffuseMap = this.spriteAsset;
        // }        

        if (!this.sprite || !this.sprite._currentClip) {
            this._onDestroy();
            return;
        }

        if (this.sprite.sprite !== this.spriteAsset.resource) {
            this.sprite.sprite = this.spriteAsset.resource;
        }

        if (!this.spriteAsset.resource.atlas) {
            console.warn("no atlas", this.spriteAsset)
            setTimeout(this._onResize.bind(this), 200)
            return;
        }

        var size = this.spriteAsset.resource.atlas.frames["1"].rect;
        var spriteWidth = size.z / 100 / 2;

        var spriteHeight = size.w / 100 / 2;

        var cameraPosition = PerspectiveView.instance.entity.getLocalPosition();
        var distance = cameraPosition.z - this.entity.getLocalPosition().z;

        var fov = PerspectiveView.instance.camera.fov;

        var refHeight = UIManager.instance.getReferenceResolution().y;
        width = width * refHeight / height;
        height = refHeight;

        var widthHeightRatio = width / height;

        var targetWidth = distance * Math.tan(fov / 2 * Math.PI / 180) * widthHeightRatio;
        var targetHeight = distance * Math.tan(fov / 2 * Math.PI / 180);

        var scaleX = targetWidth / spriteWidth;
        var scaleY = targetHeight / spriteHeight;
        var maxScale = Math.max(scaleX, scaleY);

        this.entity.setLocalScale(maxScale, maxScale, maxScale);
        this.entity.setLocalPosition(0, 0, this.entity.getLocalPosition().z);
    },

    _onCameraChange: function (orthoHeight) {
        this._switchSprite();
    },
});


// WorldManager.js
var WorldManager = pc.createScript('worldManager');

WorldManager.attributes.add('worldBackgroundImages', { type: 'asset', assetType: 'sprite', array: true });
WorldManager.attributes.add('blurredWorldBackgroundImages', { type: 'asset', assetType: 'sprite', array: true });

WorldManager.attributes.add('unlockablePartAssets', {
    type: 'json',
    schema: [{
        name: "completedModel",
        type: 'asset',
        assetType: "model"
    }, {
        name: "partModel",
        type: 'asset',
        assetType: "model"

    }, {
        name: "partSprite",
        type: 'asset',
        assetType: "sprite"
    },
    {
        name: "textures",
        type: 'asset',
        assetType: "texture",
        array: true
    }
    ],
    array: true
});
WorldManager.attributes.add('worldTextColors', { type: 'rgb', array: true });
WorldManager.attributes.add('starImages', { type: 'asset', assetType: 'sprite', array: true });

pc.extend(WorldManager.prototype, {
    initialize: function () {
        WorldManager.instance = this;

        this._worldIndex = 0;

        this._worldList = {
            1: { name: 'WORLD_1', nLevels: 100, nParts: 4, isUnlocked: true, comics: [], index: 0, minLevel: 1, maxLevel: 100 },
            2: { name: 'WORLD_2', nLevels: 150, nParts: 6, isUnlocked: true, comics: [], index: 1, minLevel: 101, maxLevel: 250 },
            3: { name: 'WORLD_3', nLevels: 150, nParts: 6, isUnlocked: true, comics: [], index: 2, minLevel: 251, maxLevel: 400 },
            4: { name: 'WORLD_4', nLevels: 200, nParts: 8, isUnlocked: true, comics: [], index: 3, minLevel: 401, maxLevel: 600 },
            5: { name: 'WORLD_5', nLevels: 200, nParts: 8, isUnlocked: true, comics: [], index: 4, minLevel: 601, maxLevel: 800 },
            6: { name: 'WORLD_6', nLevels: 200, nParts: 8, isUnlocked: true, comics: [], index: 5, minLevel: 801, maxLevel: 1000 },
            7: { name: 'WORLD_7', nLevels: 250, nParts: 10, isUnlocked: true, comics: [], index: 6, minLevel: 1001, maxLevel: 1250 },
            8: { name: 'WORLD_8', nLevels: 250, nParts: 10, isUnlocked: true, comics: [], index: 7, minLevel: 1251, maxLevel: 1500 },
            9: { name: 'WORLD_9', nLevels: 250, nParts: 10, isUnlocked: true, comics: [], index: 8, minLevel: 1501, maxLevel: 1750 },
            10: { name: 'WORLD_10', nLevels: 250, nParts: 10, isUnlocked: true, comics: [], index: 9, minLevel: 1751, maxLevel: 2000 },
        };

        this.maxLevel = 0;

        for (var i = 1; i <= 10; i++) {
            if (!this._worldList[i].isUnlocked) {
                break;
            }
            this.maxLevel += this._worldList[i].nLevels;
        }

        this.app.on('LevelManager:unlockNewPage', this.unlockNewPage, this);
    },

    postInitialize: function () {
        this.findComicAssets();
    },

    switchWorld: function (index) {
        if (typeof index !== 'number') {
            index = Number.parseInt(index);
        }

        if (index === this._worldIndex) {
            return;
        }

        this._worldIndex = index;
    },

    getWorldIndex: function () {
        return this._worldIndex;
    },

    getWorldList: function () {
        return this._worldList;
    },

    getWorldData: function (id) {
        if (this._worldList.hasOwnProperty(id)) {
            return this._worldList[id];
        } else {
            // console.warn('World ' + id + ' does not exist');
        }
    },

    getWorldIDByIndex: function (index) {
        return Object.keys(this._worldList)[index];
    },

    setWorldIndexWithCurrentLevel: function () {
        this.setWorldIndex(this.getCurrentWorld());
    },

    setWorldIndex: function (index) {
        if (typeof index !== 'number') {
            index = Number.parseInt(index);
        }

        this._worldIndex = index;

        this.app.fire('WorldManager:changeWorldIndex', this._worldIndex);
    },

    getWorldIndexByID: function (id) {
        return Object.keys(this._worldList).indexOf(String(id));
    },

    getCurrentWorld: function (level) {
        return this.getWorldByLevel(level || LevelDataManager.instance.getCurrentLevel());
    },

    isNextWorldExisting: function (chapterID) {
        var nextWorldIndex = WorldManager.instance.getWorldIndexByID(chapterID) + 1;

        var nextWorldData = this.getWorldData(this.getWorldIDByIndex(nextWorldIndex));

        if (nextWorldData && nextWorldData.isUnlocked === false) {
            return false;
        }

        return true;
    },

    getWorldByLevel: function (currentLevel) {
        var minLevel = 0;
        var maxLevel = 0;

        for (var worldKey in this._worldList) {
            minLevel = maxLevel + 1;
            maxLevel = maxLevel + this._worldList[worldKey].nLevels;

            if (currentLevel >= minLevel && currentLevel <= maxLevel) {
                return this._worldList[worldKey].index + 1;
            }
        }
    },

    getPageInWorld: function (world, level) {
        var currentWorld = this.getWorldData(world);
        level = Math.min(this.getMaxLevels(world), level);
        levelNumber = this._getCurrentWorldLevel(level);

        return Math.floor((level - currentWorld.minLevel) / ((currentWorld.nLevels / currentWorld.nParts)));
    },

    getMaxLevels: function (world) {
        var totalLevels = 0;

        for (var i = 1; i <= world; i++) {
            totalLevels += this._worldList[i].nLevels;
        }

        return totalLevels;
    },

    getNumberOfParts: function (chapterID) {
        var worldData = this.getWorldData(chapterID);
        return worldData.nParts;
    },

    getLevelNumberinPage: function (currentLevel) {
        var levelCounter = 0;

        for (var worldKey in this._worldList) {
            minLevel = this._worldList[worldKey].minLevel;
            maxLevel = this._worldList[worldKey].maxLevel;
            if (currentLevel >= minLevel && currentLevel <= maxLevel) {
                return ((currentLevel - minLevel) % (this._worldList[worldKey].nLevels / this._worldList[worldKey].nParts)) + 1;
            }
        }
    },

    isEndOfPage: function (levelNumber) {
        var currentWorld = this.getCurrentWorld(levelNumber);
        levelNumber = this._getCurrentWorldLevel(levelNumber);
        return levelNumber % (this._worldList[currentWorld].nLevels / this._worldList[currentWorld].nParts) === 0;
    },


    isEndOfWorld: function (levelNumber) {
        var currentWorld = this.getCurrentWorld();
        levelNumber = this._getCurrentWorldLevel(levelNumber);
        return levelNumber === this._worldList[this.getCurrentWorld()].nLevels; // check if page number aligns with 
    },

    findComicAssets: function () {
        for (var worldKey in this._worldList) {
            var worldData = this._worldList[worldKey];
            for (var i = 1; i <= worldData.nParts; i += 1) {
                worldData.comics[i - 1] = this.app.assets.find('w' + worldKey + '_p' + i + '.png');
            }
        }
    },

    _getCurrentWorldLevel: function (levelNumber, currentWorld) {
        for (var worldKey in this._worldList) {
            if (worldKey < this.getCurrentWorld(levelNumber))
                levelNumber -= this._worldList[worldKey].nLevels;
        }

        return levelNumber;
    },

    getWorldBackgroundImage: function (worldID = this.getWorldIndex()) {
        var index = this.getWorldIndexByID(worldID);
        return this.worldBackgroundImages[index];
    },

    getBlurredWorldBackgroundImage: function (worldID = Number.parseInt(this.getWorldIndex())) {
        //         console.warn("getBlurredWorldBackgroundImage is deprecated");

        //         return;
        const image = this.blurredWorldBackgroundImages[worldID - 1];

        if (!image) {
            console.warn("no image is found with the world id", worldID);
            image = this.blurredWorldBackgroundImages[0];
        }

        return this.blurredWorldBackgroundImages[worldID - 1];
    },

    getPartAssets: function (worldID) {
        var index = this.getWorldIndexByID(worldID);
        return this.unlockablePartAssets[index];
    },

    getWorldTextColor: function (worldID) {
        var index = this.getWorldIndexByID(worldID);
        return this.worldTextColors[index];
    },

    getStarAsset: function (worldID) {
        var index = this.getWorldIndexByID(worldID);
        return this.starImages[index];
    },

    isInWorld: function (worldID) {
        const currentLevel = LevelDataManager.instance.getRealCurrentLevel();
        const minLevel = this._worldList[worldID].minLevel;
        const maxLevel = this._worldList[worldID].maxLevel;

        return currentLevel >= minLevel && currentLevel <= maxLevel;
    },

    worldExists: function (worldID) {
        return !!this._worldList[worldID];
    },
});


// WorldSelectButton.js
var WorldSelectButton = pc.createScript('worldSelectButton');

var _worldIndexEnum = [ 
    { "World 1": 0 },
    { "World 2": 1 }, 
    { "World 3": 2 },
    { "World 4": 3 },
    { "World 5": 4 }, 
    { "World 6": 5 } 
];

WorldSelectButton.attributes.add('worldIndex', { type: 'number', enum: _worldIndexEnum });

pc.extend(WorldSelectButton.prototype, {
    initialize: function() {
        if (!this._elementInput) {
            this._elementInput = this.entity.script.create('elementInput');
            console.warn('Add the script elementInput to this entity:', this.entity.name);
        }
        
        this.entity.script.elementInput.on('click', this._onClick, this);
    },
    
    _onClick: function() {
        WorldManager.instance.switchWorld(this.worldIndex);
    },  
});


// LevelDataManager.js
var LevelDataManager = pc.createScript('levelDataManager');

pc.extend(LevelDataManager.prototype, {
    initialize: function () {
        if (Singleton.instance.canCreateInstance(this)) {
            LevelDataManager.instance = this;
        }
        this.app.on('GardenUIEntity:cheatFired', this.cheatFunction, this);
        this.storageKey = 'levelData';
        this.statisticsKey = 'levelStatistics';
        this._levelData = this._getSaveData();
        this._levelStatistics = this._getLevelStatistics();
        this._calculateTotalStars();
        this._calculatePartsCollected();
        this.app.on("StorageManager:changedStorage", this._onStorageChange, this);
    },

    cheatFunction: function () {
        this._levelData = this._getSaveData();
        this._calculateTotalStars();
        this._calculatePartsCollected();
    },

    _onStorageChange: function () {
        this._levelData = this._getSaveData();

        this._calculateTotalStars();
        this._calculatePartsCollected();
    },

    compareCurrentLevel: function (level) {
        if (level > this._levelData.currentLevel) {
            this._levelData.currentLevel = level;
        }
    },

    getRealCurrentLevel: function () {
        return this._levelData.currentLevel;
    },

    getCurrentLevel: function () {
        if (GameManager.instance.forcedMode) {
            return 1000;
        }

        return pc.math.clamp(this._levelData.currentLevel, 0, WorldManager.instance.maxLevel);
    },

    getLevelData: function (worldID, levelID) {
        if (!this._levelData.hasOwnProperty(worldID) || !this._levelData[worldID].hasOwnProperty(levelID)) {
            return null;
        }

        return this._levelData[worldID][levelID];
    },

    isLevelFirstTime(level) {
        return !this._levelStatistics.levelsPlayed.includes(level);
    },

    startLevel(level) {
        this.firstTime = this.isLevelFirstTime(level);

        if (this.firstTime) {
            this._levelStatistics.levelsPlayed.push(level);

            StorageManager.instance.set(this.statisticsKey, this._levelStatistics);
            Wrapper.instance.sendGAEvent(Wrapper.GA_EVENT_TYPE.PROGRESSION, {
                progressionStatus: 'Start',
                progression01: 'firstTimeLevelExperience',
                progression02: `level_${level}`,
            });
        }

        Wrapper.instance.sendGAEvent(Wrapper.GA_EVENT_TYPE.PROGRESSION, {
            progressionStatus: 'Start',
            progression01: 'level',
            progression02: `level_${level}`,
        });
    },

    endLevel(level, result) {
        //CODEREVIEW: A: why don't we set a value for progression01? then the funnel will properbly break;
        const data = {
            progressionStatus: result === 'win' ? 'Complete' : 'Fail',
            progression01: 'level',
            progression02: `level_${level}`,
            value: ScoreManager.instance.getScore(),
        }

        if (this.firstTime) {
            data.progression01 = 'firstTimeLevelExperience';
            switch (result) {
                case 'win':
                    Wrapper.instance.sendGAEvent(Wrapper.GA_EVENT_TYPE.PROGRESSION, data);
                    break;

                case 'lose':
                    Wrapper.instance.sendGAEvent(Wrapper.GA_EVENT_TYPE.PROGRESSION, data);
                    break;
            }
        }

        data.progression01 = 'level';

        Wrapper.instance.sendGAEvent(Wrapper.GA_EVENT_TYPE.PROGRESSION, data);

        switch (result) {
            case 'win':
                Wrapper.instance.sendGAEvent(Wrapper.GA_EVENT_TYPE.DESIGN, {
                    eventId: `levelData:starsWon:level_${level}`,
                    value: ScoreManager.instance.getStars()
                });

                Wrapper.instance.sendGAEvent(Wrapper.GA_EVENT_TYPE.DESIGN, {
                    eventId: `levelData:movesLeft:level_${level}`,
                    value: MovesManager.instance.getMoves()
                });

                break;

            case 'lose':

                break;
        }

    },

    getTotalStarData: function (worldID) {
        if (!this._starData.hasOwnProperty(worldID)) {
            return null;
        }
        return this._starData[worldID];
    },

    getPartsData: function (worldID) {
        if (!this._partsData.hasOwnProperty(worldID)) {
            return null;
        }
        return this._partsData[worldID];
    },

    completedLevelsInWorld: function (worldID) {
        if (!this._partsData.hasOwnProperty(worldID)) {
            return null;
        }
        return Object.keys(this._levelData[worldID]).length;
    },

    _getSaveData: function () {
        var levelSaveData = StorageManager.instance.get(this.storageKey);

        levelSaveData = this._validateData(levelSaveData);

        return levelSaveData;
    },

    _getLevelStatistics: function () {
        var levelSaveData = StorageManager.instance.get(this.statisticsKey);

        return levelSaveData;
    },

    _validateData: function (levelSaveData) {
        var worldList = WorldManager.instance.getWorldList();

        // Change to object if it's an array
        if (Array.isArray(levelSaveData)) {
            levelSaveData = {};
        }

        // Change to object if it's not an object
        if (typeof levelSaveData !== 'object') {
            levelSaveData = {};
        }

        var currentLevel = levelSaveData.currentLevel || 1;

        for (var worldKey in levelSaveData) {
            // delete keys which are not used.
            if (!worldList.hasOwnProperty(worldKey)) {

                console.log('World exists in data, but not in world list. Deleting world.');
                delete levelSaveData[worldKey];
            }
        }

        var updateData = false;

        for (var worldKey in worldList) {
            // Check if the object has the key. Else set default data.
            if (!levelSaveData.hasOwnProperty(worldKey)) {
                levelSaveData[worldKey] = this._createWorldData();
                updateData = true;
            }

            if (Array.isArray(levelSaveData[worldKey])) {
                levelSaveData[worldKey] = {};
            }

            // Change to object if it's not an object
            if (typeof levelSaveData[worldKey] !== 'object') {
                levelSaveData[worldKey] = {};
            }

        }

        levelSaveData.currentLevel = currentLevel;

        if (!levelSaveData.hasOwnProperty('currentLevel')) {
            levelSaveData.currentLevel = 1;
            updateData = true;
        }


        // Only update if necessary
        if (updateData) {
            StorageManager.instance.set(this.storageKey, levelSaveData);
        }

        return levelSaveData;
    },

    _createWorldData: function () {
        return {};
    },

    _createLevelData: function (score, stars) {
        return {
            score: score,
            stars: stars
        };
    },

    saveLevelData: function (worldID, levelID, score, stars, dontSave) {
        if (!this._levelData.hasOwnProperty(worldID) || !WorldManager.instance.getWorldList().hasOwnProperty(worldID)) {
            console.error('World ' + worldID + ' does not exist');
            return;
        }
        var worldData = this._levelData[worldID];

        if (worldData.hasOwnProperty(levelID)) {
            if (score > worldData[levelID].score) worldData[levelID].score = score;
            if (stars > worldData[levelID].stars) worldData[levelID].stars = stars;
        } else {
            worldData[levelID] = this._createLevelData(score, stars);
        }

        if (levelID > (this._levelData.currentLevel - 1)) {
            this._levelData.currentLevel = levelID + 1;
        }

        if (!dontSave) {
            StorageManager.instance.set(this.storageKey, this._levelData);
            if (GardenDataManager.instance.firstTime) {
                Wrapper.instance.sendGAEvent(Wrapper.GA_EVENT_TYPE.DESIGN, { eventId: 'tutorialFunnel:wonLevel' });
            }
        }

        this._calculateTotalStars(worldID);
        this._calculatePartsCollected(worldID);
    },

    _resetData: function (levelSaveData) {
        for (var worldKey in this._levelData) {
            delete this._levelData[worldKey];
        }
    },

    _calculateTotalStars: function (worldID) {
        this._starData = {};
        if (!this._starData.hasOwnProperty(worldID)) {
            // Do for all worlds
            var worldList = WorldManager.instance.getWorldList();
            for (var worldKey in worldList) {
                this._starData[worldKey] = 0;
                for (var levelKey in this._levelData[worldKey]) {
                    this._starData[worldKey] += this._levelData[worldKey][levelKey].stars;
                }
            }
        } else {
            // Do only param world
            this._starData[worldID] = 0;
            for (var levelKey in this._levelData[worldID]) {
                this._starData[worldID] += this._levelData[worldID][levelKey].stars;
            }
            this.app.fire('LevelDataManager:onSpecificTotalStarsChange', worldID, this._starData[worldID]);
        }

        // console.log(this._starData)
    },

    getStars: function (level) {
        const worldID = WorldManager.instance.getCurrentWorld(level);

        if (!worldID) {
            console.warn("World Id not found", level);
            return 0;
        }

        const levelData = this._levelData[worldID][level];

        if (!levelData) {
            // console.warn("No data found", worldID, level);
            return 0;
        }

        return levelData.stars;
    },

    _calculatePartsCollected: function (worldID) {
        this._partsData = {};

        var worldList = WorldManager.instance.getWorldList();
        if (!this._partsData.hasOwnProperty(worldID)) {
            // Do for all worlds
            for (var worldKey in worldList) {
                var nLevelsCompleted = Object.keys(this._levelData[worldKey]).length;
                var nLevelsPerPart = worldList[worldKey].nLevels / worldList[worldKey].nParts;
                this._partsData[worldKey] = Math.floor(nLevelsCompleted / nLevelsPerPart);
            }
        } else {
            // Do only param world
            var nLevelsCompleted = Object.keys(this._levelData[worldID]).length;
            var nLevelsPerPart = worldList[worldID].nLevels / worldList[worldID].nParts;
            this._partsData[worldID] = Math.floor(nLevelsCompleted / nLevelsPerPart);
            this.app.fire('LevelDataManager:onSpecificPartsChange', worldID, this._partsData[worldID]);
        }
    },

    cheat: function (maxLevel) {
        var worldID = 1;
        var nLevels = WorldManager.instance.getWorldList()[worldID].nLevels;

        for (var i = 1; i <= maxLevel; i++) {
            if (i > nLevels) {
                worldID++;
                nLevels += WorldManager.instance.getWorldList()[worldID].nLevels;
            }
            this.saveLevelData(worldID, i, 10000, 3, true);
        }

        StorageManager.instance.set(this.storageKey, this._levelData);


        this._levelData = this._getSaveData();

        WorldManager.instance.setWorldIndex(WorldManager.instance.getCurrentWorld());
    },


    cheatGarden: function (area) {
        let worldID = 1;
        var nLevels = WorldManager.instance.getWorldList()[worldID].nLevels;
        var maxLevels = WorldManager.instance.getWorldList()[area].maxLevel - 1;

        for (var i = 1; i <= maxLevels; i++) {
            if (i > nLevels) {
                worldID++;
                nLevels += WorldManager.instance.getWorldList()[worldID].nLevels;
            }
            this.saveLevelData(worldID, i, 10000, 3, true);
        }

        StorageManager.instance.set(this.storageKey, this._levelData);


        this._levelData = this._getSaveData();

        WorldManager.instance.setWorldIndex(WorldManager.instance.getCurrentWorld());
    },

    cheatGardenReset: function (area) {
        var areaData = WorldManager.instance.getWorldList()[area - 1];
        var maxLevels = areaData ? areaData.maxLevel : 1;

        for (let i = 10; i >= area; i--) {
            this._levelData[i] = {}
        }

        this._levelData.currentLevel = maxLevels;

        StorageManager.instance.set(this.storageKey, this._levelData);


        this._levelData = this._getSaveData();

        WorldManager.instance.setWorldIndex(WorldManager.instance.getCurrentWorld());
    },

});

// Blocker.js
var Blocker = pc.createScript('blocker');

pc.extend(Blocker.prototype, {
    initialize: function () {
        this.parent = null;

        this._explode = false;

        this.animationController = this.entity.script.tileAnimationController;
        this.animationController.on('explode', this._onExplodeAnimation, this);
        this.animationController.on('exploded', this._onCompleteAnimation, this);
    },

    despawnInstant: function () {
        this._explode = true;
    },

    recycle: function () {
        if (this._explode) {
            console.warn("already recycled");
            return;
        }

        this._explode = true;

        this.entity.objectPool.recycle(this.entity);
    },

    init: function (parent) {
        this.parent = parent;
        this.parent.typeID = backgroundTileEnum.BLOCKER;
    },

    awake: function () {
        this.parent.hasExploded = false;
        this._explode = false;
        this.parent._modelComponent.entity.enabled = true;
        this.animationController.setLayer(this.parent.currentLayer - 1);

    },

    explode: function (delay) {
        if (this.parent.hasExploded) {
            this.animationController.playExplode(this.parent.currentLayer, delay, true);

            return true;
        } else {

            this.parent._onLayerExplode();

            this.parent.currentLayer--;

            this.animationController.playExplode(this.parent.currentLayer, delay);

            this.parent.hasExploded = true;
            this.parent._isDamaged = true;

            if (this.parent.currentLayer === 0) {
                this.parent.isDestroyed = true;
                StatisticsManager.instance.incrementStatistic('obstacle_destroyed', {
                    obstacle_type: TileLibrary.instance.getObstacleName(this.parent.typeID),
                });
            }

            return true;
        }
    },

    _onExplodeAnimation: function (animationData) {
        var isLastLayer = this.parent.currentLayer === 0;

        this.parent._onExplode(isLastLayer, animationData.delay, true);

        if (isLastLayer) {
            GridManager.instance.playSFX('blocker_destroy.mp3');
        } else {
            GridManager.instance.playSFX('blocker_hit.mp3');
        }
    },

    _onCompleteAnimation: function () {
        this.recycle();
    },

    getDespawnDelay: function () {
        return this.animationController.getDespawnDelay();
    },
});


// DialogInterface.js
var DialogInterface = pc.createScript('dialogInterface');

DialogInterface.attributes.add('leftPersonContainer', { type: 'entity' });
DialogInterface.attributes.add('rightPersonContainer', { type: 'entity' });
DialogInterface.attributes.add('leftPersonNameTag', { type: 'entity' });
DialogInterface.attributes.add('rightPersonNameTag', { type: 'entity' });
DialogInterface.attributes.add('dialogText', { type: 'entity' });
DialogInterface.attributes.add('overlay', { type: 'entity' });
DialogInterface.attributes.add('skipButton', { type: 'entity' });
DialogInterface.attributes.add('tapTutorialGroup', { type: 'entity' });

pc.extend(DialogInterface.prototype, {

    initialize: function () {
        this.leftPersonText = this.leftPersonNameTag.findByName('Text');
        this.rightPersonText = this.rightPersonNameTag.findByName('Text');

        this.app.on('ViewportManager:onResize', this.onResize, this);
    },

    onResize: function () {
        if (this.leftPositionTween) {
            this.leftPositionTween.stop();
        }

        if (this.rightPositionTween) {
            this.rightPositionTween.stop();
        }


        if (this.leftOpacityTween) {
            this.leftOpacityTween.stop();
        }


        if (this.rightOpacityTween) {
            this.rightOpacityTween.stop();
        }

        if (this.dialogInfo && this.dialogInfo.person && this.dialogInfo.side === 'right') {
            this._enableLeftPerson(false, true);
            this._enableRightPerson(true, true);
        } else if (this.dialogInfo && this.dialogInfo.person && this.dialogInfo.side === 'left') {
            this._enableLeftPerson(true, true);
            this._enableRightPerson(false, true);
        } else {
            this._enableLeftPerson(false, true);
            this._enableRightPerson(false, true);
        }
    },

    initializeSingleSentence: function () {
        // remove characters for a single sentence
        this._enableLeftPerson(false, true);
        this._enableRightPerson(false, true);
    },

    disablePersons: function () {
        this._enableLeftPerson(false, true);
        this._enableRightPerson(false, true);
    },

    converstation: function (dialogInfo, person) {
        var isLeft = dialogInfo.side === "left" ? true : false;

        this.dialogInfo = dialogInfo;

        // set who is talking
        if (person) {
            this._enableLeftPerson(isLeft);
            this._enableRightPerson(!isLeft);

            // set image

            if (isLeft) {
                this.leftPersonContainer.element.spriteAsset = person.images[dialogInfo.image];
                this.leftPersonNameTag.element.spriteAsset = person.nameContainer;
                this.leftPersonText.element.text = LocalizationManager.instance.get(person.name.toUpperCase());
                this.leftPersonContainer.element.width = this.leftPersonContainer.element.sprite._atlas._frames[this.leftPersonContainer.element.sprite.frameKeys[0]].rect.z;
                this.leftPersonContainer.element.height = this.leftPersonContainer.element.sprite._atlas._frames[this.leftPersonContainer.element.sprite.frameKeys[0]].rect.w;
            } else {
                this.rightPersonContainer.element.spriteAsset = person.images[dialogInfo.image];
                this.rightPersonNameTag.element.spriteAsset = person.nameContainer;
                this.rightPersonText.element.text = LocalizationManager.instance.get(person.name.toUpperCase());
                this.rightPersonContainer.element.width = this.rightPersonContainer.element.sprite._atlas._frames[this.rightPersonContainer.element.sprite.frameKeys[0]].rect.z;
                this.rightPersonContainer.element.height = this.rightPersonContainer.element.sprite._atlas._frames[this.rightPersonContainer.element.sprite.frameKeys[0]].rect.w;
            }
        } else {
            this._enableLeftPerson(false);
            this._enableRightPerson(false);
        }
        this.displaySentence(dialogInfo.text);

        this.tapTutorialGroup.enabled = this.tapTutorial;

        this.tapTutorial = false;
    },

    setPosition: function (x, y) {
        return;
        if (isFinite(x) && isFinite(y)) {
            this.entity.setLocalPosition(x, y, 0);
        }
    },

    _enableLeftPerson: function (isTrue, noTween) {
        if (noTween) {
            this.leftPersonContainer.enabled = isTrue;
            this.leftPersonNameTag.enabled = isTrue;

            return;
        }

        if (isTrue) {
            this.leftPersonContainer.enabled = true;
            this.leftPersonNameTag.enabled = true;

            const position = this.leftPersonContainer.script.dynamicElement.getPosition();

            this.leftPersonContainer.setLocalPosition(position.x - 100, position.y, position.z);

            if (this.leftPositionTween) {
                this.leftPositionTween.stop();
            }

            this.leftPositionTween = this.leftPersonContainer.tween(this.leftPersonContainer.getLocalPosition()).to(position, DialogInterface.TWEEN_DURATION, pc.Linear).start();

            // this.leftPersonContainer.element.opacity = 0;

            if (this.leftOpacityTween) {
                this.leftOpacityTween.stop();
            }

            this.leftOpacityTween = this.leftPersonContainer.tween(this.leftPersonContainer.element).to({ opacity: 1 }, DialogInterface.TWEEN_DURATION, pc.CubicOut).start();
        } else {
            this.leftPersonNameTag.enabled = false;

            const position = this.leftPersonContainer.script.dynamicElement.getPosition();

            this.leftPersonContainer.setLocalPosition(position.x, position.y, position.z);

            if (this.leftPositionTween) {
                this.leftPositionTween.stop();
            }

            this.leftPositionTween = this.leftPersonContainer.tween(this.leftPersonContainer.getLocalPosition()).to({ x: position.x - 100, y: position.y, z: position.z }, DialogInterface.TWEEN_DURATION, pc.Linear).start()
            this.leftPositionTween.on('complete', () => {
                this.leftPersonContainer.enabled = false;
            });

            // this.leftPersonContainer.element.opacity = 1;

            if (this.leftOpacityTween) {
                this.leftOpacityTween.stop();
            }

            this.leftOpacityTween = this.leftPersonContainer.tween(this.leftPersonContainer.element).to({ opacity: 0 }, DialogInterface.TWEEN_DURATION, pc.CubicOut).start();
        }
    },
    _enableRightPerson: function (isTrue, noTween) {
        if (noTween) {
            this.rightPersonContainer.enabled = isTrue;
            this.rightPersonNameTag.enabled = isTrue;

            return;
        }


        if (isTrue) {
            this.rightPersonContainer.enabled = true;
            this.rightPersonNameTag.enabled = true;

            const position = this.rightPersonContainer.script.dynamicElement.getPosition();

            this.rightPersonContainer.setLocalPosition(position.x + 100, position.y, position.z);

            if (this.rightPositionTween) {
                this.rightPositionTween.stop();
            }

            this.rightPositionTween = this.rightPersonContainer.tween(this.rightPersonContainer.getLocalPosition()).to(position, DialogInterface.TWEEN_DURATION, pc.Linear).start();

            // this.rightPersonContainer.element.opacity = 0;

            if (this.rightOpacityTween) {
                this.rightOpacityTween.stop();
            }

            this.rightOpacityTween = this.rightPersonContainer.tween(this.rightPersonContainer.element).to({ opacity: 1 }, DialogInterface.TWEEN_DURATION, pc.CubicOut).start();
        } else {
            this.rightPersonNameTag.enabled = false;

            const position = this.rightPersonContainer.script.dynamicElement.getPosition();

            this.rightPersonContainer.setLocalPosition(position.x, position.y, position.z);

            if (this.rightPositionTween) {
                this.rightPositionTween.stop();
            }

            this.rightPositionTween = this.rightPersonContainer.tween(this.rightPersonContainer.getLocalPosition()).to({ x: position.x + 100, y: position.y, z: position.z }, DialogInterface.TWEEN_DURATION, pc.Linear).start()
            this.rightPositionTween.on('complete', () => {
                this.rightPersonContainer.enabled = false;
            });

            // this.rightPersonContainer.element.opacity = 1;

            if (this.rightOpacityTween) {
                this.rightOpacityTween.stop();
            }

            this.rightOpacityTween = this.rightPersonContainer.tween(this.rightPersonContainer.element).to({ opacity: 0 }, DialogInterface.TWEEN_DURATION, pc.CubicOut).start();
        }
    },

    displaySentence: function (text) {
        LocalizationManager.instance.setText(this.dialogText, text);
        // this.dialogText.element.text = LocalisationManager.instance.get(text);
    },

    hideDialogBox: function () {
        const promise = UIManager.instance._hideUI(UIManager.SCREEN_DIALOG);
        // this.app.fire('UIManager:hideUI', UIManager.SCREEN_DIALOG);
        this.app.fire('DialogManager:dialogDone');
        //this.app.fire('UIManager:showUI', this._previousScreen.script.uiEntity.name);

        return promise;
    },

    isBusy: function () {
        if (this.entity.script.uiEntity) {
            return this.entity.script.uiEntity.isBusy();
        }

        return;
    },

    displayDialogBox: function () {
        this.initializeSingleSentence();
        //this._previousScreen = UIManager.instance.getTopStack('Screen');
        //this.app.fire('UIManager:hideAll');
        this.app.fire('UIManager:showUI', UIManager.SCREEN_DIALOG);
    },

    enableOverlay: function (value) {
        this.overlay.enabled = value;
        //this.skipButton.enabled = value;
    },

    toggleSkip: function (allowSkip) {
        //this.skipButton.enabled = allowSkip;
    },

    setTapTutorial: function (value) {
        this.tapTutorial = value;
    },
});

DialogInterface.TWEEN_DURATION = 0.3;

// DialogManager.js
var DialogManager = pc.createScript('dialogManager');

var dialogTypes = Object.freeze({ CONVERSATION: 0, GAMETUTORIAL: 1, PREBOOSTERTUTORIAL: 2, GARDENTUTORIAL: 3, GARDENTUTORIAL_TASKSCREEN: 4 });

DialogManager.attributes.add('dialogScript', {
    type: 'asset',
    assetType: 'json'
});

DialogManager.attributes.add('dialogInterface', {
    type: 'entity'
});

DialogManager.attributes.add('gameTutorialInterface', {
    type: 'entity'
});

DialogManager.attributes.add('gardenTutorialInterface', {
    type: 'entity'
});

DialogManager.attributes.add('gardenTutorialTaskScreenInterface', {
    type: 'entity'
});

DialogManager.attributes.add('preBoosterTutorialInterface', {
    type: 'entity'
});

DialogManager.attributes.add('characters', {
    type: 'json',
    schema: [{
        name: "name",
        type: 'string'
    }, {
        name: "images",
        type: 'asset',
        assetType: 'sprite',
        array: true
    }, {
        name: "nameContainer",
        type: 'asset',
        assetType: 'sprite'
    }],
    array: true
});

DialogManager.attributes.add('keyForTapTutorial', { type: 'string', default: 'garden-area-1-unlock-part-1' });

pc.extend(DialogManager.prototype, {
    initialize: function () {
        DialogManager.instance = this;

        this.gameTutorialInterface.enabled = false;
        this.dialogInterface.enabled = false;
        this.preBoosterTutorialInterface.enabled = false;
        this.gardenTutorialInterface.enabled = false;

        this._interface = null;
        // variables
        this.dialog = this.dialogScript.resource;
        this.currentDialogIndex = 0;

        this.dialogCharacters = {};
    },

    setInterface: function (dialogType) {
        switch (dialogType) {
            case dialogTypes.GAMETUTORIAL:
                this._interface = this.gameTutorialInterface.script.tutorialInterface;
                break;
            case dialogTypes.PREBOOSTERTUTORIAL:
                this._interface = this.preBoosterTutorialInterface.script.tutorialInterface;
                break;
            case dialogTypes.CONVERSATION:
                this._interface = this.dialogInterface.script.dialogInterface;
                break;
            case dialogTypes.GARDENTUTORIAL:
                this._interface = this.gardenTutorialInterface.script.tutorialInterface;
                break;
            case dialogTypes.GARDENTUTORIAL_TASKSCREEN:
                this._interface = this.gardenTutorialTaskScreenInterface.script.tutorialInterface;
                break;
            default:
                console.log(dialogType, "is not valid");
                break;
        }
    },

    stopDialog: function (key) {
        if (this.currentKey === key) {
            this.skipDialog();
            delete this.currentKey;
        }
    },

    // public functions
    showDialog: function (key, functionAfter, functionScope, dialogType, allowSkip) {
        if (!key) {
            if (functionAfter) {
                functionAfter.call(functionScope);
            }

            return;
        }

        this.key = key;

        this._resetDialogIndex();

        this.setInterface(dialogType);

        this._interface.displayDialogBox();

        this.functionAfter = functionAfter;
        this.functionScope = functionScope;
        this.currentDialogIndex = 0;
        this.currentDialog = this._getDialog(key);

        this._setTapTutorial(key === this.keyForTapTutorial);
        this._getPeopleFromDialog(this.currentDialog);
        this._handleDialog(this.currentDialog[this.currentDialogIndex]);

        this._interface.toggleSkip(allowSkip);

        this.fire("step", this.currentDialogIndex);

        //this._pauseGame();
    },

    hideDialog: function () {
        if (this._interface) {
            this._interface.hideDialogBox();
            this._interface = null;
        }
    },

    skipDialog: function () {
        return this._closeDialog();
    },

    nextDialog: function () {
        if (typeof this._interface.isBusy === 'function') {
            if (this._interface.isBusy()) {
                return;
            }
        }

        if (this.closing) {
            return;
        }
        // show the next dialog if there is one
        if (this.currentDialogIndex < this.currentDialog.length - 1) {
            this._handleDialog(this.currentDialog[++this.currentDialogIndex]);
        } else {
            var promise = this._closeDialog();
            this.closing = true;
            if (promise instanceof Promise) {
                promise.then(() => {
                    if (this.functionAfter) {
                        this.functionAfter.call(this.functionScope);
                    }
                    this.closing = false;

                    this.fire("finish");
                    this.fire("step", this.currentDialogIndex);
                });
                return;
            } else {
                if (this.functionAfter) {
                    this.functionAfter.call(this.functionScope);
                }

                this.closing = false;
                this.fire("finish");
            }
        }

        this.fire("step", this.currentDialogIndex);
    },

    previousDialog: function () {
        this._handleDialog(this.currentDialog[--this.currentDialogIndex]);

        this.fire("step", this.currentDialogIndex);
    },

    // private function

    _getDialog: function (key) {
        // get the dialog with the key from the filetest
        var dialog = [];

        var dialogPart = this.dialog[key];

        // set the dialog in the right place
        if (Array.isArray(dialogPart)) {
            for (var i = 0; i < dialogPart.length; i++) {
                dialog[i] = dialogPart[i];
            }
        } else {
            dialog[0] = dialogPart;
            this._interface.initializeSingleSentence();
        }

        this.currentKey = key;

        return dialog;
    },

    _handleDialog: function (currentDialog) {
        if (typeof currentDialog === 'object') {
            this._interface.converstation(currentDialog, this.dialogCharacters[currentDialog.person]); // if entire dialogue

            if (currentDialog.textBubble && this._interface instanceof TutorialInterface) this._interface.setTopOrBottomBubble(currentDialog.textBubble);
        } else
            this._interface.displaySentence(currentDialog); // if just one dialog
    },

    _getPeopleFromDialog: function (currentDialog) {
        for (var i = 0; i < currentDialog.length; i++) {
            if (!this.dialogCharacters[currentDialog[i].person]) {
                this.dialogCharacters[currentDialog[i].person] = this._getCharacterInfo(currentDialog[i].person);
            }
        }
    },

    _getCharacterInfo: function (name) {
        for (var i = 0; i < this.characters.length; i++) {
            if (this.characters[i].name.toUpperCase() === name.toUpperCase())
                return this.characters[i];
        }
    },

    _closeDialog: function () {
        const promise = this._interface.hideDialogBox();

        //this._resumeGame();

        return promise;
    },

    _resetDialogIndex: function () {
        this.currentDialogIndex = 0;
    },

    enableOverlay: function (value) {
        this._interface.enableOverlay(value);
    },

    _setTapTutorial: function (value) {
        if (typeof this._interface.setTapTutorial === 'function') {
            this._interface.setTapTutorial(value);
        }
    },

});


// Panel.js
var Panel = pc.createScript('panel');

pc.extend(Panel.prototype, {
    initialize: function () {
        this.parent = null;

        this._explode = false;

        this.animationController = this.entity.script.tileAnimationController;
        this.animationController.on('explode', this._onExplodeAnimation, this);
        this.animationController.on('exploded', this._onCompleteAnimation, this);
    },

    despawnInstant: function () {
        this._explode = true;
    },

    init: function (parent) {
        this.parent = parent;
        this.parent.typeID = backgroundTileEnum.PANEL;
    },

    recycle: function () {
        if (this._explode) {
            console.warn("already recycled");
            return;
        }

        this._explode = true;

        this.entity.objectPool.recycle(this.entity);
    },

    awake: function () {
        this.parent.hasExploded = false;
        this._explode = false;
        this.parent._modelComponent.entity.enabled = true;
        this.animationController.setLayer(this.parent.currentLayer - 1);
    },

    explode: function (delay) {
        if (this.parent.hasExploded) {
            this.animationController.playExplode(this.parent.currentLayer, delay, true);

            return true;
        } else {

            this.parent._onLayerExplode();

            this.parent.currentLayer--;

            this.animationController.playExplode(this.parent.currentLayer, delay);

            this.parent.hasExploded = true;
            this.parent._isDamaged = true;

            if (this.parent.currentLayer === 0) {
                this.parent.isDestroyed = true;
                StatisticsManager.instance.incrementStatistic('obstacle_destroyed', {
                    obstacle_type: TileLibrary.instance.getObstacleName(this.parent.typeID),
                });
            }

            return true;
        }
    },

    _onExplodeAnimation: function (animationData) {
        var isLastLayer = this.parent.currentLayer === 0;

        this.parent._onExplode(isLastLayer, animationData.delay, true);

        if (isLastLayer) {
            GridManager.instance.playSFX('panel_destroy.mp3');
        } else {
            GridManager.instance.playSFX('panel_hit.mp3');
        }
    },

    _onCompleteAnimation: function () {
        this.recycle();
    },

    getDespawnDelay: function () {
        return this.animationController.getDespawnDelay();
    },
});


// Dropper.js
var Dropper = pc.createScript('dropper');

pc.extend(Dropper.prototype, {
    initialize: function () {
        this.doIdleCountdown = false;
        this.active = false;

        this.app.on('SwapMode:onCascadeDone', this.startIdleCountdown, this);
    },

    update: function (dt) {
        if (this.doIdleCountdown) {
            if (this.superClass._recycled) {
                this.stopIdleCountdown();
                this.stopIdleTween();
            }
            this.idleCountdown += dt;
            if (this.idleCountdown >= this.idleCountdownDuration) {
                this.startIdleAnimation();
                this.stopIdleCountdown();
            }
        }
    },

    init: function (superClass) {
        this.superClass = superClass;
        this.superClass.typeID = foregroundTileEnum.DROPPER;
    },

    explode: function () {
        this.stopIdleCountdown();
        GridManager.instance.removeDropper(this);

        this.app.fire('ScoreManager:scoreForegroundTile', this.superClass.typeID, true, this.superClass);
        GridManager.instance.playSFX('dropper_deliver.mp3');
        this.superClass.despawn();

        StatisticsManager.instance.incrementStatistic("obstacle_destroyed", { obstacle_type: 'bean' }, 1);

        return true;
    },

    onAwake: function () {
        this.active = true;
        this.startIdleCountdown();
    },

    appear: function () {
        this.stopTween();
    },

    move: function () {
        this.stopTween();
    },

    applyGravity: function () {
        this.stopTween();
    },

    stopTween: function () {
        this.stopIdleCountdown();
        this.stopIdleTween();
    },

    startIdleAnimation: function () {
        var position = GridManager.instance.calculatePosition(this.superClass.x, this.superClass.y, 0.2);
        this.idleTween = this.entity.tween(this.entity.getLocalPosition())
            .to({ x: position.x, y: position.y - 0.1, z: position.z }, 0.2, pc.SineInOut)
            .yoyo(true)
            .repeat(4)
            .start();

            this.idleTween.on('complete', function () {
                this.startIdleCountdown();
                this.idleTween = null;
            }.bind(this), this)
    },

    startIdleCountdown: function () {
        if (!this.active) {
            return;
        }

        this.idleCountdown = 0;
        var min = 5;
        var max = 10;
        this.idleCountdownDuration = Math.random() * (max - min) + min;
        this.doIdleCountdown = true;
    },

    stopIdleCountdown: function () {
        this.doIdleCountdown = false;
    },

    stopIdleTween: function () {
        if (this.idleTween) {
            this.idleTween.stop();
            this.idleTween = null;

            this.resetPosition();
        }
    },

    resetPosition: function () {
        var position = GridManager.instance.calculatePosition(this.superClass.x, this.superClass.y, 0);
        this.entity.setLocalPosition(position);
    },

    recycle: function () {
        this.stopIdleCountdown();
        this.stopIdleTween();
        this.active = false;
    }
});


// BookUI.js
var BookUI = pc.createScript('bookUI');

BookUI.attributes.add('chapterSelectPageEntity', { type: 'entity' });
BookUI.attributes.add('levelSelectPageEntity', { type: 'entity' });
BookUI.attributes.add('pageGroup', { type: 'entity' });

BookUI.attributes.add('bookOpenEntity', { type: 'entity' });

BookUI.attributes.add('bookFadeEntities', { type: 'entity', array: true });
BookUI.attributes.add('pageFlipAnimationEntity', { type: 'entity' });

BookUI.attributes.add('newChapterEntity', { type: 'entity' });
BookUI.attributes.add('newChapterImage', { type: 'entity' });

BookUI.attributes.add('worldPreview', { type: 'entity' });
BookUI.attributes.add('duration', { type: 'number' });
BookUI.attributes.add('alphaCurve', { type: 'curve' });
BookUI.attributes.add('bookScaleEntity', { type: 'entity' });
BookUI.attributes.add('shaderSize', { type: 'entity' });
BookUI.attributes.add('camera', { type: 'entity' });
BookUI.attributes.add('chapterTitleText', { type: 'entity' });

pc.extend(BookUI.prototype, {
    initialize: function () {
        BookUI.instance = this;

        this._createPageList();

        this._closeAllPages();

        this.pageFlipAnimation = this.pageFlipAnimationEntity.script.PageFlipAnimation;

        this.app.on('BookUI:chapterIntro', this.openFirstPageOfChapter, this);
        this.app.on('BookUI:previousPage', this.previousPage, this);
        this.app.on('BookUI:nextPage', this.nextPage, this);
        this.app.on('BookUI:chapterSelect', this.openChapterSelect, this);
        this.app.on('BookUI:levelSelect', this.openSpecificLevelPage, this);
        this.app.on('BookUI:currentLevel', this.openCurrentLevelPage, this);
    },

    onUIEntityOpen: function (args) {
        this.app.fire('UIManager:showUI', 'FloatingUI');

        this.app.fire('GardenInput:setMouseWheel', false);

        const unlocked = this.checkNewChapter();

        if (this.showNextPageUnlock) {
            args = { key: 'nextLevelUnlockAnim' };
            this.showNextPageUnlock = false;
        }

        // console.log('BookUI.js:', args)
        switch (args.key) {
            case "nextLevel":
                this.openAndMoveToCurrentLevel();
                break;
            case "currentLevel":
                //this.focussPlayedLevel(LevelManager.instance.getCurrentChapterNumber(), LevelManager.instance.getCurrentLevelNumber());
                this.setWorldBackground();
                break;
            case 'lowStarLevel':
                var level = this.getLowStarLevel(args.chapterID, 1);
                this.openAndMoveToSpecificLevel(args.chapterID, level);
                if (args.openLevelPage) {
                    if (unlocked) {
                        this.once('worldPreviewDone', () => this.showLevelInfo(args.chapterID, level));
                    } else {
                        this.showLevelInfo(args.chapterID, level);
                    }
                }

                break;
            case "lastLevel":
                this.openAndMoveToSpecificLevel();
                break;
            case "nextLevelUnlockAnim":
                this.openNextLevelOrPage();
                break;
            default:
                this.openAndMoveToCurrentLevel();
                break;
        }

        this.fadein();
    },

    checkNewChapter: function () {
        var unlocked = WorldUnlockManager.instance.isUnlocked();

        this.newChapterEntity.enabled = false;

        if (unlocked) {
            this.app.on('ViewportManager:onResize', this.onResize, this);
            if (WorldUnlockManager.instance.worldID != 0) {
                this.showPageDissolve();
                this.newChapterEntity.enabled = true;
            }
        }

        return unlocked;
    },

    showPageDissolve: function () {
        this.app.fire('UIManager:showUI', 'InputDisabler');
        const pageDissolveShader = this.worldPreview.script.pageDissolveShader
        this.time = 0;
        this.worldPreview.enabled = true;
        pageDissolveShader.setDiffuseMap(WorldManager.instance.getWorldBackgroundImage());

        const index = WorldManager.instance.getWorldIndex();
        pageDissolveShader.setWorldIndex(index);
        LocalizationManager.instance.setText(this.chapterTitleText, WorldManager.instance.getWorldList()[index].name);

        this.onResize(ViewportManager.instance.getOrientation(), ViewportManager.instance.width, ViewportManager.instance.height);
        //WorldUnlockManager.instance.disable();

        const value = this.alphaCurve.value(this.time / this.duration);
        pageDissolveShader.updateAlpha(value, 0);
    },

    onUIEntityOpenFinish: function () {
        this.startDissolve = this.newChapterEntity.enabled;

        if (this.startDissolve) {
            this.onResize(ViewportManager.instance.getOrientation(), ViewportManager.instance.width, ViewportManager.instance.height);
        }
    },

    update: function (dt) {
        if (this.startDissolve) {
            this.time += dt;
            const value = this.alphaCurve.value(this.time / this.duration);
            this.worldPreview.script.pageDissolveShader.updateAlpha(value, dt);

            if (this.time > this.duration) {
                this.worldPreview.enabled = false;
                this.newChapterEntity.enabled = false;
                this.app.fire('UIManager:hideUI', 'InputDisabler');

                this.fire('worldPreviewDone');
            }
        }
    },

    onResize: function (orientation, width, height, device) {
        const scale = this.bookScaleEntity.getLocalScale();
        const reference = UIManager.instance.getReferenceResolution();
        const element = this.shaderSize.element;

        const imageWidth = element.width;
        const imageHeight = element.height;

        const minSize = Math.min(imageWidth, imageHeight);

        const fov = this.camera.camera.fov;

        const distance = ((reference.y / (minSize * scale.x)) / 2) / Math.tan(fov / 2 * (Math.PI / 180));

        this.worldPreview.setLocalPosition(0, 0, -distance);
    },

    fadein: function () {
        for (var i = 0; i < this.bookFadeEntities.length; i++) {
            var entity = this.bookFadeEntities[i];

            entity.enabled = false;
        }
    },

    fadeout: function () {
        for (var i = 0; i < this.bookFadeEntities.length; i++) {
            var entity = this.bookFadeEntities[i];

            entity.enabled = true;
        }
    },

    onUIEntityClose: function (args) {
        this.fadeout();

        this.app.off('ViewportManager:onResize', this.onResize, this);
    },

    setWorldBackground: function () {
        var pageInfo = this.pages[this.currentPage].pageInfo;
        var worldInfo = WorldManager.instance.getWorldData(pageInfo.chapterID);

        var currentPage = this.getCurrentPageScript();

        currentPage.setPageInformation(pageInfo.chapterID, pageInfo.pageID, worldInfo);
    },

    nextPage: function () {
        this.fadeout();
        var nextPage = this.currentPage + 1;

        var levelSelectPage = this.getCurrentPageScript();
        var nextPageInfo = this.pages[nextPage];
        var nextWorldInfo = WorldManager.instance.getWorldData(nextPageInfo.pageInfo.chapterID);
        var scroll = levelSelectPage.getScrollValue();

        pc.timer.add(0.1, () => {
            levelSelectPage.setRightPage(nextPageInfo.pageInfo.chapterID, nextPageInfo.pageInfo.pageID, nextWorldInfo);

            levelSelectPage.scrollToValue(0);
        }, this);


        this.pageFlipAnimation.flipNextPage(this.pages[this.currentPage], this._getNextPageInformation(nextPage), scroll).once('complete', () => {
            this.app.fire('LevelSelectPage:scrollTo', 0);

            if (nextPage < this.pages.length) {
                this._switchPage(nextPage);
            }
            this.fadein();

            AssetManager.instance.unloadPreviousAssets();
        });
    },

    previousPage: function () {
        this.fadeout();
        var previousPage = this.currentPage - 1;
        var levelSelectPage = this.getCurrentPageScript();
        var previousPageInfo = this.pages[previousPage];
        var previousWorldInfo = WorldManager.instance.getWorldData(previousPageInfo.pageInfo.chapterID);

        var scroll = levelSelectPage.getScrollValue();

        pc.timer.add(0.1, () => {
            levelSelectPage.setLeftPage(previousPageInfo.pageInfo.chapterID, previousPageInfo.pageInfo.pageID, previousWorldInfo);
        }, this);

        this.pageFlipAnimation.flipPreviousPage(this.pages[this.currentPage], this._getNextPageInformation(previousPage), scroll).once('complete', () => {

            this.app.fire('LevelSelectPage:scrollTo', 1);

            if (previousPage >= 0) {
                this._switchPage(previousPage);
            }
            this.fadein();
            AssetManager.instance.unloadPreviousAssets();
        });
    },

    openChapterSelect: function () {
        UnlockLevelAnimation.instance.stopAllAnimations();
        this._switchPage(this.pageTracker.chapterSelect.pageIndex);
    },

    openFirstPageOfChapter: function (worldID) {
        if (this.pageTracker.hasOwnProperty(worldID)) {
            this._switchPage(this.pageTracker[worldID][0].pageIndex);
        } else {
            var currentChapter = this._getCurrentChapter();
            if (currentChapter !== null) {
                this._switchPage(this.pageTracker[currentChapter][0].pageIndex);
            }
        }
        var levelSelectPage = this.getCurrentPageScript();
        levelSelectPage.scrollToValue(0);
    },

    openSpecificLevelPage: function (worldID, partID) {
        this._switchPage(this.pageTracker[worldID][partID].pageIndex);
    },


    openCurrentLevelPage: function () {
        var levelCounter = 0;
        var latestWorld = 0;
        var currentLevel = LevelDataManager.instance.getCurrentLevel();

        var worldList = WorldManager.instance.getWorldList();
        for (var worldKey in worldList) {
            if (worldList[worldKey].isUnlocked === false) {

                this.openSpecificLevelPage(latestWorld, worldList[worldKey].nParts - 1);
                return;
            }
            var minLevel = levelCounter + 1;
            var maxLevel = minLevel + worldList[worldKey].nLevels - 1;
            latestWorld = worldKey;
            if (currentLevel >= minLevel && currentLevel <= maxLevel) {
                for (var i = 0; i < worldList[worldKey].nParts; i += 1) {
                    var pageMinLevel = minLevel + i * (worldList[worldKey].nLevels / worldList[worldKey].nParts);
                    var pageMaxLevel = minLevel + ((i + 1) * (worldList[worldKey].nLevels / worldList[worldKey].nParts)) - 1;
                    if (currentLevel >= pageMinLevel && currentLevel <= pageMaxLevel) {
                        this.openSpecificLevelPage(worldKey, i);
                        return;
                    }
                }
            }
            levelCounter = maxLevel;
        }
    },

    openAndMoveToCurrentLevel: function () {
        this.openCurrentLevelPage();
        var levelSelectPage = this.getCurrentPageScript();
        levelSelectPage.scrollToLevel(LevelDataManager.instance.getCurrentLevel());
    },

    openNextLevelOrPage: function () {
        var chapterID = LevelManager.instance.getCurrentChapterNumber();

        if (!WorldManager.instance.isNextWorldExisting(chapterID) && WorldManager.instance.isEndOfWorld(LevelManager.instance.getCurrentLevelNumber())) {
            this.openAndMoveToSpecificLevel();
        } else if (WorldManager.instance.isEndOfPage(LevelManager.instance.getCurrentLevelNumber())) {

            // new page or world unlocked -> don't unlock new level
            this.openAndMoveToSpecificLevel();
            var levelSelectPage = this.getCurrentPageScript();
            levelSelectPage.unlockNextPageButton();
        } else {
            this.openAndMoveToCurrentLevel();
            var levelSelectPage = this.getCurrentPageScript();
            levelSelectPage.unlockLatestLevel(false);
        }
    },

    openAndMoveToSpecificLevel: function (chapter = LevelManager.instance.getCurrentChapterNumber(), level = LevelManager.instance.getCurrentLevelNumber()) {
        if (chapter === null || level === null) {
            // check if a level has been played
            this.openAndMoveToCurrentLevel();
            return;
        }

        var levelSelectPage = this._getPage(chapter, level);
        this._switchPage(this._getPageNumber(chapter, level));
        levelSelectPage.scrollToLevel(level);
    },

    _createPageList: function () {
        this.pages = [];
        this.pageTracker = {};

        var worldList = WorldManager.instance.getWorldList();

        //set book order
        this._setPageOrderData(this.pageTracker, 'chapterSelect', this.chapterSelectPageEntity, { pageScript: 'chapterSelectPage' });

        for (var worldKey in worldList) {
            this.pageTracker[worldKey] = {};
            // this._setPageOrderData(this.pageTracker[worldKey], 'chapterIntro', chapterIntro, { pageScript: 'chapterIntroPage', chapterID: worldKey});

            for (var i = 0; i < worldList[worldKey].nParts; i += 1) {
                this._setPageOrderData(this.pageTracker[worldKey], i, this.levelSelectPageEntity, { pageScript: 'levelSelectPage', chapterID: worldKey, pageID: i });
            }
        }
    },

    _closeAllPages: function () {
        for (var i = 0; i < this.pages.length; i += 1) {
            this.pages[i].entity.enabled = false;
        }
    },

    _setPageOrderData: function (object, name, page, pageInfo) {
        this.pages.push({ entity: page, pageInfo: pageInfo });

        object[name] = {};
        object[name].pageIndex = this.pages.length - 1;
        object[name].page = page;
    },

    _getNextPageInformation: function (pageIndex) {
        //if (!isNaN(this.currentPage) && pageIndex === this.currentPage) {
        return this.pages[pageIndex];
        //}
    },

    _switchPage: function (pageIndex) {
        if (!isNaN(this.currentPage) && pageIndex === this.currentPage) {
            this._onPageOpen(this.pages[pageIndex]);
            // this.app.fire('BookUI:switchPage', this.currentPage, this.pages.length, this.pages[pageIndex]);
            return;
        }
        if (pageIndex >= 0 && pageIndex < this.pages.length) {
            if (!isNaN(this.currentPage)) {
                this.pages[this.currentPage].entity.enabled = false;
                this._onPageClose(this.pages[this.currentPage]);
            }

            this.currentPage = pageIndex;
            this.pages[pageIndex].entity.enabled = true;

            this._onPageOpen(this.pages[pageIndex]);
            this.app.fire('BookUI:switchPage', this.currentPage, this.pages.length, this.pages[pageIndex]);
            this.bookOpenEntity.enabled = this.currentPage > 0;
        }
    },

    getCurrentPageScript: function () {
        var pageData = this.pages[this.currentPage];
        var pageScript = pageData.entity.script.get(pageData.pageInfo.pageScript);
        return pageScript;
    },

    _onPageOpen: function (pageData) {
        var pageScript = pageData.entity.script.get(pageData.pageInfo.pageScript);

        if (pageScript) {
            pageScript._onPageOpen(pageData.pageInfo);
        }
    },

    _onPageClose: function (pageData) {
        var pageScript = pageData.entity.script.get(pageData.pageInfo.pageScript);

        if (pageScript) {
            pageScript._onPageClose(pageData.pageInfo);
        }
    },

    _getCurrentChapter: function () {
        var worldList = WorldManager.instance.getWorldList();

        var worldKeys = Object.keys(worldList);
        for (var i = 0; i < worldKeys.length; i += 1) {
            if (i === worldKeys.length - 1 && this.currentPage > this.pageTracker[worldKeys[i]].chapterIntro.pageIndex) return worldKeys[i];
            if (this.currentPage > this.pageTracker[worldKeys[i]].chapterIntro.pageIndex &&
                this.currentPage < this.pageTracker[worldKeys[i + 1]].chapterIntro.pageIndex) {
                return worldKeys[i];
            }
        }
        return null;
    },

    _getPage: function (chapter, level) {
        var page = WorldManager.instance.getPageInWorld(chapter, level);

        return this.pages[this.pageTracker[chapter][page].pageIndex].entity.script.levelSelectPage;
    },

    _getPageNumber: function (chapter, level) {
        var page = WorldManager.instance.getPageInWorld(chapter, level);

        return this.pageTracker[chapter][page].pageIndex;
    },

    _startPageFlipAnim: function () {
        this.bookOpenEntity.enabled = this.currentPage > 0;
        if (this.pageFlipEntity.enabled === true) this.pageFlipEntity.script.tweenRotation.startTween();
    },
    //function get lowest level in chapter with x amount of stars
    getLowStarLevel: function (area = 1, stars = 2) {
        var areaStars = StorageManager.instance.get("levelData")[area];
        switch (stars) {
            case 2: return this.closestTwoStarLevel(areaStars, area);
            case 1: return this.closestOneStarLevel(areaStars, area);
            default: return this.closestTwoStarLevel(areaStars, area);
        }
    },
    closestTwoStarLevel: function (areaStars, area) {
        var currentLevel = LevelDataManager.instance.getRealCurrentLevel();
        if (currentLevel < WorldManager.instance.maxLevel && WorldManager.instance.getWorldByLevel(currentLevel) === area) {
            return LevelDataManager.instance.getCurrentLevel();
        }

        var oneStarLevel = null;
        var areaStarKeys = Object.keys(areaStars);
        var starsArrayLength = areaStarKeys.length;
        if (starsArrayLength === 0) {
            // console.log(WorldManager.instance.getMaxLevels(area-1) + 1)
            var returnValue = 1;
            if (area !== 1) {
                returnValue = WorldManager.instance.getMaxLevels(area - 1) + 1;
            }
            return returnValue;
        }
        for (var i = 0; i < starsArrayLength; i++) {
            if (areaStars[areaStarKeys[i]].stars < 3) {
                if (areaStars[areaStarKeys[i]].stars === 2)
                    return parseInt(areaStarKeys[i]);
                if (areaStars[areaStarKeys[i]].stars === 1 && !oneStarLevel) {
                    oneStarLevel = parseInt(areaStarKeys[i]);
                }
            }
        }
        return oneStarLevel ? oneStarLevel : WorldManager.instance.getMaxLevels(area - 1) + 1;
    },
    closestOneStarLevel: function (areaStars, area) {
        var currentLevel = LevelDataManager.instance.getRealCurrentLevel();
        if (currentLevel < WorldManager.instance.maxLevel && WorldManager.instance.getWorldByLevel(currentLevel) === area) {
            return LevelDataManager.instance.getCurrentLevel();
        }

        var areaStarKeys = Object.keys(areaStars);
        var starsArrayLength = Object.keys(areaStars).length;
        if (starsArrayLength === 0) {
            // console.log(WorldManager.instance.getMaxLevels(area-1) + 1)
            var returnValue = 1;
            if (area !== 1) {
                returnValue = WorldManager.instance.getMaxLevels(area - 1) + 1;
            }
            return returnValue;
        }
        for (var j = 0; j < starsArrayLength; j++) {
            if (areaStars[areaStarKeys[j]].stars < 3) {
                if (areaStars[areaStarKeys[j]].stars === 1) {
                    return parseInt(areaStarKeys[j]);
                }
            }
        }
        return starsArrayLength + 1;
    },
    showLevelInfo: function (chapterID, level) {
        this.app.fire('UIManager:showUI', 'LevelInfo');
        this.app.fire('WorldManager:setWorld');

        var data = LevelManager.instance.getLevelData(level);
        UIManager.instance.getScreen('LevelInfo').script.levelInfoScreen.setInformation(chapterID, level, undefined, data);
    },

});

// BookButton.js
var BookButton = pc.createScript('bookButton');

var bookOptions = Object.freeze({
    HOME: 0,
    NEXTREPLAY: 1,
    NEXTCURRENT: 2,
    RESETLEVEL: 3,
    GARDEN: 4
});

var typeOptions = [
    { HOME: bookOptions.HOME },
    { NEXTREPLAY: bookOptions.NEXTREPLAY },
    { NEXTCURRENT: bookOptions.NEXTCURRENT },
    { RESETLEVEL: bookOptions.RESETLEVEL },
    { GARDEN: bookOptions.GARDEN },
];

BookButton.attributes.add('goTo', { type: 'number', enum: typeOptions });

BookButton.attributes.add('currentLevelText', { type: 'entity' });

pc.extend(BookButton.prototype, {
    initialize: function () {
        this.bookOptions = bookOptions;
        this.entity.script.elementInput.on(inputEvents.CLICK, this._onClick, this);
        this.setCurrentLevelText(LevelDataManager.instance.getCurrentLevel());
        // this.app.on('GardenTasksScreen:gotoLevel', this._onClick, this);
        this.tunnelValues = null;
        this.on('enable', this.onEnable, this);
    },

    onEnable: function () {
        this.setCurrentLevelText(LevelDataManager.instance.getCurrentLevel());
    },

    _onClick: function () {
        this.app.fire('UIManager:hideAll');
        switch (this.goTo) {
            case bookOptions.NEXTREPLAY:
                // replayed a old level
                this.app.fire('UIManager:showUI', 'LoadingScreen', LoadingScreen.BACKGROUND.BOOK);

                LoadingScreen.instance.setType(LoadingScreen.TYPES.ASSETS).once('fadeInComplete', () => {
                    AssetManager.instance.loadBookAssets(WorldManager.instance.getWorldIndex(), function () {
                        this.app.fire('Audio:bgm', 'main_ost.mp3');
                        this.app.fire('UIManager:hideUI', 'LoadingScreen');
                        this.app.fire('UIManager:hideAll');
                        this.app.fire('UIManager:showUI', 'Book', { key: 'lastLevel' });
                    }, this);
                });

                break;

            case bookOptions.NEXTCURRENT:
                //console.log("delete this load scene");
                // played a new level
                this.app.fire('UIManager:showUI', 'LoadingScreen', LoadingScreen.BACKGROUND.BOOK);

                LoadingScreen.instance.setType(LoadingScreen.TYPES.ASSETS).once('fadeInComplete', () => {

                    AssetManager.instance.loadBookAssets(WorldManager.instance.getWorldIndex(), () => {
                        this.app.fire('UIManager:hideUI', 'LoadingScreen');

                        this.goTo = bookOptions.HOME;
                        this.app.fire('UIManager:showUI', 'Book', { key: 'nextLevelUnlockAnim' });
                    });
                });

                // AssetManager.instance.loadBookAssets(WorldManager.instance.getWorldIndex(), function() {
                //     this.app.fire('UIManager:hideAll');
                //     this.app.fire('UIManager:showUI', 'Book', 'nextLevelUnlockAnim');
                // }, this);
                break;

            case bookOptions.HOME:

                var worldID = WorldManager.instance.getWorldByLevel(LevelDataManager.instance.getCurrentLevel());

                this.app.fire('UIManager:showUI', 'LoadingScreen', LoadingScreen.BACKGROUND.BOOK);

                LoadingScreen.instance.setType(LoadingScreen.TYPES.ASSETS).once('fadeInComplete', () => {
                    AssetManager.instance.loadBookAssets(worldID, () => {
                        this.app.fire('UIManager:hideUI', 'LoadingScreen');
                        this.app.fire('UIManager:showUI', 'Book', { key: 'nextLevel' });
                    });
                });

                // AssetManager.instance.loadBookAssets(WorldManager.instance.getWorldIndex(), function() {
                //     this.app.fire('UIManager:hideAll');
                //     this.app.fire('UIManager:showUI', 'Book', 'nextLevel');
                //     AssetManager.instance.loadWorldLevels();
                // }, this); 

                break;

            case bookOptions.GARDEN:
                this.app.fire('BackToGardenButton:click');

                AssetManager.instance.setGarden();
                LoadSceneController.load('Garden', false, 'garden');
                this.app.once('switchedScene', () => {
                    this.app.fire('UIManager:hideUI', 'LoadingScreen');

                    this.app.fire('UIManager:hideAll');

                    if (WorldUnlockManager.instance.isUnlocked()) {
                        WorldUnlockManager.instance.startGardenSequence();
                    } else {
                        this.app.fire('UIManager:showUI', 'Garden', this.tunnelValues);
                    }

                    this.tunnelValues = null;
                }, this);
                break;

            case bookOptions.RESETLEVEL:
                // console.warn("RESETLEVEL case is empty! Falling back on default");
                // AssetManager.instance.loadBookAssets(WorldManager.instance.getWorldIndex(), function() {
                //     this.app.fire('UIManager:hideAll');
                //     this.app.fire('UIManager:showUI', 'Book', {key:'nextLevel'});
                // }, this);

                Wrapper.instance.showInterstitialAd('restart_level', () => {
                    LevelManager.instance.startLevel(LevelManager.instance.currentLevel, LevelManager.instance.currentChapter, true, false, false);
                });

                break;

            default:
                this.app.fire('UIManager:showUI', 'LoadingScreen', LoadingScreen.BACKGROUND.BOOK);

                AssetManager.instance.loadBookAssets(WorldManager.instance.getWorldIndex(), function () {
                    this.app.fire('UIManager:hideUI', 'LoadingScreen');

                    this.app.fire('UIManager:hideAll');
                    this.app.fire('UIManager:showUI', 'Book', { key: 'nextLevel' });
                }, this);
                break;

        }
        // this.app.fire('UIManager:showUI', 'Settings');
    },

    setCurrentLevelText: function (currentLevel) {
        if (this.currentLevelText !== null)
            this.currentLevelText.element.text = currentLevel;
    },

    setType: function (type) {
        this.goTo = type;
    },
    setTunnelValues: function (args) {
        this.tunnelValues = args;
    }

});

// ShopInterface.js
var ShopInterface = pc.createScript('shopInterface');

ShopInterface.attributes.add('packs', { type: 'entity', array: true });
ShopInterface.attributes.add('dailyReward', { type: 'entity' });

ShopInterface.attributes.add('scrollbarHorizontal', { type: 'entity' });
ShopInterface.attributes.add('scrollbarVertical', { type: 'entity' });
ShopInterface.attributes.add('scrollViewEntity', { type: 'entity' });

ShopInterface.attributes.add('coinPlusIcon', { type: 'entity' });
ShopInterface.attributes.add('coinNotificationBadge', { type: 'entity' });


pc.extend(ShopInterface.prototype, {
    init: function () {

        this.key = 'shop';

        // this.app.mouse.on(pc.EVENT_MOUSEWHEEL, this.onMouseWheel, this);

        this.app.on('ViewportManager:onResize', this._onResize, this);

        if (this.scrollViewEntity) {
            this.scrollViewEntity.scrollview.horizontal = false;
            this.scrollViewEntity.scrollview.vertical = false;

            this._onResize(ViewportManager.instance.getOrientation(), ViewportManager.instance.width, ViewportManager.instance.height, ViewportManager.instance.getDevice());
        }

        this.dailyReward.script.dailyReward.init();

        for (var i = 0; i < this.packs.length; i++) {
            var adPackScript = this.packs[i].script.shopItem;
            adPackScript.init();
        }

        this.getAdData();
        this.dailyReward.script.dailyReward.checkCooldown();
    },

    postInitialize: function () {

        this.app.on("StorageManager:changedStorage", this._onStorageChange, this);
    },

    _onStorageChange: function () {
        this.getAdData();

        this.dailyReward.script.dailyReward.checkCooldown();
    },

    onUIEntityOpen: function (showGarden) {
        this.showGarden = showGarden;
        GameManager.instance.trackCustomEvent('shop', 'open');
        this.app.fire('Audio:sfx', 'shop_open.mp3');
        this.app.fire('UIManager:showUI', 'FloatingUI');
        // this.coinUIIcon.enabled = false;
        if (this.scrollViewEntity) {
            if (this.scrollbarHorizontal.enabled) {
                this.scrollbar = this.scrollbarHorizontal;
            } else if (this.scrollbarVertical.enabled) {
                this.scrollbar = this.scrollbarVertical;
            }
        }

        for (var i = 0; i < this.packs.length; i++) {
            var adPackScript = this.packs[i].script.shopItem;
            adPackScript.on('updateAdSaveData', this.saveAdData, this);
            adPackScript.checkCooldown();
        }

        this.dailyReward.script.dailyReward.on('updateAdSaveData', this.saveAdData, this);

        this.app.on('Wrapper:checkHasRewardedAd', this.checkHasRewarded, this);
        this.app.on('FamobiAPI:cooldown', this.checkHasRewarded, this);

        this.dailyReward.script.dailyReward.checkCooldown();
        //this.checkHasRewarded();

        this.coinPlusIcon.enabled = false;
        if (this.dailyReward.script.dailyReward.isAvailable()) {
            this.coinNotificationBadge.script.notificationBadge.hide();
        }
    },

    onUIEntityClose: function () {
        this.dailyReward.script.dailyReward.off('updateAdSaveData', this.saveAdData, this);
        // this.coinUIIcon.enabled = true;
        for (var i = 0; i < this.packs.length; i++) {
            var adPackScript = this.packs[i].script.shopItem;
            adPackScript.off('updateAdSaveData', this.saveAdData, this);
        }
        // if (AssetManager.instance.currentWorld === AssetManager.WORLDS.GARDEN) this.app.fire('UIManager:hideUI', 'Coins');

        // if (!UIManager.instance.getScreen('BoosterShop').enabled) this.app.fire('UIManager:hideUI', 'Coins');
        this.app.off('Wrapper:checkHasRewardedAd', this.checkHasRewarded, this);
        this.app.off('FamobiAPI:cooldown', this.checkHasRewarded, this);

        this.coinPlusIcon.enabled = true;
        if (this.dailyReward.script.dailyReward.isAvailable()) {
            this.coinNotificationBadge.script.notificationBadge.show();
        }

        if (this.showGarden) {
            this.app.fire('UIManager:showUI', 'Garden');
            this.app.fire('UIManager:hideUI', 'FloatingUI');

            delete this.showGarden;
        }
    },

    saveAdData: function () {
        var adData = {};

        for (var i = 0; i < this.packs.length; i++) {
            var adPackScript = this.packs[i].script.shopItem;
            var key = adPackScript.getKey();
            var data = adPackScript.getData();
            adData[key] = data;
        }

        adData[this.dailyReward.script.dailyReward.key] = this.dailyReward.script.dailyReward.data;
        StorageManager.instance.set(this.key, adData);
    },

    getAdData: function () {
        this.data = StorageManager.instance.get(this.key);
        this.dailyReward.script.dailyReward.setData(this.data[this.dailyReward.script.dailyReward.key]);

        for (var i = 0; i < this.packs.length; i++) {
            var adPackScript = this.packs[i].script.shopItem;

            adPackScript.setData(this.data[adPackScript.key]);
        }
    },

    _onResize: function (orientation, width, height, device) {
        if (this.scrollViewEntity) {
            this.scrollViewEntity.scrollview.horizontal = orientation === orientationEnum.LANDSCAPE;
            this.scrollViewEntity.scrollview.vertical = orientation === orientationEnum.PORTRAIT;
            this.scrollViewEntity.scrollview._scroll.set(0, 0);
            this.scrollbar = orientation === orientationEnum.LANDSCAPE ? this.scrollbarHorizontal : this.scrollbarVertical;
            if (this.scrollbar.scrollbar) {
                this.scrollbar.scrollbar.value = 0;
            }
        }

    },

    onMouseWheel: function () {
        if (!UIManager.instance.isTopOfStack('Screen', 'Shop')) return;
        var sensitivity = 0.1;
        if (this.scrollbar.scrollbar && this.scrollbar.enabled) {
            this.scrollbar.scrollbar.value -= event.wheelDelta * sensitivity;
        }

    },
});

// LimitFPS.js
var LimitFps = pc.createScript('limitFps');

LimitFps.attributes.add('targetFps', { type: 'number', default: 30 });

// initialize code called once per entity
LimitFps.prototype.initialize = function() {
    var app = this.app;

    this.limit(this.targetFps);

    // Handle any runtime changes to the FPS target
    this.on('attr:targetFps', function (value, prev) {
        this.limit(value);
    });
};

LimitFps.prototype.limit = function(targetFps) {
    var app = this.app;

    if (this.intervalId) {
        clearInterval(this.intervalId);
        this.intervalId = null;
    }

    if (targetFps >= 60) {
        app.autoRender = true;
    } else {
        app.autoRender = false;

        this.intervalId = setInterval(function () {
            app.renderNextFrame = true;
        }, 1000 / targetFps);
    }
};

// CollectibleUnlockInterface.js
var CollectibleUnlockInterface = pc.createScript('collectibleUnlockInterface');

var animationStates = Object.freeze({ IDLE: 0, ANIMATE: 1, LEAVE: 2, ADDTOCOLLECTION: 3, FUSE: 4, READYFORFUSE: 5 });

CollectibleUnlockInterface.attributes.add('spineObject', { type: 'entity' });
CollectibleUnlockInterface.attributes.add('unlockContainer', { type: 'entity' });
CollectibleUnlockInterface.attributes.add('pivotPoint', { type: 'entity' });
CollectibleUnlockInterface.attributes.add('completedObjectEntity', { type: 'entity' });

CollectibleUnlockInterface.attributes.add('color', { type: 'rgba' });
CollectibleUnlockInterface.attributes.add('unlockText', { type: 'entity' });

CollectibleUnlockInterface.attributes.add('popupTime', { type: 'number', default: 1 });
CollectibleUnlockInterface.attributes.add('popupScale', { type: 'number', default: 2 });
CollectibleUnlockInterface.attributes.add('popupAnimation', { type: 'string', default: "BackOut" });

CollectibleUnlockInterface.attributes.add('fullDuration', { type: 'number', default: 6 });
CollectibleUnlockInterface.attributes.add('speedyFullDuration', { type: 'number', default: 5 });
CollectibleUnlockInterface.attributes.add('durationUntilMoveOut', { type: 'number', default: 4 });
CollectibleUnlockInterface.attributes.add('yOffset', { name: "element center offset", type: 'number', default: 1 });

CollectibleUnlockInterface.attributes.add('flashImage', { type: 'entity' });
CollectibleUnlockInterface.attributes.add('viginette', { type: 'entity' });
CollectibleUnlockInterface.attributes.add('backdrop', { type: 'entity' });
CollectibleUnlockInterface.attributes.add("animateStateDuration", { title: "", default: 4, type: "number" });
CollectibleUnlockInterface.attributes.add("addtocollectionStateDuration", { title: "", default: 0.5, type: "number" });
CollectibleUnlockInterface.attributes.add("fuseStateDuration", { title: "", default: 5.5, type: "number" });
CollectibleUnlockInterface.attributes.add("leaveStateDuration", { title: "", default: 1.5, type: "number" });
CollectibleUnlockInterface.attributes.add("readyForFuseStateDuration", { title: "", default: 2.5, type: "number" });
CollectibleUnlockInterface.attributes.add("unlockStartScale", { title: "", default: 0.25, type: "number" });
CollectibleUnlockInterface.attributes.add("newUnlockStartScale", { title: "", default: 0.6, type: "number" });
CollectibleUnlockInterface.attributes.add("finalFlowerScale", { title: "", default: 0.8, type: "number" });
CollectibleUnlockInterface.attributes.add("specialFlowerRotationSpeed", { title: "", default: 45, type: "number" });

CollectibleUnlockInterface.attributes.add("spineTemplate", { title: "", type: "asset" });
CollectibleUnlockInterface.attributes.add("camera", { title: "", type: "entity" });


pc.extend(CollectibleUnlockInterface.prototype, {
    init: function () {
        CollectibleUnlockInterface.instance = this;

        //set scales for the animation depending on desktop/mobile, portrait/landscape
        this.unlockContainerDesktopScale = { x: 2, y: 2, z: 2 };
        this.unlockContainerMobilePortraitScale = { x: 1, y: 1, z: 1 };
        this.unlockContainerMobileLandscapeScale = { x: 2.5, y: 2.5, z: 2.5 };

        this.state = animationStates.IDLE;
        this.callback = null;
        this.uiScreen = this.entity.script.uiEntity.name;
        this.circleDegrees = 360;


        this.yOffsetStart = this.yOffset;
        this.containerPos = this.unlockContainer.getLocalPosition().clone();
        this.pivotPointStartPos = this.pivotPoint.getLocalPosition().clone();
        this.petalStartRotation = { x: 90, y: 0, z: 0 };


        //pivot point rotations
        this.startRot = this.pivotPoint.getLocalEulerAngles().z;
        this.endRot = this.startRot + this.circleDegrees * 2;
        this.speedyEndRot = this.startRot + this.circleDegrees * 3;

        //variables for the rotation of the animation
        this.circleStartSpeed = -30;
        this.circleEndSpeed = -200;
        this.circleCurrentSpeed = { x: this.circleStartSpeed };
        this.acceleration = 1.1;
        this.deceleration = 7;


        this.unlockTextStartScale = new pc.Vec3(0.5, 0.5, 0.5);
        this.unlockObjectiveEntityStartScale = new pc.Vec3(this.unlockStartScale, this.unlockStartScale, this.unlockStartScale);
        this.newUnlockedObjectiveEntityStartScale = new pc.Vec3(this.newUnlockStartScale, this.newUnlockStartScale, this.newUnlockStartScale);

        this.unlockObjectiveEntitystartPos = new pc.Vec3(0, -0.25, 0);
        this.completedObjectAngleUpright = new pc.Vec3(0, 270, 0);
    },

    unlockObject: function (callback, partObject = WorldManager.instance.getPartAssets(1).partModel, amountOfParts = 4, totalParts = 4, completedObject = WorldManager.instance.getPartAssets(1).completedModel) {
        this.callback = callback;
        this.partAsset = partObject;
        this.amountOfParts = amountOfParts;
        this.totalParts = totalParts;
        this.completedAsset = completedObject;
        this.state = animationStates.ANIMATE;

        this.viginette.enabled = true;
        this.backdrop.enabled = true;
        this.flashImage.element.opacity = 1;
        this.unlockContainer.enabled = true;
        this.unlockContainer.setLocalPosition(this.containerPos);

        this.yOffset = this.yOffsetStart;
        this.amountOfPartsBefore = this.amountOfParts - 1;
        this.changeAngle = this.circleDegrees / this.amountOfParts;

        if (this.amountOfParts === this.totalParts) {
            this.app.fire('Audio:sfx', 'all_petal_collected_new.mp3');

            this.spineObject = this.spineTemplate.resource.instantiate();
            this.camera.addChild(this.spineObject);
            this.spineObject.spine.state.setAnimation(0, "animation", false);

            this.unlockText.enabled = false;
        } else {
            this.app.fire('Audio:sfx', 'petal_collected_2_new.mp3');
            this.unlockText.enabled = true;
        }

        this.app.fire('UIManager:showUI', this.uiScreen);
        this.materialStartColor = this.partAsset.resource.meshInstances[0].material.emissive;

        for (var i = 0; i < this.amountOfParts; i++) {
            //general pivot point
            var pivotPoint = this.unlockContainer.children[i];
            var angle = this.changeAngle * i;

            //objective Entity pivot point
            var unlockEntityModelPivot = pivotPoint.children[0];
            var unlockObjectiveEntity = pivotPoint.children[0].children[0];

            pivotPoint.enabled = true;
            pivotPoint.setLocalPosition(pc.Vec3.ZERO);

            unlockObjectiveEntity.model.asset = this.partAsset;
            unlockObjectiveEntity.setLocalPosition(this.unlockObjectiveEntitystartPos);

            pivotPoint.setLocalEulerAngles(0, 0, angle);

            if (i === this.amountOfPartsBefore) {
                //if last petal, use this one as newly acquired
                unlockEntityModelPivot.setLocalPosition(pc.Vec3.ZERO);
                unlockObjectiveEntity.setLocalScale(this.newUnlockedObjectiveEntityStartScale);
            } else {
                //any other petal
                unlockObjectiveEntity.setLocalScale(this.unlockObjectiveEntityStartScale);
                unlockEntityModelPivot.setLocalPosition(0, 15, 0);
            }
        }
        this.unlockText.setLocalScale(this.unlockTextStartScale);
        this.unlockText.element.text = this.amountOfPartsBefore + "/" + this.totalParts;

        this.changeState(animationStates.ANIMATE);

    },

    changeState: function (state) {
        this.state = state;
        this.onStateSwitch();
    },


    onStateSwitch: function () {
        switch (this.state) {
            case animationStates.IDLE:
                this.unlockContainer.enabled = false;
                this.animationDone();
                break;
            case animationStates.ANIMATE:
                this._counter = 0;
                this.unlockContainer.enabled = true;
                this.currentStateDuration = this.animateStateDuration;
                this._resetTimers();
                this._scaleObject();
                break;
            case animationStates.LEAVE:
                this.currentStateDuration = this.leaveStateDuration;
                this.moveOut();
                this._counter = 0;
                break;
            case animationStates.ADDTOCOLLECTION:
                this._counter = 0;
                this.currentStateDuration = this.addtocollectionStateDuration;
                this.doCircleAnimation();
                break;
            case animationStates.FUSE:
                this.currentStateDuration = this.fuseStateDuration;
                this.timeSinceStartRotation = 0;
                this._counter = 0;
                this.fuseParts();
                break;
            case animationStates.READYFORFUSE:
                this.currentStateDuration = this.readyForFuseStateDuration;
                this._counter = 0;
                break;
        }
    },

    update: function (dt) {
        switch (this.state) {
            case animationStates.IDLE:
                break;
            case animationStates.ANIMATE:
                this.rotateCircleOfParts(dt);
                this.wiggleUnlockedParts(dt);
                this.updateCounter(dt);
                break;
            case animationStates.LEAVE:
                this.updateCounter(dt);
                break;
            case animationStates.ADDTOCOLLECTION:
                this.rotateCircleOfParts(dt);
                this.wiggleUnlockedParts(dt);
                this.updateCounter(dt);
                break;
            case animationStates.FUSE:
                this.rotateCompletedObject(dt);
                this.rotateCircleOfParts(dt);
                this.speedDownRotationOfParts();
                this.wiggleUnlockedParts(dt);
                this.updateCounter(dt);
                break;
            case animationStates.READYFORFUSE:
                this.rotateCircleOfParts(dt);
                this.wiggleUnlockedParts(dt);
                this.updateCounter(dt);
                break;
        }

        this.timeSinceStartRotation = Math.min(this.timeSinceStartRotation += dt, this.fullDuration);
    },

    updateCounter: function (dt) {
        this._counter += dt;
        if (this._counter >= this.currentStateDuration) {
            this.onStateEnd(this.state);
        }
    },

    animationDone: function () {
        var material = this.partAsset.resource.meshInstances[0].material;
        material.emissive = this.materialStartColor;
        material.emissiveIntensity = 0;
        material.update();
        this.unlockTextTween.stop();
        this.unlockText.setLocalScale(this.unlockTextStartScale);
        this.unlockText.enabled = false;
        this.flashImage.enabled = false;
        this.circleCurrentSpeed.x = this.circleStartSpeed;
        this.completedObjectEntity.enabled = false;
        this.flashImage.enabled = false;
        this.unlockContainer.enabled = false;
        this.angle = 0;

        if (this.spineObject) {
            this.spineObject.destroy();
            delete this.spineObject;
        }

        if (this.callback) {
            this.callback();
            this.callback = null;

        } else {
            this.app.fire('UIManager:hideUI', this.uiScreen);
        }
    },

    rotateCircleOfParts: function (dt) {
        //rotates the circle of objects
        if (!this.completedObjectEntity.enabled) {
            this.unlockContainer.setLocalEulerAngles(this.unlockContainer.getLocalEulerAngles().x,
                this.unlockContainer.getLocalEulerAngles().y,
                this.unlockContainer.getLocalEulerAngles().z + this.circleCurrentSpeed.x * dt);
        }
    },

    speedUpRotationOfParts: function () {

        if (this.amountOfParts === this.totalParts) {
            this.entity.tween(this.circleCurrentSpeed).to({ x: this.circleEndSpeed }, 4, pc.SineIn).start();
            this.highlight();
        } else {
            if (this._counter <= this.currentStateDuration) {
                if (this.circleCurrentSpeed <= this.circleEndSpeed) {
                    this.circleCurrentSpeed += this.acceleration;
                }
            }
        }

    },

    highlight: function () {
        var intensity = { x: 0 };
        //changes the color and intensity of texture --- IMPORTANT, SET BACK TO NORMAL VALUES
        var material = this.partAsset.resource.meshInstances[0].material;
        material.emissive = this.color;
        this.entity.tween(intensity).to({ x: 1 }, 1, pc.SineOut, this.fuseStateDuration - 1)
            .start()
            .on('update', function () {
                material.emissiveIntensity = intensity.x;
                material.update();
            }, this);
    },

    highlightDown: function () {
        var intensity = { x: 1 };
        var material = this.partAsset.resource.meshInstances[0].material;
        this.entity.tween(intensity).to({ x: 0 }, 3, pc.QuarticOut, 0.5).start().on('update', function () {
            material.emissiveIntensity = intensity.x;
            material.update();
        }, this);

    },

    speedDownRotationOfParts: function () {

        if (this.amountOfParts === this.totalParts) {
            this.entity.tween(this.circleCurrentSpeed).to({ x: this.circleStartSpeed }, 6, pc.SineOut, 6).start();
        } else {
            if (this.circleCurrentSpeed >= 0) {
                this.circleCurrentSpeed -= this.deceleration;
                if (this.circleCurrentSpeed < 0) this.circleCurrentSpeed = 0;
            }
        }



    },

    wiggleUnlockedParts: function (dt) {
        //wiggle the unlocked parts
        var amplitude = 15;
        for (var i = 0; i < this.amountOfParts; i++) {
            var object = this.unlockContainer.children[i];
            object.children[0].setLocalEulerAngles(
                this.petalStartRotation.x,
                (-amplitude) * Math.sin(5 * (this.unlockContainer.getLocalEulerAngles().z - object.getLocalEulerAngles().z) * (Math.PI / 180)),
                this.petalStartRotation.z - object.getLocalEulerAngles().z - this.unlockContainer.getLocalEulerAngles().z)
                ;
        }

    },

    //rotates the completed (flower) object
    rotateCompletedObject: function (dt) {
        if (this.completedObjectEntity.enabled) {
            this.completedObjectEntity.rotateLocal(0, this.specialFlowerRotationSpeed * dt, 0);
        }
    },

    _resetTimers: function () {
        this._counter = 0;
        this.secsSinceStart = 0;
        this.timeSinceStartRotation = 0;
    },

    _scaleObject: function () {
        var popupScale = this.unlockContainerDesktopScale;

        if (ViewportManager.instance.getDevice() === deviceEnum.MOBILE) {

            if (ViewportManager.instance.getOrientation() === orientationEnum.PORTRAIT) {
                popupScale = this.unlockContainerMobilePortraitScale;
            } else {
                popupScale = this.unlockContainerMobileLandscapeScale;
            }
        }

        this.unlockContainer
            .tween(this.unlockContainer.getLocalScale())
            .to(popupScale, this.popupTime, pc[this.popupAnimation])
            .start();
    },



    moveOut: function () {
        var collectibleUnlockInterface = this;
        if (this.amountOfParts === this.totalParts) {
            this.completedObjectEntity
                .tween(this.completedObjectEntity.getLocalPosition())
                .to({ x: this.completedObjectEntity.getLocalPosition().x + 15, y: this.completedObjectEntity.getLocalPosition().y, z: this.completedObjectEntity.getLocalPosition().z }, this.leaveStateDuration, pc.Linear)
                .start();
        } else {
            for (var i = 0; i < this.amountOfParts; i++) {
                var pivotPoint = this.unlockContainer.children[i];
                var objectToTween = pivotPoint.children[0];
                var position = {
                    x: objectToTween.getLocalPosition().x,
                    y: objectToTween.getLocalPosition().y + 15,
                    z: objectToTween.getLocalPosition().z
                };

                objectToTween.tween(objectToTween.getLocalPosition()).to(position, this.leaveStateDuration, pc.Linear).start();
            }
        }

    },


    doCircleAnimation: function () {
        var distantPartsMoveDuration = 3;
        var delay = 0.1;

        for (var i = 0; i < this.amountOfParts; i++) {
            //general pivot point
            var pivotPoint = this.unlockContainer.children[i];
            //"model pivot"
            var unlockEntityModelPivot = pivotPoint.children[0];
            //"unlock entity"
            var unlockObjectiveEntity = pivotPoint.children[0].children[0];
            var unlockEntityFlyInDelay = delay * i;

            //checks if it is the last part
            if (i === this.amountOfParts - 1) {

                //scales the new unlocked object down to the size of the others
                unlockObjectiveEntity
                    .tween(unlockObjectiveEntity.getLocalScale())
                    .to({ x: this.unlockStartScale, y: this.unlockStartScale, z: this.unlockStartScale }, distantPartsMoveDuration / 2, pc.QuadraticOut, unlockEntityFlyInDelay + distantPartsMoveDuration * 0.75)
                    .start();


                //moves the new unlocked object from the middle to join the circle
                var objectJoinsCircleTween = unlockEntityModelPivot
                    .tween(unlockEntityModelPivot.getLocalPosition())
                    .to({ x: 0, y: 0 + this.yOffset, z: 0 }, distantPartsMoveDuration / 2, pc.QuadraticOut, unlockEntityFlyInDelay + distantPartsMoveDuration * 0.75)
                    .start().on('complete', function () {
                        this.speedUpRotationOfParts();
                    }, this);
            } else {
                //moves the previously acquired parts into the circle
                unlockEntityModelPivot
                    .tween(unlockEntityModelPivot.getLocalPosition())
                    .to({ x: 0, y: 0 + this.yOffset, z: 0 }, distantPartsMoveDuration, pc.QuadraticOut, unlockEntityFlyInDelay)
                    .start();
            }

            this.unlockTextTween = this.unlockText
                .tween(this.unlockText.getLocalScale())
                .to(new pc.Vec3(1, 1, 1), 0.15, pc.SineInOut, 5.6)
                .yoyo(true)
                .repeat(2)
                .start();

            this.unlockTextTween.on('yoyo', function () {
                this.unlockText.element.text = this.amountOfParts + "/" + this.totalParts;
                this.app.fire('vibrate', 100);
            }, this);

        }

    },

    onStateEnd: function (state) {

        switch (state) {
            case animationStates.ANIMATE:
                this.changeState(animationStates.ADDTOCOLLECTION);
                break;
            case animationStates.ADDTOCOLLECTION:
                if (this.amountOfParts === this.totalParts) this.changeState(animationStates.READYFORFUSE);
                else this.changeState(animationStates.LEAVE);
                break;
            case animationStates.FUSE:
                this.changeState(animationStates.LEAVE);
                break;
            case animationStates.LEAVE:
                this.changeState(animationStates.IDLE);
                break;
            case animationStates.READYFORFUSE:
                this.changeState(animationStates.FUSE);
        }
    },

    fuseParts: function () {
        this.partAssetNormalIntensity = 0;


        for (var i = 0; i < this.amountOfParts; i++) {
            var pivotPoint = this.unlockContainer.children[i];
            var unlockEntityModelPivot = pivotPoint.children[0];
            var moveIntoCircleTween = unlockEntityModelPivot
                .tween(unlockEntityModelPivot.getLocalPosition())
                .to(this.unlockContainer.getLocalPosition(), 0.35, pc.BackIn)
                .start();

            if (i === this.amountOfParts - 1) {
                moveIntoCircleTween.on('complete', function () {
                    for (var i = 0; i < this.amountOfParts; i++) {
                        var pivotPoint = this.unlockContainer.children[i];
                        pivotPoint.enabled = false;
                    }
                    this.app.fire('vibrate', 250);
                    this.unlockText.enabled = false;
                    this.screenFlash();

                }, this);
            }
        }

    },

    screenFlash: function () {
        this.flashImage.enabled = true;
        pc.timer.add(0.1, () => {
            this.completedObjectEntity.enabled = true;
            this.completedObjectEntity.model.asset = this.completedAsset;
            this.completedObjectEntity.setLocalPosition(this.unlockContainer.getLocalPosition().x, this.unlockContainer.getLocalPosition().y, this.unlockContainer.getLocalPosition().z);
            this.completedObjectEntity.setLocalEulerAngles(this.completedObjectAngleUpright);
            this.completedObjectEntity.setLocalScale(this.finalFlowerScale, this.finalFlowerScale, this.finalFlowerScale)
            this.unlockContainer.setLocalEulerAngles(this.unlockContainer.getLocalEulerAngles().x, this.unlockContainer.getLocalEulerAngles().y, 0);
        }, this);

        this.flashImage.tween(this.flashImage.element).to({ opacity: 0 }, 2, pc.Linear).start();
        this.highlightDown();
        this.backdrop.enabled = true;
        this.viginette.enabled = true;


    },

});


// BoosterShopManager.js
var BoosterShopManager = pc.createScript('BoosterShopManager');

BoosterShopManager.storeEnum = [
    { PREBOOSTER_1: "PREBOOSTER_1" },
    { PREBOOSTER_2: "PREBOOSTER_2" },
    { PREBOOSTER_3: "PREBOOSTER_3" },
    { BOOSTER_1: "BOOSTER_1" },
    { BOOSTER_2: "BOOSTER_2" },
    { BOOSTER_3: "BOOSTER_3" }
];

BoosterShopManager.attributes.add('stock', {
    type: 'json',
    schema: [{
        name: "inventoryKey",
        type: "string",
        enum: BoosterShopManager.storeEnum
    }, {
        name: "image",
        type: "asset",
        assetType: 'sprite'
    }, {
        name: "price",
        type: "number"
    }, {
        name: "amount",
        type: "number"
    }, {
        name: "title",
        type: "string"
    }, {
        name: "description",
        type: "string"
    }],
    array: true
});

BoosterShopManager.attributes.add('coinReward', { type: "number" });

pc.extend(BoosterShopManager.prototype, {
    initialize: function () {
        BoosterShopManager.instance = this;
    },

    getStock: function () {
        return this.stock;
    },

    purchase: function (item, amount = 1) {
        return new Promise((resolve, reject) => {
            var coins = Inventory.instance.getItem('COINS');

            if (coins >= item.price) {
                this.app.fire('UIManager:showUI', 'loading');
                Xsolla.instance.buyBundleWithVirtualCurrency(Inventory.instance.getXsollaSKU(item.inventoryKey)).then(() => {
                    var success = Inventory.instance.tryPayItem('COINS', item.price, 'boost', item.inventoryKey);
                    // statistics
                    StatisticsManager.instance.incrementStatistic("coins_used", {}, item.price);
                    this._updatePurchaseStatistics(item.inventoryKey);

                    // update
                    this.app.fire('CoinInterface:updateCoins');
                    Inventory.instance.addItem(item.inventoryKey, amount, 'purchase', 'boosterShop');
                    this.app.fire('BoosterShopManager:onItemBought');
                    this.app.fire('Audio:sfx', 'coin_pay.mp3');
                    resolve(true);
                }).finally(() => {
                    this.app.fire('UIManager:hideUI', 'loading');
                });
            } else {
                this.app.fire('UIManager:showUI', 'Shop');
                reject(false);
            }
        });
    },

    changeBoosterPrice: function (inventoryKey, newPrice) {
        var stockItem = this._getStockByinventoryKey(inventoryKey);
        stockItem.price = newPrice;
    },

    watchAd: function () {
        Wrapper.instance.rewardedAd(this.rewardAd, this);
    },

    rewardAd: function (result) {
        if (result.rewardGranted) {
            this.app.fire('Audio:sfx', 'coin_gain_single.mp3');
            StatisticsManager.instance.incrementStatistic("coins_received", {}, this.coinReward);
            Inventory.instance.addItem('COINS', this.coinReward, 'reward', 'rewardedAd');
            this.app.fire('CoinInterface:updateCoins');
        }
    },

    _getStockByinventoryKey: function (inventoryKey) {
        for (var i = 0; i < this.stock.length; i++) {
            if (this.stock[i].inventoryKey === inventoryKey) {
                return this.stock[i];
            }
        }

        return false;
    },

    // function to increase statistics
    _updatePurchaseStatistics: function (inventoryKey) {
        switch (inventoryKey) {
            case boosterEnum.PREBOOSTER_1:
                StatisticsManager.instance.incrementStatistic("pre_booster_bought", { type: 'bee' }, 3);
                break;
            case boosterEnum.PREBOOSTER_2:
                StatisticsManager.instance.incrementStatistic("pre_booster_bought", { type: 'ladybug' }, 3);
                break;
            case boosterEnum.PREBOOSTER_3:
                StatisticsManager.instance.incrementStatistic("pre_booster_bought", { type: 'butterfly' }, 3);
                break;
            case boosterEnum.BOOSTER_1:
                StatisticsManager.instance.incrementStatistic("booster_bought", { type: 'glove' }, 3);
                break;
            case boosterEnum.BOOSTER_2:
                StatisticsManager.instance.incrementStatistic("booster_bought", { type: 'shovel' }, 3);
                break;
            case boosterEnum.BOOSTER_3:
                StatisticsManager.instance.incrementStatistic("booster_bought", { type: 'beehive' }, 3);
                break;
        }
    }

});



// BookNavigationButton.js
var BookNavigationButton = pc.createScript('bookNavigationButton');
var bookButtonTypes = {
    PREVIOUSPAGE: 0,
    NEXTPAGE: 1,
    CHAPTERSELECT: 2,
    LEVELSELECT: 3,
    CLOSE: 4
};

var bookButtonTypeAttribute = [
    {PREVIOUSPAGE: bookButtonTypes.PREVIOUSPAGE},
    {NEXTPAGE: bookButtonTypes.NEXTPAGE},
    {CHAPTERSELECT: bookButtonTypes.CHAPTERSELECT},
    {LEVELSELECT: bookButtonTypes.LEVELSELECT},
    {CLOSE: bookButtonTypes.CLOSE}
];

BookNavigationButton.attributes.add('type', { type: 'number', enum: bookButtonTypeAttribute});
BookNavigationButton.attributes.add('worldID',  {type: 'number'});
BookNavigationButton.attributes.add('pageID',  {type: 'number'});

pc.extend(BookNavigationButton.prototype, {
    initialize: function() {
        this.entity.script.elementInput.on(inputEvents.CLICK, this._onClick, this);
        this.app.on('BookUI:switchPage', this._onPageSwitch, this);
    },

    _onPageSwitch: function(pageIndex, totalPages, pageData) {
        switch(this.type) {
            case bookButtonTypes.PREVIOUSPAGE:
                this.entity.enabled = pageIndex > 1;
                break;
            case bookButtonTypes.NEXTPAGE:
                var pageScript = pageData.entity.script.get(pageData.pageInfo.pageScript);
                var containsCurrentLevel = false;
                if (pageScript) 
                    containsCurrentLevel = pageScript.containsCurrentLevel;

                this.entity.enabled = pageIndex < totalPages - 1 && !containsCurrentLevel;

                if(pageData.pageInfo.chapterID) {
                    var worldData = WorldManager.instance.getWorldData(pageData.pageInfo.chapterID);
                    if(worldData && pageData.pageInfo.pageID === worldData.nParts - 1)
                        this.entity.enabled = false;     
                }

                break;
            case bookButtonTypes.CHAPTERSELECT:
                this.entity.enabled = pageData.pageInfo.pageScript !== 'chapterSelectPage';
                break;
            case bookButtonTypes.LEVELSELECT:
                this.entity.enabled = pageData.pageInfo.pageScript === 'levelSelectPage' || (pageData.pageInfo.pageScript === 'chapterSelectPage' && this.worldID >= 0);
                break;
            case bookButtonTypes.CLOSE:
                // nothing
                break;
        }
    },

    _onClick: function() {
        this.app.fire('Audio:sfx', 'page_flip.mp3');

        switch(this.type) {
            case bookButtonTypes.PREVIOUSPAGE:
                this.app.fire('BookUI:previousPage');
                break;
            case bookButtonTypes.NEXTPAGE:
                this.app.fire('BookUI:nextPage');
                break;
            case bookButtonTypes.CHAPTERSELECT:
                this.app.fire('BookUI:chapterSelect');
                break;
            case bookButtonTypes.LEVELSELECT:
                this.app.fire('BookUI:levelSelect', this.worldID, this.pageID);
                break;
            case bookButtonTypes.CLOSE: 
                this.app.fire('UIManager:hideAll');
                this.app.fire('UIManager:showUI', 'Menu');
                break;
        }
    }
});

// ChapterSelectPage.js
var ChapterSelectPage = pc.createScript('chapterSelectPage');

ChapterSelectPage.attributes.add('chapterButtonTemplate', { type: 'asset', assetType: 'template' });
ChapterSelectPage.attributes.add('buttonGroup', { type: 'entity' });
ChapterSelectPage.attributes.add('buttonSprites', { type: 'asset', assetType: 'sprite', array: true });
ChapterSelectPage.attributes.add('finalImage', { type: 'entity' });

pc.extend(ChapterSelectPage.prototype, {
    initialize: function () {
        this.createButtons();
    },

    _onPageOpen: function (pageInfo) {
        this.setCurrentChapter(this.findCurrentChapter());
        this.finalImage.enabled = LevelDataManager.instance.getRealCurrentLevel() > WorldManager.instance.maxLevel;
    },

    _onPageClose: function (pageInfo) {
    },

    createButtons: function () {
        this.chapterButtons = [];
        var worldList = WorldManager.instance.getWorldList();
        var worldKeys = Object.keys(worldList);
        for (var i = 0; i < worldKeys.length; i += 1) {
            var button = this.chapterButtonTemplate.resource.instantiate();
            this.buttonGroup.addChild(button);
            var angle = (-360 / worldKeys.length) * i;
            button.setLocalEulerAngles(0, 0, angle);
            button.script.chapterSelectButton.setCounterRotation(-angle);
            button.script.chapterSelectButton.setButtonInformation(worldKeys[i], this.buttonSprites[i]);
            this.chapterButtons.push(button);
        }
    },

    findCurrentChapter: function () {
        var levelCounter = 0;
        var maxWorldKey = 0;
        var currentLevel = LevelDataManager.instance.getCurrentLevel();

        var worldList = WorldManager.instance.getWorldList();
        for (var worldKey in worldList) {
            var minLevel = levelCounter + 1;
            var maxLevel = minLevel + worldList[worldKey].nLevels - 1;
            maxWorldKey = worldKey;
            if (currentLevel >= minLevel && currentLevel <= maxLevel) {
                return worldKey;
            }
            levelCounter = maxLevel;
        }

        return maxWorldKey;
    },

    setCurrentChapter: function (currentChapterID) {
        var isUnlocked = true;
        for (var i = 0; i < this.chapterButtons.length; i += 1) {
            var button = this.chapterButtons[i].script.chapterSelectButton;

            if (WorldManager.instance.getWorldData(button.chapterID).isUnlocked === false) {
                button.setState(ChapterSelectButton.buttonStates.UNAVAILABLE);
            } else if (button.chapterID === currentChapterID) {
                button.setState(ChapterSelectButton.buttonStates.CURRENT);
                isUnlocked = false;
            } else {
                button.setState(isUnlocked ? ChapterSelectButton.buttonStates.UNLOCKED : ChapterSelectButton.buttonStates.LOCKED);
            }

        }
    },
});

// ChapterIntroPage.js
var ChapterIntroPage = pc.createScript('chapterIntroPage');

ChapterIntroPage.attributes.add('chapterNumberText', { type: 'entity' });
ChapterIntroPage.attributes.add('chapterTitleText', { type: 'entity' });
ChapterIntroPage.attributes.add('chapterStarsText', { type: 'entity' });
ChapterIntroPage.attributes.add('chapterPartsText', { type: 'entity' });
ChapterIntroPage.attributes.add('chapterPartsImage', { type: 'entity' });

ChapterIntroPage.attributes.add('pageButtonTemplate', { type: 'asset', assetType: 'template' });
ChapterIntroPage.attributes.add('pageButtonGroup', { type: 'entity' });

ChapterIntroPage.attributes.add('petalImage', { type: 'entity' });

pc.extend(ChapterIntroPage.prototype, {
    initialize: function() {
        this.createPageButtons();
        this.app.on('ViewportManager:onResize', this._onResize, this);
        this._onResize(ViewportManager.instance.getOrientation(), ViewportManager.instance.width, ViewportManager.instance.height, ViewportManager.instance.getDevice());

        this.currentTime = 0;
    },

    _onResize: function(orientation, width, height, device) {
        if (orientation === orientationEnum.PORTRAIT) {
            this.pageButtonGroup.element.width = 580;
        } else {
            this.pageButtonGroup.element.width = 350;
        }
        if (!this.nParts) return;
        this.pageButtonGroup.element.height = this.nParts * 120;
    },

    _onPageOpen: function(pageInfo) {
        var worldInfo = WorldManager.instance.getWorldData(pageInfo.chapterID);
        this.setPageInformation(pageInfo.chapterID, worldInfo);
        this.setCurrentPage(this.findCurrentPage(this.chapterID));
        this._onResize(ViewportManager.instance.getOrientation(), ViewportManager.instance.width, ViewportManager.instance.height, ViewportManager.instance.getDevice());

        if(WorldManager.instance.isNewPageUnlocked()) {
            this.app.fire("ComicInterface:queueComic");
            this.unlockPage();
            WorldManager.instance.emptyPageUnlock();
        }
    },

    _onPageClose: function(pageInfo) {

    },

    setPageInformation: function(chapterID, chapterInfo) {
        this.chapterID = chapterID;

        LocalizationManager.instance.setText(this.chapterNumberText, "CHAPTER_NUMBER", chapterID);

        LocalizationManager.instance.setText(this.chapterTitleText, chapterInfo.name);

        var starData = LevelDataManager.instance.getTotalStarData(chapterID);
        this.chapterStarsText.element.text = starData + '/' + (chapterInfo.nLevels * 3);

        var partsData = LevelDataManager.instance.getPartsData(chapterID);
        // this.chapterPartsText.element.text = partsData + '/' + chapterInfo.nParts;
        this.setPartsInfo(partsData, chapterInfo.nParts);

        this.nParts = chapterInfo.nParts;

        //adjust the scroll view based on the amount of pages
        this.pageButtonGroup.element.height = this.nParts * 150;

        for (var i = 0; i < this.pageButtons.length; i += 1) {
            if (i >= chapterInfo.nParts) {
                this.pageButtons[i].enabled = false;
                continue;
            }
            this.pageButtons[i].enabled = true;
            this.pageButtons[i].script.chapterPageButton.setButtonInformation(chapterID, i);
        }

    },

    setCurrentPage: function(currentPage) {
        var isUnlocked = currentPage > 0;
        for (var i = 0; i < this.pageButtons.length; i += 1) {
            var button = this.pageButtons[i].script.chapterPageButton;

            if (button.pageID === currentPage) {
                button.setState(ChapterPageButton.buttonStates.CURRENT);
                isUnlocked = false;
            } else {
                button.setState(isUnlocked ? ChapterPageButton.buttonStates.UNLOCKED : ChapterPageButton.buttonStates.LOCKED);
            }
        }
    },

    findCurrentPage: function(chapterID) {
        var levelCounter = 0;
        var foundCurrentChapter = false;
        var isCurrentChapter = false;

        var currentLevel = LevelDataManager.instance.getCurrentLevel();

        var worldList = WorldManager.instance.getWorldList();
        for (var worldKey in worldList) {
            var minLevel = levelCounter + 1;
            var maxLevel = minLevel + worldList[worldKey].nLevels - 1;
            if (currentLevel >= minLevel && currentLevel <= maxLevel) {
                foundCurrentChapter = true;
                isCurrentChapter = true;
            } else {
                isCurrentChapter = false;
            }
            levelCounter = maxLevel;

            if (worldKey === chapterID) {
                if (!foundCurrentChapter) {
                    // return something bigger so all are unlocked
                    return worldList[worldKey].nParts + 1;
                } else if (isCurrentChapter) {
                    // find current page
                    for (var i = 0; i < worldList[worldKey].nParts; i += 1) {
                        var pageMinLevel = minLevel + i * (worldList[worldKey].nLevels / worldList[worldKey].nParts);
                        var pageMaxLevel = minLevel + ((i + 1) * (worldList[worldKey].nLevels / worldList[worldKey].nParts)) - 1
                        if (currentLevel >= pageMinLevel && currentLevel <= pageMaxLevel) {
                            return i;
                        }
                    }
                } else if (!isCurrentChapter) {
                    // return -1 so none are unlocked
                    return -1;
                }
            }
        }
    },

    unlockPage: function() {  
        var partData = LevelDataManager.instance.getPartsData(LevelManager.instance.getCurrentChapterNumber());
        var nParts = WorldManager.instance.getWorldData(this.chapterID).nParts;
        var currentPage = this.findCurrentPage(this.chapterID);
        var button = null;

        if(partData === nParts) {
            // flower unlock
            
            this.setPartsInfo((partData - 1), nParts);

            this.petalImage.enabled = true;
            this.petalImage.element.spriteAsset = WorldManager.instance.unlockableFlowers[LevelManager.instance.getCurrentChapterNumber() - 1].partSprite; // get correct sprite image
            for (var j = 0; j < this.pageButtons.length; j += 1) {
                if(this.pageButtons[j].script.chapterPageButton.pageID === undefined) {
                    continue;
                }
                button = this.pageButtons[j].script.chapterPageButton;
            }
            this.app.fire('UitoUimanager:showAnimation', button.entity, this.showFlowerAnimation.bind(this));

        } else {
            // part unlock
            for (var i = 0; i < this.pageButtons.length; i += 1) {
                button = this.pageButtons[i].script.chapterPageButton;
                this.chapterPartsText.element.text = (partData - 1) + "/" + nParts;

                if (button.pageID === currentPage) {
                    // variables that are used in the tween complete
                    this.currentButton = button;
                    var previousButton = this.pageButtons[i - 1];

                    // set the correct things before the petal animation triggers
                    button.setState(ChapterPageButton.buttonStates.LOCKED);
                    this.petalImage.enabled = true;

                    // get the previous part button
                    this.petalImage.element.spriteAsset = WorldManager.instance.unlockableFlowers[LevelManager.instance.getCurrentChapterNumber() - 1].partSprite; // get correct sprite image

                    this.app.fire('UitoUimanager:showAnimation', previousButton.script.chapterPageButton.entity, this .unlockPageButton.bind(this));
                }
            }
        }
    },

    unlockPageButton: function() {
        var partData = LevelDataManager.instance.getPartsData(LevelManager.instance.getCurrentChapterNumber());
        var nParts = WorldManager.instance.getWorldData(this.chapterID).nParts;

        // animate the flower petal and once it is done, trigger the button animation
        this.currentButton.unlockItem();
        this.setPartsInfo(partData, nParts);
    },

    showFlowerAnimation: function() {
        var partData = LevelDataManager.instance.getPartsData(LevelManager.instance.getCurrentChapterNumber());
        var nParts = WorldManager.instance.getWorldData(this.chapterID).nParts;
        this.setPartsInfo(partData, nParts);
        CollectibleUnlockInterface.instance.showQueuedUnlock();
    },

    setPartsInfo: function(partData, nParts) {
        var completedCollectible = partData >= nParts;
        this.chapterPartsText.element.text = partData + "/" + nParts;
        this.chapterPartsImage.element.opacity = completedCollectible ? 1 : 0.5;
        this.chapterPartsImage.element.color = completedCollectible ? pc.Color.WHITE : pc.Color.BLACK;
        this.chapterPartsText.enabled = !completedCollectible;
    },

    createPageButtons: function() {
        var longestChapterPages = 0;
        var worldList = WorldManager.instance.getWorldList();
        for (var worldKey in worldList) {
            if (worldList[worldKey].nParts > longestChapterPages) longestChapterPages = worldList[worldKey].nParts;
        }

        this.pageButtons = [];
        for (var i = 0; i < longestChapterPages; i += 1) {
            var button = this.pageButtonTemplate.resource.instantiate();
            this.pageButtonGroup.addChild(button);
            this.pageButtons.push(button);
        }
    }
});

// switchPageOrChapterButton.js
var SwitchPageOrChapterButton = pc.createScript('switchPageOrChapterButton');

SwitchPageOrChapterButton.attributes.add('isNext', { type: 'boolean' });
SwitchPageOrChapterButton.attributes.add('chapterButton', { type: 'entity' });
SwitchPageOrChapterButton.attributes.add('pageButton', { type: 'entity' });
SwitchPageOrChapterButton.attributes.add('lockEntity', { type: 'entity' });
SwitchPageOrChapterButton.attributes.add('disableOnInactiveEntities', { type: 'entity', array: true });
SwitchPageOrChapterButton.attributes.add('comingSoonTextEntity', { type: 'entity' });

SwitchPageOrChapterButton.attributes.add('chapterNumberTextEntity', { type: 'entity' });
SwitchPageOrChapterButton.attributes.add('chapterImageEntity', { type: 'entity' });

pc.extend(SwitchPageOrChapterButton.prototype, {
    initialize: function () {
        if (this.chapterButton.script && this.chapterButton.script.elementInput) {
            this.chapterButton.script.elementInput.on(inputEvents.CLICK, this._onClick, this);
        }

        if (this.pageButton.script && this.pageButton.script.elementInput) {
            this.pageButton.script.elementInput.on(inputEvents.CLICK, this._onClick, this);
        }

        this.goToComic = true;

        this.isNewUnlock = false;
    },

    onPageSwitch: function (pageInfo, pageScript) {
        if (!pageInfo.chapterID) {
            this.setButton(null);
            return;
        }
        this.chapterID = pageInfo.chapterID;
        this.pageID = pageInfo.pageID;

        var worldList = WorldManager.instance.getWorldList();

        var isFirstPageInChapter = pageInfo.pageID === 0;
        var isLastPageInChapter = pageInfo.pageID === worldList[pageInfo.chapterID].nParts - 1;
        var isChapterButton = (isFirstPageInChapter && !this.isNext) || (isLastPageInChapter && this.isNext);

        if (this.isNext) {
            // check if page is the last page in the book
            var isLastChapter = worldList[pageInfo.chapterID].index === worldList.length - 1;
            if (isLastChapter && isLastPageInChapter) {
                this.setButton(null);
                return;
            }

            // check if this chapter is the last unlocked chapter

            var worldExists = WorldManager.instance.worldExists(parseInt(pageInfo.chapterID) + 1);

            var nextWorldData = WorldManager.instance.getWorldData(parseInt(pageInfo.chapterID) + 1);

            if (!worldExists && isLastPageInChapter) {
                this.entity.enabled = false;
                return;
            } else if (nextWorldData && nextWorldData.isUnlocked === false && isLastPageInChapter) {

                this.setButtonsLocked(true, true);
            } else {
                // check if page is the last unlocked page
                var containsCurrentLevel = pageScript.containsCurrentLevel;
                this.setButtonsLocked(containsCurrentLevel, false);
            }
            this.setButton(isChapterButton ? this.chapterButton : this.pageButton);

        } else {
            // check if the page is the first chapter and first page
            var isFirstChapter = worldList[pageInfo.chapterID].index === 0;
            if (isFirstChapter && isFirstPageInChapter) {
                this.setButton(null);
                return;
            }
            this.setButtonsLocked(false, false);

            this.setButton(isChapterButton ? this.chapterButton : this.pageButton);
        }

        if (this.chapterButton.enabled) {
            var nextPreviousChapterID = this.isNext ? parseInt(pageInfo.chapterID) + 1 : parseInt(pageInfo.chapterID) - 1;

            this.chapterNumberTextEntity.element.text = nextPreviousChapterID;

            var backgroundSprite = WorldManager.instance.getWorldBackgroundImage(nextPreviousChapterID);
            if (backgroundSprite !== undefined) this.chapterImageEntity.element.spriteAsset = backgroundSprite.id;
        }
    },

    _onClick: function () {
        var newWorldIndex = -1;

        var worldList = WorldManager.instance.getWorldList();

        var onLoaded = function () {
            this.app.fire('UIManager:hideUI', 'loading');

            if (this.isNext && this.isNewUnlock === true) {
                var worldList = WorldManager.instance.getWorldList();

                var isLastPageInChapter = this.pageID === worldList[this.chapterID].nParts - 1;
                var nextWorldID = WorldManager.instance.getWorldIDByIndex(WorldManager.instance.getWorldIndexByID(this.chapterID) + 1);
                var chapterID = this.chapterID;
                var pageID = this.pageID;
                PageFlipAnimation.instance.once('complete', () => {
                    this.app.fire('ComicInterface:showUnlockedComic', isLastPageInChapter ? nextWorldID : chapterID, isLastPageInChapter ? 0 : pageID + 1);
                });
                this.isNewUnlock = false;
            }

            if (this.isNext) {
                this.app.fire('BookUI:nextPage');
            } else {
                this.app.fire('BookUI:previousPage');
            }
        };

        if (this.isNext && this.pageID === worldList[this.chapterID].nParts - 1) {
            this.app.fire('UIManager:showUI', 'loading');

            // LoadingScreen.instance.setType(LoadingScreen.TYPES.ASSETS).once('fadeInComplete', () => {

            WorldManager.instance.setWorldIndex(WorldManager.instance.getWorldIndex() + 1);

            AssetManager.instance.setBook(WorldManager.instance.getWorldIndex(), onLoaded, this, false, false);
            // });

            // LoadingScreen.instance.once('done', onLoaded, this);

        } else if (!this.isNext && this.pageID === 0) {
            this.app.fire('UIManager:showUI', 'loading');

            // LoadingScreen.instance.setType(LoadingScreen.TYPES.ASSETS).once('fadeInComplete', () => {
            WorldManager.instance.setWorldIndex(WorldManager.instance.getWorldIndex() - 1);

            AssetManager.instance.setBook(WorldManager.instance.getWorldIndex(), onLoaded, this, false, false);
            // });

            // LoadingScreen.instance.once('done', onLoaded, this);
        } else {
            onLoaded.call(this);
        }
    },

    removeLoadingScreen: function() {
        this.app.fire('UIManager:hideUI', 'loading');
    },

    loadWorldAssets: function() {
        AssetManager.instance.loadBookAssets(WorldManager.instance.getWorldIndex(), function() {

            this.app.fire('UIManager:showUI', 'Book', 'nextLevel');
            AssetManager.instance.loadWorldLevels();
        }, this);
    },

    setButton: function (button) {
        this.entity.enabled = true;

        var chapterButtonVisible = button === this.chapterButton;
        var pageButtonVisible = button === this.pageButton;

        this.chapterButton.enabled = chapterButtonVisible;
        this.pageButton.enabled = pageButtonVisible;

        // set the group as well so the scroll view doesnt calculate the height
        this.entity.enabled = this.chapterButton.enabled || this.pageButton.enabled;
    },

    setButtonsLocked: function (isLocked, isComingSoon) {
        this.isLocked = isLocked;
        this.isComingSoon = isComingSoon;

        this.chapterButton.script.elementInput.setActive(!isLocked);
        this.pageButton.script.elementInput.setActive(!isLocked);

        for (var i = 0; i < this.disableOnInactiveEntities.length; i += 1) {
            this.disableOnInactiveEntities[i].enabled = !isLocked;
        }

        this.lockEntity.enabled = isLocked && !isComingSoon;
        this.comingSoonTextEntity.enabled = isLocked && isComingSoon;
    },

    unlockAnimation: function () {
        if (this.isLocked && this.isComingSoon) {
            return;
        }

        UnlockLevelAnimation.instance.startAnim(this.entity, this.lockEntity, function () {
            this.setButtonsLocked(false, false);
            this.isNewUnlock = true;
        }.bind(this));

        this.setButtonsLocked(true, false);
    },
});

// LevelSelectPage.js
var LevelSelectPage = pc.createScript('levelSelectPage');

LevelSelectPage.attributes.add('chapterNumberText', { type: 'entity' });
LevelSelectPage.attributes.add('chapterImageEntity', { type: 'entity' });
LevelSelectPage.attributes.add('storyImage', { type: 'entity' });
LevelSelectPage.attributes.add('scrollviewBackgroundEntity', { type: 'entity' });
LevelSelectPage.attributes.add('backgroundImageEntity', { type: 'entity' });

LevelSelectPage.attributes.add('levelTemplate', { type: 'asset', assetType: 'template' });
LevelSelectPage.attributes.add('levelGroup', { type: 'entity' });
LevelSelectPage.attributes.add('scrollBar', { type: 'entity' });
LevelSelectPage.attributes.add('previousPageButtonGroup', { type: 'entity' });
LevelSelectPage.attributes.add('nextPageButtonGroup', { type: 'entity' });
LevelSelectPage.attributes.add('viewport', { type: 'entity' });
LevelSelectPage.attributes.add('nextChapterButton', {type: 'entity'});

LevelSelectPage.MARGIN = 50;

pc.extend(LevelSelectPage.prototype, {
    initialize: function() {
        this.createLevelList();

        LevelSelectPage.instance = this;

        this.app.on('LevelSelectPage:scrollTo', this.scrollToValue, this);
        this.app.on('ViewportManager:onResize', this._onResize, this);
        this._onResize(ViewportManager.instance.getOrientation(), ViewportManager.instance.width, ViewportManager.instance.height, ViewportManager.instance.getDevice());

        this.app.mouse.on(pc.EVENT_MOUSEWHEEL, this.onMouseWheel, this);
    },


    _onResize: function(orientation, width, height, device) {
        this.levelGroup.element.height = this.getScrollViewHeight();
    },

    getScrollViewHeight: function() {
        var totalHeight = 0;

        for (var i = 0 ; i < this.levelGroup.children.length; i +=1) {
            totalHeight += this.levelGroup.children[i].element.height;
            totalHeight += this.levelGroup.layoutgroup.spacing.y;
        }

        totalHeight += this.levelGroup.layoutgroup.padding.w + this.levelGroup.layoutgroup.padding.y;
        return totalHeight;
    },

    _onPageOpen: function(pageInfo) {
        // TODO check if the world index should be set here
        WorldManager.instance.setWorldIndex(pageInfo.chapterID);

        var worldInfo = WorldManager.instance.getWorldData(pageInfo.chapterID);
        
        this.setPageInformation(pageInfo.chapterID, pageInfo.pageID, worldInfo);

        this.previousPageButtonGroup.script.switchPageOrChapterButton.onPageSwitch(pageInfo, this);
        this.nextPageButtonGroup.script.switchPageOrChapterButton.onPageSwitch(pageInfo, this);
        this._onResize(ViewportManager.instance.getOrientation(), ViewportManager.instance.width, ViewportManager.instance.height, ViewportManager.instance.getDevice());
                
        // this.backgroundImageEntity.script.blurShader.uDiffuseMap = WorldManager.instance.getWorldBackgroundImage(pageInfo.chapterID);
        pc.timer.add(0.1, () => {
            // timed out because pc takes some time to correctly place the buttons in the layoutgroup
            this.fire('onPageLoadDone');
        }, this);
    },

    _onPageClose: function(pageInfo) {

    },
    
    setWorldBackground: function(chapterID = WorldManager.instance.getWorldIndex()) {
        this.backgroundImageEntity.element.spriteAsset = WorldManager.instance.getBlurredWorldBackgroundImage(chapterID).id;
    },

    setLeftPage: function(chapterID, pageID, worldInfo) {
        LocalizationManager.instance.setText(this.chapterNumberText, worldInfo.name);
        this.chapterImageEntity.element.spriteAsset = WorldManager.instance.getWorldBackgroundImage(chapterID).id;

        var pageComic = worldInfo.comics[pageID];

        if (pageComic) {
            // if (!pageComic.resource) {
            //     LazyLoader.instance.lazyLoad(pageComic, this.setPageInformation.bind(this, chapterID, pageID, worldInfo), this);
            //     return;
            // }
            this.storyImage.element.spriteAsset = pageComic.id;
        }

        var starData = LevelDataManager.instance.getTotalStarData(chapterID);
        var partsData = LevelDataManager.instance.getPartsData(chapterID);  
        this.app.fire('ChapterInformationBar:updateStats', starData, (worldInfo.nLevels * 3), partsData, worldInfo.nParts, chapterID);
    },
    
    setPageInformation: function(chapterID, pageID, worldInfo) {
        this.setLeftPage(chapterID, pageID, worldInfo);
        this.setRightPage(chapterID, pageID, worldInfo);
        
        this.setWorldBackground(chapterID);
    },
    
    setRightPage: function(chapterID, pageID, worldInfo) {
        this.previousPageButtonGroup.script.switchPageOrChapterButton.onPageSwitch({ chapterID: chapterID, pageID: pageID }, this);
        this.nextPageButtonGroup.script.switchPageOrChapterButton.onPageSwitch({ chapterID: chapterID, pageID: pageID }, this);
        
        this.scrollviewBackgroundEntity.element.spriteAsset = WorldManager.instance.getWorldBackgroundImage(chapterID).id;
        
        this.containsCurrentLevel = false;

        for (var i = 0; i < this.levelButtons.length; i += 1) {
            if (i > (worldInfo.nLevels / worldInfo.nParts)) {
                this.levelButtons[i].enabled = false;
                continue;
            }
            
            this.levelButtons[i].enabled = true;
            var levelID = this.getLevelID(chapterID, pageID, i);
            this.levelButtons[i].script.levelButton.setButtonInformation(chapterID, levelID);

            if (levelID < LevelDataManager.instance.getCurrentLevel()) {
                this.levelButtons[i].script.levelButton.setState(LevelButton.buttonStates.UNLOCKED);
            } else if (levelID === LevelDataManager.instance.getCurrentLevel()){
                this.levelButtons[i].script.levelButton.setState(LevelButton.buttonStates.CURRENT);
                this.containsCurrentLevel = true;
            } else {
                this.levelButtons[i].script.levelButton.setState(LevelButton.buttonStates.LOCKED);
            }   
        }

//         var pageComic = worldInfo.comics[pageID];
        
//         if (pageComic) {
//             if (!pageComic.resource) {
//                 LazyLoader.instance.lazyLoad(pageComic, this.setPageInformation.bind(this, chapterID, pageID, worldInfo), this);
//                 return;
//             }
            
//             this.storyImage.element.sprite = pageComic.resource;
//         }

//         var starData = LevelDataManager.instance.getTotalStarData(chapterID);
//         var partsData = LevelDataManager.instance.getPartsData(chapterID);   
//         this.app.fire('ChapterInformationBar:updateStats', starData, (worldInfo.nLevels * 3), partsData, worldInfo.nParts, chapterID);

    },

    createLevelList: function() {
        this.previousPageButtonGroup.reparent(this.levelGroup);
        this.previousPageButtonGroup.enabled = true; // temp

        var longestPageLevels = 0;
        var worldList = WorldManager.instance.getWorldList();
        for (var worldKey in worldList) {
            var nLevels = worldList[worldKey].nLevels / worldList[worldKey].nParts;
            if (nLevels > longestPageLevels) longestPageLevels = nLevels;
        }

        this.levelButtons = [];
        for (var i = 0; i < longestPageLevels; i += 1) {
            var button = this.levelTemplate.resource.instantiate();
            this.levelGroup.addChild(button);
            this.levelButtons.push(button);
        }

        this.nextPageButtonGroup.reparent(this.levelGroup);
        this.nextPageButtonGroup.enabled = true; // temp
    },

    getLevelID: function(chapterID, pageID, levelIndex) {
        var pageCounter = 0;
        var worldList = WorldManager.instance.getWorldList();
        for (var worldKey in worldList) {
            if (worldKey !== chapterID) {
                pageCounter += worldList[worldKey].nLevels;
            } else {
                for (var i = 0; i < worldList[worldKey].nParts; i += 1) {
                    if (i !== pageID) {
                        pageCounter += worldList[worldKey].nLevels / worldList[worldKey].nParts;
                    } else {
                        return pageCounter + levelIndex + 1;
                    }
                }
            }
        }
    },

    scrollToLevel: function(level) {
        var currentWorld = WorldManager.instance.getWorldByLevel(level);
        var worldList = WorldManager.instance.getWorldList();

        var levelInPage = WorldManager.instance.getLevelNumberinPage(level); 

        var levelsPerPage = worldList[currentWorld].nLevels / worldList[currentWorld].nParts;
        var levelHeight = this.levelGroup.children[1].element.height + this.levelGroup.layoutgroup.spacing.y;

        var firstButtonHeight = 0;

        if (this.previousPageButtonGroup.enabled) {
            firstButtonHeight = this.previousPageButtonGroup.element.height + this.levelGroup.layoutgroup.spacing.y;
        }

        var viewportHeight = this.viewport.element.height;

        var position = this.levelGroup.layoutgroup.padding.w + firstButtonHeight + levelInPage * levelHeight;
        var centerPosition = viewportHeight / 2 + levelHeight / 2;

        var ratio = pc.math.clamp((position - centerPosition) / (this.getScrollViewHeight() - viewportHeight), 0, 1);

        this.scrollBar.scrollbar.value = ratio;
    },

    scrollToValue: function(value) {
        this.scrollBar.scrollbar.value = value;
    },

    getScrollValue: function() {
        return this.scrollBar.scrollbar.value;
    },
    
    unlockLatestLevel: function(openPopup) {
        var button = this._getButton(LevelDataManager.instance.getCurrentLevel());
        if(openPopup) {
            button.script.levelButton.triggerPopup();
        }
        button.script.levelButton.unlockAnimation();
        this.containsCurrentLevel = true;
    },

    openLevel: function() {
        var button = this._getButton(LevelDataManager.instance.getCurrentLevel());
        button.script.levelButton.click();
    },

    _isLevelInPage: function(level) {
        var button = this._getButton(level);
        return button ? true : false;
    },

    _getButton: function(levelIndex) {
        for(var i = 0; i < this.levelButtons.length; i++) {
            if(this.levelButtons[i].script.levelButton.levelID === levelIndex) {
                return this.levelButtons[i];
            }
        } 
        return null;
    },

    onMouseWheel: function(event) {
        if (!UIManager.instance.isTopOfStack('Screen', 'Book')) return;
        var sensitivity = 0.05;
        this.scrollBar.scrollbar.value += event.wheelDelta * sensitivity;
    },

    unlockNextPageButton: function () {

        var nextChapterButtonScript = this.nextChapterButton.script.switchPageOrChapterButton;
        nextChapterButtonScript.unlockAnimation();
    },

    getPageInfo: function() {
        return {
            scroll: this.scrollBar.scrollbar.value
        }
    },
});

// ChapterSelectButton.js
var ChapterSelectButton = pc.createScript('chapterSelectButton');

ChapterSelectButton.buttonStates = Object.freeze({
    LOCKED: 0,
    UNLOCKED: 1,
    CURRENT: 2,
    UNAVAILABLE: 3,
});

ChapterSelectButton.attributes.add('buttonEntity', { type: 'entity' });
ChapterSelectButton.attributes.add('chapterIDText', { type: 'entity' });
ChapterSelectButton.attributes.add('counterRotateEntities', { type: 'entity', array: true });
ChapterSelectButton.attributes.add('lockedImage', { type: 'entity' });
ChapterSelectButton.attributes.add('commingSoonText', { type: 'entity' });
ChapterSelectButton.attributes.add('worldSelectButton', { type: 'entity' });
ChapterSelectButton.attributes.add('worldImageEntity', { type: 'entity' });


pc.extend(ChapterSelectButton.prototype, {
    setButtonInformation: function(chapterID, worldImage) {
        this.chapterID = chapterID;
        this.chapterIDText.element.text = chapterID;

        this.buttonEntity.script.elementInput.on(inputEvents.CLICK, this._onClick, this);
        this.worldImageEntity.element.spriteAsset = worldImage.id;
    },

    setCounterRotation: function(angle) {
        for (var i = 0; i < this.counterRotateEntities.length; i += 1) {
            this.counterRotateEntities[i].setLocalEulerAngles(0, 0, angle);
        }
    },

    setState: function(state) {
        if(this.currentState === ChapterSelectButton.buttonStates.UNAVAILABLE) {
            return;
        }
        this.currentState = state;

        this.worldSelectButton.enabled = this.currentState !== ChapterSelectButton.buttonStates.UNAVAILABLE;
        this.lockedImage.enabled = this.currentState === ChapterSelectButton.buttonStates.LOCKED;
        this.commingSoonText.enabled = this.currentState === ChapterSelectButton.buttonStates.UNAVAILABLE;
        // todo set visuals
    },

    _onClick: function() {
        if (this.currentState === ChapterSelectButton.buttonStates.LOCKED || this.currentState === ChapterSelectButton.buttonStates.UNAVAILABLE) return;

        if (WorldManager.instance.getWorldIndex() === parseInt(this.chapterID)) {
            this.onAssetLoaded(true);
        } else {
            WorldManager.instance.setWorldIndex(this.chapterID);

            this.app.fire('UIManager:showUI', 'LoadingScreen');

            LoadingScreen.instance.setType(LoadingScreen.TYPES.ASSETS).once('fadeInComplete', () => {
                AssetManager.instance.loadBookAssets(this.chapterID, this.onAssetLoaded, this);
            });
        }
    },

    onAssetLoaded: function(ignoreHiding) {
        if (!ignoreHiding) {
            this.app.fire('UIManager:hideUI', 'LoadingScreen');
        }

        LevelLoader.instance.lazyLoadLevels();

        this.app.fire('BookUI:chapterIntro', this.chapterID);
        this.app.fire('Audio:sfx', 'page_flip.mp3');
    },
});

// ChapterPageButton.js
var ChapterPageButton = pc.createScript('chapterPageButton');

ChapterPageButton.buttonStates = Object.freeze({
    LOCKED: 0,
    UNLOCKED: 1,
    CURRENT: 2
});

ChapterPageButton.attributes.add('pageIDText', { type: 'entity' });

ChapterPageButton.attributes.add('buttonSpriteEntity', { type: 'entity' });
ChapterPageButton.attributes.add('lockEntity', { type: 'entity' });
ChapterPageButton.attributes.add('unlockedBgImage', { type: 'asset', assetType: 'sprite' });
ChapterPageButton.attributes.add('lockedBgImage', { type: 'asset', assetType: 'sprite' });

ChapterPageButton.attributes.add('buttonUnlockScale', { type: 'vec3', default: [0.1, 0.1, 0.1] });
ChapterPageButton.attributes.add('buttonUnlockAnimationTime', { type: 'number', default: 1 });
ChapterPageButton.attributes.add('buttonUnlockAnimationDelay', { type: 'number', default: 1 });

pc.extend(ChapterPageButton.prototype, {
    setButtonInformation: function (chapterID, pageID) {
        this.chapterID = chapterID;
        this.pageID = pageID;

        LocalizationManager.instance.setText(this.pageIDText, "PAGE_NUMBER", (pageID + 1));

        // todo set star / flower stamps

        this.entity.script.elementInput.on(inputEvents.CLICK, this._onClick, this);
        this.entity.script.dynamicElementSize._onResize(ViewportManager.instance.getOrientation(), ViewportManager.instance.width, ViewportManager.instance.height, ViewportManager.instance.getDevice());

    },

    unlockItem: function () {
        var button = this;
        var executeTime = 0;
        const tween = this.entity
            .tween(this.entity.getLocalScale())
            .to(this.buttonUnlockScale, (this.buttonUnlockAnimationTime / 2), pc.BackOut)
            .delay(this.buttonUnlockAnimationDelay).yoyo(true)
            .repeat(2)
            .start();

        tween.on('update', function (dt) {
            executeTime += dt;
            if (executeTime > (button.buttonUnlockAnimationTime / 2) && button.buttonSpriteEntity.element.sprite !== button.unlockedBgImage.resource) {
                button.buttonSpriteEntity.element.spriteAsset = button.unlockedBgImage.id;
                button.pageIDText.enabled = true;
                button.lockEntity.enabled = false;
            }
        });

        tween.on('complete', function () {
            button.currentState = ChapterPageButton.buttonStates.CURRENT;
            button._pulse();
        });
    },

    setState: function (state) {
        if (this.pulseTween) {
            this._cancelPulse();
        }

        this.currentState = state;

        this.pageIDText.enabled = this.currentState !== ChapterPageButton.buttonStates.LOCKED;
        this.lockEntity.enabled = this.currentState === ChapterPageButton.buttonStates.LOCKED;
        this.buttonSpriteEntity.element.spriteAsset = this.currentState === ChapterPageButton.buttonStates.LOCKED ? this.lockedBgImage.id : this.unlockedBgImage.id;

        if (this.currentState === LevelButton.buttonStates.CURRENT) {
            this._pulse();
        }
    },

    _onClick: function () {
        if (this.currentState === ChapterSelectButton.buttonStates.LOCKED) return;
        this.app.fire('BookUI:levelSelect', this.chapterID, this.pageID);
        this.app.fire('Audio:sfx', 'page_flip.mp3');
    },

    _pulse: function () {
        this.pulseTween = this.entity.tween(this.entity.getLocalScale()).to({ x: 1.1, y: 1.1, z: 1.1 }, 1.0, pc.SineOut).loop(true).yoyo(true).start();
    },

    _cancelPulse: function () {
        this.pulseTween.stop();
        this.entity.setLocalScale(1, 1, 1);
        this.pulseTween = null;
    },

});

// LevelButton.js
var LevelButton = pc.createScript('levelButton');

LevelButton.buttonStates = Object.freeze({
    LOCKED: 0,
    UNLOCKED: 1,
    CURRENT: 2
});


LevelButton.attributes.add('buttonBorderEntity', { type: 'entity' });
LevelButton.attributes.add('levelNumberText', { type: 'entity' });
LevelButton.attributes.add('starImages', { type: 'entity', array: true });
LevelButton.attributes.add('objectiveImages', { type: 'entity', array: true });

LevelButton.attributes.add('backgrounds', { type: 'asset', array: true });

LevelButton.attributes.add('unlockedBorderEntity', { type: 'entity' });
LevelButton.attributes.add('lockedGroupEntity', { type: 'entity' });
LevelButton.attributes.add('currentGroupEntity', { type: 'entity' });

// animation parameters
LevelButton.attributes.add('totalAnimationTime', { type: 'number', default: 5 });
LevelButton.attributes.add('animationDelay', { type: 'number', default: 0.2 });
LevelButton.attributes.add('popupDelay', { type: 'number', default: 2 });

pc.extend(LevelButton.prototype, {
    initialize: function () {
        this.entity.script.elementInput.on(inputEvents.CLICK, this._onClick, this);
        this.popupTimer = 0;
        this.openPopup = false;
        this.pulseTween = null;
        this.startScale = this.entity.getLocalScale().clone();
        this.startPosition = this.entity.getLocalPosition().clone();

        this.app.on('ViewportManager:onResize', this._onResize.bind(this), this);
        this._onResize(ViewportManager.instance.getOrientation(), ViewportManager.instance.width, ViewportManager.instance.height, ViewportManager.instance.getDevice());

        this.app.on('LevelButton:cancelPopup', this._cancelPopup, this);
        LevelSelectPage.instance.on('onPageLoadDone', this._pulse, this);
    },

    update: function (dt) {
        if (this.openPopup) {
            this.popupTimer += dt;
            if (this.popupTimer > this.popupDelay) {
                this.openPopup = false;
                this.popupTimer = 0;

                if (this.currentState != LevelButton.buttonStates.UNLOCKED) // for if the tween broke
                    this.setState(LevelButton.buttonStates.UNLOCKED);

                this._onClick();
            }
        }
    },

    _onResize: function (orientation, width, height, device) {
        this._cancelPulse();
        pc.timer.add(0.3, () => {
            if (this.currentState === LevelButton.buttonStates.CURRENT) {
                this._pulse();
            }
        }, this);
    },

    // NOTE levelInfo is not used yet, but created for the purpose of objectiveData
    setButtonInformation: function (chapterID, levelID, levelInfo) {
        this.levelNumberText.element.text = levelID;
        this.levelID = levelID;
        this.levelInfo = levelInfo;
        this.chapterID = chapterID;

        this.setImage();

        // stars
        var levelData = LevelDataManager.instance.getLevelData(chapterID, levelID);

        var nStars = levelData === null ? 0 : levelData.stars;
        for (var i = 0; i < this.starImages.length; i += 1) {
            var enabled = nStars > i
            this.starImages[i].enabled = enabled;

            if (enabled) {
                this.starImages[i].children[0].script.coloredStar.setStarBasedOnWorldIndex(chapterID);
            }
        }

        // objectives
        this.data = LevelManager.instance.getLevelData(this.levelID);

        if (this.data) {
            var keys = Object.keys(this.data);

            if (keys.length > 3) {
                console.error("This level has too many objectives! Level:", this.levelID, this.data)
                return;
            }

            var index = 0;

            for (var j = 0; j < keys.length; j++) {
                var key = keys[j];

                if (key === 'turns') {
                    continue;
                }
                var sprite = TileLibrary.instance.getTileSprite(key);

                if (sprite) {
                    this.objectiveImages[index].enabled = true;
                    this.objectiveImages[index].element.spriteAsset = sprite;
                    index++;
                } else {
                    console.warn("No asset found for key:", key);
                }
            }

            if (index === 1) {
                this.objectiveImages[index].enabled = false;
            }
        } else {
            console.warn("No data found for level", levelID);
            this.objectiveImages[0].enabled = false;
            this.objectiveImages[1].enabled = false;
            this.setState(LevelButton.buttonStates.LOCKED);
        }
    },

    setImage: function () {
        this.entity.element.spriteAsset = this.backgrounds[this.chapterID - 1].id;
    },

    setState: function (state) {
        this._cancelPulse();
        this.currentState = state;

        this.lockedGroupEntity.enabled = this.currentState === LevelButton.buttonStates.LOCKED;
        this.unlockedBorderEntity.enabled = this.currentState !== LevelButton.buttonStates.LOCKED;
        this.currentGroupEntity.enabled = this.currentState === LevelButton.buttonStates.CURRENT;

        for (var i = 0; i < this.objectiveImages.length; i++) {
            this.objectiveImages[i].element.color = this.currentState === LevelButton.buttonStates.LOCKED ? LevelButton.GREY : pc.Color.WHITE;
            this.objectiveImages[i].element.opacity = this.currentState === LevelButton.buttonStates.LOCKED ? 0.7 : 1;
        }
    },

    _onClick: function (event) {
        var levelData = LevelDataManager.instance.getLevelData(this.chapterID, this.levelID);

        if (event.button === 1) {
            LevelDataManager.instance.saveLevelData(this.chapterID, this.levelID, 90000, 3);

            this.setState(LevelButton.buttonStates.UNLOCKED);
            var nStars = levelData === null ? 0 : levelData.stars;
            for (var i = 0; i < this.starImages.length; i += 1) {
                this.starImages[i].enabled = nStars > i;
            }
            return;
        } else if (event.button === 2) {
            LevelDataManager.instance.saveLevelData(this.chapterID, this.levelID, 0, 0);
            if (this.levelID != 1) {
                LevelDataManager.instance._levelData.currentLevel = this.levelID - 1;
            } else {
                LevelDataManager.instance._levelData.currentLevel = this.levelID;
            }

            var nStars = levelData === null ? 0 : levelData.stars;
            for (var i = 0; i < this.starImages.length; i += 1) {
                this.starImages[i].enabled = nStars > i;
            }
            this.setState(LevelButton.buttonStates.LOCKED);
        }

        if (this.currentState === LevelButton.buttonStates.LOCKED) return;
        this.app.fire('LevelButton:cancelPopup');
        this.app.fire('UIManager:showUI', 'LevelInfo');
        this.app.fire('ToggleElementPerScreen:onOpen', 'LevelInfo'),

            // this.app.fire('WorldManager:setWorld');
            UIManager.instance.getScreen('LevelInfo').script.levelInfoScreen.setInformation(this.chapterID, this.levelID, this.levelInfo, this.data);
    },

    _cancelPopup: function () {
        if (this.openPopup === true) {
            this.openPopup = false;
            this.popupTimer = 0;
        }

    },

    _pulse: function () {
        if (this.currentState !== LevelButton.buttonStates.CURRENT) return;

        if (this.pulseTween !== null) {
            return;
        }
        var startPos = this.entity.getLocalPosition().clone();
        // this.entity.setLocalScale(this.startScale.x, this.startScale.y, this.startScale.z);
        this.pulseTween = this.entity
            .tween(this.entity.getLocalPosition())
            .to({ x: startPos.x, y: startPos.y - 5, z: startPos.z }, 0.15, pc.SineInOut)
            .delay(2)
            .repeat(4)
            .yoyo(true)
            .start();

        this.pulseTween.on('complete', function () {
            this.pulseTween.start();
        }.bind(this));

        // this.entity.setLocalScale(this.startScale.x, this.startScale.y, this.startScale.z);
        // this.pulseTween = this.entity.tween(this.entity.getLocalScale()).to({x: this.startScale.x * 1.05, y: this.startScale.y * 1.05, z: this.startScale.z * 1.05}, 1.0, pc.SineInOut).loop(true).yoyo(true).start();
    },

    _cancelPulse: function () {
        if (this.pulseTween) {
            this.pulseTween.stop();
            this.pulseTween = null;
            this.entity.setLocalScale(this.startScale.x, this.startScale.y, this.startScale.z);
        }
    },

    triggerPopup: function () {
        this.openPopup = true;
    },

    unlockAnimation: function () {
        this.lock = this.lockedGroupEntity.findByName('Lock');
        UnlockLevelAnimation.instance.startAnim(this.entity, this.lock, function () {
            this.setState(LevelButton.buttonStates.CURRENT);
        }.bind(this));

        this.setState(LevelButton.buttonStates.LOCKED);
        // Merge conflict (We might need some stuff from the old code.)
        //     unlockAnimation: function() {
        //         var timer = 0;
        //         var self = this;

        //         self.setState(LevelButton.buttonStates.LOCKED);

        //         this.entity.tween(this.entity.getLocalScale()).to({x: 0.1, y: 0.1, z: 0.1}, (this.totalAnimationTime / 2), pc.BackOut).delay(this.animationDelay).repeat(2).yoyo(true).on('update', function (dt) {
        //             timer += dt;
        //             if(timer >= (self.totalAnimationTime / 2) && self.currentState !== 1) {
        //                 self.setState(LevelButton.buttonStates.UNLOCKED);
        //             }     
        //         }).on('complete', function () {
        //             timer = 0;
        //             self.app.fire('Audio:sfx', 'level_unlock.mp3');
        //             self.setState(LevelButton.buttonStates.CURRENT);
        //             self._pulse();
        //         }).start();
    },

    click: function () {
        this._onClick();
    },
});

LevelButton.GREY = new pc.Color(0.2, 0.2, 0.2);

// PreBoosterButton.js
var PreBoosterButton = pc.createScript('preBoosterButton');

PreBoosterButton.buttonStates = Object.freeze({
    ACTIVE: 0,
    INACTIVE: 1,
    EMPTY: 2
});

PreBoosterButton.attributes.add('inventoryKey', { type: 'string' });
PreBoosterButton.attributes.add('activeBubble', { type: 'entity' });
PreBoosterButton.attributes.add('inactiveBubble', { type: 'entity' });
PreBoosterButton.attributes.add('emptyBubble', { type: 'entity' });
PreBoosterButton.attributes.add('amountText', { type: 'entity' });

PreBoosterButton.DISABLE_OPACITY = 0.5;

pc.extend(PreBoosterButton.prototype, {
    initialize: function () {
        this.entity.script.elementInput.on(inputEvents.CLICK, this._onClick, this);
        this.app.on('BoosterShopManager:onItemBought', this.getInventoryAmount, this);

        this._hand = this.entity.findByTag('tutorial')[0];
    },

    getInventoryAmount: function () {
        var currentAmount = Inventory.instance.getItem(this.inventoryKey);

        if (this._tutorial && currentAmount === 0) {
            currentAmount = 1;
        }

        if (currentAmount > 0) {
            this.setState(PreBoosterButton.buttonStates.INACTIVE);
        } else {
            this.setState(PreBoosterButton.buttonStates.EMPTY);
        }
        this.amountText.element.text = currentAmount;
    },

    setState: function (state) {
        this.currentState = state;

        this.activeBubble.enabled = this.currentState === PreBoosterButton.buttonStates.ACTIVE;
        this.inactiveBubble.enabled = this.currentState === PreBoosterButton.buttonStates.INACTIVE;
        this.emptyBubble.enabled = this.currentState === PreBoosterButton.buttonStates.EMPTY;
    },

    _onClick: function () {
        switch (this.currentState) {
            case PreBoosterButton.buttonStates.ACTIVE:
                this.setState(PreBoosterButton.buttonStates.INACTIVE);
                break;
            case PreBoosterButton.buttonStates.INACTIVE:
                this.app.fire('PreBoosterButton:active', this.inventoryKey);
                this.setState(PreBoosterButton.buttonStates.ACTIVE);
                break;
            case PreBoosterButton.buttonStates.EMPTY:
                this.app.fire('UIManager:showUI', 'BoosterShop');
                this.app.fire('BoosterShopInterface:setBooster', this.inventoryKey);

                break;
        }
    },

    activate: function (value) {
        this._active = value;

        if (value) {
            this.entity.element.useInput = true;
            var elements = this.entity.findComponents("element");
            for (var j = 0; j < elements.length; j++) {
                elements[j].opacity = 1; // 3E3E3E
                elements[j].color = pc.Color.WHITE;
            }
        } else {
            this.entity.element.useInput = false;
            // this.entity.element.opacity = this.disableOpacity;
            // this.entity.element.color = new pc.Color().fromString("#3E3E3E");
            var elements = this.entity.findComponents("element");
            for (var j = 0; j < elements.length; j++) {
                elements[j].opacity = PreBoosterButton.DISABLE_OPACITY; // 
                elements[j].color = PreBoosterButton.GREY;
            }
        }
    },

    activateBooster: function () {
        if (this.currentState !== PreBoosterButton.buttonStates.ACTIVE) return false;

        var success = !this._tutorial ? Inventory.instance.tryPayItem(this.inventoryKey, 1, 'preboost', 'consumePrebooster') : true;

        if (!success) return false;

        switch (this.inventoryKey) {
            case 'PREBOOSTER_1':
                BoosterManager.instance.addPreBoosterToQueue(preGameBoosters.LINECLEAR, 2, this._tutorial);
                StatisticsManager.instance.incrementStatistic("pre_booster_used", { type: 'bees' });
                break;
            case 'PREBOOSTER_2':
                BoosterManager.instance.addPreBoosterToQueue(preGameBoosters.BOMB, 2, this._tutorial);
                StatisticsManager.instance.incrementStatistic("pre_booster_used", { type: 'ladybugs' });
                break;
            case 'PREBOOSTER_3':
                BoosterManager.instance.addPreBoosterToQueue(preGameBoosters.COLORBOMB, 1, this._tutorial);
                StatisticsManager.instance.incrementStatistic("pre_booster_used", { type: 'butterflies' });
                break;
        }

        return true;
    },

    useInput: function (tag) {
        var isTag = tag ? this.entity.tags.has(tag) : true;

        if (isTag && tag) {
            this.setTutorial(true);
        }


        this.entity.element.useInput = isTag && this._active;
    },

    setTutorial: function (isTutorial) {
        this._tutorial = isTutorial;

        if (isTutorial) {
            if (this.currentState === PreBoosterButton.buttonStates.EMPTY) {
                this.amountText.element.text = 1;
                this.setState(PreBoosterButton.buttonStates.INACTIVE);
            } else {
                this.amountText.element.text = Inventory.instance.getItem(this.inventoryKey);
            }
        }

        this.enableTutorial(isTutorial);
    },

    enableTutorial: function (value) {
        this._hand.enabled = value;
    },
});

PreBoosterButton.GREY = new pc.Color().fromString("#3E3E3E");

// LevelInfoScreen.js
var LevelInfoScreen = pc.createScript('levelInfoScreen');

LevelInfoScreen.attributes.add('levelNumberText', { type: 'entity' });
LevelInfoScreen.attributes.add('movesAmountText', { type: 'entity' });
LevelInfoScreen.attributes.add('objectiveEntities', { type: 'entity', array: true });
LevelInfoScreen.attributes.add('boosterButtonEntities', { type: 'entity', array: true });
LevelInfoScreen.attributes.add('startLevelButton', { type: 'entity' });
LevelInfoScreen.attributes.add('closeButton', { type: 'entity' });

LevelInfoScreen.attributes.add('screenEntity', { type: 'entity' });
LevelInfoScreen.attributes.add('characterLeftEntity', { type: 'entity' });

pc.extend(LevelInfoScreen.prototype, {
    initialize: function () {
        LevelInfoScreen.instance = this;

        this.startLevelButton.script.elementInput.on('click', this._onClick, this);

        this._levelInfoScreen = this.entity.findByName('LevelInfoScreen');

        // this._characterImage = this.entity.findByName('CharacterImage');

        this._clicked = false;
        this._allButtons = this.entity.findScripts('elementInput');
    },

    onUIEntityOpen: function () {
        this._clicked = false;

        for (var i = 0; i < this._allButtons.length; i++) {
            var entity = this._allButtons[i].entity;

            if (entity.script.preBoosterButton) {
                entity.script.preBoosterButton.setTutorial(false);
            }
        }
    },

    onUIEntityCloseFinish: function (args) {
        if (args === "STARTLEVEL") {
            this._startLevel();
        }
    },

    _onClick: function () {
        if (this._clicked) {
            return;
        }

        this._clicked = true;

        if (LivesManager.instance.hasLives()) {
            Wrapper.instance.showInterstitialAd('start_level', this.onInterstitialAdWatched.bind(this));


        } else {
            this.app.fire("UIManager:showUI", 'NoMoreLivesScreen');
            this._clicked = false;
        }
    },

    onInterstitialAdWatched() {
        this._clicked = false;

        this.app.fire("UIManager:hideUI", 'LevelInfo', 'STARTLEVEL');
        this.app.fire("UIManager:hideUI", 'FloatingUI');
    },

    setInformation: function (chapterID, levelID, levelInfo, levelData) {
        WorldManager.instance.switchWorld(chapterID);

        this.levelID = levelID;
        this.chapterID = chapterID;

        LocalizationManager.instance.setText(this.levelNumberText, "LEVEL_NUMBER", levelID);

        // TODO set moves, objectives

        for (var i = 0; i < this.boosterButtonEntities.length; i += 1) {
            this.boosterButtonEntities[i].script.preBoosterButton.getInventoryAmount();
        }

        if (!levelData) {
            console.warn("no level data is found", levelData);
            return;
        }

        this.movesAmountText.element.text = levelData.turns;

        var keys = Object.keys(levelData);
        var index = 0;
        for (var j = 0; j < keys.length; j++) {
            var key = keys[j];

            if (key === 'turns') {
                continue;
            }

            var amount = levelData[key];

            this.objectiveEntities[index].enabled = true;
            this.objectiveEntities[index].script.popupObjectiveUI.setGoal(key, amount);
            index++;
        }

        if (index === 1) {
            this.objectiveEntities[index].enabled = false;
        }

        TutorialManager.instance.preGameBooster(this.levelID);
    },

    _startLevel: function () {
        if (this._clicked) {
            return;
        }

        if (!LivesManager.instance.hasLives()) {
            this.app.fire('UIManager:showUI', 'NoMoreLivesScreen');
            return;
        }

        this._clicked = true;
        this.fire('start');

        var consume

        for (var i = 0; i < this.boosterButtonEntities.length; i += 1) {
            this.boosterButtonEntities[i].script.preBoosterButton.activateBooster();
        }

        LevelManager.instance.startLevel(this.levelID, this.chapterID);
    },

    enableOneButton: function (tag) {
        for (var i = 0; i < this._allButtons.length; i++) {
            var entity = this._allButtons[i].entity;

            if (entity.script.preBoosterButton) {
                entity.script.preBoosterButton.useInput(tag);
            } else {
                entity.element.useInput = entity.tags.has(tag);
            }
        }
    },

    enableAll: function (value) {
        this.startLevelButton.element.useInput = value;
        this.closeButton.element.useInput = value;

        for (var i = 0; i < this._allButtons.length; i++) {
            var entity = this._allButtons[i].entity;

            if (entity.script.preBoosterButton) {
                entity.script.preBoosterButton.useInput();
                entity.script.preBoosterButton.enableTutorial(false);
            }
        }
    },
});

// SettingsToggleUI.js
var SettingsToggleUI = pc.createScript('settingsToggleUI');

SettingsToggleUI.EXCEPTION = Object.freeze({
    NONE: 'none',
    LANDSCAPE_MOBILE: 'landscapeMobile'
});

SettingsToggleUI.EXCEPTION_ENUM = Object.freeze([
    { NONE: 'always' },
    { LANDSCAPE_MOBILE: 'landscapeMobile' },
]);

SettingsToggleUI.attributes.add('uiToDisable', { type: 'entity', array: true });
SettingsToggleUI.attributes.add('exception', { type: 'string', enum: SettingsToggleUI.EXCEPTION_ENUM, default: SettingsToggleUI.EXCEPTION.NONE });

pc.extend(SettingsToggleUI.prototype, {
    initialize: function() {
        this.hamburgerButton = this.entity.script.hamburgerMenu;
        this.hamburgerButton.on('MenuToggle', this.onMenuToggle, this);
    },

    onMenuToggle: function(isOpen) {
        if (isOpen && this.exception === SettingsToggleUI.EXCEPTION.LANDSCAPE_MOBILE &&
        ViewportManager.instance.getOrientation() === orientationEnum.LANDSCAPE && 
        ViewportManager.instance.getDevice() === deviceEnum.MOBILE) {
            return;
        }

        for (var i = 0; i < this.uiToDisable.length; i++) {
            if (this.uiToDisable[i]._keepDisabled) {
                continue;
            }
            this.uiToDisable[i].enabled = !isOpen;
        }
    }
});

// StarBarStar.js
var StarBarStar = pc.createScript('starBarStar');

StarBarStar.attributes.add('starImageEntity', { type: 'entity' });
StarBarStar.attributes.add('inactiveStarEntity', { type: 'entity' });
StarBarStar.attributes.add('coloredStarEntity', { type: 'entity' });

pc.extend(StarBarStar.prototype, {
    setRotation: function(value) {
        this.barValue = value;
        this.isActive = false;
        this.entity.setLocalEulerAngles(0, 0, value * -360);
        this.starImageEntity.setLocalEulerAngles(0, 0, value * 360);
        this.inactiveStarEntity.setLocalEulerAngles(0, 0, value * 360);
    },

    setActive: function() {
        if (this.isActive) return;
        this.app.fire('Audio:sfx', 'star_ingame.mp3');
        this.isActive = true;
        this.starImageEntity.enabled = true;
        this.starImageEntity.script.tweenScale.startTween();
        this.coloredStarEntity.script.coloredStar.setStarBasedOnWorldIndex();
    },

    setInactive: function() {
        this.starImageEntity.script.tweenScale.stopTween();
        this.starImageEntity.script.tweenScale.reset();
        
        this.isActive = false;
        this.starImageEntity.enabled = false;
    },
    
    checkActivate: function(currentValue) {
        if (currentValue > this.barValue) {
            this.setActive();
        } else {
            this.setInactive();
        }
    }
});

// PopupObjectiveUI.js
var PopupObjectiveUI = pc.createScript('popupObjectiveUI');

PopupObjectiveUI.attributes.add('hasResult', { type: 'boolean' });
PopupObjectiveUI.attributes.add('objectiveIconEntity', { type: 'entity' });
PopupObjectiveUI.attributes.add('goalTextEntity', { type: 'entity' });
PopupObjectiveUI.attributes.add('resultTextEntity', { type: 'entity' });
PopupObjectiveUI.attributes.add('resultIconEntity', { type: 'entity' });
PopupObjectiveUI.attributes.add('completeIcon', { type: 'asset', assetType: 'sprite' });
PopupObjectiveUI.attributes.add('failedIcon', { type: 'asset', assetType: 'sprite' });
PopupObjectiveUI.attributes.add('completeColor', { type: 'rgb' });
PopupObjectiveUI.attributes.add('failedColor', { type: 'rgb'});

pc.extend(PopupObjectiveUI.prototype, {
    initialize: function() {
        this.resultTextEntity.enabled = this.hasResult;
        this.resultIconEntity.enabled = this.hasResult;
        this.goalTextEntity.enabled = !this.hasResult;
    },

    setGoal: function(type, amount) {
        this.goal = amount;

        // TODO set objective icon
        this.objectiveIconEntity.element.spriteAsset = TileLibrary.instance.getTileSprite(type);

        this.goalTextEntity.element.text = (this.hasResult ? '/' : '') + amount;
        
        this.setTextWidth();
    },

    setResult: function(amount) {
        if (!this.hasResult) return;
        
        var remainingValue = pc.math.clamp(this.goal - amount, 0, Number.POSITIVE_INFINITY);
        
        
        // if (remainingValue < 0) {
        //     console.warn("Remaining value is lower than 0", remainingValue);
        //     return;
        // }

        this.resultTextEntity.element.text = remainingValue;

        var completedGoal = remainingValue <= 0;
        this.resultTextEntity.element.color = completedGoal ? this.completeColor : this.failedColor;
        this.resultIconEntity.element.spriteAsset = completedGoal ? this.completeIcon.id : this.failedIcon.id;
        
        this.setTextWidth();
    },

    setTextWidth: function() {
        this.goalTextEntity.parent.element.width = this.hasResult ? this.resultTextEntity.element.width : this.goalTextEntity.element.width;
        this.entity.element.width = this.goalTextEntity.parent.element.width + this.objectiveIconEntity.element.width;
    }
});

// TutorialManager.js
var TutorialManager = pc.createScript('tutorialManager');

TutorialManager.attributes.add('focusOverlay', { type: 'entity' });
TutorialManager.attributes.add('overlay', { type: 'entity' });

TutorialManager.attributes.add('objectiveEntity', { type: 'entity' });
TutorialManager.attributes.add('moveEntity', { type: 'entity' });

TutorialManager.attributes.add('scaleCurve', { type: 'curve' });

TutorialManager.attributes.add('pregameBoosters', {
    type: 'json',
    array: true,
    schema: [{
        name: 'level',
        type: 'number'
    }, {
        name: 'data',
        type: 'asset'
    }],
});

TutorialManager.attributes.add('tutorials', {
    type: 'json',
    array: true,
    schema: [{
        name: 'level',
        type: 'number'
    }, {
        name: 'data',
        type: 'asset'
    }],
});

pc.extend(TutorialManager.prototype, {
    initialize: function () {
        TutorialManager.instance = this;

        this.skipTutorial = Wrapper.instance.hasFeature("skip_tutorial");

        this.focusOverlay.enabled = false;
        this.overlay.enabled = false;

        this.active = false;
        this._currentStep = -1;
        this._currentTutorialSteps = null;

        this.app.on('ViewportManager:onResize', this._onResize, this);
        this.app.on('PerspectiveView:onCameraChange', this._onResize, this);
    },

    _onResize: function () {
        pc.timer.add(0.01, () => {
            if (!this._currentTutorialStep) {
                return;
            }

            switch (this._currentTutorialStep.type) {
                case 'dialog':
                    if (this._currentTutorialStep.focus) {
                        this.focus(this._currentTutorialStep.focus);
                    }
                    break;

                case undefined:
                    break;

                default:
                    break;
            }

        }, this);
    },

    preGameBooster: function (level) {
        var currentLevel = LevelDataManager.instance.getCurrentLevel();

        var index = this.pregameBoosters.findIndex(function (element) {
            return element.level === level;
        });

        if (index === -1) {
            return;
        }

        this._setTutorial(this.pregameBoosters[index].data.resources);
    },

    startLevel: function (level) {
        if (this.skipTutorial) {
            return;
        }

        var index = this.tutorials.findIndex(function (element) {
            return element.level === level;
        });

        if (index === -1) {
            return;
        }

        this._setTutorial(this.tutorials[index].data.resources);
    },

    _checkActionStep: function (step) {
        this._dialogStep = step;
        this._canDoAction = this._isActionStep(this._dialogStep);

        // DialogManager.instance.enableOverlay(!this._canDoAction);
        this.app.fire("GameInput:toggleGameInput", this._canDoAction);

        if (this._canDoAction) {
            if (this._currentTutorialStep.type === 'booster' && this._currentTutorialStep.index.indexOf(this._dialogStep) !== 0) {
                return;
            }
            this._showAction();
        }
    },

    _setTutorial: function (currentTutorial) {
        this.active = true;

        this._currentStep = 0;
        this._currentTutorial = currentTutorial;
        this._currentTutorialStep = this._currentTutorial[this._currentStep];

        this._showTutorial();
        this._checkActionStep(0);
    },

    _showTutorial: function () {
        if (this._currentTutorialStep.dialog) {
            var isPrebooster = this._currentTutorialStep.type === 'prebooster';
            var allowSkip = this._currentTutorialStep.type !== 'booster' && !isPrebooster;
            DialogManager.instance.showDialog(this._currentTutorialStep.dialog, null, null, isPrebooster ? dialogTypes.PREBOOSTERTUTORIAL : dialogTypes.GAMETUTORIAL, allowSkip);
        }

        switch (this._currentTutorialStep.type) {
            case 'prebooster':
                this.app.on('PreBoosterButton:active', this._onPreboosterClick, this);
                DialogManager.instance.on('step', this._checkActionStep, this);
                //                 LevelInfoScreen.instance.on('start', this._onStartClick, this);

                LevelInfoScreen.instance.enableAll(false);
                // FirstTimeUserManager.instance.checkItem(this._currentTutorialStep.tag);
                break;

            case 'booster':
                DialogManager.instance.on('step', this._checkActionStep, this);
                DialogManager.instance.on("finish", this._nextTutorialStep, this);


                if (!this._currentTutorialStep.dialog) {
                    this._showAction();
                }
                break;

            case 'dialog':
                DialogManager.instance.on("finish", this._nextTutorialStep, this);
                this.overlay.enabled = true;

                this.focus(this._currentTutorialStep.focus);

                break;

            case 'swap':
                DialogManager.instance.on('step', this._checkActionStep, this);
                DialogManager.instance.on("finish", this._nextTutorialStep, this);

                if (!this._currentTutorialStep.dialog) {
                    this._showAction();
                }
                break;

            case 'randomMatch':
                DialogManager.instance.on('step', this._checkActionStep, this);
                this.app.on('SwapMode:onMoveStart', this._nextTutorialStep, this);
                if (!this._currentTutorialStep.dialog) {
                    this._showAction();
                }
                break;

            case 'waitForCascade':
                this.app.on('SwapMode:onCascadeDone', this._onCascadeFinish, this);

                if (this._currentTutorialStep.enableOverlay) {
                    this.enableOverlay(true);
                }
                break;

            default:
                console.warn("Type is not recognized: ", this._currentTutorialStep.type);
                break;
        }
    },

    _hideTutorial: function () {
        this._resetHand();

        if (!this._currentTutorialStep) {
            Sentry.captureMessage("No tutorial in level " + LevelManager.instance.currentLevel);
            return;
        }

        switch (this._currentTutorialStep.type) {
            case 'prebooster':
                this.app.off('PreBoosterButton:active', this._onPreboosterClick, this);
                DialogManager.instance.off('step', this._checkActionStep, this);
                // LevelInfoScreen.instance.off('start', this._onStartClick, this);

                LevelInfoScreen.instance.enableAll(true);
                break;

            case 'booster':
                var boosterIndex = this._currentTutorialStep.boosterIndex
                pc.timer.add(0.01, () => {
                    this.app.fire('TutorialManager:enableBoosters', boosterIndex);
                }, this);

                this.enableOverlay(false);

                DialogManager.instance.off("finish", this._nextTutorialStep, this);
                DialogManager.instance.off('step', this._checkActionStep, this);
                this._boosterEntity.script.boosterButton.off('cancel', this._onBoosterCancel, this);
                this._boosterEntity.script.boosterButton.off('use', this._onBoosterUse, this);

                this._boosterEntity = null;
                break;

            case 'dialog':
                DialogManager.instance.off("finish", this._nextTutorialStep, this);

                this.enableOverlay(false);
                break;

            case 'swap':
                DialogManager.instance.off('step', this._checkActionStep, this);
                DialogManager.instance.off("finish", this._nextTutorialStep, this);
                this.enableOverlay(false);

                break;

            case 'randomMatch':
                DialogManager.instance.off('step', this._checkActionStep, this);
                DialogManager.instance.nextDialog();
                this.app.off('SwapMode:onMoveStart', this._nextTutorialStep, this);
                break;

            case 'waitForCascade':
                this.app.off('SwapMode:onCascadeDone', this._onCascadeFinish, this);

                if (this._currentTutorialStep.enableOverlay) {
                    this.enableOverlay(false);
                }
                break;


            default:
                console.warn("Type is not recognized: ", this._currentTutorialStep.type);
                break;
        }

    },

    _showAction: function () {
        switch (this._currentTutorialStep.type) {
            case 'prebooster':
                LevelInfoScreen.instance.enableOneButton(this._currentTutorialStep.tag);
                break;

            case 'booster':
                this.app.fire('TutorialManager:enableBooster', this._currentTutorialStep.boosterIndex);

                break;

            case 'dialog':

                break;

            case 'swap':
                this._showTutorialHand();

                this.setOverlayWorldPosition();

                GridManager.instance.showTutorialMatch([
                    GridManager.instance.getTile(this._currentTutorialStep.tile1.x, this._currentTutorialStep.tile1.y),
                    GridManager.instance.getTile(this._currentTutorialStep.tile2.x, this._currentTutorialStep.tile2.y)
                ]);
                break;

            case 'randomMatch':
                break;

            case 'waitForCascade':
                break;

            default:
                console.warn("Type is not recognized: ", this._currentTutorialStep.type);
                break;
        }

    },

    _onPreboosterClick: function () {
        this._nextTutorialStep();
    },

    _onStartClick: function () {
        this._nextTutorialStep();
    },

    _onCascadeFinish: function () {
        this._nextTutorialStep();
    },

    _nextTutorialStep: function () {

        this._hideTutorial();
        this._currentStep++;
        this._currentTutorialStep = this._currentTutorial[this._currentStep];

        if (!this._currentTutorialStep) {
            this.endTutorial();
            return;
        }

        this._showTutorial();
        this._checkActionStep(0);

        if (this._currentTutorialStep.type !== 'waitForCascade') {
            this.app.fire('BoosterButton:disableAll');
        }
    },

    _isActionStep: function (step) {
        if (this._currentTutorialStep.type === 'randomMatch' && (typeof this._currentTutorialStep.index !== 'number' || !Array.isArray(this._currentTutorialStep.index))) {
            return true;
        }

        if (Array.isArray(this._currentTutorialStep.index)) {
            return this._currentTutorialStep.index.indexOf(step) !== -1;
        }

        return step === this._currentTutorialStep.index;
    },

    _resetHand: function () {
        if (this._tween) {
            this._tween.stop();
        }

        if (GridManager.instance && GridManager.instance.tutorialHand) {
            var hand = GridManager.instance.tutorialHand;

            hand.enabled = false;
            hand.setLocalScale(1, 1, 1);
        }
    },

    _showTutorialHand: function () {
        this._resetHand();

        var hand = GridManager.instance.tutorialHand;
        hand.enabled = true;

        var tile1 = this._currentTutorialStep.tile1;
        var tile2 = this._currentTutorialStep.tile2;

        var position1 = GridManager.instance.calculatePosition(tile1.x, tile1.y, 1);
        var position2 = GridManager.instance.calculatePosition(tile2.x, tile2.y, 1);

        hand.setLocalPosition(position1);
        this._tween = hand.tween(hand.getLocalPosition()).to({ x: position2.x, y: position2.y, z: position2.z }, 1, pc.Linear)
            .loop(true)
            .yoyo(true)
            .start();
    },

    _showTutorialHandClick: function (position) {
        this._resetHand();

        var hand = GridManager.instance.tutorialHand;
        hand.enabled = true;

        var position1 = GridManager.instance.calculatePosition(position.x, position.y, 1);
        hand.setLocalPosition(position1);
        var size = 1.5;
        this._tween = hand.tween(hand.getLocalScale()).to({ x: size, y: size, z: size }, 1, pc.Linear)
            .loop(true)
            .yoyo(true)
            .start();
    },

    checkAllowedSwap: function (tile1, tile2) {
        if (!this.active) return true;

        if (this._currentTutorialStep.type === "randomMatch") {
            return true;
        }

        if (this._currentTutorialStep.type !== "swap") {
            if (this._currentTutorialStep.type !== "booster") {
                return false;
            } else if (this._currentTutorialStep.boosterIndex !== 0) {
                return false;
            }
        }

        if (BoosterManager.instance.isBoosterActive(boosterEnum.FREESWAP) && this._currentTutorialStep.boosterIndex !== 0) {
            return;
        }

        var position1 = this._currentTutorialStep.tile1;
        var position2 = this._currentTutorialStep.tile2;

        if (!tile1 || !tile2) {
            console.warn("No tile 1 or tile 2");
            console.log(tile1);
            console.log(tile2);
            return false;
        }

        var tutorialTile1 = GridManager.instance.getTile(position1.x, position1.y);
        var tutorialTile2 = GridManager.instance.getTile(position2.x, position2.y);

        var tile1IsTutorialTile = tile1 === tutorialTile1 || tile1 === tutorialTile2;
        var tile2IsTutorialTile = tile2 === tutorialTile1 || tile2 === tutorialTile2;

        if (tile1IsTutorialTile && tile2IsTutorialTile) {
            this._resetHand();
            DialogManager.instance.nextDialog();
            //this._nextTutorialStep();
        }

        return tile1IsTutorialTile && tile2IsTutorialTile;
    },

    setBoosterEntity: function (entity) {
        this._boosterEntity = entity;
        this._boosterEntity.script.boosterButton.off('use', this._onBoosterUse, this);
        this._boosterEntity.script.boosterButton.on('use', this._onBoosterUse, this);

        // this.enableOverlay(true);
        // this.setOverlayPosition(entity);

        this.app.fire("GameInput:toggleGameInput", false);
    },

    _onBoosterUse: function () {
        this.enableOverlay(false);

        this.app.fire("GameInput:toggleGameInput", true);

        this._boosterEntity.script.boosterButton.off('use', this._onBoosterUse, this);

        this._boosterEntity.script.boosterButton.on('cancel', this._onBoosterCancel, this);

        DialogManager.instance.nextDialog();

        // this.enableOverlay(true);


        if (this._currentTutorialStep.tile) {
            this._showTutorialHandClick(this._currentTutorialStep.tile);
        } else if (this._currentTutorialStep.tile1 && this._currentTutorialStep.tile2) {
            this._showTutorialHand();
        }

        //setTimeout(function() {
        this.setOverlayWorldPosition();
        //}.bind(this), 100);
    },

    _onBoosterCancel: function () {
        DialogManager.instance.previousDialog();
        this._boosterEntity.script.boosterButton.off('cancel', this._onBoosterCancel, this);

        this._resetHand();
    },

    canUseBooster: function (tile) {
        var position = this._currentTutorialStep.tile;

        if (!position) {
            return false;
        }

        var same = tile.x === position.x && tile.y === position.y;

        if (same) {
            DialogManager.instance.nextDialog();
        }

        return same;
    },

    endTutorial: function (forced) {
        if (!this.active) {
            return;
        }

        if (this._currentTutorialStep) {
            this._hideTutorial();
        }
        this.active = false;
        DialogManager.instance.hideDialog();
        // this.app.fire("GameInput:toggleGameInput", true);

        if (!forced) {
            this.app.fire('TutorialManager:stopTutorial');
        }
    },

    enableOverlay: function (visible) {
        this.focusOverlay.enabled = visible;
        this.overlay.enabled = false;

        this._targetEntity = null;
        this._follow = false;
    },

    setOverlayPosition: function (targetEntity) {
        this.focusOverlay.setPosition(targetEntity.getPosition());

        this._targetEntity = targetEntity;
        this._follow = true;

        this._setScale(1);
    },

    setOverlayWorldPosition: function () {
        var screenPosition = new pc.Vec3();
        var startPosition = null;

        if (this._currentTutorialStep.tile) {
            startPosition = GridManager.instance.calculatePosition(this._currentTutorialStep.tile.x, this._currentTutorialStep.tile.y, 0);

        } else if (this._currentTutorialStep.tile1 && this._currentTutorialStep.tile2) {
            startPosition = GridManager.instance.calculatePosition(
                (this._currentTutorialStep.tile1.x + this._currentTutorialStep.tile2.x) / 2,
                (this._currentTutorialStep.tile1.y + this._currentTutorialStep.tile2.y) / 2,
                0
            );
        }


        PerspectiveView.instance.entity.camera.worldToScreen(startPosition, screenPosition);
        screenPosition.mul(new pc.Vec3(1, ViewportManager.instance.getDPR(), 0));

        var scale = UIManager.instance.getScale();
        var width = ViewportManager.instance.width;

        this.focusOverlay.setLocalPosition((screenPosition.x - width / 2) / scale * ViewportManager.instance.getDPR(), (-screenPosition.y / scale + 640), 0);

        var overlayScale = this.scaleCurve.value(this._getRadius() / 100);

        this._setScale(overlayScale)
    },

    update: function () {
        if (this._follow) {
            this.focusOverlay.setPosition(this._targetEntity.getPosition());
        }
    },

    focus: function (obj) {
        switch (obj) {
            case 'objective':
                this.enableOverlay(true);
                this.setOverlayPosition(this.objectiveEntity);
                break;

            case 'move':
                this.setOverlayPosition(this.moveEntity);
                break;
        }
    },

    _getRadius: function () {
        return Math.abs(PerspectiveView.instance.entity.parent.getLocalPosition().z);
    },

    _setScale: function (scale) {
        this.focusOverlay.setLocalScale(scale, scale, scale);
    },
});


// PyzomathDataReader.js
var PyzomathDataReader = {};

PyzomathDataReader.objectiveTypeLink = Object.freeze({
    0: objectiveTypesEnum.ORDER,
    1: objectiveTypesEnum.ORDER,
    2: objectiveTypesEnum.ORDER,
    3: objectiveTypesEnum.ORDER,
    4: objectiveTypesEnum.SCORE,
    5: objectiveTypesEnum.ORDER,
});

pc.extend(PyzomathDataReader, {
    getColumns: function(levelData) {
        return levelData.levelSettings.maxHorSize;
    },

    getRows: function(levelData) {
        return levelData.levelSettings.maxVertSize;
    },

    getColors: function(levelData) {
        return levelData.levelSettings.maxNrOfColors;
    },

    getMoves: function(levelData) {
        var moveData = levelData.levelSettings.triggers.find(function(trigger) {
            return trigger.consequence === 1;
        });
        return moveData.conditions[0].maxSetting;
    },

    getObjectives: function(levelData) {
        var objectives = levelData.levelSettings.triggers.find(function(trigger) {
            return trigger.consequence === 0;
        }).conditions;
        var translatedObjectives = [];

        for (var i = 0; i < objectives.length; i += 1) {
            var objective = objectives[i];

            var objectiveType = PyzomathDataReader.objectiveTypeLink[objective.conditionType];


            switch (objectiveType) {
                case objectiveTypesEnum.ORDER:
                    var layerID = objective.elements[0].hasOwnProperty('background') ? tileLayerEnum.BACKGROUND : tileLayerEnum.FOREGROUND;
                    var typeID = layerID === tileLayerEnum.BACKGROUND ? objective.elements[0].background : objective.elements[0].foreground;
                    translatedObjectives.push({
                        objectiveType: objectiveType,
                        goal: objective.maxSetting,
                        orderTypeObject: { 
                            layerID: layerID,
                            typeID: TileLibrary.instance.getOriginalTypeID(layerID, typeID),
                            colorID: objective.elements[0].hasOwnProperty('color') ? ColorManager.instance.getColorInOrder(objective.elements[0].color) : 0
                        }
                    });
                    break;

                case objectiveTypesEnum.SCORE:
                    translatedObjectives.push({
                        objectiveType: objectiveType,
                        goal: objective.maxSetting,
                        orderTypeObject: {}
                    });
                    break;
                    
                default: 
                    console.warn("Type is not recognized:", objectiveType, PyzomathDataReader.objectiveTypeLink);
                    break;

            }
        }
        return translatedObjectives;
    },

    getTiles: function(levelData) {
        return levelData.grid.startingState;
    },

    getStarValues: function(levelData) {
        return levelData.starValues;
    }
});

// ShopItem.js
var ShopItem = pc.createScript('shopItem');

var cooldownStates = Object.freeze({ AVAILABLE: 0, ONCOOLDOWN: 1, NOT_AVAILABLE: 2, INIT: 3 });

ShopItem.attributes.add('coinTemplate', { type: 'asset', assetType: 'template' });
ShopItem.attributes.add('coinPerXAmount', { type: 'number', default: 20, title: '1 coin per this amount' });
ShopItem.attributes.add('coinAnimGroup', { type: 'entity' });
ShopItem.attributes.add('endPoint', { type: 'entity' });
ShopItem.attributes.add('key', { type: 'string' });
ShopItem.attributes.add('cooldown', { type: 'number', title: 'Cooldown in Hours' });
ShopItem.attributes.add('buyButtonEntity', { type: 'entity' });
ShopItem.attributes.add('buttonText', { type: 'entity' });
ShopItem.attributes.add('coinSpawn', { type: 'entity' });
ShopItem.attributes.add('coinReward', {
    type: 'json', schema: [{
        name: 'coinTextEntity',
        type: 'entity'
    }, {
        name: 'rewardAmount',
        type: 'number'
    }, {
        name: 'rewardPerAdAmountTextEntity',
        type: 'entity'
    }, {
        name: 'rewardPerAdAmount',
        type: 'number'
    }]
});
ShopItem.attributes.add('boosterRewards', {
    type: 'json', schema: [{
        name: 'rewardAmount',
        type: 'number'
    }, {
        name: 'inventoryKey',
        type: 'string'
    }], array: true
});
ShopItem.attributes.add('boosterRewardsTemplate', {
    type: 'json', schema: [{
        name: 'template',
        type: 'asset',
        assetType: 'template'
    }, {
        name: 'parent',
        type: 'entity'
    }]
});
ShopItem.attributes.add('adCost', {
    type: 'json', schema: [{
        name: 'amount',
        type: 'number'
    }, {
        name: 'textEntity',
        type: 'entity'
    }]
});
ShopItem.attributes.add('adProgression', {
    type: 'json', schema: [{
        name: 'template',
        type: 'asset',
        assetType: 'template'
    }, {
        name: 'parent',
        type: 'entity'
    }]
});

pc.extend(ShopItem.prototype, {
    init: function () {
        this.setItem();
        this.buyButtonEntity.script.elementInput.on(inputEvents.CLICK, this._onClick, this);

        this.data = { adsWatched: 0, time: 0 };

        this.buttonTextKey = this.buttonText.element.key;
        this.buttonUnavailableTextKey = 'AD_NOT_AVAILABLE_BUTTON';

        this.adIcon = this.entity.findByName('Ad icon');
        this.currentState = null //cooldownStates.AVAILABLE;

        this.currentTime = new Date();
        this.supported = Wrapper.instance.hasFeature('rewarded');



        this.onState(true);

        this.on('state', this.onState, this);
    },

    onState: function (enabled) {
        if (!this.supported) {
            return;
        }

        if (enabled) {
            this.interval = setInterval(() => {
                if (this.currentState === cooldownStates.AVAILABLE || this.currentState === cooldownStates.NOT_AVAILABLE) {
                    this.setState(cooldownStates.AVAILABLE);
                }
            }, 1000);
        } else {
            clearInterval(this.interval);
            delete this.interval;
        }
    },

    update: function () {
        this.currentTime = Date.now();
        switch (this.currentState) {
            case cooldownStates.ONCOOLDOWN:
                var timeUntilReset = this.timeTilReset();
                timeUntilReset = pc.utils.millisecondsToTimeFormat(timeUntilReset);
                this.setItemText(timeUntilReset);

                if (this.currentTime > this.resetTime) {
                    this.setState(cooldownStates.AVAILABLE);
                    this.setItemKey();
                }
                break;
        }
    },


    _onClick: function () {

        if (this.currentState === cooldownStates.AVAILABLE) {
            this.watchAd();
        }
    },

    setItem: function () {
        this.coinReward.coinTextEntity.element.text = this.coinReward.rewardAmount;
        this.progressionOrbs = [];
        if (this.adCost.amount > 1) this.coinReward.rewardPerAdAmountTextEntity.element.text = '+' + this.coinReward.rewardPerAdAmount;

        if (this.boosterRewardsTemplate.parent) {
            this.emptyGroup(this.boosterRewardsTemplate.parent);

            for (var i = 0; i < this.boosterRewards.length; i += 1) {
                var reward = this.boosterRewardsTemplate.template.resource.instantiate();
                reward.reparent(this.boosterRewardsTemplate.parent);

                var stockItem = BoosterShopManager.instance._getStockByinventoryKey(this.boosterRewards[i].inventoryKey);
                reward.children[0].element.spriteAsset = stockItem.image.id;
                reward.children[1].element.text = 'x' + this.boosterRewards[i].rewardAmount;
            }
        }
        //set the orbs for the amount of ads to watch
        if (this.adCost.amount > 1) {
            this.adCost.textEntity.element.text = this.adCost.amount;

            if (this.adProgression.parent) {

                this.emptyGroup(this.adProgression.parent);

                for (var i = 0; i < this.adCost.amount; i += 1) {
                    var progression = this.adProgression.template.resource.instantiate();
                    this.progressionOrbs.push(progression);
                    progression.reparent(this.adProgression.parent);

                }
            }
        }
    },

    emptyGroup: function (group) {
        for (var i = group.children.length - 1; i >= 0; i -= 1) {
            group.children[i].destroy();
        }
    },

    watchAd: function () {
        if (this.clicked) {
            return;
        }
        this.clicked = true;

        Wrapper.instance.rewardedAd(this.rewardAd, this);
    },

    rewardAd: function (result) {
        if (result.rewardGranted) {
            this.data.adsWatched++;
            // StatisticsManager.instance.incrementStatistic(this.key + "_total_ads_watched", 1, true);



            if (this.adCost.amount > 1) {
                //Inventory.instance.addItem('COINS', this.coinReward.rewardPerAdAmount);
                //this.app.fire('Audio:sfx', 'coin_gain_single.mp3');
                //this.app.fire('CoinInterface:updateCoins');
                Inventory.instance.addItem('COINS', this.coinPerXAmount, 'reward', 'rewardedAd');
                this.createNewCoins(this.amountOfCoins(this.coinReward.rewardPerAdAmount), this.coinPerXAmount, 0.6);
            }


            this.updateAdsWatched();
            this.fire('updateAdSaveData');
            if (this.data.adsWatched >= this.adCost.amount) {

                this.addCoins(this.coinReward.rewardAmount);
                this.addBoosterRewards();

                // StatisticsManager.instance.incrementStatistic(this.key + "_reward_gotten", 1, true);
                StatisticsManager.instance.incrementStatistic("coins_received", this.coinReward.rewardAmount);


                this.data.adsWatched = 0;
                this.data.time = Date.now();

                this.updateAdsWatched();
                this.setResetTime();
                this.setState(cooldownStates.ONCOOLDOWN);
                this.fire('updateAdSaveData');
            }
        }

        this.clicked = false;
    },

    updateAdsWatched: function () {
        if (this.adProgression.parent) {
            for (var i = 0; i < this.progressionOrbs.length; i++) {
                this.progressionOrbs[i].children[1].enabled = i < this.data.adsWatched;
            }
        }
    },

    getData: function () {
        return this.data;
    },

    getKey: function () {
        return this.key;
    },

    setData: function (data) {
        if (data) {
            this.data = data;
        }
        this.updateAdsWatched();
    },

    hoursToMilliSeconds: function (hours) {
        var mins = hours * 60;
        var secs = mins * 60;
        var ms = secs * 1000;

        return ms;
    },

    setResetTime: function () {
        this.resetTime = this.data.time + this.hoursToMilliSeconds(this.cooldown);
    },

    setItemText: function (time) {
        if (this.buttonText.element.key !== time) {
            this.buttonText.element.key = time;
        }
    },

    setItemKey: function () {
        this.buttonText.element.key = this.currentState === cooldownStates.AVAILABLE ? this.buttonTextKey : this.buttonUnavailableTextKey;

        this.adIcon.enabled = this.currentState !== cooldownStates.NOT_AVAILABLE;
    },

    timeTilReset: function () {
        return this.resetTime - this.currentTime;
    },

    setState: function (state) {
        const previousState = this.currentState;

        if (state === cooldownStates.AVAILABLE) {
            if (!Wrapper.instance.hasFeature("rewarded")) {
                state = cooldownStates.NOT_AVAILABLE;
            } else {
                if (Wrapper.instance.hasRewardedAd()) {
                    this.currentState = state;
                } else {
                    state = cooldownStates.NOT_AVAILABLE;
                }
            }
        }

        this.currentState = state;
        if (this.currentState !== previousState) {
            this.buyButtonEntity.element.color = this.currentState === cooldownStates.AVAILABLE ? pc.Color.WHITE : ShopItem.GREY;
            this.setItemKey();
        }

    },

    checkCooldown: function () {
        if (this.data.time) {
            if (this.currentTime > this.resetTime) {
                this.setState(cooldownStates.AVAILABLE);
            } else {
                this.setResetTime();
                this.setState(cooldownStates.ONCOOLDOWN);
            }
        } else {
            this.setState(cooldownStates.AVAILABLE);
        }

        if (!Wrapper.instance.hasFeature('rewarded')) {
            this.setState(cooldownStates.NOT_AVAILABLE);
        }

        if (this.currentState !== cooldownStates.ONCOOLDOWN) {
            this.setItemKey();
        }
    },

    addBoosterRewards: function () {
        for (var i = 0; i < this.boosterRewards.length; i++) {
            Inventory.instance.addItem(this.boosterRewards[i].inventoryKey, this.boosterRewards[i].rewardAmount, 'reward', 'rewardedAd');
        }
    },

    addCoins: function () {
        this.createNewCoins(this.amountOfCoins(this.coinReward.rewardAmount), this.coinPerXAmount);
        Inventory.instance.addItem('COINS', this.coinReward.rewardAmount, 'reward', 'rewarded');

    },

    createNewCoins(amount, coinPerXAmount, time) {
        this.endPosition = this.endPoint.getLocalPosition();

        for (var i = 0; i < amount; i++) {
            var coin = this.coinTemplate.resource.instantiate();
            coin.enabled = true;
            coin.reparent(this.coinAnimGroup);
            coin.setPosition(this.coinSpawn.getPosition());
            coin.script.coinAnimation.playAnimation(this.endPosition, amount, coinPerXAmount, time, i);
        }
    },

    amountOfCoins(amount) {
        return Math.round(amount / this.coinPerXAmount);
    }

});

ShopItem.GREY = new pc.Color().fromString('AEAEAE');

// CoinInterface.js
var CoinInterface = pc.createScript('coinInterface');

CoinInterface.attributes.add('addCoinsButton', { type: 'entity' });
CoinInterface.attributes.add('coinTextEntity', { type: 'entity' });
CoinInterface.attributes.add('showGarden', { type: 'boolean' });

pc.extend(CoinInterface.prototype, {
    initialize: function () {
        this.addCoinsButton.script.elementInput.on(inputEvents.CLICK, this._onClick, this);

        this.on('enable', this.onEnable, this);
        this.on('disable', this.onDisable, this);
    },

    postInitialize: function () {
        this.onEnable();
    },

    onEnable: function () {
        this.setCoinAmount();

        this.app.on('CoinInterface:updateCoins', this.setCoinAmount, this);
        this.app.on('CoinInterface:addCoins', this.addCoinAmount, this);
    },

    onDisable: function () {
        this.app.off('CoinInterface:updateCoins', this.setCoinAmount, this);
        this.app.off('CoinInterface:addCoins', this.addCoinAmount, this);
    },

    onUIEntityOpen: function () {
        this.setCoinAmount();
    },

    setCoinAmount: function (coinAmount = Inventory.instance.getItem('COINS')) {
        this.coinTextEntity.element.text = coinAmount;

        this.amount = coinAmount;
    },

    addCoinAmount: function (coins) {
        this.amount += coins;
        this.coinTextEntity.element.text = this.amount;
    },

    _onClick: function () {
        this.app.fire('UIManager:showUI', 'Shop', this.showGarden);
        this.app.fire('UIManager:hideUI', 'Garden')
    }
});

// PerspectiveView.js
var PerspectiveView = pc.createScript('perspectiveView');

var defaultString = "------------------------------------------------------";

PerspectiveView.attributes.add('padding', { type: 'number', min: 0, max: 0.3, precision: 2 });
PerspectiveView.attributes.add('desktopClamp', { type: 'number', default: 1600 });

PerspectiveView.attributes.add('a', { type: 'string', title: 'Desktop Landscape', default: defaultString });

PerspectiveView.attributes.add('landscapeWidthDesktop', { type: 'number', default: 0.75, max: 1, min: 0 });
PerspectiveView.attributes.add('landscapeHeightDesktop', { type: 'number', default: 0.8, max: 1, min: 0 });

PerspectiveView.attributes.add('b', { type: 'string', title: 'Desktop Portrait', default: defaultString });

PerspectiveView.attributes.add('portraitWidthDesktop', { type: 'number', default: 1.0, max: 1, min: 0 });
PerspectiveView.attributes.add('portraitHeightDesktop', { type: 'number', default: 0.67, max: 1, min: 0 });

PerspectiveView.attributes.add('c', { type: 'string', title: 'Mobile Landscape', default: defaultString });

PerspectiveView.attributes.add('landscapeWidthMobile', { type: 'curve' });
PerspectiveView.attributes.add('landscapeHeightMobile', { type: 'number', default: 1, max: 1, min: 0 });

PerspectiveView.attributes.add('d', { type: 'string', title: 'Mobile Portrait', default: defaultString });

PerspectiveView.attributes.add('portraitWidthMobile', { type: 'number', default: 1, max: 1, min: 0 });
PerspectiveView.attributes.add('portraitHeightMobile', { type: 'number', default: 0.8, max: 1, min: 0 });

PerspectiveView.attributes.add('tweenEntity', { type: 'entity' });

Object.defineProperty(PerspectiveView.prototype, 'camera', {
    get: function () {
        return this._camera;
    },
});

pc.extend(PerspectiveView.prototype, {
    initialize: function () {
        PerspectiveView.instance = this;

        this._radius = this.entity.getLocalPosition().z;

        this._camera = this.entity.camera;

        this.app.on('ViewportManager:onResize', this._onResize, this);
        this._referenceResolution = UIManager.instance.getReferenceResolution();
        this._onResize(Wrapper.instance.getOrientation(), ViewportManager.instance.width, ViewportManager.instance.height, ViewportManager.instance.getDevice());

    },

    _onResize: function (orientation, width, height, device) {
        this._orientation = orientation;
        this._device = device;

        this._heightWidthRatio = height / width;

        var widthReference = width * this._referenceResolution.y / height;

        if (this._device === deviceEnum.DESKTOP) {
            widthReference = Math.min(widthReference, this.desktopClamp);
        }

        this._widthRatio = widthReference / this._referenceResolution.y;
        this._heightRatio = 1;

        this.focus();
    },

    setAABB: function (aabb) {
        this._aabb = aabb;
        this.focus();
    },

    focus: function () {
        if (!this._aabb) {
            return;
        }

        var fov = this._camera.fov;

        var width = 0;
        var height = 0;

        switch (this._orientation) {
            case 'portrait':
                width = this._aabb.halfExtents.x / this._widthRatio / (1 - this.padding) / (1 - (this._device === deviceEnum.DESKTOP ? this.portraitWidthDesktop : this.portraitWidthMobile));
                height = this._aabb.halfExtents.y / this._heightRatio / (1 - this.padding) / (1 - (this._device === deviceEnum.DESKTOP ? this.portraitHeightDesktop : this.portraitHeightMobile));
                break;

            case '':
            case 'landscape':
                width = this._aabb.halfExtents.x / this._widthRatio / (1 - this.padding) / (1 - (this._device === deviceEnum.DESKTOP ? this.landscapeWidthDesktop : this.landscapeWidthMobile.value(this._heightWidthRatio)));
                height = this._aabb.halfExtents.y / this._heightRatio / (1 - this.padding) / (1 - (this._device === deviceEnum.DESKTOP ? this.landscapeHeightDesktop : this.landscapeHeightMobile));
                break;

            default:
                console.warn("Something went wrong with the orientation", this._orientation);
                break;
        }

        var distanceX = width / Math.tan(fov / 2 * Math.PI / 180);
        var distanceY = height / Math.tan(fov / 2 * Math.PI / 180);

        this._radius = Math.max(distanceX, distanceY);

        this._stopTweens();

        //this.resetParentPosition();

        this.entity.setLocalEulerAngles(0, 0, 0);
        //this.entity.setLocalPosition(this._aabb.center.x, this._aabb.center.y, this._radius);
        this.app.fire('PerspectiveView:onCameraChange', this._radius);

        this.fire('complete');
    },

    getRadius: function () {
        return this._radius;
    },

    getOffset: function () {
        return { x: this._aabb.center.x, y: this._aabb.center.y, z: this._radius };
    },

    tweenAngle: function (degree, degreePerSeconds) {
        if (typeof degree !== 'number') {
            return;
        }
        var position = this._calculatePosition(degree);

        var currentDegree = this.entity.getLocalEulerAngles().x;

        var deltaDegree = Math.abs(currentDegree - degree);

        if (deltaDegree === 0) {
            return;
        }

        this._stopTweens();

        this._positionTween = this.entity
            .tween(this.entity.getLocalPosition())
            .to({ x: position.x, y: position.y, z: position.z }, deltaDegree / degreePerSeconds, pc.CubicInOut)
            .start();

        var self = this;
        this._rotationTween = this.entity
            .tween(this.entity.getLocalRotation())
            .rotate({ x: degree, y: 0, z: 0 }, deltaDegree / degreePerSeconds, pc.CubicInOut)
            .start(true);

        this._rotationTween.on('complete', function () {
            self.fire('complete');
        });
    },

    tweenEndAnimation: function () {
        var position = this._calculatePosition(50);

        this._stopTweens();

        var self = this;

        this._positionTween = this.entity
            .tween(this.entity.getLocalPosition())
            .to({ x: position.x, y: position.y, z: position.z }, 2, pc.CubicInOut)
            .start();

        this._rotationTween = this.entity
            .tween(this.entity.getLocalRotation())
            .rotate({ x: 50, y: 0, z: 0 }, 2, pc.CubicInOut)
            .start(true);

        this._parentPositionTween = this.tweenEntity
            .tween(this.tweenEntity.getLocalPosition())
            .to({ x: 0, y: this.entity.getLocalPosition().z / 2, z: 0 }, 2, pc.CubicInOut, 1)
            .start();

        this._parentPositionTween.on('complete', function () {
            self.fire('complete');
        });
    },
    resetParentPosition: function () {
        this.tweenEntity.setLocalPosition(0, 0, 0);
    },

    _stopTweens: function () {
        if (this._positionTween) {
            this._positionTween.stop();
        }

        if (this._rotationTween) {
            this._rotationTween.stop();
        }

        if (this._parentPositionTween) {
            this._parentPositionTween.stop();
        }
    },

    setAngle: function (degree) {
        var position = this._calculatePosition(degree);

        //this.entity.setLocalPosition(position);
        this.entity.setLocalEulerAngles(degree, 0, 0);
    },

    _calculatePosition: function (degree) {
        var position = new pc.Vec3(this._aabb.center.x, this._aabb.center.y, 0);

        var z = this._radius * Math.cos(degree * Math.PI / 180);
        var y = this._radius * Math.sin(degree * Math.PI / 180);

        position.set(position.x, position.y - y, z);
        return position;
    },

});


// LoseScreen.js
var LoseScreen = pc.createScript('loseScreen');

LoseScreen.attributes.add('objectiveEntities', { type: 'entity', array: true });
LoseScreen.attributes.add('boosterButtonEntities', { type: 'entity', array: true });
LoseScreen.attributes.add('retryLevelButton', { type: 'entity' });
LoseScreen.attributes.add('buttons', { type: 'entity' });

pc.extend(LoseScreen.prototype, {
    initialize: function () {
        this.retryLevelButton.script.elementInput.on(inputEvents.CLICK, this._startLevel, this);
        this.app.on('StartLevelButton:onLevelStart', this._onLevelStart, this);
    },

    onUIEntityOpen: function () {
        LivesManager.instance.reduceLife(1, 'lose');

        this.buttons.enabled = false;
        this.getObjectiveData();
        this.getBoosters();
        this._retry = false;

        var self = this;

        this.app.fire('Audio:sfx', 'level_lose.mp3');
        this.app.fire('AudioManager:stopBgm');

        TrackingManager.instance.levelEnd(false);

        pc.timer.add(1, () => {
            GameManager.instance.trackEventLevelFail()
                .then(() => {
                    this.app.fire('UIManager:showUI', 'FloatingUI');
                    this.app.fire('ToggleElementPerScreen:update');

                    self.buttons.enabled = true;
                });
        }, this);

        LevelManager.instance.reset();
    },

    onUIEntityCloseFinish: function () {
        if (this._retry) {
            // this.app.fire('Audio:bgm', 'ingame_ost_world' + LevelManager.instance.currentChapter + '.mp3');
            LevelManager.instance.startLevel(LevelManager.instance.currentLevel, LevelManager.instance.currentChapter, true, false, false);
        }
    },

    getBoosters: function () {
        for (var i = 0; i < this.boosterButtonEntities.length; i += 1) {
            this.boosterButtonEntities[i].script.preBoosterButton.getInventoryAmount();
        }
    },

    getObjectiveData: function () {
        var objectives = ObjectiveManager.instance.getObjectives();

        for (var i = 0; i < this.objectiveEntities.length; i += 1) {
            if (i >= objectives.length) {
                this.objectiveEntities[i].enabled = false;
                return;
            }
            this.objectiveEntities[i].enabled = true;
            this.objectiveEntities[i].script.popupObjectiveUI.setGoal(objectives[i].orderTypeObject, objectives[i].values.goal);
            this.objectiveEntities[i].script.popupObjectiveUI.setResult(objectives[i].values.current);
        }
    },

    _startLevel: function () {
        if (LivesManager.instance.hasLives()) {
            this._retry = true;

            for (var i = 0; i < this.boosterButtonEntities.length; i += 1) {
                this.boosterButtonEntities[i].script.preBoosterButton.activateBooster();
            }

            this.app.fire('UIManager:hideAll');
        } else {
            this.app.fire('UIManager:showUI', 'FloatingUI');
            this.app.fire('UIManager:showUI', 'NoMoreLivesScreen');
        }
    },
});

// WinScreen.js
var WinScreen = pc.createScript('winScreen');

WinScreen.attributes.add('tweenStarObjects', { type: 'entity', array: true });
WinScreen.attributes.add('staticStarObjects', { type: 'entity', array: true });
WinScreen.attributes.add('starStartObjects', { type: 'entity', array: true });
WinScreen.attributes.add('tweenStarGoal', { type: 'entity' });

WinScreen.attributes.add('progressBarEntity', { type: 'entity' });
WinScreen.attributes.add('progressBarFill', { type: 'entity' });
WinScreen.attributes.add('progressBarBg', { type: 'entity' });
WinScreen.attributes.add('progressBarTextEntity', { type: 'entity' });
WinScreen.attributes.add('progressBarDescriptionTextEntity', { type: 'entity' });
WinScreen.attributes.add('progressBarObjectImageEntity', { type: 'entity' });

WinScreen.attributes.add('scoreTextEntity', { type: 'entity' });
WinScreen.attributes.add('levelTickerEntity', { type: 'entity' });

WinScreen.attributes.add('buttonGroup', { type: 'entity' });
WinScreen.attributes.add('completionShinePulse', { type: 'entity' });
WinScreen.attributes.add('completionShineStay', { type: 'entity' });
WinScreen.attributes.add('robertCharacterEntity', { type: 'entity' });
WinScreen.attributes.add('robertTextBalloonEntity', { type: 'entity' });
WinScreen.attributes.add('robertTutorialText', { type: 'entity' });
WinScreen.attributes.add('robertElementGroup', { type: 'entity' });

pc.extend(WinScreen.prototype, {

    getCurrentObjective() {
        this.currentObjectiveObject = GardenDataManager.instance.getNextUnlockableObject(); // Can be null/undefined

        if (this.currentObjectiveObject) {
            this.currentObjectiveCost = this.currentObjectiveObject.costSingle;
            this.currentAreaStars = this.currentObjectiveObject.stars;
            this.objectivePreviouslyFinished = this.currentObjectiveObject.complete;
        }
    },

    playWinSound: function () {
        this.app.fire('AudioManager:stopBgm');
        this.winSound = AudioManager.instance.playSFX('level_win.mp3');
        if (this.winSound) {
            this.winSound.once('end', this._playWinBGM, this);
        } else {
            this._playWinBGM();
        }
    },

    showCompletionShine() {
        this.completionShineStay.enabled = this.objectivePreviouslyFinished;
    },

    checkToForceGarden(flowerUnlocked) {
        if (flowerUnlocked || this.objectivePreviouslyFinished) {
            this.buttonGroupScript.setButtonsToGarden();
        }
    },

    onUIEntityOpen: function (args) {
        FirstTimeUserManager.instance.ftue = false;

        const level = args.currentLevel;
        const newScore = args.newScore;
        const newStarScore = args.newStars;
        const oldStarScore = LevelDataManager.instance.getStars(level);
        TrackingManager.instance.levelEnd(true);
        this.starsAddedInCurrentCycle = 0;
        this.getCurrentObjective();


        this.playWinSound();
        this.resetObjects();



        this.buttonGroupScript.setNextButton(args.replayingLevel);
        this.checkToForceGarden(args.flowerUnlocked);
        this.showCompletionShine();
        this.playStarSounds(newStarScore);

        this.onCurrentObjective();
        this.setScore();

        this.setStars(newStarScore, oldStarScore)
        this.setTimer()

    },

    setScore: function () {
        var score = ScoreManager.instance.getScore();
        this.scoreTextEntity.element.text = score;
        this.levelTickerEntity.element.text = 'Level ' + LevelManager.instance.currentLevel;
    },

    setStars: function (newStarScore, oldStarScore) {
        let starsTweened = 0;

        for (let i = 0; i < this.tweenStarObjects.length; i++) {
            if (newStarScore > oldStarScore) {
                if (i < oldStarScore) {
                    this.staticStarObjects[i].enabled = true;
                }
                else if (i >= oldStarScore && i < newStarScore) {
                    this.playStarToBarTween(this.tweenStarObjects[i], i, i);
                    starsTweened++;
                }

            } else {
                if (i < oldStarScore) {
                    this.staticStarObjects[i].enabled = true;
                }
            }
        }
    },

    setTimer() {
        if (this.currentObjectiveObject) {
            this.buttonTimer = pc.timer.add(3, this.animationsFinished, this);
        } else {
            this.buttonTimer = pc.timer.add(1, this.animationsFinished, this);
        }
    },

    onCurrentObjective: function () {
        if (!this.currentObjectiveObject) { return }
        this.progressBarEntity.enabled = true;
        var objValues = GardenDataManager.instance.getObjectValues(parseInt(LevelManager.instance.currentChapter), this.currentObjectiveObject.name);

        if (!objValues) {
            console.warn("something went wrong", parseInt(LevelManager.instance.currentChapter), this.currentObjectiveObject.name);
            delete this.currentObjectiveObject;
            return
        }
        var areaStars = GardenDataManager.instance.getAreaStars();
        var sprite = this.app.assets.get(objValues.spriteId);
        var imageSize = sprite.resource.atlas.frames[sprite.resource.frameKeys[0]].rect;

        this.progressBarDescriptionTextEntity.element.key = objValues.descriptionKey;
        this.progressBarObjectImageEntity.element.spriteAsset = sprite;
        this.progressBarObjectImageEntity.element.width = imageSize.z;
        this.progressBarObjectImageEntity.element.height = imageSize.w;

        this.objectiveProgress = 0;
        let objectiveCost = this.currentObjectiveObject.cost;
        let currentTotalStars = this.currentObjectiveObject.totalStars;
        this.setProgressionBarProgress(false);

        if (objectiveCost <= currentTotalStars) objectiveProgress = objectiveCost;
        else objectiveProgress = currentTotalStars;


    },

    onUIEntityClose: function () {
        this.robertCharacterEntity.script.MoveUITween.doCloseAnimation();
        if (this.winSound) {
            this.winSound.off('end', this._playWinBGM, this);
        }
        this.app.fire('WinScreen:close');
        this.app.fire('ParticleManager:disableParticles');
        this.app.fire('Audio:bgm', 'main_ost.mp3');

    },

    resetObjects: function () {
        this.buttonGroupScript = this.buttonGroup.script.winScreenButtons;

        for (let i = 0; i < this.tweenStarObjects.length; i++) {
            this.staticStarObjects[i].enabled = false;
            this.tweenStarObjects[i].enabled = false;
            this.tweenStarObjects[i].setLocalPosition(this.starStartObjects[i].getLocalPosition());
        }
        this.buttonGroup.enabled = false;
        this.robertElementGroup.enabled = false;
        this.robertTextBalloonEntity.enabled = false;
        this.completionShinePulse.enabled = false;
        this.completionShineStay.enabled = false;
        this.buttonGroupScript.resetButtons();
        this.robertFlag = false;
        this.completed = false;
    },

    playStarSounds: function (starScore) {
        if (starScore === 2) {
            pc.timer.add(WinScreen.INITIAL_TWEEN_DELAY, this._playStarSound.bind(this, 0), this);
            pc.timer.add(WinScreen.INITIAL_TWEEN_DELAY + WinScreen.DELAY_BETWEEN_STARS * 2, this._playStarSound.bind(this, 1), this);
        } else {
            for (let i = 0; i < starScore; i++) {
                pc.timer.add(WinScreen.INITIAL_TWEEN_DELAY + i * WinScreen.DELAY_BETWEEN_STARS, this._playStarSound.bind(this, i), this);
            }
        }
    },

    playStarToBarTween: function (starToTween, delayMultiplier, staticStarElement) {
        var duration = WinScreen.DELAY_BETWEEN_STARS;
        var delayTime = 2 + duration * delayMultiplier;
        starToTween.enabled = true;
        this.staticStarObjects[staticStarElement].enabled = true;

        if (!this.currentObjectiveObject) {
            return;
        }

        var tween1 = starToTween.tween(starToTween.getLocalPosition())
            .to({ x: this.tweenStarGoal.getLocalPosition().x, y: this.tweenStarGoal.getLocalPosition().y, z: this.tweenStarGoal.getLocalPosition().z }, duration, pc.SineInOut)
            .delay(delayTime)
            .start();

        tween1.on('complete', this.setProgressionBarProgress.bind(this, true), this)

        var tween2 = starToTween.tween(starToTween.getLocalScale())
            .to({ x: 5, y: 5, z: 5 }, duration * 0.66, pc.SineInOut)
            .delay(delayTime);
        var tween3 = starToTween.tween(starToTween.getLocalScale())
            .to({ x: 0, y: 0, z: 0 }, duration * 0.33, pc.SineInOut);
        tween2.chain(tween3).start();
    },

    setProgressionBarProgress: function (incrementCounter) {
        var currentObjectiveProgress = this.currentAreaStars;

        if (incrementCounter) {
            this.app.fire('vibrate', 75);
            this.starsAddedInCurrentCycle++;
        }
        currentObjectiveProgress += this.starsAddedInCurrentCycle;
        currentObjectiveProgress = pc.math.clamp(currentObjectiveProgress, 0, this.currentObjectiveCost);


        var goal = (this.progressBarBg.element.width / this.currentObjectiveCost) * currentObjectiveProgress;
        goal = pc.math.clamp(goal, 0, this.progressBarBg.element.width);
        var tween = this.entity.tween(this.progressBarFill.element)
            .to({ width: goal }, 0.15, pc.BackOut)
            .start();

        this.progressBarTextEntity.element.text = "" + currentObjectiveProgress + "/" + this.currentObjectiveCost;
        if (!this.objectivePreviouslyFinished && currentObjectiveProgress === this.currentObjectiveCost) {
            this.playBarFinishAnimation();
            this.buttonGroupScript.setButtonsToGarden();
        } else {
            // This is used for testing the tween of Robert.
            // pc.timer.add(1, this._enableRobert, this);
        }
    },

    playBarFinishAnimation: function () {
        this.completionShinePulse.enabled = true;
        this.completionShineStay.enabled = true;
        pc.timer.add(2, this._enableRobert, this);
    },

    animationsFinished: function () {
        pc.timer.add(1, () => {
            GameManager.instance.trackEventLevelSuccess()
                .then(() => {
                    this.buttonGroup.enabled = true;
                    var ftue = StorageManager.instance.get('gardenFTUE');

                    if (this.completionShinePulse.enabled || this.objectivePreviouslyFinished || ftue) {
                        this.buttonGroupScript.setButtonPulse();
                        this.app.fire('GardenTasksScreen:moveToArea', Number.parseInt(LevelManager.instance.currentChapter));
                    } else {
                        this.buttonGroupScript.setNextButtonPulse();
                    }

                    if ((this.currentObjectiveObject && this.currentObjectiveObject.complete) || ftue) {
                        this._enableRobert();
                    }

                    this.robertTutorialText.element.key = "WIN_SCREEN_TASK_COMPLETE"
                    if (ftue) {
                        this.robertTutorialText.element.key = "WIN_SCREEN_FTUE"
                    }
                });
        });
    },

    _enableRobert: function () {
        if (this.robertFlag === true) return;
        this.robertElementGroup.enabled = true;
        this.robertTextBalloonEntity.enabled = true;
        this.robertCharacterEntity.script.MoveUITween.doOpenAnimation();
        this.robertFlag = true;
    },

    _playStarSound: function (index) {
        this.app.fire('Audio:sfx', 'win_star_' + (index + 1) + '.mp3');
        this.app.fire('vibrate', 50 + index * 50);
    },

    _playWinBGM: function () {
        this.app.fire('Audio:bgm', 'level_win_ost.mp3');
    },
});

WinScreen.DELAY_BETWEEN_STARS = 0.5;
WinScreen.INITIAL_TWEEN_DELAY = 0.8;

// OutOfMovesScreen.js
var OutOfMovesScreen = pc.createScript('outOfMovesScreen');

OutOfMovesScreen.attributes.add('objectiveEntities', { type: 'entity', array: true });
OutOfMovesScreen.attributes.add('addMovesButtonAd', { type: 'entity' });
OutOfMovesScreen.attributes.add('addMovesButton', { type: 'entity' });
OutOfMovesScreen.attributes.add('addMovesPriceText', { type: 'entity' });
OutOfMovesScreen.attributes.add('addMovesPrice', { type: 'number', array: true });

pc.extend(OutOfMovesScreen.prototype, {
    initialize: function () {
        this.addMovesButton.script.elementInput.on(inputEvents.CLICK, this._onClick, this);
        this.addMovesButtonAd.script.elementInput.on(inputEvents.CLICK, this._onAdClick, this);
    },

    onUIEntityOpen: function () {
        GridManager.instance.active(false);
        this.getObjectiveData();
        this.app.fire('UIManager:showUI', 'FloatingUI');

        const amount = GameManager.instance.amountOfMovesAddedWithCoins;
        this.cost = this.addMovesPrice[amount];

        this.addMovesButton.enabled = !!this.cost;
        this.addMovesButtonAd.enabled = GameManager.instance.canUseAdsForMoves();

        this.addMovesPriceText.element.text = this.cost;
    },

    onUIEntityClose: function () {
        this.app.fire('UIManager:hideUI', 'FloatingUI');
    },

    onCloseClick: async function () {
        this.app.fire('UIManager:hideUI', 'AddMoves');

        try {
            await GameManager.instance.trackEventEnd("fail");
            this.app.fire('UIManager:showUI', 'Lose');

        } catch (e) {
            console.log(e)
        }

    },

    getObjectiveData: function () {
        var objectives = ObjectiveManager.instance.getObjectives();

        for (var i = 0; i < this.objectiveEntities.length; i += 1) {
            if (i >= objectives.length) {
                this.objectiveEntities[i].enabled = false;
                return;
            }
            this.objectiveEntities[i].enabled = true;

            this.objectiveEntities[i].script.popupObjectiveUI.setGoal(objectives[i].orderTypeObject, objectives[i].values.goal);
            this.objectiveEntities[i].script.popupObjectiveUI.setResult(objectives[i].values.current);
        }
    },

    _onClick: function () {
        if (this.clicked) {
            return;
        }

        var success = Inventory.instance.tryPayItem('COINS', this.cost, 'revive', 'moves');

        if (success) {
            if (Xsolla.instance.loggedIn) {
                Xsolla.instance.revokeUser(Inventory.instance.getXsollaSKU('COINS'), this.cost);
            }

            GameManager.instance.increaseAmountOfMovesAddedWithCoins();

            StatisticsManager.instance.incrementStatistic('revived');

            this.onSuccess(OutOfMovesScreen.NUMBER_MOVES_COINS);
            this.app.fire('CoinInterface:updateCoins');
        } else {
            this.app.fire('UIManager:showUI', 'Shop');
        }
    },

    _onAdClick: function () {
        if (this.clicked) {
            return;
        }

        this.clicked = true;

        Wrapper.instance.rewardedAd(this.rewardAd, this);
    },

    rewardAd: function (result) {
        this.clicked = false;

        if (result.rewardGranted) {
            StatisticsManager.instance.incrementStatistic('revived');
            GameManager.instance.increaseAmountOfMovesAddedWithAds();
            this.onSuccess(OutOfMovesScreen.NUMBER_MOVES_AD);
        }
    },

    onSuccess: function (amountOfMoves) {
        this.app.fire('Audio:sfx', 'coin_pay.mp3');
        MovesManager.instance.addMoves(amountOfMoves);

        if (GridManager.instance.hasExploderTriggered()) {
            // if an exploder also triggered, also add to timer of exploders for free
            GridManager.instance.addExploderTimer(amountOfMoves);
        }

        Wrapper.instance.sendGAEvent(Wrapper.GA_EVENT_TYPE.DESIGN, {
            eventId: `level_${LevelManager.instance.currentLevel}:addMoves`,
            value: amountOfMoves
        });

        GridManager.instance.checkAllPossibleMatches();

        TrackingManager.instance.addRevive();
        this.app.fire('UIManager:hideAll');
        this.app.fire('UIManager:showUI', 'Game');
        this.app.fire("GameInput:toggleGameInput", true);
    },
});

OutOfMovesScreen.NUMBER_MOVES_AD = 3;
OutOfMovesScreen.NUMBER_MOVES_COINS = 5;


// LevelDataExporter.js
var LevelDataExporter = function () {
    this.initialize();
};

pc.extend(LevelDataExporter.prototype, {
    initialize: function () {
        this.app = pc.Application.getApplication();
        this.app.on('LevelLoader:levelsLoaded', this.getAllAssets, this);
    },

    getAllAssets: function () {
        var assets = this.app.assets.findByTag('level');

        var data = {};

        for (var i = 0; i < assets.length; i++) {
            var asset = assets[i];

            var level = {};

            if (!asset.resource) {
                continue;
            }

            var triggers = asset.resource.levelSettings.triggers;

            for (var j = 0; j < triggers.length; j++) {
                var trigger = triggers[j];

                if (trigger.consequence === 1) {
                    for (var k = 0; k < trigger.conditions.length; k++) {
                        var condition = trigger.conditions[k];

                        var words = condition.name.split(' ');
                        var name = '';
                        while (!name && words.length > 0) {
                            name = words.pop();
                        }

                        switch (name) {
                            default:
                                level[name || 'turns'] = condition.maxSetting;

                                break;
                        }
                    }
                } else {
                    for (var l = 0; l < trigger.conditions.length; l++) {
                        var condition = trigger.conditions[l];

                        var words = condition.name.split(' ');
                        var name = '';
                        while ((!name || !isNaN(parseInt(name, 10)) || name === "") && words.length > 0) {
                            name = words.pop();
                        }

                        if (condition.name === " sinker 1") {
                            console.log("my name is", name)
                        }


                        switch (name) {
                            case 'default':
                                for (var m = 0; m < condition.elements.length; m++) {
                                    var element = condition.elements[m];
                                    level["default_" + ColorManager.instance.getColorInOrder(element.color)] = condition.maxSetting;
                                }

                                break;

                            case 'exploder':
                                for (var m = 0; m < condition.elements.length; m++) {
                                    var element = condition.elements[m];
                                    level["exploder_" + ColorManager.instance.getColorInOrder(element.color)] = condition.maxSetting;
                                }
                                break;
                            case 'switcher':
                                level[`${name}_${asset.resource.levelSettings.minNrOfColors}`] = condition.maxSetting;
                                break;

                            default:
                                level[name || 'turns'] = condition.maxSetting;
                                break;
                        }
                    }
                }
            }

            var levelName = asset.name.replace('level_', '').replace('.json', '');

            data[levelName] = level;

            if (Object.keys(level).length > 3) {
                console.error(level)
            }
        }

        var ordered = {};
        Object.keys(data).sort().forEach(function (key) {
            ordered[key] = data[key];
        });
        console.log(ordered);

        console.log(JSON.stringify(ordered));
    },
});

// Enable this line for the level data exporter
// var levelDataExporter = new LevelDataExporter();


// DynamicElementSize.js
var DynamicElementSize = pc.createScript('dynamicElementSize');

var defaultString = "------------------------------------------------------";

DynamicElementSize.attributes.add('a', { type: 'string', title: 'Desktop Landscape', default: defaultString });

DynamicElementSize.attributes.add('desktopLandscapeSize', { type: 'vec2', title: 'Size' });

DynamicElementSize.attributes.add('b', { type: 'string', title: 'Desktop Portrait', default: defaultString });

DynamicElementSize.attributes.add('desktopPortraitSize', { type: 'vec2', title: 'Size' });

DynamicElementSize.attributes.add('c', { type: 'string', title: 'Mobile Landscape', default: defaultString });

DynamicElementSize.attributes.add('mobileLandscapeSize', { type: 'vec2', title: 'Size' });

DynamicElementSize.attributes.add('d', { type: 'string', title: 'Mobile Portrait', default: defaultString });

DynamicElementSize.attributes.add('mobilePortraitSize', { type: 'vec2', title: 'Size' });

DynamicElementSize.attributes.add('dynamicWidth', { type: 'boolean' });
DynamicElementSize.attributes.add('dynamicWidthOffset', { type: 'number' });

DynamicElementSize.attributes.add('debug', { type: 'boolean' });


pc.extend(DynamicElementSize.prototype, {
    initialize: function () {
        this._onResize(ViewportManager.instance.getOrientation(), ViewportManager.instance.width, ViewportManager.instance.height, ViewportManager.instance.getDevice());
        this.app.on('ViewportManager:onResize', this._onResize, this);

        this.on('destroy', this._onDestroy, this);
    },

    _onResize: function (orientation, width, height, device) {
        if (device === deviceEnum.DESKTOP) {
            if (orientation === orientationEnum.LANDSCAPE) {
                this._applyOrientation(this.desktopLandscapeSize);
            }

            if (orientation === orientationEnum.PORTRAIT) {
                this._applyOrientation(this.desktopPortraitSize);
            }
        }

        if (device === deviceEnum.MOBILE) {
            if (orientation === orientationEnum.LANDSCAPE) {
                this._applyOrientation(this.mobileLandscapeSize);
            }

            if (orientation === orientationEnum.PORTRAIT) {
                this._applyOrientation(this.mobilePortraitSize);
            }
        }


        if (this.dynamicWidth) {
            this._applyDynamicWidth();
        }
    },

    _applyOrientation: function (size) {
        if (this.debug) {
            console.log(size, this.entity.name);
        }

        this.currentSize = size;

        this.entity.element.width = size.x;
        this.entity.element.height = size.y;
    },

    _applyDynamicWidth() {
        const reference = UIManager.instance.entity.screen.referenceResolution;
        const resolution = UIManager.instance.entity.screen.resolution;

        const width = reference.y / resolution.y * resolution.x - this.dynamicWidthOffset;

        if (width < this.currentSize.x) {
            this.entity.element.width = width;
        } else {
            this.entity.element.width = this.currentSize.x;
        }
    },

    _onDestroy() {
        this.app.off('ViewportManager:onResize', this._onResize, this);
    }
}); 

// TutorialInterface.js
var TutorialInterface = pc.createScript('tutorialInterface');

TutorialInterface.attributes.add('picture', { type: 'entity' });
TutorialInterface.attributes.add('topBubble', {
    type: 'json',
    schema: [{
        name: 'bubbleEntity',
        type: 'entity'
    }, {
        name: 'textEntity',
        type: 'entity',
    }]
});
TutorialInterface.attributes.add('bottomBubble', {
    type: 'json',
    schema: [{
        name: 'bubbleEntity',
        type: 'entity'
    }, {
        name: 'textEntity',
        type: 'entity',
    }]
});

pc.extend(TutorialInterface.prototype, {
    initialize: function () {
    },

    initializeSingleSentence: function () {

    },

    converstation: function (dialogInfo, person) {
        var sprite = person.images[dialogInfo.image];
        var imageSize = sprite.resource.atlas.frames[sprite.resource.frameKeys[0]].rect;
        this.picture.element.spriteAsset = sprite;
        this.picture.element.width = imageSize.z;
        this.picture.element.height = imageSize.w;
        this.displaySentence(dialogInfo.text);
        // this.setCharacterPosition(dialogInfo.y);
    },

    displaySentence: function (text) {
        this._textAvailable = typeof LocalizationManager.instance.get(text) !== 'string' || LocalizationManager.instance.get(text) !== '';
        LocalizationManager.instance.setText(this.topBubble.textEntity, text);
        LocalizationManager.instance.setText(this.bottomBubble.textEntity, text);
    },

    hideDialogBox: function () {
        var picturePosition = this.picture.getLocalPosition().clone();
        if (this.entity.enabled) {
            var yScale = UIManager.instance.getReferenceResolution().y / ViewportManager.instance.height;
            var distance = ViewportManager.instance.width * yScale / 2;
            var moveInTween = this.picture.tween(this.picture.getLocalPosition())
                .to({ x: picturePosition.x + distance, y: picturePosition.y, z: picturePosition.z }, 0.5, pc.SineOut)
                .start();

            moveInTween.on('complete', function () {
                this.entity.enabled = false;
                this.picture.setLocalPosition(picturePosition.x, picturePosition.y, picturePosition.z);
            }.bind(this));

            var topPopDownTween = this.topBubble.bubbleEntity.tween(this.topBubble.bubbleEntity.getLocalScale()).to({ x: 0, y: 0, z: 0 }, 0.2, pc.BackIn).start();
            var bottomPopDownTween = this.bottomBubble.bubbleEntity.tween(this.bottomBubble.bubbleEntity.getLocalScale()).to({ x: 0, y: 0, z: 0 }, 0.2, pc.BackIn).start();
        } else {
            this.entity.enabled = false;
        }
    },

    displayDialogBox: function () {
        var yScale = UIManager.instance.getReferenceResolution().y / ViewportManager.instance.height;
        var distance = ViewportManager.instance.width * yScale / 2;
        var moveDuration = 0.5;
        var picturePosition = this.picture.getLocalPosition().clone();
        this.picture.setLocalPosition(picturePosition.x + distance, picturePosition.y, picturePosition.z);
        var moveInTween = this.picture.tween(this.picture.getLocalPosition()).to({ x: picturePosition.x, y: picturePosition.y, z: picturePosition.z }, moveDuration, pc.SineOut).start();

        this.topBubble.bubbleEntity.setLocalScale(0, 0, 0);
        this.bottomBubble.bubbleEntity.setLocalScale(0, 0, 0);
        var topPopUpTween = this.topBubble.bubbleEntity.tween(this.topBubble.bubbleEntity.getLocalScale()).to({ x: 1, y: 1, z: 1 }, 0.3, pc.BackOut, moveDuration).start();
        var bottomPopUpTween = this.bottomBubble.bubbleEntity.tween(this.bottomBubble.bubbleEntity.getLocalScale()).to({ x: 1, y: 1, z: 1 }, 0.3, pc.BackOut, moveDuration).start();

        this.entity.enabled = true;

    },

    enableOverlay: function (value) {
    },

    setTopOrBottomBubble: function (bubbleSetting) {
        this.topBubble.bubbleEntity.enabled = bubbleSetting === 'top' && this._textAvailable;
        this.bottomBubble.bubbleEntity.enabled = bubbleSetting === 'bottom' && this._textAvailable;
    },

    toggleSkip: function (allowSkip) {
        // not used currently
    },

    setCharacterPosition: function (y = 0) {
        const localPosition = this.picture.getLocalPosition();
        this.picture.setLocalPosition(localPosition.x, y, localPosition.z);
    }
});


// FirstTimeUserManager.js
var FirstTimeUserManager = pc.createScript('firstTimeUserManager');


var disableEnum = {
    disableButton: 0,
    disappear: 1
};

var disableOptions = [
    { disableButton: disableEnum.disableButton },
    { disappear: disableEnum.disappear }
];

FirstTimeUserManager.attributes.add('lockableEntities', {
    type: 'json',
    schema: [{
        name: "entity",
        type: 'entity',
        array: true
    }, {
        name: "unlockLevel",
        type: 'number',
        default: 0,
        description: 'Unlock when you are on this specific level'
    }, {
        name: "key",
        type: 'string'
    }, {
        name: "type",
        type: 'number',
        enum: disableOptions
    }],
    array: true
});


FirstTimeUserManager.attributes.add('disableOpacity', {
    type: 'number',
    default: 0.5
});


pc.extend(FirstTimeUserManager.prototype, {
    postInitialize: function () {
        FirstTimeUserManager.instance = this;

        this.ftue = false

        if (GameManager.instance.forcedMode) {
            return;
        }

        this.checkEntities();
    },

    checkEntities: function () {
        for (var entityKey in this.lockableEntities) {
            switch (this.lockableEntities[entityKey].type) {
                case disableEnum.disableButton:
                    this._checkButton(this.lockableEntities[entityKey]);
                    break;
                case disableEnum.disappear:
                    this._checkAppearance(this.lockableEntities[entityKey]);
                    break;
            }
        }
    },

    checkItem: function (key) {
        for (var entityKey in this.lockableEntities) {
            if (this.lockableEntities[entityKey].key === key) {
                switch (this.lockableEntities[entityKey].type) {
                    case disableEnum.disableButton:
                        this._checkButton(this.lockableEntities[entityKey]);
                        break;
                    case disableEnum.disappear:
                        this._checkAppearance(this.lockableEntities[entityKey]);
                        break;
                }
            }
        }
    },

    unlockItem: function (key) {
        for (var entityKey in this.lockableEntities) {
            if (this.lockableEntities[entityKey].key === key) {
                switch (this.lockableEntities[entityKey].type) {
                    case disableEnum.disableButton:
                        this._enableButton(this.lockableEntities[entityKey]);
                        break;
                    case disableEnum.disappear:
                        this._appear(this.lockableEntities[entityKey]);
                        break;
                }
            }
        }
    },

    lockItem: function (key) {
        for (var entityKey in this.lockableEntities) {
            if (this.lockableEntities[entityKey].key === key) {
                switch (this.lockableEntities[entityKey].type) {
                    case disableEnum.disableButton:
                        this._disableButton(this.lockableEntities[entityKey]);
                        break;
                    case disableEnum.disappear:
                        this._disappear(this.lockableEntities[entityKey]);
                        break;
                }
            }
        }
    },


    checkDisappear: function () { // run in ui manager to check which ui elements need to be disabled              
        if (GameManager.instance.forcedMode) {
            return;
        }

        for (var entityKey in this.lockableEntities) {
            if (this.lockableEntities[entityKey].type === disableEnum.disappear) {
                this._checkAppearance(this.lockableEntities[entityKey]);
            }
        }
    },

    // disable check
    _checkButton: function (item) {
        if (!this.ftue && item.unlockLevel <= LevelDataManager.instance.getCurrentLevel())
            this._enableButton(item);
        else
            this._disableButton(item);
    },

    _disableButton: function (item) {
        for (var i = 0; i < item.entity.length; i++) {
            if (item.entity[i].script.preBoosterButton) {
                item.entity[i].script.preBoosterButton.activate(false);
            } else if (item.entity[i].script.boosterButton) {
                item.entity[i].script.boosterButton.activate(false);
            } else if (item.entity[i].script.boosterShopItem) {
                item.entity[i].script.boosterShopItem.activate(false);
            }
        }
    },

    _enableButton: function (item) {
        for (var i = 0; i < item.entity.length; i++) {
            if (item.entity[i].script.preBoosterButton) {
                item.entity[i].script.preBoosterButton.activate(true);
            } else if (item.entity[i].script.boosterButton) {
                item.entity[i].script.boosterButton.activate(true);
            } else if (item.entity[i].script.boosterShopItem) {
                item.entity[i].script.boosterShopItem.activate(true);
            }
        }
    },


    // disappear check
    _checkAppearance: function (item) {
        if (item.unlockLevel <= LevelDataManager.instance.getCurrentLevel())
            this._appear(item);
        else
            this._disappear(item);

    },

    _disappear: function (item) {
        for (var i = 0; i < item.entity.length; i++) {
            item.entity[i].enabled = false;
        }

    },

    _appear: function (item) {
        for (var i = 0; i < item.entity.length; i++) {
            item.entity[i].enabled = true;
        }
    },

    enableFTUE: function () {
        this.ftue = true;
        this.checkEntities();
    },

    disableFTUE: function () {
        if (this.ftue) {
            this.ftue = false;
            this.checkEntities();
        }
    }
});

// SettingsBackground.js
var SettingsBackground = pc.createScript('settingsBackground');

pc.extend(SettingsBackground.prototype, {
    initialize: function() {
        this.hamburgerButton = this.entity.parent.script.hamburgerMenu;
        this.hamburgerButton.on('MenuToggle', this.onMenuToggle, this);
        this.entity.element.width = 0;
    },

    onMenuToggle: function(isOpen) {
        var counter = 1;
        for (var i = 0; i < this.hamburgerButton.content.length; i += 1) {
            const button = this.hamburgerButton.buttons[i];

            if (!button) {
                continue
            }

            if (button.enabled) counter += 1 ;
        }
        
        var bgWidth = isOpen ? counter * this.hamburgerButton.unfoldDistance - 20: 0;
        
        
        this.app.tween(this.entity.element).to({ width: bgWidth}, this.hamburgerButton.unfoldDuration, pc.SineOut).start();
    }
});

// AsyncScoreManager.js
var AsyncScoreManager = pc.createScript('asyncScoreManager');

pc.extend(AsyncScoreManager.prototype, {
    initialize: function() {
        this.app.on('AsyncScoreManager:setScore', this._setScore, this);
        this.app.on('AsyncScoreManager:reset', this._resetScore, this);
        this.app.on('LevelManager:onLevelStart', this._resetScore, this);
        this.app.on('SwapMode:onWait', this._checkScore, this);
        this._resetScore();
    },
    
    _resetScore: function() {
        this.currentScore = 0;   
    },

    _setScore: function(score) {
        if (!LevelManager.instance.playing) {
            return;
        }
        
        this.currentScore += score;

        this.app.fire('AsyncScoreManager:showScore', this.currentScore);
    },

    _checkScore: function() {
        var score = ScoreManager.instance.getScore();
        if(score !== this.currentScore && LevelManager.instance.playing) {
            console.warn("Missing score visual! ScoreManager:" + score + " AsyncScoreManager: "  + this.currentScore);
            this.currentScore = score;
        } else {
            // console.log("Correct! ScoreManager:" + score + " AsyncScoreManager: "  + this.currentScore);
        }
    },
});


// GameScreen.js
var GameScreen = pc.createScript('gameScreen');

GameScreen.attributes.add('endMode', { type: 'entity' });
GameScreen.attributes.add('settingsButton', { type: 'entity' });
GameScreen.attributes.add('exitButton', { type: 'entity' });

GameScreen.attributes.add('level', { type: 'entity' });
GameScreen.attributes.add('score', { type: 'entity' });
GameScreen.attributes.add('moves', { type: 'entity' });
GameScreen.attributes.add('starBar', { type: 'entity' });
GameScreen.attributes.add('objectives', { type: 'entity' });
GameScreen.attributes.add('bar', { type: 'entity' });

GameScreen.attributes.add('boosterToggle', { type: 'entity' });

// initialize code called once per entity
pc.extend(GameScreen.prototype, {
    initialize: function () {

    },

    onUIEntityOpen: function () {
        if (GridManager.instance) {
            GridManager.instance.active(true);
        }

        CameraAnimations.instance.off('complete', CameraAnimations.instance._onCameraComplete, CameraAnimations.instance);


        this.exitButton._keepDisabled = GardenDataManager.instance.firstTime || Wrapper.instance.hasFeature('external_pause');
        this.exitButton.enabled = !this.exitButton._keepDisabled;

        if (GameManager.instance.forcedMode) {
            this.hideUI();
        }

        this.endMode.script.endModeVisuals.hideAll();
    },

    onUIEntityClose: function () {
        if (GridManager.instance) {
            GridManager.instance.active(false);
        }
    },

    hideUI: function () {
        const forcedModeProperties = GameManager.instance.forcedModeProperties;

        if (forcedModeProperties.override && forcedModeProperties.override.hide_ui && Array.isArray(forcedModeProperties.override.hide_ui)) {
            if (forcedModeProperties.override.hide_ui.includes('level')) {
                this.level.enabled = false;
            }

            if (forcedModeProperties.override.hide_ui.includes('score')) {
                this.score.enabled = false;
            }

            if (forcedModeProperties.override.hide_ui.includes('moves')) {
                this.moves.enabled = false;
            }

            if (forcedModeProperties.override.hide_ui.includes('star_bar')) {
                this.starBar.enabled = false;
            }

            if (forcedModeProperties.override.hide_ui.includes('settings_button')) {
                this.settingsButton.enabled = false;
                this.settingsButton._keepDisabled = true;
            }

            if (forcedModeProperties.override.hide_ui.includes('exit_button')) {
                this.exitButton.enabled = false;
                this.exitButton._keepDisabled = true;
            }

            if (forcedModeProperties.override.hide_ui.includes('objectives')) {
                this.objectives.enabled = false;
            }

            if (forcedModeProperties.override.hide_ui.includes('star_bar') && forcedModeProperties.override.hide_ui.includes('moves')) {

                if (forcedModeProperties.override.hide_ui.includes('score')) {
                    this.objectives.setLocalPosition(0, 0, 0);
                } else {
                    this.score.setLocalPosition(0, 20, 0);
                }
            }

            if (!this.objectives.enabled && !this.starBar.enabled && !this.moves.enabled && !this.score.enabled && !this.level.enabled) {
                this.bar.enabled = false;
            }

        }

        this.boosterToggle.script.tutorialBoosterToggle.setForcedModeProperties(
            !(Array.isArray(forcedModeProperties.override.hide_ui) && forcedModeProperties.override.hide_ui.includes('booster')) && forcedModeProperties.state.has_booster_swap,
            !(Array.isArray(forcedModeProperties.override.hide_ui) && forcedModeProperties.override.hide_ui.includes('booster')) && forcedModeProperties.state.has_booster_shovel,
            !(Array.isArray(forcedModeProperties.override.hide_ui) && forcedModeProperties.override.hide_ui.includes('booster')) && forcedModeProperties.state.has_booster_beehive,
        );
    },
});


// ModelToUIManager.js
var ModelToUIManager = pc.createScript('modelToUimanager');

ModelToUIManager.attributes.add('screen', { type: 'entity' });

ModelToUIManager.attributes.add('elementFollower', { type: 'entity' });

ModelToUIManager.attributes.add('size', { type: 'curve', });
ModelToUIManager.attributes.add('sizeMultiplier', { type: 'number', default: 0.5 });
ModelToUIManager.attributes.add('speed', { type: 'number', default: 1600 });
ModelToUIManager.attributes.add('startTime', { type: 'number', default: 0.1 });

ModelToUIManager.attributes.add('deltaDuration', { type: 'number', default: 0.05 });

pc.extend(ModelToUIManager.prototype, {
    initialize: function() {
        this.app.on('ModelToUIManager:showAnimation', this._showAnimation, this);
        this.app.on('PerspectiveView:onCameraChange', this._onCameraChange, this);
        this._objectPool = this.entity.script.objectPool;
                
        this._delay = 0;
        
        this.app.on('SwapMode:onCascadeDone', this._resetDuration, this);
        this.app.on('SwapMode:onTileMatch', this._resetDuration, this);
        this.app.on('ConfirmLeaveGameButton:leave', this._resetDuration, this);


        this.on('destroy', this._onDestroy, this);
        
        this._array = [];
    },
    
    _resetDuration: function() {
        this._delay = 0;
    },
    
    _onDestroy: function() {
        this.app.off('ModelToUIManager:showAnimation', this._showAnimation, this);
        this.app.off('PerspectiveView:onCameraChange', this._onCameraChange, this);
        this.app.off('SwapMode:onCascadeDone', this._resetDuration, this);
        this.app.off('SwapMode:onTileMatch', this._resetDuration, this);
        this.app.off('ConfirmLeaveGameButton:leave', this._resetDuration, this);
    },
    
    _onCameraChange: function() {
        if (!PerspectiveView.instance.entity.parent) {
            return;
        }
        
        this._cameraPosition = PerspectiveView.instance.entity.parent.getLocalPosition();
    },
    
    _showAnimation: function(startPosition, data, delay) {
        if (!LevelManager.instance.playing) {
            return;
        }
        
        if (isNaN(delay)) {
            console.error("No delay is found:", delay);
            delay = this._delay;
        }
        
        var entity = this._objectPool.use();

        var screenPosition = new pc.Vec3();
        
        var sprite = TileLibrary.instance.getTileSprite(data);
        
        var size = this.size.value(this._cameraPosition.z / 100) * this.sizeMultiplier;
        
        entity.element.spriteAsset = sprite;
        entity.element.width = size;
        entity.element.height = size;
        
        entity.setLocalScale(1, 1, 1);
        
        var scale = UIManager.instance.getScale();
        var device = this.app.graphicsDevice;
        
        var xOffset = (this.screen.element.width - this.screen.parent.element.width) / 2;
        
        PerspectiveView.instance.entity.camera.worldToScreen(startPosition, screenPosition);
        
        screenPosition.scale(ViewportManager.instance.getDPR());
        
        entity.reparent(this.screen);
        entity.setLocalPosition((screenPosition.x) / scale - xOffset, -screenPosition.y / scale, 0);
        entity.enabled = true;
        
        var self = this;
        
        var endPosition = this.elementFollower.script.elementFollower.getLocalPosition();
        
        var deltaX = endPosition.x - startPosition.x;
        var deltaY = endPosition.y - startPosition.y;
        var distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        
        var duration = this.startTime + 0.2;
        
        var newDelay = 0;
        
        
        if (delay - this._delay < this.deltaDuration) {
            newDelay = this.deltaDuration - (delay - this._delay);
        }
        
        this._delay = delay + newDelay;
        
        duration += newDelay;
        
        var scaleTween = entity
            .tween(entity.getLocalScale())
            .to({x: 2, y: 2, z: 2}, duration, pc.Linear)
            .yoyo(true)
            .loop(true)
            .start();
        
        entity
            .tween(entity.getLocalPosition())
            .to({x: endPosition.x, y: endPosition.y, z: endPosition.z}, duration * 2, pc.BackIn)
            .start()
            .on('complete', function() {
                scaleTween.stop();
                entity.enabled = false;
                self._objectPool.recycle(entity);
                ObjectiveManager.instance.onObjectiveAdd(data.layerID, data.typeID, data.colorID);
            
            });
    },
});


// UItoUImanager.js
var UitoUimanager = pc.createScript('uitoUimanager');

// initialize code called once per entity
UitoUimanager.attributes.add('screen', { type: 'entity' });
UitoUimanager.attributes.add('elementFollower', { type: 'entity' });
UitoUimanager.attributes.add('elementFollower2', { type: 'entity' });

UitoUimanager.attributes.add('object', { type: 'entity' });

UitoUimanager.attributes.add('speed', { type: 'number', default: 1600 });
UitoUimanager.attributes.add('delay', { type: 'number', default: 0.2 });


var animationStages = Object.freeze({
    IDLE: 0,
    PREPERATION: 1,
    ANIMATE: 2,
    DONE: 3,
});

pc.extend(UitoUimanager.prototype, {

    initialize: function() {
        this.app.on('UitoUimanager:showAnimation', this._showAnimation, this);
        this.setStart = false;
        this.currentDelayTimer = 0;
        this.currentState = animationStages.IDLE;
        this.callback = null;
    },

    update: function(dt) {
        if(this.currentState === animationStages.PREPERATION && this.currentDelayTimer < this.delay) {
            this.currentDelayTimer += dt;
            this.startPosition = this.elementFollower2.script.elementFollower.getLocalPosition();
            this.object.setLocalPosition(this.startPosition);
        } else if (this.currentState === animationStages.PREPERATION) {
            this._switchState(animationStages.ANIMATE);
        }
        
        if(this.currentState === animationStages.ANIMATE) {
            // console.log(this.object.getLocalScale());
        }
    },

    _showAnimation: function(startEntity, callback) {
        this.callback = callback;
        this.elementFollower2.script.elementFollower.updateTarget(startEntity);
        this._switchState(animationStages.PREPERATION);
    },

    _prepareAnimation: function() {
        this.object.enabled = false;
        this.object.reparent(this.screen);
    },

    _animateObject: function() {
        this.object.enabled = true;

        this.currentDelayTimer = 0;
        this.setStart = false;

        this.endPosition = this.elementFollower.script.elementFollower.getLocalPosition();

        var deltaX = this.endPosition.x - this.startPosition.x;
        var deltaY = this.endPosition.y - this.startPosition.y;
        var distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

        this.duration = this.delay + distance / this.speed;

        this._scaleObject(this.duration);
        this._moveObject(this.duration);
    },

    _animationDone: function() {
        this.scaleTween.stop();
        this.object.enabled = false;
        this.callback();
        this.callback = null;
    },

    _scaleObject: function(duration) {
        this.scaleTween = this.object
            .tween(this.object.getLocalScale())
            .to({x: 1.5, y: 1.5, z: 1.5}, duration, pc.Linear)
            .yoyo(true)
            .loop(true)
            .start();
    },

    _moveObject: function(duration) {
        var self = this;
        this.object
            .tween(this.object.getLocalPosition())
            .to({x: this.endPosition.x, y: this.endPosition.y, z: this.endPosition.z}, duration * 2, pc.BackIn)
            .start()
            .on('complete', function() {
            self._switchState(animationStages.DONE);
        });
    },

    _switchState: function(state) {
        this.currentState = state;
        switch(this.currentState) {
            case animationStages.PREPERATION: 
                this._prepareAnimation();
                break;
            case animationStages.ANIMATE:
                this._animateObject();
                break;
            case animationStages.DONE:
                this._animationDone();
                this._switchState(animationStages.IDLE);
                break;
        }
    }
});

// raycastColliderObject.js
/* =============================================
 * Stores entity in the boundingbox library
 * Allows raycast to see object as object target
 * =============================================
 */
class RaycastColliderObject extends pc.ScriptType {
    static addAttributes(){
        
    }
    initialize() {
        this.generateBoundingBox();
        this.storeObjectInLibrary();
        this.app.on("BoundingBoxLibrary:showObjectColliders", this.visualizeBoxes, this);
        this.on('destroy', this._onDestroy, this);
        this.visualizeBoxes();
    }
    
    _onDestroy() {
        this.app.off("BoundingBoxLibrary:showObjectColliders", this.visualizeBoxes, this);
    }
    
    generateBoundingBox(){
    
        //create bounding box based on cube model
        switch (this.entity.model.type) {
            case 'box': 
                this.generatedBB = new pc.OrientedBox(this.entity.getWorldTransform(), new pc.Vec3(0.5, 0.5, 0.5));
                break;
                
            case 'sphere':
                const scale = this.entity.getLocalScale();
                
                if (scale.x !== scale.y && scale.x !== scale.z) {
                    console.warn("scale is not equal", scale.toString(), this.entity.name, this.entity.parent.name, this.entity.parent.parent.parent.parent.name, this.entity.parent.parent.parent.name);
                }
                
                this.generatedBB = new pc.BoundingSphere(this.entity.getPosition(), scale.x / 2);
                break;
                
            default: 
                console.warn("Invalid type", this.entity.model.type);
                break;
        }
    }

    storeObjectInLibrary(){
        // console.log('storing object', this.entity.name);
        //get areaNumber from parent areaManager
        var number = this.getArea(this.entity);
        // console.log(number);
        //store object in library
        if(number){
            BoundingBoxLibrary.instance.addBB(this, number);
        }else{
            console.warn(this.entity.name + " (child of "+ this.entity.parent.name + ") cant find 'areaManager.js' in parent hierarchy");
        }
    }
    //Recursive function that searches parent hierarchy and returns areaNumber.
    getArea(gameObject) {
        if (gameObject.parent) {
            if (gameObject.parent.script && gameObject.parent.script.has('areaManager')) {
                return gameObject.parent.script.get('areaManager').areaNumber;
            } else {
                return this.getArea(gameObject.parent);
            }
        } else {
            return null;
        }
    }
    
    visualizeBoxes(){
        //remove model if visualize is turned off
        if(!BoundingBoxLibrary.instance.visualizeBoxes){
            this.entity.removeComponent('model');
        } else{
            //add model if visualize is turned on
            if(!this.entity.model){
                this.entity.addComponent("model", {
                    type: 'box',
                });
            }
            this.entity.model.enabled = true;
            //render model as wireframe
            for (var i = 0; i < this.entity.model.meshInstances.length; i++) {
                this.entity.model.meshInstances[i].renderStyle = pc.RENDERSTYLE_WIREFRAME;
            }
        }
        
    }
}
pc.registerScript(RaycastColliderObject, 'raycastColliderObject');
RaycastColliderObject.addAttributes();



// DropperExitHandler.js
var DropperExitManager = pc.createScript('dropperExitManager');

pc.extend(DropperExitManager.prototype, {
    initialize: function() {
        DropperExitManager.instance = this;
        
        this.dropperExitPool = TilePrefabManager.instance.getObjectPool('DropperExitObjectPool');
        this.exitVisuals = [];
    },

    setExits: function(exits, hasDroppers) {
        if (!hasDroppers) {
            return;
        }
                
        for (var i = 0; i < exits.length; i += 1) {
            var newExit = this.dropperExitPool.use();
            this.exitVisuals.push(newExit);
            newExit.enabled = true;
            newExit.reparent(GridManager.instance.entity);
            var position = GridManager.instance.calculatePosition(exits[i].x, exits[i].y - 0.5, GridManager.instance.radius - 0.8);
            newExit.setLocalPosition(position);
        }
    },

    removeExits: function() {
        for (var i = 0; i < this.exitVisuals.length; i += 1) {
            this.dropperExitPool.recycle(this.exitVisuals[i]);
        }
        
        this.exitVisuals.length = 0;
    }
});

// ElementFollower.js
var ElementFollower = pc.createScript('elementFollower');

ElementFollower.attributes.add('target', { type: 'entity' });

pc.extend(ElementFollower.prototype, {
    initialize: function () {

    },

    updateTarget: function (entity) {
        this.target = entity;
    },

    // update: function() {
    //     if(this.target) {
    //         this.entity.setPosition(this.target.getPosition()); 
    //     }

    // },

    getLocalPosition: function () {
        this.entity.setPosition(this.target.getPosition());
        return this.entity.getLocalPosition();
    },
});


// HoldCounter.js
class HoldCounter extends pc.ScriptType {
    static addAttributes() {
        this.attributes.add('holdingStages', { type: 'asset', assetType: 'texture', array: true, title: 'The images that you see when you hold an object' });
        this.attributes.add('totalAnimationSeconds', { type: 'number', default: 2, title: 'Animation time', description: 'Amount of seconds the animation takes' });
        this.attributes.add('rotationDestination', { type: 'number', default: -120, description: 'Amount of rotation' });
        this.attributes.add('rotateGroup', { type: 'entity' });
        this.attributes.add('rotateGroupFill', { type: 'entity' });

        this.attributes.add('tapDelay', { type: 'number', default: 0.1 });
    }
    init() {
        this.canEdit = true;
        this.selectedEntity = null;
        this.firstObject = null;
        this.delay = 0;

        this.app.on('GardenCamera:startHold', this.startCountDown, this);
        this.app.on('GardenCamera:move', this.onMove, this);
        this.app.on('GardenCamera:stopHold', this.stopCountDown, this);
        this.app.on('GardenCamera:holdComplete', this.setCanEdit, this);
        this.app.on('HoldCounter:setEntity', this.setEntity, this);
        this.app.on('GardenCamera:initHold', this.startCountDown2, this);
        this.app.on('changeObjectTutorial:setTarget', this.setChangeObject, this);
        this.on('destroy', this._destroy, this);

        this._currentTime = this.totalAnimationSeconds;
        this.objectOffset = 50;
        this._currentIndex = -1;
        this.initialHoldObjectRotation = this.rotateGroup.getLocalEulerAngles();
    }

    setChangeObject(target) {
        this.target = target;
    }

    postInitialize() {
        this.entity.enabled = false;
    }

    _destroy() {
        this.app.off('GardenCamera:startHold', this.startCountDown, this);
        this.app.off('GardenCamera:move', this.onMove, this);
        this.app.off('GardenCamera:stopHold', this.stopCountDown, this);
        this.app.off('GardenCamera:holdComplete', this.setCanEdit, this);
        this.app.off('HoldCounter:setEntity', this.setEntity, this);
        this.app.off('GardenCamera:initHold', this.startCountDown2, this);
        this.app.off('changeObjectTutorial:setTarget', this.setChangeObject, this);
    }
    setCanEdit(arg) {
        this.canEdit = arg;
    }
    setEntity(arg) {
        this.selectedEntity = arg;
    }
    startCountDown(x, y) {
        this.running = true;
        this.entity.enabled = true;
        this.setEntityPosition(x, y);
        this._currentTime = this.totalAnimationSeconds;
    }
    setEntityPosition(x, y) {
        var scale = this.entity._parent._parent.screen.scale;
        var device = this.app.graphicsDevice;
        var pixelratio = pc.Application.getApplication().graphicsDevice.maxPixelRatio;
        var xPos = (x * pixelratio) - (device.width / 2);
        var yPos = (device.height / 2) - ((y - this.objectOffset) * pixelratio);
        this.entity.setLocalPosition(xPos / scale, yPos / scale, 0);
    }
    startCountDown2(x, y) {
        this.delay = this.tapDelay;
        this.running = true;
        this.entity.enabled = true;
        this.entity.children[0].enabled = false;
        this.canEdit = false;
        this.selectedEntity = null;

        this.setEntityPosition(x, y);
        this.inaccessiblePosition = GardenCamera.instance.entity.camera.screenToWorld(x, y, GardenCamera.instance.entity.getPosition().y * 1.5);
        this._currentTime = this.totalAnimationSeconds;
    }
    stopCountDown() {
        this.app.fire('HoldCounter:stopHolding');
        this.running = false;
        this.entity.enabled = false;
        this.rotateGroup.setLocalEulerAngles(this.initialHoldObjectRotation);
        this.rotateGroupFill.setLocalEulerAngles(this.initialHoldObjectRotation);
    }
    onMove() {
        this.entity.setLocalPosition(GardenCamera.instance.pointerUIPos.x, GardenCamera.instance.pointerUIPos.y, 0);
    }
    update(dt) {
        if (this.running) {
            if (this.target && this.target !== GardenCamera.instance.selectedEntity) {
                return;
            } else if (this.target) {
                this.app.fire('HoldCounter:holding');
            }
            if (this.delay > 0) {
                this.delay -= dt;

                if (this.delay > 0) {
                    return;
                } else {
                    this.entity.children[0].enabled = true;
                }
            }

            this._currentTime -= dt;
            if (this._currentTime <= 0) {
                if (this.canEdit) {
                    if (this.target) {
                        DialogManager.instance.nextDialog();
                    }
                    this.app.fire('HoldCounter:finish', GardenCamera.instance.selectedEntity);

                    this.app.fire('Audio:sfx', 'button_click.mp3');
                } else {
                    if (this.selectedEntity !== null) {
                        if (this.selectedEntity._parent.script.areaManager.regionState === AreaManager.states.Unlocked) {
                            var amountNeeded = this.getAmountOfStars(this.selectedEntity.script.objectOptions.amountOfStars, this.selectedEntity.script.objectOptions.world);
                            if (this.selectedEntity.script && this.selectedEntity.script.get("objectOptions") && this.selectedEntity.script.get("objectOptions").getCurrentIndex() === 3 && amountNeeded <= 0) {
                                var event = { x: GardenCamera.instance.pointerUIPos.x, y: GardenCamera.instance.pointerUIPos.y };
                                this.app.fire('GardenInput:onMouseUp', event);
                                GardenUIEntity.instance.taskButton.script.switchUibutton._onClick();
                                this.app.fire('GardenTasksScreen:moveToArea', this.selectedEntity.findScriptInParents('areaManager').areaNumber);
                                this.app.fire('Audio:sfx', 'button_click.mp3');
                            } else {
                                //LocalizationManager.instance.setText(GardenUIEntity.instance.notEnoughStarsTextEntity, 'NOT_ENOUGH_STARS_DESCRIPTION', [amountNeeded]);
                                //this.app.fire('HoldCounter:ObjectLocked', this.selectedEntity);
                                var event = { x: GardenCamera.instance.pointerUIPos.x, y: GardenCamera.instance.pointerUIPos.y };
                                this.app.fire('GardenInput:onMouseUp', event);
                                GardenUIEntity.instance.taskButton.script.switchUibutton._onClick();
                                if (this.target) {
                                    DialogManager.instance.nextDialog();
                                }
                                this.app.fire('Audio:sfx', 'button_click.mp3');
                            }
                        } else {
                            // area not unlocked yet
                            this.app.fire('HoldCounter:AreaLocked', this.selectedEntity);
                        }
                    } else {
                        // cant edit
                        this.app.fire('HoldCounter:inaccessible', this.inaccessiblePosition);
                    }
                }
                this.stopCountDown();
                return;
            }
            var index = Math.floor(this.holdingStages.length * this._currentTime / this.totalAnimationSeconds);
            var progress = this._currentTime / this.totalAnimationSeconds;

            var zRotation = (this.initialHoldObjectRotation.z + this.rotationDestination) - progress * this.rotationDestination;
            this.rotateGroup.setLocalEulerAngles(0, 0, zRotation);
            this.rotateGroupFill.setLocalEulerAngles(0, 0, zRotation);

            if (index !== this._currentIndex) {
                this._currentIndex = index;

                // this.entity.element.texture = this.holdingStages[index].resource;
            }
        }
    }

    getAmountOfStars(value, area) {
        var areaStars = Object.values(LevelDataManager.instance._starData)[area - 1];
        return (value - areaStars);
    }
}
pc.registerScript(HoldCounter, 'holdCounter');
HoldCounter.addAttributes();

// DropperCollection.js
var DropperCollection = pc.createScript('dropperCollection');

DropperCollection.attributes.add('droppers', {
    type: 'json',
    schema: [{
        name: 'petalModel',
        type: 'asset'
    }, {
        name: 'petalMaterial',
        type: 'asset',
        assetType: 'material'
    }],
    array: true
});



//DropperCollection.attributes.add('droppers', { type: 'asset', array: true });
//DropperCollection.attributes.add('materials', { type: "asset", assetType: "material", array: true });

pc.extend(DropperCollection.prototype, {
    initialize: function () {
        this.doIdleCountdown = false;
        this.active = false;

        this.app.on('SwapMode:onCascadeDone', this.startIdleCountdown, this);
    },

    update: function (dt) {
        if (this.doIdleCountdown) {
            if (this.superClass._recycled) {
                this.stopIdleCountdown();
                this.stopIdleTween();
            }
            this.idleCountdown += dt;
            if (this.idleCountdown >= this.idleCountdownDuration) {
                this.startIdleAnimation();
                this.stopIdleCountdown();
            }
        }
    },

    init: function (superClass) {
        this.superClass = superClass;
        this.superClass.typeID = foregroundTileEnum.DROPPER_COLLECTION;
    },

    awake: function () {
        this.worldIndex = pc.math.clamp(WorldManager.instance.getWorldIndex() - 1, 0, this.droppers.length - 1);

        this._changeDropper();
    },

    explode: function () {
        this.stopIdleCountdown();

        // this.app.fire('ForegroundTile:onExplode', tileLayerEnum.FOREGROUND, this.superClass.typeID, this.superClass.colorID);
        this.app.fire('ScoreManager:scoreForegroundTile', this.superClass.typeID, true, this.superClass);
        GridManager.instance.playSFX('dropper_deliver.mp3');
        StatisticsManager.instance.incrementStatistic("obstacle_destroyed", { obstacle_type: 'flower_part' }, 1);

        this.superClass.despawn();
        this.superClass.setDespawnEndPosition(this.superClass.x, this.superClass.y - 1);

        return true;
    },

    onAwake: function () {
        this.startIdleCountdown();
    },

    appear: function () {
        this.stopTween();
    },

    move: function () {
        this.stopTween();
    },

    applyGravity: function () {
        this.stopTween();
    },

    stopTween: function () {
        this.stopIdleCountdown();
        this.stopIdleTween();
    },

    startIdleAnimation: function () {
        var position = GridManager.instance.calculatePosition(this.superClass.x, this.superClass.y, 0.2);
        this.idleTween = this.entity.tween(this.entity.getLocalPosition())
            .to({ x: position.x, y: position.y - 0.1, z: position.z }, 0.2, pc.SineInOut)
            .yoyo(true)
            .repeat(4)
            .start();

        this.idleTween.on('complete', function () {
            this.startIdleCountdown();
            this.idleTween = null;
        }.bind(this), this)
    },

    startIdleCountdown: function () {
        this.idleCountdown = 0;
        var min = 5;
        var max = 10;
        this.idleCountdownDuration = Math.random() * (max - min) + min;
        this.doIdleCountdown = true;
    },

    stopIdleCountdown: function () {
        this.doIdleCountdown = false;
    },

    stopIdleTween: function () {
        if (this.idleTween) {
            this.idleTween.stop();
            this.idleTween = null;

            this.resetPosition();
        }
    },

    resetPosition: function () {
        var position = GridManager.instance.calculatePosition(this.superClass.x, this.superClass.y, 0);
        this.entity.setLocalPosition(position);
    },

    recycle: function () {
        this.stopIdleCountdown();
        this.stopIdleTween();
        this.active = false;
    },

    _changeDropper: function () {
        var dropperIndex = this.worldIndex;
        var dropperAsset = this.droppers[dropperIndex].petalModel;
        var materialAsset = this.droppers[dropperIndex].petalMaterial;
        // TODO use the world manager instead.

        var highlight = this.superClass._highlightModel;

        highlight.model.asset = dropperAsset;

        var meshInstances = highlight.model.meshInstances;

        for (var i = 0; i < meshInstances.length; i++) {
            var mesh = meshInstances[i];
            mesh.material = materialAsset.resource;
        }

        this.superClass._model.model.asset = dropperAsset;
    },
});


// Locker.js
var Locker = pc.createScript('locker');

pc.extend(Locker.prototype, {
    initialize: function () {
        this.parent = null;

        this._explode = false;

        this.animationController = this.entity.script.tileAnimationController;
        this.animationController.on('explode', this._onExplodeAnimation, this);
        this.animationController.on('exploded', this._onCompleteAnimation, this);
    },

    despawnInstant: function () {
        this._explode = true;
    },

    init: function (parent) {
        this.parent = parent;
        this.parent.typeID = backgroundTileEnum.LOCKER;
    },

    recycle: function () {
        if (this._explode) {
            console.warn("already recycled");
            return;
        }

        this._explode = true;

        this.entity.objectPool.recycle(this.entity);
    },

    awake: function () {
        this.parent.hasExploded = false;
        this._explode = false;
        this.parent._modelComponent.entity.enabled = true;
        this.animationController.setLayer(this.parent.currentLayer - 1);
    },

    explode: function (delay) {
        if (this.parent.hasExploded) {
            this.animationController.playExplode(this.parent.currentLayer, delay, true);

            return true;
        } else {

            this.parent._onLayerExplode();

            this.parent.currentLayer--;

            this.animationController.playExplode(this.parent.currentLayer, delay);

            this.parent.hasExploded = true;
            this.parent._isDamaged = true;

            if (this.parent.currentLayer === 0) {
                this.parent.isDestroyed = true;
                StatisticsManager.instance.incrementStatistic('obstacle_destroyed', {
                    obstacle_type: TileLibrary.instance.getObstacleName(this.parent.typeID),
                });
            }

            return true;
        }
    },

    _onExplodeAnimation: function (animationData) {
        this.stopShakeTile();

        var isLastLayer = this.parent.currentLayer === 0;

        this.parent._onExplode(isLastLayer, animationData.delay, true);

        if (isLastLayer) {
            GridManager.instance.playSFX('ice_destroy.mp3');
        } else {
            GridManager.instance.playSFX('ice_hit.mp3');
        }
    },

    _onCompleteAnimation: function () {
        this.recycle();
    },

    getDespawnDelay: function () {
        return this.animationController.getDespawnDelay();
    },

    doHintAnimation: function () {
        this.stopHintAnimation();
        this._isPlayingHint = true;
        var hintCounter = 0;
        this.hintTween = this.entity.tween(this.entity.getLocalScale()).to({ x: 1.1, y: 1.1, z: 1 }, 0.5, pc.SineInOut).loop(true).yoyo(true).start();

        this.hintTween.on('loop', function () {
            if (this.hintMoveTween) {
                hintCounter++;
                if (hintCounter % (this.hintMoveLoops * 2) === 0) {
                    this.repeatHintMove();
                }
            }

            // extra check because the tween gets stuck randomly some times 
            if (!this._isPlayingHint) {
                this.hintTween.stop();
                if (this.hintMoveTween) {
                    this.hintMoveTween.stop();
                    this.hintMoveTween = null;
                }
            }
        }.bind(this));
    },

    stopHintAnimation: function () {
        if (this._isPlayingHint) {
            this._isPlayingHint = false;
            this.hintTween.stop();
            this.entity.setLocalScale(pc.Vec3.ONE);

            if (this.hintMoveTween) {
                this.hintMoveTween.stop();
                this.hintMoveTween = null;
            }
        }
    },

    shakeTile: function (delay) {
        if (this.shakeTween) {
            return;
        }

        delay = delay ? delay : 0;
        this.rotation = this.entity.getLocalEulerAngles().clone();
        this.entity.setLocalEulerAngles(this.rotation.x, this.rotation.y, -5);

        this.shakeTween = this.entity.tween(this.entity.getLocalRotation())
            .rotate({ x: this.rotation.x, y: this.rotation.y, z: 5 }, 0.1, pc.SineInOut)
            .loop(true)
            .yoyo(true)
            .delay(delay)
            .start(true);
    },

    stopShakeTile: function () {
        if (this.shakeTween) {
            this.entity.setLocalEulerAngles(this.rotation.x, this.rotation.y, this.rotation.z);
            this.shakeTween.stop();
            delete this.shakeTween;
        }
    },

    stopAllTweens: function () {
        this.stopHintAnimation();
        this.stopShakeTile();
    },
});


// ComicInterface.js
var ComicInterface = pc.createScript('comicInterface');

var worldEnum = Object.freeze({
    WORLD_1: 0,
    WORLD_2: 1,
    WORLD_3: 2,
    WORLD_4: 3,
    WORLD_5: 4,
    WORLD_6: 5,
    WORLD_7: 6,
    WORLD_8: 7,
    WORLD_9: 8,
    WORLD_10: 9,
});

ComicInterface.attributes.add('scrollbar', { type: 'entity' });
ComicInterface.attributes.add('scrollView', { type: 'entity' });

ComicInterface.attributes.add('dotPrefab', { type: 'entity' });
ComicInterface.attributes.add('navigation', { type: 'entity' });

ComicInterface.attributes.add('panelContainer', { type: 'entity' });
ComicInterface.attributes.add('panel', { type: 'asset', assetType: 'template' });

ComicInterface.attributes.add('content', { type: 'entity' });
ComicInterface.attributes.add('chapterText', { type: 'entity' });

ComicInterface.attributes.add('prevButton', { type: 'entity' });
ComicInterface.attributes.add('nextButton', { type: 'entity' });

pc.extend(ComicInterface.prototype, {
    init: function () {

        ComicInterface.instance = this;

        this.dots = [];
        this.scrollbar.scrollbar.value = 1;
        this.totalWidth = 0;

        this.nextButton.script.elementInput.on(inputEvents.CLICK, this.nextSlide, this);
        this.prevButton.script.elementInput.on(inputEvents.CLICK, this.previousSlide, this);

        this.scrollView.scrollview.on('set:scroll', this.scroll, this);

        this.app.on("ComicInterface:showUnlockedComic", this.showUnlockedComic, this);
        this.app.on("ComicInterface:showComic", this.showComic, this);

        // this.content.script.elementInput.on(inputEvents.UP, this._onRealease, this);
        // this.content.script.elementInput.on(inputEvents.DOWN, this._onPress, this);

        this.scrollIItem = new pc.Entity();
        this.lastPosition = 0;
        this.isMoving = false;

        this.app.mouse.on(pc.EVENT_MOUSEWHEEL, this.onMouseWheel, this);
    },

    update: function () {
        if (this.content.getLocalPosition().x - this.lastPosition >= 1 || this.content.getLocalPosition().x - this.lastPosition <= -1 && this.isMoving) {
            this.lastPosition = this.content.getLocalPosition().x;
        } else if (this.isMoving) {
            this.isMoving = false;
            this.centerComic(this.currentPanel);
        }
    },

    showUnlockedComic: function (chapterID, pageID) {
        this.setComic(chapterID);
        this.app.fire('UIManager:showUI', 'Comic');
        this.setStartLocation(pageID - 1);
        this.enableAllPanelsInput(false);
        this.centerComic(pageID, 1, this.showImage.bind(this), 1);
        this.lockLatestPanel(pageID);
    },

    showComic: function (chapterID, pageID) {
        this.setComic(chapterID);
        this.app.fire('UIManager:showUI', 'Comic');
        this.setStartLocation(pageID);
    },

    makePanel: function (sprite, isUnlocked, i) {
        var image = this.panel.resource.instantiate();
        image.enabled = true;
        this.panelContainer.addChild(image);
        this.panels.push(image);

        image.element.spriteAsset = sprite;
        this.itemWidth = image.element.width;
        this.totalHeight = image.element.height;
        this.totalWidth = this.totalWidth ? this.totalWidth + this.itemWidth : this.itemWidth;

        image.script.comicToBookButton.pageID = i;
        image.script.comicToBookButton.worldID = this.worldID;
        image.script.comicToBookButton.isUnlocked = isUnlocked;
        image.script.comicToBookButton.setLockVisibility(!isUnlocked);

        image.button.active = isUnlocked;
    },

    setComic: function (world) {
        this.panels = [];
        this.worldID = world;
        this._resetContainer();

        var worldData = WorldManager.instance.getWorldData(world);
        for (var i = 0; i < worldData.comics.length; i++) {
            var partData = LevelDataManager.instance.getPartsData(world);
            this.makePanel(worldData.comics[i], i <= partData, i);
        }

        this.chapterText.element.color = WorldManager.instance.getWorldTextColor(this.worldID);
        LocalizationManager.instance.setText(this.chapterText, worldData.name);

        this.comicLength = worldData.comics.length;
        this.calculateContentWidth(this.comicLength);
        this.generateDots(this.comicLength);
    },

    setStartLocation: function (panelToCenter) {
        this.highLightDot(panelToCenter);
        this.currentPanel = panelToCenter;
        var maxWidth = this.content.element.width - this.scrollView.element.width;
        var itemDiff = (panelToCenter) * ((this.panelContainer.layoutgroup.spacing.x) + this.itemWidth) / (maxWidth / 100) / 100;
        this.scrollbar.scrollbar.value = itemDiff;
        this.scroll();
    },

    centerComic: function (panelToCenter, delay, callback, duration) {
        this.currentPanel = panelToCenter;
        var maxWidth = this.content.element.width - this.scrollView.element.width;
        var itemDiff = panelToCenter * ((this.panelContainer.layoutgroup.spacing.x) + this.itemWidth) / (maxWidth / 100) / 100;
        this.tweenTo(itemDiff, delay, callback, duration);
    },

    tweenTo: function (itemDiff, delay, callback, duration = 0.3) {
        delay = delay ? delay : 0;
        this.tweenAnimation = this.app.tween(this.scrollbar.scrollbar).to({ value: itemDiff }, duration, pc.SineOut).delay(delay).start();
        this.tweenAnimation.on('complete', function () {
            if (callback) {
                callback();
            }
        }.bind(this));
    },

    calculateContentWidth: function (itemLength) {
        this.panelContainer.element.width = this.totalWidth + this.panelContainer.layoutgroup.padding.x + this.panelContainer.layoutgroup.padding.z + (this.panelContainer.layoutgroup.spacing.x * (itemLength - 1));
        this.panelContainer.element.height = this.totalHeight + this.panelContainer.layoutgroup.padding.y + this.panelContainer.layoutgroup.padding.w;
        this.content.element.width = this.panelContainer.element.width;
        this.scrollView.element.width = this.itemWidth + this.panelContainer.layoutgroup.spacing.x * 2;
    },

    _resetContainer: function () {
        this.totalWidth = 0;
        if (this.panelContainer.children.length > 0) {
            for (var j = this.panelContainer.children.length - 1; j >= 0; j--) {
                if (this.panelContainer.children[j].name !== "Untitled") {
                    this.panelContainer.children[j].destroy();
                }
            }
        }
        if (this.navigation.children.length > 0) {
            this.dots = [];
            for (var k = this.navigation.children.length - 1; k >= 0; k--) {
                if (this.navigation.children[k].name !== "Untitled") {
                    this.navigation.children[k].destroy();
                }
            }
        }
    },

    enableAllPanelsInput: function (value) {
        for (var i = 0; i < this.panels.length; i++) {
            this.panels[i].element.useInput = value;
        }
    },

    lockLatestPanel: function (number) {
        this.panels[number].element.color = ComicInterface.LOCKED_COLOR;
        this.lockedPanel = number;
    },

    showImage: function () {
        var color = new pc.Color(0, 0, 0).copy(ComicInterface.LOCKED_COLOR);
        const panel = this.panels[this.lockedPanel];

        panel.script.comicToBookButton.fadeOutLock();

        const tween = this.app.tween(color).to(pc.Color.WHITE, 1, pc.Linear)
            .start();

        tween.on('update', function () {
            if (!panel.button.active) {
                panel.button.active = true;
            }

            panel.element.color = color;
        }, this)

        tween.on('complete', this.enableAllPanelsInput.bind(this, true), this)
    },

    // dots // 

    // highlight dots on scroll 
    scroll: function () {
        var scrollValue = this.scrollbar.scrollbar.value;
        var last = 0;
        for (var i = 0; i < this.comicLength; i++) {
            var maxWidth = this.content.element.width - this.scrollView.element.width;

            var itemDiff = (((i) * ((this.panelContainer.layoutgroup.spacing.x) + this.itemWidth)) - (this.itemWidth / 2)) / (maxWidth / 100) / 100;
            if (scrollValue >= itemDiff) {
                last = i;
            }
        }

        if (this.currentPanel !== last) {
            this.currentPanel = last;
            this.highLightDot(this.currentPanel);
        }

    },

    generateDots: function (count) {
        var newDot;
        for (var i = 0; i < count; i++) {
            newDot = this.dotPrefab.clone();
            newDot.enabled = true;
            this.changeOpacity(newDot, i === 0 ? false : true);
            this.navigation.addChild(newDot);
            this.dots.push(newDot);
        }
        this.navigation.element.width = (newDot.element.width * count) + (this.navigation.layoutgroup.spacing.x * count);
    },

    changeOpacity: function (dot, isTransparent) {
        dot.element.opacity = isTransparent ? 0.5 : 1;
    },

    highLightDot: function (number) {
        for (var i = 0; i < this.dots.length; i++) {
            this.changeOpacity(this.dots[i], i === (number) ? false : true);
        }
    },

    // buttons

    nextSlide: function () {
        if (this.currentPanel < this.comicLength - 1) {
            this.centerComic(this.currentPanel + 1);
        }
    },

    previousSlide: function () {
        if (this.currentPanel > 0) {
            this.centerComic(this.currentPanel - 1);
        }
    },

    onMouseWheel: function (event) {
        if (!UIManager.instance.isTopOfStack('Screen', 'Comic')) return;
        var maxWidth = this.content.element.width - this.scrollView.element.width;
        var sensitivity = ((this.panelContainer.layoutgroup.spacing.x) + this.itemWidth) / (maxWidth / 100) / 100;
        this.scrollbar.scrollbar.value += event.wheelDelta * sensitivity;
    },

});

ComicInterface.LOCKED_COLOR = new pc.Color().fromString('#1D1D40');


// UpgradeGardenItemAnim.js
var UpgradeGardenItemAnim = pc.createScript('upgradeGardenItemAnim');

UpgradeGardenItemAnim.attributes.add('sawEntity', { type: 'entity', title: 'Saw Entity' });
UpgradeGardenItemAnim.attributes.add('hammerEntity', { type: 'entity', title: 'Hammer Entity' });
UpgradeGardenItemAnim.attributes.add('smokeParticles', { type: 'entity', title: 'Smoke Particles', array: true });
UpgradeGardenItemAnim.attributes.add('hammerAnimDuration', { type: 'number', default: 0.4, title: 'hammer animation duration' });
UpgradeGardenItemAnim.attributes.add('sawAnimDuration', { type: 'number', default: 0.3, title: 'saw animation duration' });
UpgradeGardenItemAnim.attributes.add('timesToPlayAnim', { type: 'number', default: 2, title: 'times to play anim' });

UpgradeGardenItemAnim.TIME_TO_SCALE = 0.1;

UpgradeGardenItemAnim.HAMMER_START_ANGLE = new pc.Vec3(0, 0, -30);
UpgradeGardenItemAnim.HAMMER_START_POS_Z = 2;
UpgradeGardenItemAnim.HAMMER_SCALE = new pc.Vec3(0.2, 0.2, 0.2);
UpgradeGardenItemAnim.HAMMER_INVERTED_ANGLES = new pc.Vec3(0, -180, 30);
UpgradeGardenItemAnim.HAMMER_END_ANGLE = 30;

UpgradeGardenItemAnim.SAW_START_ANGLE = new pc.Vec3(0, 0, -115);
UpgradeGardenItemAnim.SAW_INVERTED_ANGLES = new pc.Vec3(-180, 0, -115);
UpgradeGardenItemAnim.SAW_START_POS_Z = 2;
UpgradeGardenItemAnim.SAW_SCALE = new pc.Vec3(0.3, 0.3, 0.3);
UpgradeGardenItemAnim.SAW_X_OFFSET = 0.75;
UpgradeGardenItemAnim.SAW_Z_OFFSET = 0.5;

pc.extend(UpgradeGardenItemAnim.prototype, {
    initialize: function () {
        this.isAnimPlaying = false;
        this.timesPlayed = 0;
        this.vibrationPlaying = false;

        this.objectPool = TilePrefabManager.instance.getObjectPool('UpgradeGardenAnimationObjectPool');
    },

    startUpgradeAnim: function () {
        if (!this.isAnimPlaying) {

            this.isAnimPlaying = true;

            this.sawEntity.enabled = false;
            this.hammerEntity.enabled = false;

            this.smokeParticles.forEach(particle => {
                particle.enabled = true;
                particle.particlesystem.reset();
                particle.particlesystem.play();
            });

            //randomizes which animation starts first
        }
    },

    stopUpgradeAnim: function () {
        this.tweenEntityOut(this.sawEntity);
        this.tweenEntityOut(this.hammerEntity);
        this.timesPlayed = 0;
        this.fire('stopped');
    },

    update: function () {
        if (this.isAnimPlaying && !this.smokeParticles[0].particlesystem.isPlaying()) {
            this.recycle();
            this.isAnimPlaying = false;
        }
    },

    startHammerAnim: function () {

        // this.tweenEntityOut(this.sawEntity);
        //this.sawEntity.enabled = false;

        this.hammerEntity.enabled = true;

        //randomizes where the hammer spawns
        var randomHammerSpawn = new pc.Vec3(pc.math.random(-1, 1), pc.math.random(1, 3), UpgradeGardenItemAnim.HAMMER_START_POS_Z);
        //randomizes the delay before the animation starts
        var randomDelay = pc.math.random(0, 0.65);
        pc.timer.add(randomDelay + 0.3, () => {
            this.app.fire('Audio:sfx', 'change_object_hammer.mp3');
        });
        var inverted = randomHammerSpawn.x <= 0;

        // Set transform

        this.hammerEntity.setLocalEulerAngles(inverted ? UpgradeGardenItemAnim.HAMMER_INVERTED_ANGLES : UpgradeGardenItemAnim.HAMMER_START_ANGLE);
        this.hammerEntity.setLocalPosition(randomHammerSpawn);
        this.hammerEntity.setLocalScale(0, 0, 0);

        var angles = {
            x: inverted ? UpgradeGardenItemAnim.HAMMER_INVERTED_ANGLES.x : UpgradeGardenItemAnim.HAMMER_START_ANGLE.x,
            y: inverted ? UpgradeGardenItemAnim.HAMMER_INVERTED_ANGLES.y : UpgradeGardenItemAnim.HAMMER_START_ANGLE.y,
            z: inverted ? UpgradeGardenItemAnim.HAMMER_END_ANGLE * -1 : UpgradeGardenItemAnim.HAMMER_END_ANGLE
        };

        this.scaleTween(this.hammerEntity, UpgradeGardenItemAnim.HAMMER_SCALE, UpgradeGardenItemAnim.TIME_TO_SCALE, pc.SineIn)
            .start();

        // Rotate
        const tween = this.rotateTween(this.hammerEntity, angles, this.hammerAnimDuration, pc.QuarticIn)
            .repeat(3)
            .delay(randomDelay)
            .start();

        tween.on('complete', () => {
            this.stopUpgradeAnim();
            this.hammerImpactVibration();
        }, this)
        tween.on('loop', this.hammerImpactVibration, this);

        // Scale
        this.scaleTween(this.hammerEntity, UpgradeGardenItemAnim.HAMMER_SCALE, UpgradeGardenItemAnim.TIME_TO_SCALE, pc.SineIn)
            .start();

        this.timesPlayed++;
    },

    // createHammerTween: function(last) {
    //     var lastTween = this.timesPlayed >= this.timesToPlayAnim;
    //     var inverted = randomHammerSpawn.x <= 0;

    //     var randomDelay = pc.math.random(0.3, 0.6);
    //     var angles = {
    //         x: inverted ? UpgradeGardenItemAnim.HAMMER_INVERTED_ANGLES.x : UpgradeGardenItemAnim.HAMMER_START_ANGLE.x,
    //         y: inverted ? UpgradeGardenItemAnim.HAMMER_INVERTED_ANGLES.y : UpgradeGardenItemAnim.HAMMER_START_ANGLE.y,
    //         z: inverted ? UpgradeGardenItemAnim.HAMMER_END_ANGLE * -1 : UpgradeGardenItemAnim.HAMMER_END_ANGLE
    //     };

    //     // Rotate

    //     this.rotateTween(this.hammerEntity, angles, this.hammerAnimDuration, pc.QuarticIn)
    //         .repeat(3)
    //         .delay(randomDelay)
    //         .start()
    //         .on('complete', this.stopUpgradeAnim, this);

    //     // Scale
    //     this.scaleTween(this.hammerEntity, UpgradeGardenItemAnim.HAMMER_SCALE, UpgradeGardenItemAnim.TIME_TO_SCALE, pc.SineIn)
    //         .start();

    //     this.timesPlayed++;
    // },


    startSawAnim: function () {
        // this.tweenEntityOut(this.hammerEntity);
        //this.hammerEntity.enabled = false;
        this.sawEntity.enabled = true;

        //randomizes spawn of the saw
        var randomSawSpawn = new pc.Vec3(pc.math.random(-1, 1), pc.math.random(1, 3), UpgradeGardenItemAnim.SAW_START_POS_Z);
        //randomizes the delay before the animation starts
        var randomDelay = pc.math.random(0, 0.6);

        pc.timer.add(randomDelay, () => {
            this.app.fire('Audio:sfx', 'change_object_saw.mp3');
        });
        var inverted = randomSawSpawn.x >= -0.1;

        //set transform
        this.sawEntity.setLocalEulerAngles(this.sawInverted ? UpgradeGardenItemAnim.SAW_INVERTED_ANGLES : UpgradeGardenItemAnim.SAW_START_ANGLE);
        this.sawEntity.setLocalPosition(randomSawSpawn);
        this.sawEntity.setLocalScale(0, 0, 0);

        var positionToTweenTowards = {
            x: inverted ? randomSawSpawn.x - UpgradeGardenItemAnim.SAW_X_OFFSET : randomSawSpawn.x + UpgradeGardenItemAnim.SAW_X_OFFSET,
            y: randomSawSpawn.y,
            z: inverted ? randomSawSpawn.z - UpgradeGardenItemAnim.SAW_Z_OFFSET : randomSawSpawn.z + UpgradeGardenItemAnim.SAW_Z_OFFSET
        };

        //tween the saw to the location
        var sawTween = this.tweenTo(this.sawEntity, positionToTweenTowards, this.sawAnimDuration, pc.QuinticInOut)
            .yoyo(true)
            .repeat(4)
            .delay(randomDelay)
            .start();

        sawTween.on('loop', this.sawDragVibration, this);

        sawTween.on('complete', this.stopUpgradeAnim, this);

        //scale the saw
        this.scaleTween(this.sawEntity, UpgradeGardenItemAnim.SAW_SCALE, UpgradeGardenItemAnim.TIME_TO_SCALE, pc.SineIn)
            .start();

        this.timesPlayed++;
    },

    hammerImpactVibration: function () {
        if (this.vibrationPlaying === false) {
            this.vibrationPlaying = true;
            this.app.fire('vibrate', 100);
            pc.timer.add(0.3, this.resetVibrationFlag, this);
        }
    },

    sawDragVibration: function () {
        if (this.vibrationPlaying === false) {
            this.vibrationPlaying = true;
            this.app.fire('vibrate', [40, 10, 40, 10, 40]);
            pc.timer.add(0.3, this.resetVibrationFlag, this);
        }
    },

    resetVibrationFlag: function () {
        this.vibrationPlaying = false;
    },

    tweenEntityOut: function (entity) {
        entity.tween(entity.getLocalScale()).to({ x: 0, y: 0, z: 0 }, UpgradeGardenItemAnim.TIME_TO_SCALE, pc.SineIn).start();
    },

    rotateTween: function (entity, eulerAngle, duration, easing) {
        return entity.tween(entity.getLocalEulerAngles()).rotate(eulerAngle, duration, easing);
    },

    tweenEntityOut: function (entity) {
        entity.tween(entity.getLocalScale()).to({ x: 0, y: 0, z: 0 }, UpgradeGardenItemAnim.TIME_TO_SCALE, pc.SineIn).start();
    },


    rotateTween: function (entity, eulerAngle, duration, easing) {
        return entity.tween(entity.getLocalEulerAngles()).rotate(eulerAngle, duration, easing);
    },

    scaleTween: function (entity, scale, duration, easing) {
        return entity.tween(entity.getLocalScale()).to(scale, duration, easing);
    },

    tweenTo: function (entity, position, duration, easing) {
        return entity.tween(entity.getLocalPosition()).to(position, duration, easing);
    },

    recycle: function () {
        this.objectPool.recycle(this.entity);
        this.entity.enabled = false;
        this.entity.reparent(null);
    },
});


// ImpulseManager.js
var ImpulseManager = {
    applyPulse: function(startX, startY, radius, amplitude, delay, duration) {
        var columns = MatchLogic.columns;
        var rows = MatchLogic.rows;
        var radiusSq = radius * radius;

        for (var x = 0; x < columns; x++) {
            for (var y = 0; y < rows; y++) {
                var tile = GridManager.instance.getTile(x, y);
                var backgroundTile = GridManager.instance.getBackgroundTile(x, y);

                var deltaX = x - startX;
                var deltaY = y - startY;
                
                var distanceSq = deltaX * deltaX + deltaY * deltaY;

                if (distanceSq > radiusSq) {
                    
                    continue;
                }
                                
                backgroundTile.pulse(deltaX, deltaY, amplitude, delay, duration);
                
                if (tile) {
                    tile.pulse(deltaX, deltaY, amplitude, delay, duration);
                } 
            }
        }
    }
};


// GameInput.js
var GameInput = pc.createScript('gameInput');

pc.extend(GameInput.prototype, {
    initialize: function() {
        this.app.on("GameInput:toggleGameInput", this.setInputEnabled, this);
        this._inputEnabled = true;
    },
    
    postInitialize: function() {
        this.entity.script.elementInput.on(inputEvents.DOWN, this._onDown, this);  
        this.entity.script.elementInput.on(inputEvents.MOVE, this._onMove, this);  
        this.entity.script.elementInput.on(inputEvents.UP, this._onUp, this);  
    },
    
    _onDown: function(event) {
        this.app.fire('GameInput:forced' + inputEvents.DOWN);
        
        if (this._inputEnabled === true) {
             this.app.fire('GameInput:' + inputEvents.DOWN, event);
        } 
    },
    
    _onMove: function(event) {
        if(this._inputEnabled === true) {
            this.app.fire('GameInput:' + inputEvents.MOVE, event);
        }
    },
    
    _onUp: function(event) {
        this.app.fire('GameInput:' + inputEvents.UP, event);
    },
    
    
    setInputEnabled: function(value) {
        this._inputEnabled = value;
    } 
});


// EndModeVisuals.js
var EndModeVisuals = pc.createScript('endModeVisuals');

EndModeVisuals.attributes.add('text', { type: 'entity' });
EndModeVisuals.attributes.add('icon', { type: 'entity' });

pc.extend(EndModeVisuals.prototype, {
    initialize: function() {
        this.app.on('SwapMode:onEndStart', this.showText, this);
        this.app.on('SwapMode:speedUp', this.showSpeedUp, this);
        this.app.on('SwapMode:onFinaleDone', this.hideAll, this);
        
        LocalizationManager.instance.setText(this.text, 'END_MODE_TEXT');
    },
    
    hideAll: function() {
        this.text.enabled = false;
        this.icon.enabled = false;
    },

    showText: function() {
        this.text.enabled = true;
        this.icon.enabled = false;
    },

    showSpeedUp: function() {
        this.text.enabled = false;
        this.icon.enabled = true;  
    },
});


// BoundingBoxRaycast.js
/* ============================================================================================================
 * Fires a raycast that collides with all the entities in the boundingbox library
 * raycast first checks which area(s) to check then loops through the entities connected to that/those area(s)
 * returns the entity closest to the camera 
 * ============================================================================================================
 */
class BoundingBoxRaycast extends pc.ScriptType {
    static addAttributes(){
        this.attributes.add('cameraEntity', {type: 'entity', title: 'Camera Entity'});
        this.attributes.add('visualizeHit', {type: 'boolean', title: 'Visualize the raycast hit point'});
        this.attributes.add('hitMarkerEntity', {type: 'entity', title: 'Hit Marker Entity'});
    }
    initialize() {
        BoundingBoxRaycast.instance = this;
        this.ray = new pc.Ray();
        this.hitPosition = new pc.Vec3();
        this.closestHitPosition = new pc.Vec3();
        if(!this.visualizeHit){
            this.hitMarkerEntity.enabled = false;
        }
        this.on('attr:visualizeHit', function (value, prev){
            if(!this.visualizeHit){
                this.hitMarkerEntity.enabled = false;
            }else{
                this.hitMarkerEntity.enabled = true;
            }
        });
    }
    doRayCast (screenPosition) {
        // Initialise the ray and work out the direction of the ray from the a screen position
        this.cameraEntity.camera.screenToWorld(screenPosition.x, screenPosition.y, this.cameraEntity.camera.farClip, this.ray.direction); 
        this.ray.origin.copy(this.cameraEntity.getPosition());
        this.ray.direction.sub(this.ray.origin).normalize();

        //entity to return
        var entity = this.checkArea();
        return this.getObjectEntity(entity);
    }
    getObjectEntity(raycastEntity){
        if(!raycastEntity) return;
        if(raycastEntity.script && raycastEntity.script.has('objectOptions')){
            return raycastEntity;
        }else{
            if(raycastEntity.parent !== null){
                return this.getObjectEntity(raycastEntity.parent);
            }else{
                return;
            }
        }
    }
    checkArea (){
        //set to null so null will be returned if no objects are found.
        var areaEntity = null;
        var returnEntity = null;
        var oldEntity = null;
        var closestDistanceSq = Number.POSITIVE_INFINITY;
        var cameraPosition = this.cameraEntity.getPosition();

        //loop through area boundingbox library so see which areas are hit
        for (var i = 0; i < BoundingBoxLibrary.instance._areaBoundingBoxes.length; i++) {
            var currentAreaBoundingBox = BoundingBoxLibrary.instance._areaBoundingBoxes[i];
            var rayCastResult = currentAreaBoundingBox.generatedBB.intersectsRay(this.ray, this.hitPosition);
            //set area to current entity
            areaEntity = currentAreaBoundingBox.entity;
            //check if area is a collider
            if (rayCastResult && areaEntity.script.has('raycastColliderArea')) {
                //set hitmarker potition to where the raycast is hit
                //this.setHitmarker(this.hitPosition);

                //get closest entity to the cam
                var areaNumber = areaEntity.script.get('raycastColliderArea').number;
                var closestEntityInArea = this.getEntity(areaNumber);

                //handle objects contained in multiple areas
                if (closestEntityInArea) {
                    var distanceSq = this.closestHitPosition.distanceSq(cameraPosition);

                    if (distanceSq < closestDistanceSq){
                        oldEntity = closestEntityInArea;
                        closestDistanceSq = distanceSq;
                    }
                }

                if(areaNumber) {
                    returnEntity = oldEntity;
                }
            }
        }

        if (returnEntity) {
            this.setHitmarker(this.closestHitPosition);
        }

        return returnEntity;
    }
    //searches for entities with raycastCollider on them
    //returns entity with hitposition closest to the camera
    //return null if no entity is hit.
    getEntity(area) {
        var closestEntity = null;
        var closestDistanceSq = Number.POSITIVE_INFINITY;
        var cameraPosition = this.cameraEntity.getPosition();

        //loop through boundingbox library based on areaIndex
        for (var i = 0; i < BoundingBoxLibrary.instance._groupList[area - 1].length; i++) {
            var currentBoundingBox = BoundingBoxLibrary.instance._groupList[area - 1][i];

            if (!currentBoundingBox.entity.enabled) {
                continue;
            }

            var rayCastResult = currentBoundingBox.generatedBB.intersectsRay(this.ray, this.hitPosition);

            if (rayCastResult && currentBoundingBox.entity.script && currentBoundingBox.entity.script.has('raycastColliderObject')) {
                // console.log(rayCastResult, currentBoundingBox.entity.enabled)

                var distanceSq = this.hitPosition.distanceSq(cameraPosition);

                if (distanceSq < closestDistanceSq) {
                    closestDistanceSq = distanceSq;
                    closestEntity = currentBoundingBox.entity;
                    this.closestHitPosition.copy(this.hitPosition);
                }
            }
        }

        return closestEntity;
    }
    //set hitmarker to given position
    setHitmarker(position){
        this.app.fire('BoundingBoxRaycast:updatePosition');
        if(this.hitMarkerEntity !== null){
            this.hitMarkerEntity.setPosition(position);
        }
    }
}
pc.registerScript(BoundingBoxRaycast, 'boundingBoxRaycast');
BoundingBoxRaycast.addAttributes();


// ImpulseHandler.js
var ImpulseHandler = pc.createScript('impulseHandler');

ImpulseHandler.attributes.add('debug', { type: 'boolean' });

pc.extend(ImpulseHandler.prototype, {
    initialize: function () {
        this._impulsesDelay = [];
        this._impulses = [];

        this._wiggle = false;
        this.wiggleTweenActive = false;

        this._model = this.entity.findByName('ModelEntity');

        this._impulseVector = new pc.Vec2();
    },

    update: function (dt) {
        for (var i = this._impulsesDelay.length - 1; i >= 0; i--) {
            var impulse = this._impulsesDelay[i];

            impulse.delay -= dt;

            if (impulse.delay <= 0) {
                this._impulses.push(this._impulsesDelay.splice(i, 1)[0]);
            }
        }

        var position = this._model.getLocalPosition();

        for (var j = this._impulses.length - 1; j >= 0; j--) {
            var impulse = this._impulses[j];
            var deltaX = impulse.deltaX;
            var deltaY = impulse.deltaY;
            var amplitude = impulse.amplitude;

            var distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            var x = deltaX === 0 ? 0 : amplitude * deltaX / distance / Math.abs(deltaX);
            var y = deltaY === 0 ? 0 : amplitude * -deltaY / distance / Math.abs(deltaY);

            this._createTween(x, y, impulse.duration, true);

            this._impulses.splice(j, 1);
        }
    },

    _createTween: function (x, y, duration, backToNeutral) {
        var position = this._model.getLocalPosition();

        this.stopTween();

        var angles = this._model.parent.getLocalEulerAngles();
        if (angles.x > 89 && angles.x < 91) {
            this._tween = this._model.tween(this._model.getLocalPosition()).to({ x: x, y: position.y, z: y }, duration || ImpulseHandler.DURATION, pc.SineInOut).start();

        } else {
            this._tween = this._model.tween(this._model.getLocalPosition()).to({ x: x, y: -y, z: position.z }, duration || ImpulseHandler.DURATION, pc.SineInOut).start();
        }


        if (backToNeutral) {
            this._tween.on('complete', function () {
                this.stopTween();
                this.moveToCenter(duration);
            }, this);
        } else {
            this._tween.on('complete', function () {
                this.wiggle();
            }, this);
        }
    },

    setWiggle: function (value) {
        this._wiggle = value;

        if (this._wiggle) {
            if (!this._tween) {
                this.wiggle();
            }
        } else if (!this._wiggle && this.wiggleTweenActive) {
            this.stopTween();
        }
    },

    wiggle: function () {
        this.stopTween();

        if (!this._wiggle) {
            return;
        }

        var angles = this._model.parent.getLocalEulerAngles();

        this.wiggleTweenActive = true;

        if (angles.x > 89 && angles.x < 91) {
            this._model.setLocalEulerAngles(0, WiggleAnimation.WIGGLE_ANGLES.min, 0);
            this._tween = this._model.tween(this._model.getLocalRotation()).rotate({ x: 0, y: WiggleAnimation.WIGGLE_ANGLES.max, z: 0 }, WiggleAnimation.WIGGLE_DURATION, pc.BackInOut).start(true);

        } else {
            this._model.setLocalEulerAngles(0, WiggleAnimation.WIGGLE_ANGLES.min, 0);
            this._tween = this._model.tween(this._model.getLocalRotation()).rotate({ x: 0, y: WiggleAnimation.WIGGLE_ANGLES.max, z: 0 }, WiggleAnimation.WIGGLE_DURATION, pc.BackInOut).start(true);
        }

        this._tween.loop(true);
        this._tween.yoyo(true);

        var time = WiggleAnimation.instance.time;
        var reverse = WiggleAnimation.instance.reverse;

        this._tween.time = time;

        if (reverse) {
            this._tween._repeat(time);
        }
    },

    moveToCenter: function (duration) {
        this._createTween(0, 0, duration, false);
    },

    impulse: function (deltaX, deltaY, amplitude, delay, duration) {
        this._impulsesDelay.push({ deltaX: deltaX, deltaY: deltaY, amplitude: amplitude, delay: delay, duration: duration });
    },

    stopTween: function () {
        if (this._tween) {
            if (this.wiggleTweenActive) {
                //console.warn("stop wiggle")
            }
            this._tween.stop();
            this._tween = null;
        }

        this.wiggleTweenActive = false;
    },

    reset: function () {
        this.stopTween();
        this._model.setLocalPosition(0, 0, 0);
        this._impulses.length = 0;
        this._impulsesDelay.length = 0;
    },
});

// ShakeCamera.js
var ShakeCamera = pc.createScript('shakeCamera');


pc.extend(ShakeCamera.prototype, {
    initialize: function () {
        this.app.on("ShakeCamera:shake", this.shakeCamera, this);
        this.on('destroy', this._onDestroy, this);

        this.tweenTime = 0.1;
    },

    _onDestroy: function () {
        this.app.off("ShakeCamera:shake", this.shakeCamera, this);
    },

    shakeCamera: function (duration, shake) {
        duration = duration / this.tweenTime;

        this.rotation = this.entity.getLocalEulerAngles().clone();

        this.shakeOffset = 0.25;
        var shakeNumber = this.shakeOffset;
        this.shakeDecrease = this.shakeOffset / duration;

        this.entity.setLocalEulerAngles(this.rotation.x, -this.shakeOffset, this.rotation.z);

        this.shakeTween(duration, shakeNumber);
    },

    shakeTween: function (duration, shakeNumber) {
        if (duration > 0) {
            this.entity.tween(this.entity.getLocalRotation())
                .rotate({ y: shakeNumber }, this.tweenTime, pc.SineInOut)
                .yoyo(true).start(true).on('complete', function () {
                    this.shakeOffset = this.shakeOffset - this.shakeDecrease;
                    if (shakeNumber < 0) {
                        shakeNumber = this.shakeOffset;
                    } else {
                        shakeNumber = this.shakeOffset * -1;
                    }
                    this.shakeTween(duration - 1, shakeNumber);
                }.bind(this));
        } else {
            this.entity.setLocalEulerAngles(this.rotation);
        }

    }
});


// ElementInputFollower.js
var ElementInputFollower = pc.createScript('elementInputFollower');

ElementInputFollower.attributes.add('followButton', { type: 'entity' });

pc.extend(ElementInputFollower.prototype, {
    initialize: function() {
        if (this.followButton.script && this.followButton.script.elementInput) {
            this.followButton.script.elementInput.on('onButtonInputChange', this._onButtonInputChange.bind(this));
        } else {
            console.warn(this.entity.name)
        }
    },
    
    _onButtonInputChange: function(down, enter, active) {
        if (!active) {
            this.entity.element.color = this.followButton.button.inactiveTint;
            return;
        }
        if (down) {
            this.entity.element.color = this.followButton.button.pressedTint;
        } else if (enter) {
            this.entity.element.color = this.followButton.button.hoverTint;
        } else {
            this.entity.element.color = this.followButton.button.defaultTint;
        }
    } 
});

// UpgradeGardenSelectAnim.js
var UpgradeGardenSelectAnim = pc.createScript('upgradeGardenSelectAnim');

UpgradeGardenSelectAnim.attributes.add('selectParticle', {type: 'entity', title: 'Garden Select Particle '});

pc.extend(UpgradeGardenSelectAnim.prototype,{
    initialize: function(){
        this.isAnimPlaying = false;
        
        this.objectPool = TilePrefabManager.instance.getObjectPool('UpgradeGardenSelectObjectPool');
    },
    update: function() {
         if (this.isAnimPlaying && !this.selectParticle.particlesystem.isPlaying()) {
            this.recycle();
            this.isAnimPlaying = false;
        }
    },

    startAnim: function() {
        if (!this.isAnimPlaying) {
            this.isAnimPlaying = true;
            
            this.selectParticle.particlesystem.reset();
            this.selectParticle.particlesystem.play();
        }
    },
    
    recycle: function() {
        this.objectPool.recycle(this.entity);
        this.entity.enabled =  false;
    }
});



// UnlockLevelAnimation.js
var UnlockLevelAnimation = pc.createScript('unlockLevelAnimation');


UnlockLevelAnimation.attributes.add('keyEntity', { type: 'entity', title: 'Key Entity' });
UnlockLevelAnimation.attributes.add('shadowKeyEntity', { type: 'entity', title: 'Shadow of Key' });
UnlockLevelAnimation.attributes.add('openLockAnimationGroup', { type: 'entity', title: 'Open Lock Group' });
UnlockLevelAnimation.attributes.add('openLock', { type: 'entity', title: 'lock Entity' });
UnlockLevelAnimation.attributes.add('openLockShine', { type: 'entity', title: 'openLock Spark' });
UnlockLevelAnimation.attributes.add('keySparkle', { type: 'entity', title: 'Key in lock Sparkle' });
UnlockLevelAnimation.attributes.add('keyAppearEffect', { type: 'entity', title: 'key unlock effect' });

UnlockLevelAnimation.attributes.add('keyMoveTweenDuration', { type: 'number', default: 1.5 });
UnlockLevelAnimation.attributes.add('keyScaleDuration', { type: 'number', default: 1, title: 'Initial key scale' });
UnlockLevelAnimation.attributes.add('keyScaleAnimationDur', { type: 'number', default: 1.5, title: 'Scale key huge' });
UnlockLevelAnimation.attributes.add('openLockScaleTweenDuration', { type: 'number', default: 0.5 });
UnlockLevelAnimation.attributes.add('fadeOutTweenDuration', { type: 'number', default: 0.7 });
UnlockLevelAnimation.attributes.add('closedLockTweenDuration', { type: 'number', default: 0.2 });
UnlockLevelAnimation.attributes.add('keySparkleDelay', { type: 'number', default: 0.3 });

UnlockLevelAnimation.KEY_END_SCALE = new pc.Vec3(1, 1, 1);
UnlockLevelAnimation.KEY_START_SCALE = new pc.Vec3(0.9, 0.9, 0.9);
UnlockLevelAnimation.SHADOW_ORIGINAL_SCALE = new pc.Vec3(0.9, 0.9, 0.9);
UnlockLevelAnimation.LOCK_END_ANGLE = new pc.Vec3(0, 0, 10);
UnlockLevelAnimation.LOCK_START_ANGLE = new pc.Vec3(0, 0, -10);
UnlockLevelAnimation.OPEN_LOCK_END_SCALE = new pc.Vec3(1, 1, 1);
UnlockLevelAnimation.OPEN_LOCK_START_SCALE = new pc.Vec3(0.2, 0.2, 0.2);
UnlockLevelAnimation.EFFECT_END_SCALE = new pc.Vec3(0.5, 0.5, 0.5);
UnlockLevelAnimation.EFFECT_START_SCALE = new pc.Vec3(0, 0, 0);

pc.extend(UnlockLevelAnimation.prototype, {

    initialize: function () {

        if (Singleton.instance.canCreateInstance(this)) {
            UnlockLevelAnimation.instance = this;
        }

        this.startParent = this.entity.parent;
        this.isAnimPlaying = false;
        this.originalKeyPos = this.keyEntity.getLocalPosition().clone();
        this.originalOpenLockPos = this.openLock.getLocalPosition().clone();
        this.originalKeyRotation = this.keyEntity.getLocalRotation().clone();
        this.shadowKeyStartPos = this.shadowKeyEntity.getLocalPosition().clone();
    },

    startAnim: function (parent, lock, onCompleteCallback) {
        this.keySparkle.enabled = false;
        this.keySparkle.element.opacity = 1;

        this.entity.reparent(parent);
        this.lock = lock;

        //set values for the key
        this.keyEntity.enabled = true;
        this.keyEntity.setLocalScale(0, 0, 0);
        this.keyEntity.setLocalPosition(this.originalKeyPos);
        this.keyEntity.setLocalEulerAngles(0, 0, 60);
        this.keyEntity.element.opacity = 1;

        //set values for the shadow of the key
        this.shadowKeyEntity.setLocalScale(0, 0, 0);
        this.shadowKeyEntity.setLocalEulerAngles(0, 0, 71.17);
        this.shadowKeyEntity.enabled = true;
        this.shadowKeyEntity.element.opacity = 1;

        this.isAnimPlaying = true;

        var keyAppearDuration = 0.5;

        var position = this.entity.getLocalPosition();

        lock.setLocalEulerAngles(UnlockLevelAnimation.LOCK_START_ANGLE);

        //closed lock animation
        this.lockTween = this.tweenRotate(lock, UnlockLevelAnimation.LOCK_END_ANGLE, this.closedLockTweenDuration, pc.Linear)
            .yoyo(true)
            .loop(true);
        var shadowScale = { x: 0.7, y: 0.7, z: 0.7 };
        var keyScale = { x: 2, y: 2, z: 2 };
        var angle = { x: 0, y: 0, z: -40 };

        var positionForBackKeyEffect = {
            x: this.originalKeyPos.x - this.keyEntity.element.width * 0.2,
            y: this.originalKeyPos.y + this.keyEntity.element.height * 0.3,
            z: 0
        };

        this.keyAppearEffect.setLocalPosition(positionForBackKeyEffect.x, positionForBackKeyEffect.y, positionForBackKeyEffect.z);
        this.keyAppearEffect.enabled = true;
        this.keyAppearEffect.setLocalScale(UnlockLevelAnimation.EFFECT_START_SCALE);

        this.shadowKeyEntity.setLocalPosition(this.keyEntity.getLocalPosition().x, this.keyEntity.getLocalPosition().y, this.keyEntity.getLocalPosition().z);

        //initial tween to make the key unlock effect appear
        this.keyAppearEffectTween = this.tweenScale(this.keyAppearEffect, UnlockLevelAnimation.EFFECT_END_SCALE, this.keyScaleDuration, pc.ElasticOut);


        //initial tween to make the key appear
        this.makeShadowAppearTween = this.tweenScale(this.shadowKeyEntity, UnlockLevelAnimation.KEY_START_SCALE, this.keyScaleDuration, pc.ElasticOut);

        this.makeKeyAppearTween = this.tweenScale(this.keyEntity, UnlockLevelAnimation.KEY_START_SCALE, this.keyScaleDuration, pc.ElasticOut);
        this.makeKeyAppearTween.on('complete', function () {

            //makes the key unlock effect  disappear
            this.keyAppearEffectDisappear = this.tweenScale(this.keyAppearEffect, UnlockLevelAnimation.EFFECT_START_SCALE, keyAppearDuration, pc.SineOut);
            this.keyAppearEffectDisappear.on('complete', function () { this.keyAppearEffect.enabled = false; }, this);

            //makes the shadow of the key smaller
            this.shadowSmallTween = this.tweenScale(this.shadowKeyEntity, shadowScale, this.keyScaleAnimationDur, pc.SineIn);
            this.shadowSmallTween.on('complete', function () { this.tweenScale(this.shadowKeyEntity, UnlockLevelAnimation.SHADOW_ORIGINAL_SCALE, keyAppearDuration, pc.SineOut); }, this);

            //makes the key huge after a small delay
            this.makeKeyHugeTween = this.tweenScale(this.keyEntity, keyScale, this.keyScaleAnimationDur, pc.SineIn);
            this.makeKeyHugeTween.on('complete', function () {

                //makes the key small again
                this.scaleKeyBackNormalTween = this.tweenScale(this.keyEntity, UnlockLevelAnimation.KEY_START_SCALE, keyAppearDuration, pc.SineOut);
                this.scaleKeyBackNormalTween.on('complete', function () {

                    var shadowOffsetX = 70;
                    var shadowOffsetY = 20;
                    var shadowPosToGo = { x: position.x + shadowOffsetX, y: position.y + shadowOffsetY, z: position.z };

                    //move shadow to the lock
                    this.moveShadowInLockTween = this.tweenTo(this.shadowKeyEntity, position, 0.1, pc.QuarticOut);
                    //move key into lock
                    this.moveKeyInLockTween = this.tweenTo(this.keyEntity, position, 0.1, pc.QuarticOut);
                    this.moveKeyInLockTween.on('complete', function () {
                        this.app.fire('vibrate', 120);
                        this.keySparkle.enabled = true;
                        this.stopAnim();
                        if (onCompleteCallback) { onCompleteCallback(); }
                    }, this);

                }, this);

            }, this);

            var keyToLockDelay = 0.5;
            var keyRotateDuration = 0.8;

            //rotates the shadow to fit in the lock
            this.tweenRotate(this.shadowKeyEntity, angle, keyRotateDuration, pc.CubicInOut, keyToLockDelay);

            //rotates the key to fit in the lock
            this.tweenRotate(this.keyEntity, angle, keyRotateDuration, pc.CubicInOut, keyToLockDelay);


            var tempPos = this.entity.getLocalPosition();

            var posToGo = {
                x: tempPos.x + 80,
                y: tempPos.y,
                z: tempPos.z
            };

            //move key to the right of the lock
            this.moveShadowNextToLockTween = this.tweenTo(this.shadowKeyEntity, posToGo, 1, pc.Linear);
            this.moveKeyNextToLockTween = this.tweenTo(this.keyEntity, posToGo, 1, pc.Linear);

        }, this);
    },

    stopAnim: function () {
        var keyFadeOut = 0.4;
        var delay = 0.4;

        this.lockTween.stop();
        this.app.fire('Audio:sfx', 'level_unlock.mp3');
        this.openLockAnimationGroup.enabled = true;

        //reset openlock position, scale and opacity back to start settings
        this.openLockAnimationGroup.setLocalPosition(this.originalOpenLockPos);
        this.openLock.element.opacity = 1;
        this.openLockShine.element.opacity = 1;
        this.openLock.setLocalScale(UnlockLevelAnimation.OPEN_LOCK_START_SCALE);

        //animates the openlock to grow up to size
        this.openLockGrowTween = this.tweenScale(this.openLock, UnlockLevelAnimation.OPEN_LOCK_END_SCALE, this.openLockScaleTweenDuration, pc.ElasticOut)
            .yoyo(true)
            .on('complete', function () {

                //FADE OUT ANIMATIONS
                //animates the shining effect behind the open lock
                this.openLockShineFadeAwayTween = this.tweenOpacity(this.openLockShine, 0, this.fadeOutTweenDuration, pc.Linear, delay)
                    .on('complete', this.disableEntities, this);

                //animates the open lock to fade away
                this.openLockFadeAwayTween = this.tweenOpacity(this.openLock, 0, this.fadeOutTweenDuration, pc.Linear, delay);

                //animates the key to fade away
                this.keyFadeAwayTween = this.tweenOpacity(this.keyEntity, 0, keyFadeOut, pc.Linear);

                //animates the keyshadow to fade away
                this.shadowFadeAwayTween = this.tweenOpacity(this.shadowKeyEntity, 0, keyFadeOut, pc.Linear);

            }, this);

        //animates the keysparkle to fade away
        this.keySparkleFadeAwayTween = this.tweenOpacity(this.keySparkle, 0, keyFadeOut, pc.Linear, this.keySparkleDelay);

        this.isAnimPlaying = false;

    },

    disableEntities: function () {
        if (this.openLockAnimationGroup) this.openLockAnimationGroup.enabled = false;
        if (this.keyEntity) this.keyEntity.enabled = false;
        if (this.shadowKeyEntity) this.shadowKeyEntity.enabled = false;
        if (this.keyAppearEffect) this.keyAppearEffect.enabled = false;
        if (this.keySparkle) this.keySparkle.enabled = false;
    },

    stopAllAnimations: function () {

        if (this.keyAppearEffectTween) this.keyAppearEffectTween.stop();
        if (this.makeShadowAppearTween) this.makeShadowAppearTween.stop();
        if (this.makeKeyAppearTween) this.makeKeyAppearTween.stop();
        if (this.keyAppearEffectDisappear) this.keyAppearEffectDisappear.stop();
        if (this.shadowSmallTween) this.shadowSmallTween.stop();
        if (this.makeKeyHugeTween) this.makeKeyHugeTween.stop();
        if (this.scaleKeyBackNormalTween) this.scaleKeyBackNormalTween.stop();
        if (this.moveShadowNextToLockTween) this.moveShadowNextToLockTween.stop();
        if (this.moveShadowInLockTween) this.moveShadowInLockTween.stop();
        if (this.moveKeyInLockTween) this.moveKeyInLockTween.stop();
        if (this.moveKeyNextToLockTween) this.moveKeyNextToLockTween.stop();
        if (this.openLockGrowTween) this.openLockGrowTween.stop();
        if (this.openLockFadeAwayTween) this.openLockFadeAwayTween.stop();
        if (this.keyFadeAwayTween) this.keyFadeAwayTween.stop();
        if (this.shadowFadeAwayTween) this.shadowFadeAwayTween.stop();
        if (this.openLockShineFadeAwayTween) this.openLockShineFadeAwayTween.stop();
        if (this.openLockGrowTween) this.openLockGrowTween.stop();
        if (this.keySparkleFadeAwayTween) this.keySparkleFadeAwayTween.stop();

        this.disableEntities();
    },


    tweenOpacity: function (entity, opacity, duration, easing, delay) {
        return entity.tween(entity.element)
            .to({ opacity: opacity }, duration, easing, delay || 0)
            .start();

    },

    tweenTo: function (entity, position, duration, easing, delay) {
        return entity.tween(entity.getLocalPosition()).to(position, duration, easing, delay || 0)
            .start();
    },

    tweenScale: function (entity, scale, duration, easing, delay) {
        return entity.tween(entity.getLocalScale())
            .to(scale, duration, easing, delay || 0)
            .start();
    },

    tweenRotate: function (entity, angle, duration, easing, delay) {
        return entity.tween(entity.getLocalEulerAngles())
            .rotate(angle, duration, easing, delay || 0)
            .start();
    }
});

// CameraPath.js
var CameraPath = pc.createScript('cameraPath');

CameraPath.CURVE_ENUM = [
    { Cardinal: 'CURVE_CARDINAL'} ,
    { Catmull: 'CURVE_CATMULL'} ,
    { Linear: 'CURVE_LINEAR'} ,
    { SmoothStep: 'CURVE_SMOOTHSTEP'} ,
    { Spline: 'CURVE_SPLINE'},
    { Step: 'CURVE_STEP'},
];

CameraPath.attributes.add("pathRoot", {type: "entity", title: "Path Root"});
CameraPath.attributes.add("duration", {type: "number", default: 10, title: "Duration Secs"});
CameraPath.attributes.add("target", {type: "entity"});

CameraPath.attributes.add('positionCurve', { type: 'string', enum: CameraPath.CURVE_ENUM, default: 'CURVE_CARDINAL' });
CameraPath.attributes.add('rotationCurve', { type: 'string', enum: CameraPath.CURVE_ENUM, default: 'CURVE_CARDINAL' });
CameraPath.attributes.add('upCurve', { type: 'string', enum: CameraPath.CURVE_ENUM, default: 'CURVE_CARDINAL' });

CameraPath.attributes.add('slider', { type: 'number', min: 0, max: 1, step: 0.001 });

CameraPath.attributes.add("playAnimation", {type: "boolean" });

CameraPath.attributes.add('lookAtTarget', { type: 'vec3' });
CameraPath.attributes.add('useLookAtTarget', { type: 'boolean' });
CameraPath.attributes.add('useLength', { type: 'boolean' });

CameraPath.attributes.add('useOffsetAll', { type: 'boolean' });
CameraPath.attributes.add('useRotation', { type: 'boolean' });

// initialize code called once per entity
pc.extend(CameraPath.prototype, {
    initialize: function() {
        // Generate the camera path using pc.Curve: http://developer.playcanvas.com/en/api/pc.Curve.html
        this.createPath();

        this._originalLookAtTarget = this.lookAtTarget.clone();
        this._originalPositions = [];
        
        // Destroy all models.
        this.pathRoot.find(function(node) {
            return node.model;
        }).forEach(function(node) {
            node.destroy();
        });
        
        for (var i = 0; i < this.pathRoot.children.length; i++) {
            var node = this.pathRoot.children[i];
            
            this._originalPositions[i] = node.getPosition().clone();
        }
        
        this.on('attr:playAnimation', this.play, this);
        this.on('attr:slider', function(value) {
            this.time = this.duration * value;
            this.updateTransform();
        }, this);

        // Learn more about live attribute tweaking from this project: https://playcanvas.com/editor/scene/475560
        // If the user decides to change the path while the app is running, this allows for quicker iteration
        this.on("attr:pathRoot", function (value, prev) {
            if (value) {
                this.createPath();
                this.time = 0;    
            }
        });

        this.time = 0;   

        // Caching some Vec3 objects that will be used in the update loop continously 
        // so we don't keep triggering the garbage collector
        this.lookAt = new pc.Vec3();
        this.up = new pc.Vec3();
    
        this.flyingThrough = false; 
    },

    update: function(dt) {
        if (!this.flyingThrough) {
            return;
        }
        
        this.time += dt;

        // Loop the path flythrough animation indefinitely 
        
        this.updateTransform();
        
        if (this.time > this.duration) {
            this.flyingThrough = false;
            this.fire('complete');
            //this.time -= this.duration;
        }
    },

    updateTransform: function() {
        // Work out how far we are in time we have progressed along the path
        var percent = this.time / this.duration;
        
        // Get the interpolated values for the position from the curves     
        this.target.setPosition(this.px.value(percent), this.py.value(percent), this.pz.value(percent));

        // Get the interpolated values for the look at point from the curves 
        this.lookAt.set(this.tx.value(percent), this.ty.value(percent), this.tz.value(percent));

        // Get the interpolated values for the up vector from the curves     
        this.up.set(this.ux.value(percent), this.uy.value(percent), this.uz.value(percent));

        // Make the camera look at the interpolated target position with the correct
        // up direction to allow for camera roll and to avoid glimbal lock
        if (this.useLookAtTarget) {
            this.target.lookAt(this.lookAtTarget, CameraPath.BACK);
            
            var position = this.target.getPosition();
            
            if (position.x === 0 && position.y === 0) {
                this.target.setEulerAngles(0, 0, 0);
            }
        } else if (this.useRotation) {
            this.target.setLocalEulerAngles(this.lookAt.x, this.lookAt.y, this.lookAt.z);
        } else {
            this.target.lookAt(this.lookAt, this.up);
        }
    },
    
    createPath:  function () {
        var curveMode = pc.CURVE_CARDINAL;

        // Create curves for position
        this.px = new pc.Curve(); 
        this.px.type = pc[this.positionCurve];

        this.py = new pc.Curve(); 
        this.py.type = pc[this.positionCurve];    

        this.pz = new pc.Curve(); 
        this.pz.type = pc[this.positionCurve];

        // Create curves for target look at position
        this.tx = new pc.Curve();
        this.tx.type = pc[this.rotationCurve];

        this.ty = new pc.Curve();
        this.ty.type = pc[this.rotationCurve];

        this.tz = new pc.Curve();
        this.tz.type = pc[this.rotationCurve];

        // Create curves for the 'up' vector for use with the lookAt function to 
        // allow for roll and avoid gimbal lock
        this.ux = new pc.Curve();
        this.ux.type = pc[this.upCurve];

        this.uy = new pc.Curve();
        this.uy.type = pc[this.upCurve];

        this.uz = new pc.Curve();
        this.uz.type = pc[this.upCurve];

        var nodes = this.pathRoot.children;  

        // Get the total linear distance of the path (this isn't correct but gives a decent approximation in length)
        var pathLength = 0;

        // Store the distance from the start of the path for each path node
        var nodePathLength = [];

        // For use when calculating the distance between two nodes on the path
        var distanceBetween = new pc.Vec3();

        // Push 0 as we are starting our loop from 1 for ease
        nodePathLength.push(0);

        for (i = 1; i < nodes.length; i++) {
            var prevNode = nodes[i-1];
            var nextNode = nodes[i];

            // Work out the distance between the current node and the one before in the path
            distanceBetween.sub2(prevNode.getPosition(), nextNode.getPosition());
            pathLength += distanceBetween.length();

            nodePathLength.push(pathLength);
        }
        
        for (i = 0; i < nodes.length; i++) {
            // Calculate the time for the curve key based on the distance of the path to the node
            // and the total path length so the speed of the camera travel stays relatively
            // consistent throughout
            var t = this.useLength ? nodePathLength[i] / pathLength : i / (nodes.length-1);
            var node = nodes[i];

            var pos = node.getPosition();
            this.px.add(t, pos.x);
            this.py.add(t, pos.y);
            this.pz.add(t, pos.z);

            // Create and store a lookAt position based on the node position and the forward direction
            if (this.useRotation) {
                var lookAt = node.getLocalEulerAngles();
                this.tx.add(t, lookAt.x);
                this.ty.add(t, lookAt.y);
                this.tz.add(t, lookAt.z);
            } else {
                var lookAt = pos.clone().add(node.forward);
                this.tx.add(t, lookAt.x);
                this.ty.add(t, lookAt.y);
                this.tz.add(t, lookAt.z);
            }


            var up = node.up;
            this.ux.add(t, up.x);
            this.uy.add(t, up.y);
            this.uz.add(t, up.z);
        }
    }, 
    
    play: function() {
        this.reset();
        this.flyingThrough = true;
        
        return this;
    },
    
    reset: function() {
        this.flyingThrough = false;
        this.time = 0;
    },
    
    stop: function() {
        this.flyingThrough = false;
    },
    
    setBeginPosition: function(radius) {
        var firstNode = this.pathRoot.children[0];
        var firstNodePosition = this._originalPositions[0];
        
        firstNode.setPosition(firstNodePosition.x, firstNodePosition.y, radius);
        
        this.createPath();
        
        return this;
    },
    
    setEndPosition: function(radius) {
        var index = this.pathRoot.children.length - 1;
        var lastNode = this.pathRoot.children[index];
        var lastNodePosition = this._originalPositions[index];

        lastNode.setPosition(lastNodePosition.x, lastNodePosition.y, radius);
        
        this.createPath();
        
        return this;
    },
    
    addAllPositions: function(radius) {        
        for (var i = 0; i < this.pathRoot.children.length; i++) {
            var node = this.pathRoot.children[i];
            var position = this._originalPositions[i];
            node.setPosition(position.x, position.y, position.z + radius);
        }
                
        this.createPath();
        
        return this;
    },
    
    addOffset: function(offset) {
        for (var i = 0; i < this.pathRoot.children.length; i++) {
            var node = this.pathRoot.children[i];
            var position = this.pathRoot.children[i].getPosition();
            node.setPosition(position.x + offset.x, position.y + offset.y, position.z);
        }
        
        this.createPath();    
        
        this.lookAtTarget.set(this._originalLookAtTarget.x + offset.x, this._originalLookAtTarget.y + offset.y, this._originalLookAtTarget.z);
                
        return this;
    },
    
    resetPositions: function() {
        for (var i = 0; i < this.pathRoot.children.length; i++) {
            var node = this.pathRoot.children[i];
            var position = this._originalPositions[i];
            node.setPosition(position.x, position.y, position.z);
        }
        
        return this;
    },
});

CameraPath.BACK = new pc.Vec3(0, 0.01, 1);

// MaxElementScale.js
var MaxElementScale = pc.createScript('maxElementScale');

MaxElementScale.attributes.add('fillPercentage', { type: 'number', default: 1 });
MaxElementScale.attributes.add('maxDesktopScale', { type: 'number', default: -1 });
MaxElementScale.attributes.add('fillSmallestSide', { type: 'boolean' });
MaxElementScale.attributes.add('debugScale', { type: 'boolean' });

pc.extend(MaxElementScale.prototype, {
    initialize: function() {
        this._onResize(ViewportManager.instance.getOrientation(), ViewportManager.instance.width, ViewportManager.instance.height, ViewportManager.instance.getDevice());
        this.app.on('ViewportManager:onResize', this._onResize, this);
    },

    _onResize: function(orientation, width, height, device) {
        var rotation = Math.abs(Math.round(this.entity.getLocalEulerAngles().z));

        // take into account that the entity can rotate so width and height need to be switched
        var isRotated = false;
        if (rotation === 90 || rotation === 270) {
            isRotated = true;
        } else if (rotation !== 0 && rotation !== 180){
            console.warn('Element is diagonal, can`t use max scale script');
            return;
        }

        // calculate the scale factor of the screenheiht based on reference resolution
        var yScale = UIManager.instance.getReferenceResolution().y / height;

        var elementWidth = this.entity.element.width;
        var elementHeight = this.entity.element.height;

        // calculate the resize scales of the x and y sizes
        var scaleX = (width * this.fillPercentage) / (isRotated ? elementHeight : elementWidth) * yScale;
        var scaleY = (height * this.fillPercentage) / (isRotated ? elementWidth : elementHeight) * yScale;

        // biggest scale is the one that needs to be used
        var biggestScale = this.fillSmallestSide ? Math.min(scaleX, scaleY) : Math.max(scaleX, scaleY);

        if (this.debugScale) console.log(biggestScale);
        if (this.maxDesktopScale > 0 && device === deviceEnum.DESKTOP) {
            biggestScale = pc.math.clamp(biggestScale, 0, this.maxDesktopScale);
        }
                
        this.entity.setLocalScale(pc.Vec3.ONE.clone().scale(biggestScale));
    },
});

// BoundingBoxLibrary.js
/* ====================================================================================
 * A library that holds boundingboxes of selectable objects and which areas they are in
 * ====================================================================================
 */
class BoundingBoxLibrary extends pc.ScriptType {
    static addAttributes(){
        this.attributes.add('showObjectColliders', {type: 'boolean', title: 'Show pickable object Colliders'});
        this.attributes.add('showAreaColliders', {type: 'boolean', title: 'Show area Colliders'});
    }
    initialize() {
        BoundingBoxLibrary.instance = this;
        this._areaBoundingBoxes = [];
        this._groupList = [];
        this.visualizeBoxes = this.showObjectColliders;
        this.visualizeAreaBoxes = this.showAreaColliders;
        
        this.on('attr:showObjectColliders', function (value, prev){
            this.visualizeBoxes = this.showObjectColliders;
            this.app.fire("BoundingBoxLibrary:showObjectColliders");
        });
        this.on('attr:showAreaColliders', function (value, prev){
            this.visualizeAreaBoxes = this.showAreaColliders;
            this.app.fire("BoundingBoxLibrary:showAreaColliders");
        });
    }
    // Add a boundingbox to the boundingbox library with group as index:
    // this._groupList[[Area1Boundingboxes], [Area2Boundingboxes], [etc], [etc], [etc]]
    addBB(bb, group) {
        var area = group -1 ;
        if(this._groupList.length <= area){
            for(var i = this._groupList.length; i <= area; i ++){
                //console.log(this.groupList.length);
                var x = [];
                this._groupList.push(x);
            }
        }
        this._groupList[area].push(bb);
        // console.log(this._groupList);
    }
    addAreaBB(bb){
        this._areaBoundingBoxes.push(bb);
    }
}
pc.registerScript(BoundingBoxLibrary, 'boundingBoxLibrary');
BoundingBoxLibrary.addAttributes();

// CameraAnimations.js
var CameraAnimations = pc.createScript('cameraAnimations');

CameraAnimations.attributes.add('introPaths', { type: 'entity' });
CameraAnimations.attributes.add('outroPaths', { type: 'entity' });
CameraAnimations.attributes.add('target', { type: 'entity' });

CameraAnimations.attributes.add('debugIndex', { type: 'number' });
CameraAnimations.attributes.add('delay', { type: 'number', placeholder: 'msec', default: 200 });

// initialize code called once per entity
pc.extend(CameraAnimations.prototype, {
    initialize: function () {
        CameraAnimations.instance = this;

        this._introPaths = this.introPaths.findScripts('cameraPath').filter(function (script) { return script.entity.enabled; });
        this._outroPaths = this.outroPaths.findScripts('cameraPath').filter(function (script) { return script.entity.enabled; });

        this._currentAnimation = null;
        this.index = 0;

        this.app.on('CameraAnimation:skip', this._stopCameraAnimation, this);
        this.app.on('PerspectiveView:onCameraChange', this._stopCameraAnimation, this);
        this.on('destroy', this._onDestroy, this);
    },

    _onDestroy: function () {
        this.app.off('CameraAnimation:skip', this._stopCameraAnimation, this);
        this.app.off('PerspectiveView:onCameraChange', this._stopCameraAnimation, this);
    },

    _stopCameraAnimation: function () {
        this.stop();

        var offset = PerspectiveView.instance.getOffset();

        this.entity.setLocalPosition(offset.x, offset.y, offset.z);
        this.entity.setLocalEulerAngles(0, 0, 0);

        this.app.fire("CameraAnimations:hasSkipped");
    },

    getRandomIndex: function (paths) {
        this.index = Math.floor(Math.random() * paths.length);

        if (this.debugIndex !== -1) {
            this.index = pc.math.clamp(this.debugIndex, 0, paths.length - 1);
        }
    },

    playRandomOutro: function () {
        this.getRandomIndex(this._outroPaths);
        var path = this.play(this._outroPaths);

        path.resetPositions();

        this.outro = true;

        if (path.useOffsetAll) {
            path.addAllPositions(PerspectiveView.instance.getRadius());
        } else {
            path.setBeginPosition(PerspectiveView.instance.getRadius());
        }
        path.addOffset(PerspectiveView.instance.getOffset());

        return this;
    },

    playRandomIntro: function () {
        if (!GardenDataManager.instance.firstTime) {
            this.app.fire('UIManager:showUI', 'cameraSkip');
        }

        this.outro = false;

        this.getRandomIndex(this._introPaths);
        this.play(this._introPaths)
            .resetPositions()
            .setEndPosition(PerspectiveView.instance.getRadius())
            .addOffset(PerspectiveView.instance.getOffset());
        return this;
    },

    play: function (paths, first) {
        if (this._currentAnimation) {
            this._currentAnimation.stop();
        }

        var path = paths[this.index];

        if (!path) {
            console.warn("No path found", paths);
        }

        if (this._currentAnimation instanceof CameraPath) {
            this._currentAnimation.stop();
        }

        this._currentAnimation = path;

        path
            .play()
            .once('complete', function () {
                pc.utils.delay(this.delay || 0.01).then(function () {
                    this.onComplete();
                }.bind(this));
            }, this);

        return path;
    },

    stop: function () {
        if (this._currentAnimation) {
            this._currentAnimation.stop();
            this.onComplete();
        }
    },

    onComplete: function () {
        this._currentAnimation = null;
        var offset = PerspectiveView.instance.getOffset();
        this.target.setLocalEulerAngles(0, 0, 0);
        if (!this.outro) {
            this.target.setLocalPosition(offset.x, offset.y, offset.z);
        }
        this.fire('complete', this.outro);
        this.app.fire('UIManager:hideUI', 'cameraSkip');
    },
});


// ElementBar.js
var ElementBar = pc.createScript('elementBar');

pc.extend(ElementBar.prototype, {
    initialize: function() {
        this._onResize(ViewportManager.instance.getOrientation(), ViewportManager.instance.width, ViewportManager.instance.height, ViewportManager.instance.getDevice());
        this.app.on('ViewportManager:onResize', this._onResize, this);
    },

    _onResize: function(orientation, width, height, device) {
        // take into account that the entity can rotate so width and height need to be switched
        var rotation = Math.abs(Math.round(this.entity.getLocalEulerAngles().z));
        var isRotated = false;
        if (rotation === 90 || rotation === 270) {
            isRotated = true;
        } else if (rotation !== 0 && rotation !== 180){
            console.warn('Element is diagonal, can`t use max scale script');
            return;
        }

        var scale = UIManager.instance.getReferenceResolution().y / height;
        
        var entityScaleX = this.entity.getLocalScale().x;
        
        //scale the bar width to perfectly fill the screen
        this.entity.element.width = (isRotated ?  (height / entityScaleX) : width) * scale;
    },
});

// Disabler.js
var Disabler = pc.createScript('disabler');

// initialize code called once per entity
Disabler.prototype.initialize = function() {
    this.entity.enabled = false;
};


// TileAnimationController.js
var TileAnimationController = pc.createScript('tileAnimationController');

TileAnimationController.attributes.add('type', { type: 'string', enum: [ { ForegroundTile: "foregroundTile" }, { BackgroundTile: "backgroundTile" }], default: 'backgroundTile' });

TileAnimationController.attributes.add('model', { type: 'entity'});

TileAnimationController.attributes.add('layerAnimations', { type: 'string',  array: true });
TileAnimationController.attributes.add('idleAnimations', { type: 'string',  array: true });
TileAnimationController.attributes.add('explodeAnimations', { type: 'string',  array: true });

TileAnimationController.attributes.add('playIdleAnimation', { type: 'boolean',  default: false });
TileAnimationController.attributes.add('playRandomIdleAnimation', { type: 'boolean',  default: false });

TileAnimationController.attributes.add('idleDelay', { type: 'vec2', placeholder: ['min', 'max'] });
TileAnimationController.attributes.add('debug', { type: 'boolean',  });


pc.extend(TileAnimationController.prototype, {
    initialize: function() {
        this.queue = [];
        this.playing = false;
        this._delay = 0;
        this._time = 0;
        this._currentAnimationData = null;
        this.animationComponent = this.model.animation;
        this.tile = this.entity.script[this.type];

        this.on('exploded', this.reset, this);
    },

    setLayer: function(layer) {
        this.reset();

        var animationData = new AnimationData(this.layerAnimations[layer], 0, null, null, 11, false, this.animationComponent);
        this.complete = false;

        this.play(animationData);
    },

    playIdle: function() {
        if (!this.playIdleAnimation) {
            return;
        }

        var layer = this.tile.currentLayer - 1;

        if (this.idleAnimations.length === 1) {
            layer = 0;
        } 

        if (this.playRandomIdleAnimation) {
            layer = Math.floor(Math.random() * this.idleAnimations.length);
        }

        this._playIdle(layer, pc.math.random(this.idleDelay.x, this.idleDelay.y));
    },

    _playIdle: function(layer, delay) {
        var animationData = new AnimationData(this.idleAnimations[layer], delay, undefined, undefined, 0, false, this.animationComponent);

        this.play(animationData);
    },

    playExplode: function(layer, delay) {
        //this.reset();
        var name = this.explodeAnimations[layer];

        var animationData = this.getDuplicate(name);

        if (animationData) {
            animationData.delay = Math.min(animationData.delay, delay);

        } else {
            animationData = new AnimationData(name, delay, 'explode', layer === 0 ? 'exploded' : null, 10, false, this.animationComponent);
            this.play(animationData);
        }

        return animationData;
    },


    playAnimation: function(name, delay, eventStart, eventEnd, priority, loop = false) {  
        var animationData = new AnimationData(name, delay, eventStart, eventEnd, priority, loop, this.animationComponent);
        this.play(animationData);

        return animationData;
    },

    update: function(dt) {
        if (!this.playing) {
            return;
        }

        if (!this._currentAnimationData.playing) {
            this._delay += dt;

            if (this._delay >= this._currentAnimationData.delay) {
                if (!this.animationComponent.getAnimation(this._currentAnimationData.name)) {
                    this.showNextAnimation();
                    return;
                }
                this.animationComponent.play(this._currentAnimationData.name);

                this._currentAnimationData.animation = this.animationComponent.getAnimation(this._currentAnimationData.name);

                this._currentAnimationData.playing = true;

                this.setLoop(this._currentAnimationData.loop);

                this.doEvent(this._currentAnimationData.eventStart, this._currentAnimationData);

                if (!this._currentAnimationData.animation) {
                    // console.warn("no animation found", this._currentAnimationData.name);
                    this.showNextAnimation();
                    return;
                }
            }
        } else if (this._currentAnimationData.hasCustomEvent()) {
            this._time += dt;
            var customEvent = this._currentAnimationData.checkCustomEvent(this._time);

            if (customEvent) {
                this.doEvent(customEvent.event, this._currentAnimationData);
            }
        } else {
            try {
                if (this.animationComponent.currentTime >= this.animationComponent.duration) {
                    this.showNextAnimation();
                }  
            } catch (e) {
                console.log(e);
            }
        }
    },

    play: function(animationData) { 
        if (!this.playing) {
            this.reset();
            this._currentAnimationData = animationData;
            this.playing = true;
        } else {
            this.addToQueue(animationData);
        }
    },

    addToQueue: function(newData) {
        for (var i = this.queue.length - 1; i >= 0; i--) {
            var data = this.queue[i];

            if (newData.priority > data.priority) {
                this.queue.pop();
            } else {
                break;
            }
        }

        if (this.queue.length === 0 && this._currentAnimationData) {
            if (newData.priority > this._currentAnimationData.priority) {
                this.reset();
                this._currentAnimationData = newData;
                this.playing = true;
            } else {
                this.queue.push(newData);
            }
        } else {
            this.queue.push(newData);
        }
    },

    showNextAnimation: function() {
        this.doEvent(this._currentAnimationData.eventEnd, this._currentAnimationData);

        this._delay = 0;
        this._time = 0;

        if (this._currentAnimationData && this._currentAnimationData.playing) {
            this._currentAnimationData = this.queue.shift();
        }

        if (!this._currentAnimationData) {            
            this.reset();

            if (!this.tile.isDestroyed) {
                this.playIdle();
            }
            return;
        }
    },

    resetAnimation: function() {
        this._currentAnimationData = null;
        this._delay = 0;
        this._time = 0;
    },

    reset: function() {
        this.queue.length = 0;
        this.playing = false;
        this.resetAnimation();
    },

    getDuplicate: function(name) {
        if (this._currentAnimationData) {

            if (this._currentAnimationData.name === name) {
                return this._currentAnimationData;
            }
        }

        for (var i = 0; i < this.queue.length; i++) {
            var animationData = this.queue[i];

            if (animationData.name === name) {
                return animationData;
            }
        }  

        return null;
    },

    doEvent: function(event, animationData) {
        if (!event) {
            return;
        }

        if (this.complete) {
            console.warn("Unable to fire event", event);
            return;
        }

        this.fire(event, animationData);

        if (event === 'exploded') {
            this.complete = true;
        }
    },

    getDespawnDelay: function() {
        var delay = 0;

        if (!this._currentAnimationData) {
            return delay;
        }

        delay += this._currentAnimationData.priority > 0 ? this._currentAnimationData.delay : 0;

        for (var i = 0; i < this.queue.length; i++) {
            var animationData = this.queue[i];
            delay += animationData.priority > 0 ? animationData.delay : 0;
        }

        return delay;
    },

    getAnimationDuration: function() {
        var duration = 0;

        if (this._currentAnimationData) {
            duration += this._currentAnimationData.priority > 0 ? this._currentAnimationData.delay : 0;
            duration += this._currentAnimationData.priority > 0 ? this._currentAnimationData.duration : 0;
        }

        for (var i = 0; i < this.queue.length; i++) {
            duration += this._currentAnimationData.priority > 0 ? this.queue[i].delay : 0;
            duration += this._currentAnimationData.priority > 0 ? this.queue[i].duration : 0;
        }

        return duration;
    },

    setLoop: function(loop) {
        this.animationComponent.loop = loop;
    }
});

var AnimationData = function(name, delay, eventStart, eventEnd, priority, loop, animationComponent) {
    this.name = name;

    if (!name) {
        console.warn("no name");
    }
    this.delay = delay || 0;

    // console.log("new delay", delay)
    this.animation = null;

    this.playing = false;

    this.eventStart = eventStart;
    this.eventEnd = eventEnd;
    this.priority = typeof priority === 'number' ? priority : 1;
    this.loop = loop;

    var animation = animationComponent.getAnimation(this.name);
    this.duration = animation ? animation.duration / animationComponent.speed + AnimationData.OFFSET : 0;

    this.customEvent = [];
};

pc.extend(AnimationData.prototype, {
    addCustomEvent: function(event, delay) {
        this.customEvent.push({ event, delay });
        this.customEvent.sort((first, second) => first.delay - second.delay);
    },

    removeCustomEvent: function() {
        return this.customEvent.shift();
    },

    hasCustomEvent: function() {
        return this.customEvent.length > 0;
    },

    checkCustomEvent: function(time) {
        if (time > this.customEvent[0].delay) {
            return this.removeCustomEvent();
        }
    }
});

AnimationData.OFFSET = 0.1;

// raycastColliderArea.js
/* =============================================
 * Stores entity in the area boundingbox library
 * Allows raycast to see object as area target
 * =============================================
 */
class RaycastColliderArea extends pc.ScriptType {
    static addAttributes(){

    }
    initialize() {
        this.generateBoundingBox();
        //get area number from areaManager
        this.number = this.getAreaNumber(this.entity);
        this.storeAreaInLibrary();        
        this.app.on("BoundingBoxLibrary:showAreaColliders", this.visualizeBoxes, this);
        this.visualizeBoxes();
    }
    generateBoundingBox(){

        //create bounding box based on cube model
        switch (this.entity.model.type) {
            case 'box': 
                this.generatedBB = new pc.OrientedBox(this.entity.getWorldTransform(), new pc.Vec3(0.5, 0.5, 0.5));
                break;

            case 'sphere':
                const scale = this.entity.getLocalScale();

                if (scale.x !== scale.y && scale.x !== scale.z) {
                    console.warn("scale is not equal", scale.toString(), this.entity.name);
                }

                this.generatedBB = new pc.BoundingSphere(this.entity.getPosition(), scale.x / 2);
                break;

            default: 
                console.warn("Invalid type", this.entity.model.type);
                break;
        }

    }
    storeAreaInLibrary(){
        //store area in library
        if(this.number){
            BoundingBoxLibrary.instance.addAreaBB(this);
        }else{
            console.warn(this.entity.name + " (child of "+ this.entity.parent.name + ") cant find 'areaManager.js' in parent hierarchy");
        }
    }
    //Recursive function that searches parent hierarchy and returns areaNumber.
    getAreaNumber(gameObject){
        if(gameObject.parent !== null && gameObject.parent.script){
            if(gameObject.parent.script.has('areaManager')){
                return gameObject.parent.script.get('areaManager').areaNumber;
            }else{
                return this.getAreaNumber(gameObject.parent);
            }
        }else{
            return null;
        }
    }

    visualizeBoxes(){
        //remove model if visualize is turned off
        if(!BoundingBoxLibrary.instance.visualizeAreaBoxes){
            this.entity.removeComponent('model');
        } else{
            //add model if visualize is turned on
            if(!this.entity.model){
                this.entity.addComponent("model", {
                    type: 'box',
                });
            }
            this.entity.model.enabled = true;
            //render model as wireframe
            for (var i = 0; i < this.entity.model.meshInstances.length; i++) {
                this.entity.model.meshInstances[i].renderStyle = pc.RENDERSTYLE_WIREFRAME;
            }
        }
    }
}

pc.registerScript(RaycastColliderArea, 'raycastColliderArea');
RaycastColliderArea.addAttributes();

// chapterInformationBar.js
var ChapterInformationBar = pc.createScript('chapterInformationBar');

ChapterInformationBar.attributes.add('currentStarsTextEntity', { type: 'entity' });
ChapterInformationBar.attributes.add('totalStarsTextEntity', { type: 'entity' });
ChapterInformationBar.attributes.add('currentPartsTextEntity', { type: 'entity' });
ChapterInformationBar.attributes.add('totalPartsTextEntity', { type: 'entity' });
ChapterInformationBar.attributes.add('statsGroupEntity', { type: 'entity' });
ChapterInformationBar.attributes.add('partImageEntity', { type: 'entity' });
ChapterInformationBar.attributes.add('starImageEntity', { type: 'entity' });

pc.extend(ChapterInformationBar.prototype, {
    initialize: function () {
        this._coloredStarScript = this.starImageEntity.script.coloredStar;

        this.app.on('ChapterInformationBar:updateStats', this._updateStats, this);
        this.app.on('BookUI:switchPage', this._onPageSwitch, this);
    },

    _updateStats: function (currentStars, totalStars, currentParts, totalParts, worldID) {
        this.currentStarsTextEntity.element.text = currentStars;
        this.totalStarsTextEntity.element.text = totalStars;

        this.currentPartsTextEntity.element.text = currentParts;
        this.totalPartsTextEntity.element.text = totalParts;

        var partSprite = WorldManager.instance.getPartAssets(worldID).partSprite.id;
        this.partImageEntity.element.spriteAsset = partSprite;

        this._coloredStarScript.setStarBasedOnWorldIndex(worldID);
    },

    _onPageSwitch: function (pageIndex, totalPages, pageData) {
        this.statsGroupEntity.enabled = !isNaN(pageData.pageInfo.chapterID);
    }
});

// comicButton.js
var ComicButton = pc.createScript('comicButton');

pc.extend( ComicButton.prototype, {
    initialize: function() {
        this.entity.script.elementInput.on(inputEvents.CLICK, this._onClick, this); 
        this.app.on('BookUI:switchPage', this._onPageSwitch, this);
        this.pageID = 0;
        this.chapterID = 1;
    },
    _onClick: function() {
        this.app.fire('ComicInterface:showComic', this.chapterID, this.pageID);
    },
    _onPageSwitch: function(pageIndex, totalPages, pageData) {
        this.pageID = pageData.pageInfo.pageID;
        this.chapterID = pageData.pageInfo.chapterID;
    },
});

// ParticleManager.js
var ParticleManager = pc.createScript('particleManager');

ParticleManager.attributes.add('worlds', { type: 'entity', array: true });


pc.extend(ParticleManager.prototype, {

    initialize: function () {
        ParticleManager.instance = this;

        this.app.on('ParticleManager:enableParticles', this.enableWorldEntity, this);
        this.app.on('ParticleManager:disableParticles', this.disableWorldEntity, this);
        this.app.on('ParticleManager:speedUpParticles', this.playParticlesSpeedUp, this);
        this.app.on('ParticleManager:switchState', this.switchState, this);
        CameraAnimations.instance.on('complete', this.setParticlesToTopOfScreen, this);

        this.app.on('SwapMode:onEndStart', this.endModeSpeedup, this);
        this.app.on('WinScreen:close', this.stopEndModeSpeed, this);

        this.app.on('PerspectiveView:onCameraChange', this.onCameraChange, this);

        this.disableAllParticles();

        this.on('destroy', this.onDestroy, this);
    },

    onDestroy: function () {
        this.app.off('ParticleManager:enableParticles', this.enableWorldEntity, this);
        this.app.off('ParticleManager:disableParticles', this.disableWorldEntity, this);
        this.app.off('ParticleManager:speedUpParticles', this.playParticlesSpeedUp, this);
        this.app.off('ParticleManager:switchState', this.switchState, this);
        CameraAnimations.instance.off('complete', this.setParticlesToTopOfScreen, this);

        this.app.off('SwapMode:onEndStart', this.endModeSpeedup, this);
        this.app.off('WinScreen:close', this.stopEndModeSpeed, this);

        this.app.off('PerspectiveView:onCameraChange', this.onCameraChange, this);
    },

    disableAllParticles: function () {
        this.worlds.forEach(w => {
            w.enabled = false;
        });
    },

    enableWorldEntity: function (worldID) {
        this.currentWorld = worldID;
        this.worlds[worldID - 1].enabled = true;

        this.currentParticles = this.worlds[worldID - 1];
        this.currentParticles.script.customizeBackgroundParticles.setParticlesPosition();
        this.currentParticles.script.customizeBackgroundParticles.resetParticleCurves();
    },

    setParticlesToTopOfScreen: function (outro) {
        if (outro) {
            return;
        }

        this.currentParticles.script.customizeBackgroundParticles.setParticlesPosition();
    },

    playParticlesSpeedUp: function (duration) {
        this.currentParticles.script.customizeBackgroundParticles.startSpeedUp(duration);
    },

    stopParticles: function () {
        this.currentParticles.script.customizeBackgroundParticles.resetParticleCurves();
    },

    switchState: function (state) {
        this.currentParticles.script.customizeBackgroundParticles.switchState(state);
    },

    disableWorldEntity: function (worldID) {
        this.worlds[this.currentWorld - 1].enabled = false;
    },

    endModeSpeedup: function () {
        this.currentParticles.script.customizeBackgroundParticles.startEndMode();
    },

    stopEndModeSpeed: function () {
        this.currentParticles.script.customizeBackgroundParticles.stopEndModeSpeed();
    },

    onCameraChange: function () {
        if (this.currentParticles) {
            this.currentParticles.script.customizeBackgroundParticles.setParticlesPosition();
        }
    },
});

// CustomizeBackgroundParticles.js
var CustomizeBackgroundParticles = pc.createScript('customizeBackgroundParticles');

CustomizeBackgroundParticles.animationStates = Object.freeze({ IDLE: 0, SPEEDUP: 1, SPEEDDOWN: 2, ENDMODE: 3, MAXSPEED: 4 });

CustomizeBackgroundParticles.attributes.add('particleSystems', { type: 'entity', array: true });
CustomizeBackgroundParticles.attributes.add('extraParticleSystems', { type: 'entity', array: true });
CustomizeBackgroundParticles.attributes.add('cameraEntity', { type: 'entity' });
CustomizeBackgroundParticles.attributes.add('shouldUseTriggerCurve', { type: 'boolean', default: true });

CustomizeBackgroundParticles.attributes.add('durationOfSpeedChange', { type: 'number', default: 5 });
CustomizeBackgroundParticles.attributes.add('durationOfMaxSpeed', { type: 'number', default: 5 });
CustomizeBackgroundParticles.attributes.add('acceleration', { type: 'number', default: 0.03 });
CustomizeBackgroundParticles.attributes.add('curveTemplateEntity', { type: 'entity' });
CustomizeBackgroundParticles.attributes.add('triggerCurveTemplateEntity', { type: 'entity' });

CustomizeBackgroundParticles.attributes.add('shouldWindPickUp', { type: 'boolean', default: false });
CustomizeBackgroundParticles.attributes.add('horizontalPosition', { type: 'number', default: 0.5, min: 0, max: 1 });
CustomizeBackgroundParticles.attributes.add('verticalPosition', { type: 'number', default: 0.5, min: 0, max: 1 });
// CustomizeBackgroundParticles.attributes.add('topOfScreen', { type: 'boolean', title: 'Should particles start at top of the screen', default: true});
// CustomizeBackgroundParticles.attributes.add('bottomOfScreen', { type: 'boolean', title: 'Should particles start at bottom of the screen', default: false});

pc.extend(CustomizeBackgroundParticles.prototype, {

    initialize: function () {
        this.app.graphicsDevice.forceCpuParticles = true;

        this._counter = 0;
        this.slowSpeed = 1;
        //set template for the normal particle system as the base
        if (this.curveTemplateEntity) {
            this.baseCurveMin = this.curveTemplateEntity.particlesystem.localVelocityGraph.clone();
            this.baseCurveMax = this.curveTemplateEntity.particlesystem.localVelocityGraph2.clone();
        }
        //set template for the sped up particle system
        if (this.shouldUseTriggerCurve) {
            this.triggerCurveMin = this.triggerCurveTemplateEntity.particlesystem.localVelocityGraph.clone();
            this.triggerCurveMax = this.triggerCurveTemplateEntity.particlesystem.localVelocityGraph2.clone();
        }

        this.endModeAccel = 0.1;
        this.endModeSpeed = 5;

        this.isEndMode = false;

        this.state = CustomizeBackgroundParticles.animationStates.IDLE;

        this.on('destroy', this._onDestroy, this);
    },

    postInitialize: function () {
        this.app.on('PerspectiveView:onCameraChange', this._onResize, this);
    },

    _onDestroy: function () {
        this.app.off('PerspectiveView:onCameraChange', this._onResize, this);
    },

    _onResize: function () {
        this.setParticlesPosition();
    },

    update: function (dt) {
        switch (this.state) {
            case CustomizeBackgroundParticles.animationStates.IDLE:
                break;
            case CustomizeBackgroundParticles.animationStates.SPEEDUP:
                this.applySpeedChange(dt);
                if (this._counter >= this.durationOfSpeedChange) {
                    this.onCurrentStateEnd(CustomizeBackgroundParticles.animationStates.SPEEDUP);
                }
                break;
            case CustomizeBackgroundParticles.animationStates.MAXSPEED:
                this.applySpeedChange(dt);
                break;
            case CustomizeBackgroundParticles.animationStates.SPEEDDOWN:
                this.slowDownParticles(dt);
                this.applySpeedChange(dt);
                if (this._counter >= this.durationOfSpeedChange) {
                    this.onCurrentStateEnd(CustomizeBackgroundParticles.animationStates.SPEEDDOWN);
                }
                break;
            case CustomizeBackgroundParticles.animationStates.ENDMODE:
                this.endModeSpeedUp(dt);
                break;
        }

        this._counter += dt;

    },

    startSpeedUp: function (duration) {
        if (this.isEndMode) return;
        this.enableOrDisableExtraParticles(true);
        if (duration) {
            this.durationOfSpeedChange = duration;
        }

        this._counter = 0;

        this.fastSpeed = 1.00001;

        this.amplitude = this.fastSpeed - this.slowSpeed;
        this.offset = this.slowSpeed;

        if (this.shouldWindPickUp && this.triggerCurveTemplateEntity) {
            for (var i = 0; i < this.particleSystems.length; i++) {
                this.particleSystems[i].particlesystem.localVelocityGraph = this.triggerCurveMin;
                this.particleSystems[i].particlesystem.localVelocityGraph2 = this.triggerCurveMax;

            }
        }
        this.switchState(CustomizeBackgroundParticles.animationStates.SPEEDUP);
    },

    applySpeedChange: function (dt) {

        var numberToEase = pc.math.clamp(this._counter / this.durationOfSpeedChange, 0, 1);
        var ease = pc.CubicInOut(numberToEase);

        var speed = dt * (this.amplitude * ease + this.offset);
        for (var i = 0; i < this.particleSystems.length; i++) {
            this.particleSystems[i].particlesystem.emitter.simTime = speed;
        }
        if (this.shouldUseTriggerCurve)
            for (var k = 0; k < this.extraParticleSystems.length; k++) {
                this.extraParticleSystems[k].particlesystem.emitter.simTime = speed;
            }
    },

    enableOrDisableExtraParticles: function (enabled) {
        if (this.extraParticleSystems.length !== 0) {
            for (var i = 0; i < this.extraParticleSystems.length; i++) {
                this.extraParticleSystems[i].enabled = enabled;
            }
        }
    },

    slowDownParticles: function (dt) {
        this.enableOrDisableExtraParticles(false);
        this.amplitude = this.slowSpeed - this.fastSpeed;
        this.offset = this.fastSpeed;

    },

    startEndMode: function () {
        this.isEndMode = true;
        this.switchState(CustomizeBackgroundParticles.animationStates.ENDMODE);
        this.enableOrDisableExtraParticles(true);
        this.fastSpeed = this.endModeSpeed;

        if (this.shouldWindPickUp) {
            for (var j = 0; j < this.particleSystems.length; j++) {
                this.particleSystems[j].particlesystem.localVelocityGraph = this.triggerCurveMin;
                this.particleSystems[j].particlesystem.localVelocityGraph2 = this.triggerCurveMax;

            }
        }
    },

    endModeSpeedUp: function (dt) {
        var endModeFastSpeed = 1;

        if (this.currentSpeedMultiplier < this.endModeSpeed) {
            endModeFastSpeed += this.endModeAccel;
        }

        for (var i = 0; i < this.particleSystems.length; i++) {
            this.particleSystems[i].particlesystem.emitter.simTime = endModeFastSpeed;
        }
        for (var k = 0; k < this.extraParticleSystems.length; k++) {
            this.extraParticleSystems[k].particlesystem.emitter.simTime = endModeFastSpeed;
        }

    },

    stopEndModeSpeed: function () {
        this.enableOrDisableExtraParticles(false);
        this.switchState(CustomizeBackgroundParticles.animationStates.IDLE);

        this.resetParticleCurves();
        this.isEndMode = false;
    },

    resetParticleCurves: function () {
        this.switchState(CustomizeBackgroundParticles.animationStates.IDLE);

        this.isEndMode = false;


        for (var j = 0; j < this.particleSystems.length; j++) {
            this.particleSystems[j].particlesystem.localVelocityGraph = this.baseCurveMin;
            this.particleSystems[j].particlesystem.localVelocityGraph2 = this.baseCurveMax;
        }

        this.enableOrDisableExtraParticles(false);
    },

    setParticlesPosition: function () {
        var radius = PerspectiveView.instance.getRadius();

        var fov = this.cameraEntity.camera.fov / 2;

        var o = radius * Math.tan(fov * Math.PI / 180);

        var x = (-o + 2 * o * this.horizontalPosition) * this.app.graphicsDevice.width / this.app.graphicsDevice.height;
        var y = o - 2 * o * this.verticalPosition;
        this.entity.setPosition(x, y, CustomizeBackgroundParticles.Z_POSITION);
    },

    onCurrentStateEnd: function (state) {
        switch (state) {
            case CustomizeBackgroundParticles.animationStates.SPEEDUP:
                this.switchState(CustomizeBackgroundParticles.animationStates.MAXSPEED);
                this._counter = 0;
                break;
            case CustomizeBackgroundParticles.animationStates.MAXSPEED:
                this.switchState(CustomizeBackgroundParticles.animationStates.SPEEDDOWN);
                this._counter = 0;
                break;
            case CustomizeBackgroundParticles.animationStates.SPEEDDOWN:
                this._counter = 0;
                this.switchState(CustomizeBackgroundParticles.animationStates.IDLE);
                for (var j = 0; j < this.particleSystems.length; j++) {
                    this.particleSystems[j].particlesystem.localVelocityGraph = this.baseCurveMin;
                    this.particleSystems[j].particlesystem.localVelocityGraph2 = this.baseCurveMax;
                }
                break;

        }
    },

    switchState(newState) {
        if (newState === this.state) {
            return;
        }
        this.state = newState;
    },
});

CustomizeBackgroundParticles.Z_POSITION = -5;

// DailyResetManager.js
class DailyResetManager extends pc.ScriptType {
    initialize() {
        DailyResetManager.instance = this;
        
        this.currentTime = new Date();        
    }
    
    postInitialize() {
        this.calculateDateTilllReset();
    }
    
    calculateDateTilllReset() {
        this.resetDate = new Date();
        
        this.resetDate.setHours(0);
        this.resetDate.setMinutes(0);
        this.resetDate.setMilliseconds(0);
        
        this.resetDate.setHours(DailyResetManager.RESET_HOUR); 
        
        if (this.currentTime > this.resetDate) {
            this.setNextResetDate();
            this.app.fire('DailyResetTimer:reset');
        }
    }
    
    setNextResetDate() {
        this.resetDate.setDate(this.resetDate.getDate() + 1);
    }
    
    get timeTillReset() {
        return this.resetDate - this.currentTime;
    }
    
    update() {        
        this.currentTime.setTime(Date.now());
        
        if (this.currentTime > this.resetDate) {
            this.setNextResetDate();  
            this.app.fire('DailyResetTimer:reset');
        }
    }
    
    isInCooldown(time) {
        if (!this.resetDate) {
            return false;
        }
        
        DailyResetManager.DATE.setTime(this.resetDate.getTime());
        DailyResetManager.DATE.setDate(DailyResetManager.DATE.getDate() - 1);

        return time > DailyResetManager.DATE.getTime();
    }
}

DailyResetManager.DATE = new Date();

DailyResetManager.RESET_HOUR = 5; // 5 AM

pc.registerScript(DailyResetManager);

// Virus.js
var Virus = pc.createScript('virus');

pc.extend(Virus.prototype, {
    initialize: function () {
        this.parent = null;

        this._explode = false;

        this._allDestroyed = false;

        this.animationController = this.entity.script.tileAnimationController;
        this.animationController.on('explode', this._onExplodeAnimation, this);
        this.animationController.on('exploded', this._onCompleteAnimation, this);
    },

    despawnInstant: function () {
        this._explode = true;
    },

    recycle: function () {
        if (this._explode) {
            console.warn("already recycled");
            return;
        }

        this._explode = true;

        this.entity.objectPool.recycle(this.entity);
    },

    init: function (parent) {
        this.parent = parent;
        this.parent.typeID = backgroundTileEnum.VIRUS;
    },

    awake: function () {
        this.parent.hasExploded = false;
        this._explode = false;
        this.parent._modelComponent.entity.enabled = true;
        this.animationController.setLayer(this.parent.currentLayer - 1);
        this._allDestroyed = false;
    },


    explode: function (delay) {
        if (this.parent.hasExploded) {
            // Set the shortest delay
            this.animationController.playExplode(this.parent.currentLayer, delay, true);
            return true;
        } else {
            GridManager.instance.onVirusHit();
            this._allDestroyed = !GridManager.instance.nViruses;
            this.parent._onLayerExplode();

            this.parent.currentLayer--;
            this.parent.hasExploded = true;
            this.parent._isDamaged = true;

            this.animationController.playExplode(this.parent.currentLayer, delay);

            if (this.parent.currentLayer === 0) {
                this.parent.isDestroyed = true;
                GridManager.instance.onVirusDespawn(this.parent);
                StatisticsManager.instance.incrementStatistic('obstacle_destroyed', {
                    obstacle_type: TileLibrary.instance.getObstacleName(this.parent.typeID),
                });
            }

            return true;
        }
    },

    _onExplodeAnimation: function (animationData) {
        var isLastLayer = this.parent.currentLayer === 0;

        this.parent._onExplode(isLastLayer, animationData.delay, true);

        GridManager.instance.playSFX('virus_hit.mp3');

        if (this._allDestroyed) {
            GridManager.instance.playSFX('virus_destroy_all.mp3');
        } else {
            GridManager.instance.playSFX('virus_destroy_voice.mp3');
        }
    },

    _onCompleteAnimation: function () {
        this.recycle();
    },

    getDespawnDelay: function () {
        return this.animationController.getDespawnDelay();
    },

    playAnimation: function (name, delay, eventStart, eventEnd, priority) {
        this.animationController.playAnimation(name, delay, eventStart, eventEnd, priority);
    },
});


// Switcher.js
class Switcher extends pc.ScriptType {
    static addAttributes() {
        this.attributes.add('fourColorModel', { type: 'asset' });
        this.attributes.add('fiveColorModel', { type: 'asset' });
        this.attributes.add('sixColorModel', { type: 'asset' });

        this.attributes.add('materials', { type: 'asset', array: true });
        this.attributes.add('highlightMaterials', { type: 'asset', array: true });
        this.attributes.add('glowMaterials', { type: 'asset', array: true });
    }

    initialize() {
        // this.superClass = null;
        this.animationController = this.entity.script.tileAnimationController;

        this.animationController.on('explode', this._onExplode, this);
        this.animationController.on('explodeComplete', this._onExplodeComplete, this);
        this.animationController.on('remove', this._onRemove, this);
        this.animationController.on('removeComplete', this._onRemoveComplete, this);
        this.animationController.on('despawn', this._onDespawn, this);

        this.colors = [];

        this.removedColors = [];

        this.previousColor = null;
    }

    init(superClass) {
        this.superClass = superClass;
        this.superClass.typeID = foregroundTileEnum.SWITCHER;
    }

    awake() {
        this.colors = ColorManager.instance.getColorArray();
        this.nColors = this.colors.length;
        this.removedColors.length = 0;

        var asset = null;

        switch (this.nColors) {
            case 4:
                asset = this.fourColorModel;
                break;
            case 5:
                asset = this.fiveColorModel;
                break;
            case 6:
                asset = this.sixColorModel;
                break;

            default: console.warn("Something went wrong", this.colors);
                break;
        }

        //this.animationController.playAnimationController
        this.superClass._model.model.asset = asset;
        this.superClass._highlightModel.model.asset = asset;

        this.animationController.reset();
        this.animationController.playAnimation(`switcher${this.nColors}_idle_${this.nColors - this.colors.length + 1}.glb`, 0);
    }

    explode() {
        if (this._exploding) {
            return;
        }

        this._exploding = true;

        this.previousColor = this.superClass.colorID;
        this.removeColor();

        this.superClass.isMovedTile = true;

        if (this.colors.length === 0) {

            this.app.fire('ScoreManager:scoreForegroundTile', this.superClass.typeID, this.superClass._isObjective, this.superClass);
            this.superClass.despawn();

            StatisticsManager.instance.incrementStatistic("obstacle_destroyed", { obstacle_type: 'switcher' }, 1);

            if (this.superClass._isObjective && this.superClass._state === ForegroundTile._States.INACTIVE) {
                if (!ObjectiveManager.instance.isObjectiveCompleted(tileLayerEnum.FOREGROUND, this.superClass.typeID, this.superClass.colorID)) {
                    this.app.fire('ForegroundTile:onExplode', tileLayerEnum.FOREGROUND, this.superClass.typeID, this.superClass.colorID);
                }
            }

            return true;
        } else {
            //this.superClass._preventDelay = false;
            //this.superClass._hitByPower = false;
            this.setRandomColor();

            if (!this.animation) {
                if (this.colors.length > 1)
                    this.animation = this.animationController.playAnimation(`switcher${this.nColors}_rotate${this.nColors - this.colors.length + 1}.glb`, delay, 'explode', 'explodeComplete');
            }

            return false;
        }
    }

    hasExploded() {
        return this.superClass.isMovedTile;
    }

    despawnAnimation() {
        this.setCompletedGlow();
        var animationData = this.animationController.playAnimation(`switcher${this.nColors}_done.glb`, 0, "remove", "removeComplete");
        animationData.addCustomEvent('despawn', this._getDespawnDelay());
    }

    _onRemove() {
        this._exploding = false;
        this.playSound();
        GridManager.instance.playSFX(`switcher_complete_${this.nColors}.mp3`);
    }

    _onDespawn() {
        if (this.superClass._isObjective && this.superClass._state === ForegroundTile._States.INACTIVE) {
            if (!ObjectiveManager.instance.isObjectiveCompleted(tileLayerEnum.FOREGROUND, this.superClass.typeID, this.superClass.colorID)) {
                this.app.fire('ModelToUIManager:showAnimation', this.entity.getLocalPosition(), { layerID: tileLayerEnum.FOREGROUND, typeID: this.superClass.typeID, colorID: this.superClass.colorID }, 0);
            }
        }
    }

    _onRemoveComplete() {
        this.superClass._recycle();
    }

    _onExplode() {
        this._exploding = false;

        this.playSound();

        this.setCompletedGlow();
        if ((this.colors.length + (1 - this.nColors % 2)) % 2) {
            this.setFrontColor(this.superClass.colorID);
        } else {
            this.setBackColor(this.superClass.colorID);
        }

        if (this.superClass.scoreValue > 0) {
            GridManager.instance.showScore(this.superClass, this.superClass.scoreValue);
            this.superClass.scoreValue = 0;
        }
    }

    _onExplodeComplete() {
        this.animation = null;
        this.superClass._preventDelay = false;
        this.superClass.despawnDelay = 0;
        this.superClass.despawnEndPosition = null;
        this.superClass._hitByPower = false;

        this.superClass.setCoatSize();
    }

    _onDelayDone() {
        if (!this.superClass._ignoreDespawnStats) {
            if (this.superClass.scoreValue) {
                GridManager.instance.showScore(this.superClass, this.superClass.scoreValue);
                this.superClass.scoreValue = 0;
            }
        }

        if (this.superClass._state === ForegroundTile._States.INACTIVE) {
            this.despawnAnimation();
        }
    }

    removeColor() {
        let index = this.colors.indexOf(this.superClass.colorID);

        if (index === -1) {
            console.error("Color not found!", this.colors, this.superClass.colorID);
            return;
        }

        var color = this.colors.splice(index, 1)[0];

        if (this.removedColors.includes(color[0])) {
            console.warn("already has the same color removed", this.removedColors, color);
        }

        this.removedColors.push(color);
    }

    setStartingColor(color) {
        if (!color) {
            this.setRandomColor(true);
        } else {
            this.superClass.colorID = color;
        }

        this.setFrontColor(this.superClass.colorID);
        this.setBackColor(this.superClass.colorID);
    }

    setRandomColor(noMatch) {
        if (noMatch) {
            var grid = GridManager.instance;
            var x = this.superClass.x;
            var y = this.superClass.y;
            var color = ColorManager.instance.getRandomColorNoMatch(
                grid.getTile(x, y - 1),
                grid.getTile(x - 1, y),
                grid.getTile(x, y - 2),
                grid.getTile(x - 2, y),
                grid.getTile(x, y + 1),
                grid.getTile(x + 1, y)
            );

            this.superClass.colorID = color;
        } else {
            if (!this.setSpecificTutorialColors()) this.superClass.colorID = this.colors[Math.floor(Math.random() * this.colors.length)];
        }
    }

    setFrontColor(colorID) {
        var color = Object.keys(tileColorEnum)[colorID];

        this.superClass._model.model.meshInstances[1].material = this.materials[colorID - 1].resource;
        this.superClass._highlightModel.model.meshInstances[1].material = this.highlightMaterials[colorID - 1].resource;
    }

    setBackColor(colorID) {
        var color = Object.keys(tileColorEnum)[colorID];

        this.superClass._model.model.meshInstances[2].material = this.materials[colorID - 1].resource;
        this.superClass._highlightModel.model.meshInstances[1].material = this.highlightMaterials[colorID - 1].resource;
    }

    setCompletedGlow() {
        if (!this.superClass._model.model.meshInstances) {
            return;
        }

        var material = this.glowMaterials[this.previousColor - 1];
        var meshInstance = this.superClass._model.model.meshInstances.find(meshInstance => meshInstance.node.name === `switcher${this.nColors}_checker${this.nColors - this.colors.length}`);


        if (material && meshInstance) {
            this.superClass._model.model.meshInstances[3 + (this.nColors - this.colors.length - 1)].material = this.glowMaterials[this.previousColor - 1].resource;
        }
    }

    setDespawnDelay(delay) {
        if (this.animation) {
            this.animation.delay = Math.min(delay, this.animation.delay);
        } else {

            if (GridManager.instance.canExplode(this.superClass.x, this.superClass.y)) {
                if (this.colors.length > 1)
                    this.animation = this.animationController.playAnimation(`switcher${this.nColors}_rotate${this.nColors - this.colors.length + 1}.glb`, delay, 'explode', 'explodeComplete');
            } else {
                pc.timer.add(0.01, () => {
                    this.superClass._preventDelay = false;
                }, this);
            }

        }
    }

    playSound() {
        GridManager.instance.playSwitcherSFX(`combo_3_${6 - this.colors.length}_new.mp3`);
    }

    getDespawnDelay(withoutEndDelay) {
        if (this.superClass._preventDelay) {
            if (!this.animation) {
                if (this.colors.length <= 1) {
                    return this.superClass.despawnDelay + this.getEndAnimationDuration();
                } else {
                    return this.superClass.despawnDelay;
                }
            }

            return this.superClass.despawnDelay + (withoutEndDelay ? 0 : this.animation.duration);

        } else {
            return this.superClass.despawnDelay;
        }
    }

    setSpecificTutorialColors() {
        if (TutorialManager.instance.active && this.superClass.x === 1 && this.superClass.y === 2) {
            // this.colors.unshift(this.colors.splice(this.colors.indexOf(tileColorEnum.BLUE), 1)[0]);
            this.superClass.colorID = tileColorEnum.YELLOW;
            return true;
        }
        return false;
    }

    getEndAnimationDuration() {
        switch (this.nColors) {
            case 4: return 2.7 / 2;
            case 5: return 3 / 2;
            case 6: return 3.4 / 2;
            default: console.warn("wrong amount of colors", this.nColors);
                return 0;
        }
    }

    _getDespawnDelay() {
        switch (this.nColors) {
            case 4: return 2.6 / 2;
            case 5: return 2.9 / 2;
            case 6: return 3.3 / 2;
            default: console.warn("wrong amount of colors", this.nColors);
                return 0;
        }
    }
}

pc.registerScript(Switcher);
Switcher.addAttributes();


// GardenCameraClamp.js
class GardenCameraClamp extends pc.ScriptType {
    static addAttributes(){
        this.attributes.add('showBorders', {type: 'boolean', title: 'Show clamp borders'});
        this.attributes.add('borderMaxX', {type:'entity',title: 'Right border'});
        this.attributes.add('borderMinX', {type:'entity',title: 'Left border'});
        this.attributes.add('borderMaxZ', {type:'entity',title: 'Top border'});
        this.attributes.add('borderMinZ', {type:'entity',title: 'Bottom border'});
    }
    initialize(){
        this.tohigh = false;
        this.borders = [];
        if(this.showBorders){
             this.spawnBorderBoxes();
        }
        // fires when `showBorders` attribute changes
        this.on('attr:showBorders', function (value, prev) {
            if(this.borders.length === 0){
             this.spawnBorderBoxes();
            }else{
                if(value){
                    for(var index = 0; index < this.borders.length; index++){
                        this.borders[index].enabled = true;
                    }
                }else{
                    for(var index2 = 0; index2 < this.borders.length; index2++){
                        this.borders[index2].enabled = false;
                    }
                }
            }
        });
    }
    postInitialize(){
        this.app.fire("GardenCameraClamp:setClamp", this);
    }
    clampCamera(cameraScript) {
        this.handleClampOffset(cameraScript);
        this.clampHorizontal(cameraScript);
        this.clampVertical(cameraScript);
    }
    
    handleClampOffset(cameraScript){
        var angleTop = Math.abs((90 - cameraScript.entity.getRotation().x)) - ((cameraScript.entity.camera.fov/2) - 0.05);
        var angleBot = Math.abs((90 - cameraScript.entity.getRotation().x)) + ((cameraScript.entity.camera.fov/2) - 0.20);
        var height = this.entity.getPosition().y - cameraScript.entity.getPosition().y;
        this.camoffsetTop = (height * Math.tan(angleTop));
        this.camoffsetBot = (height * Math.tan(angleBot));
    }
    
    clampHorizontal(cameraScript){
        var height = Math.abs(this.entity.getPosition().y - cameraScript.entity.getPosition().y);
        var offset = (4 * (height/10)) * cameraScript.entity.camera.aspectRatio;

        var maxX = this.borderMaxX.getPosition().x - offset;
        var minX = this.borderMinX.getPosition().x + offset;
        
        if(maxX < minX){
            this.tohigh = true;
        } else{
            this.tohigh = false;
        }
        
        var predictedX = cameraScript.entity.getPosition().x + cameraScript.getRealVelocityX();
        // console.log(predictedX, maxX, offset)
        if (predictedX > maxX && !this.tohigh){
            // console.log('horizontal clamp > maxX')
            cameraScript.entity.setPosition(maxX, cameraScript.entity.getPosition().y, cameraScript.entity.getPosition().z);
        } else if (predictedX < minX && !this.tohigh){
            // console.log('horizontal clamp < minX')
            cameraScript.entity.setPosition(minX, cameraScript.entity.getPosition().y, cameraScript.entity.getPosition().z);
        } else if(this.tohigh){
            // console.log('horizontal clamp toHigh = true')
            cameraScript.entity.setPosition((minX + maxX)/2, cameraScript.entity.getPosition().y, cameraScript.entity.getPosition().z);
        }
    }
    clampVertical(cameraScript){
        var offsetTop = 10; 
        var offsetBot = 1.2; 

        var topClamp = this.borderMaxZ.getPosition().z - offsetTop;
        var botClamp = this.borderMinZ.getPosition().z + offsetBot;

        if(cameraScript.entity.getPosition().z + cameraScript.getRealVelocityZ() > botClamp + this.camoffsetBot){
            cameraScript.entity.setPosition(cameraScript.entity.getPosition().x, cameraScript.entity.getPosition().y, botClamp + this.camoffsetBot) ;
            cameraScript.velocity.z = 0;
        }

        if(cameraScript.entity.getPosition().z + cameraScript.getRealVelocityZ() < topClamp + this.camoffsetTop){
            cameraScript.entity.setPosition(cameraScript.entity.getPosition().x, cameraScript.entity.getPosition().y, topClamp + this.camoffsetTop) ;
            cameraScript.velocity.z = 0;
        }
    }
    
    
    //debugging
    spawnBorderBoxes(){
        var yOffset = 1.5;
        var height = 1;
        var width = 0.1;
        var boxMaxX = new pc.Entity();
        var boxMinX = new pc.Entity();
        var boxMaxZ = new pc.Entity();
        var boxMinZ = new pc.Entity();
        
        this.app.root.addChild(boxMaxX);
        this.app.root.addChild(boxMinX);
        this.app.root.addChild(boxMaxZ);
        this.app.root.addChild(boxMinZ);
        
        boxMaxX.addComponent("model", { type: 'box', });
        boxMinX.addComponent("model", { type: 'box', });
        boxMaxZ.addComponent("model", { type: 'box', });
        boxMinZ.addComponent("model", { type: 'box', });
        
        boxMaxX.setLocalScale(width, height, this.borderMaxZ.getPosition().z-this.borderMinZ.getPosition().z);
        boxMinX.setLocalScale(width, height, this.borderMaxZ.getPosition().z-this.borderMinZ.getPosition().z); 
        boxMaxZ.setLocalScale(this.borderMaxX.getPosition().x - this.borderMinX.getPosition().x, height*2, width);
        boxMinZ.setLocalScale(this.borderMaxX.getPosition().x - this.borderMinX.getPosition().x, height, width);
        
        boxMaxX.setPosition(this.borderMaxX.getPosition().x, this.entity.getPosition().y + yOffset, this.borderMaxX.getPosition().z );
        boxMinX.setPosition(this.borderMinX.getPosition().x, this.entity.getPosition().y + yOffset, this.borderMinX.getPosition().z );
        boxMaxZ.setPosition(this.borderMaxZ.getPosition().x, this.entity.getPosition().y + yOffset + 1.5, this.borderMaxZ.getPosition().z );
        boxMinZ.setPosition(this.borderMinZ.getPosition().x, this.entity.getPosition().y + yOffset, this.borderMinZ.getPosition().z );
        
        this.borders.push(boxMaxX);
        this.borders.push(boxMinX);
        this.borders.push(boxMaxZ);
        this.borders.push(boxMinZ);
    }
}
pc.registerScript(GardenCameraClamp, 'gardenCameraClamp');
GardenCameraClamp.addAttributes();

// Exploder.js
class Exploder extends pc.ScriptType {
    static addAttributes() {
        this.attributes.add('colorId', { type: 'number', enum: Exploder.colorEnum });
        this.attributes.add('text', { type: 'entity' });
        this.attributes.add('timerBackground', { type: 'entity' });
        this.attributes.add('triggerParticle', { type: 'entity' });
    }

    initialize() {
        this._explode = false;

        this.timer = 0;

        this._active = false;
        this.isGoingToBeDestroyed = false;
        this._despawned = false;
        this.exploded = false;
        this._waitForDespawnn = false;

        this.app.on('SwapMode:onMoveStart', this._onMoveStart, this);
        this.app.on('SwapMode:onMoveEnd', this._onMoveEnd, this);
        this.app.on('ExploderParticleAnimation:startAnim', this.startTriggerAnim, this);

        this.animationController = this.entity.script.tileAnimationController;
        this.animationController.on('exploded', this._onCompleteAnimation, this);
        this.animationController.on('triggered', this.showTriggerParticles, this);
        this.animationController.on('countdownLoop', this.startCountdownLoop, this);
    }

    init(superClass) {
        this.parent = superClass;
        this.parent.colorID = this.colorId;
        this.parent.typeID = foregroundTileEnum.EXPLODER;
    }

    awake(timer) {
        this.timer = timer;
        this.animationController.setLoop(false);
        this.timerBackground.script.tweenScale.stopTween();
        this.timerBackground.setLocalScale(1, 1, 1);

        this._active = true;
        this.isGoingToBeDestroyed = false;
        this.exploded = false;
        this._despawned = false;
        this._waitForDespawnn = false;

        this.setText();

        this.animationController.setLayer(0);
        this.animationController.setLoop(false);


        GridManager.instance.addExploder(this);
    }

    _onMoveStart(ignore) {

        if (ignore) {
            return;
        }

        if (!this._active) {
            return;
        }

        this.timer--;

        this.setText();

        if (this.timer === 0) {
            // this._active = false;
            this.isGoingToBeDestroyed = true;
        }

        this.animationController.setLoop(false);

        switch (this.timer) {
            case 0:
                this.animationController.playAnimation('exploder_begin3_animation.glb', 0, null, 'countdownLoop', 2);
                GridManager.instance.playSFX('exploder_trigger_voice2.mp3');
                break;
            case 1:
                this.animationController.playAnimation('exploder_begin2_animation.glb', 0, null, 'countdownLoop', 2);
                GridManager.instance.playSFX('exploder_timer_close_to_zero.mp3');
                GridManager.instance.playSFX('exploder_trigger_voice2.mp3');
                break;
            case 2:
                this.animationController.playAnimation('exploder_begin1_animation.glb', 0, null, 'countdownLoop', 2);
                GridManager.instance.playSFX('exploder_timer.mp3');
                GridManager.instance.playSFX('exploder_trigger_voice2.mp3');
                break;
            case 3:
                this.animationController.playAnimation('exploder_pulse_animation.glb', 0, null, null, 2);
                GridManager.instance.playSFX('exploder_timer.mp3');
                break;
            default:
                this.animationController.playAnimation('exploder_pulse_animation.glb', 0, null, null, 2);
                break;
        }
        // TODO update visuals
    }

    update() {
        if (this._waitForDespawnn) {
            if (!this.triggerParticle.particlesystem.isPlaying()) {
                this._waitForDespawnn = false;
                GridManager.instance._despawnForegroundTile(this.entity.script.foregroundTile);
                this._onCompleteAnimation();
            }
        }
    }

    _onMoveEnd(ignore) {
        if (ignore) {
            return;
        }

        // if (this._active) {
        //     return;
        // }

        this.animationController.setLoop(false);
        switch (this.timer) {
            case 0:
                this.animationController.playAnimation('exploder_end2_animation.glb', 0, null, null, 2);
                break;

            case 1:
                this.animationController.playAnimation('exploder_end2_animation.glb', 0, null, null, 2);
                break;

            case 2:
                this.animationController.playAnimation('exploder_end1_animation.glb', 0, null, null, 2);
                break;
        }
    }

    setText() {
        this.text.element.text = this.timer;

        if (this.timer <= 3) {
            this.text.element.color = pc.Color.RED;
        } else {
            this.text.element.color = pc.Color.BLACK;
        }
    }

    isTriggered() {
        return this.isGoingToBeDestroyed && this.parent._state !== ForegroundTile._States.INACTIVE;
    }

    explode() {
        GridManager.instance.removeExploder(this);
        this.app.fire('ScoreManager:scoreForegroundTile', this.parent.typeID, this.parent._isObjective, this.parent);
        this.parent.despawn();
        this.exploded = true;
        this._active = false;

        StatisticsManager.instance.incrementStatistic("obstacle_destroyed", { obstacle_type: 'exploder' }, 1);

        return true;
    }

    despawnAnimation() {
        if (this._despawned) {
            return;
        }

        this._despawned = true;

        this.tweenTimer();
        this.animationController.reset();
        this.animationController.setLoop(false);
        this.animationController.playExplode(0, 0);
        GridManager.instance.playSFX('exploder_explode.mp3');
    }

    tweenTimer() {
        this.timerBackground.script.tweenScale.startTween();
    }

    _onCompleteAnimation() {
        this._active = false;
        this.parent._recycle();
    }

    getDespawnDelay(withoutEndDelay) {
        if (this.parent._preventDelay) {
            return this.parent.despawnDelay + (withoutEndDelay ? 0 : 0.5);
        } else {
            // It's stil possible to have an delay, when it is in a locker.
            return this.parent.despawnDelay || 0;
        }
    }

    addTimer(amount = 5) {
        this.timer += amount;

        this._active = true;
        this.isGoingToBeDestroyed = false;

        this.setText();
    }

    startTriggerAnim() {
        if (!this._active) {
            return;
        }

        if (this.timer > 0) return;

        this.animationController.setLoop(false);
        this.tweenTimer();
        this.animationController.playAnimation('exploder_explode_animation.glb', 0, null, "triggered", 4);
        this.isGoingToBeDestroyed = true;
        GridManager.instance.playSFX('exploder_trigger_voice2.mp3');
    }

    showTriggerParticles() {

        this.triggerParticle.particlesystem.reset();
        this.triggerParticle.particlesystem.play();
        this._waitForDespawnn = true;
    }

    startCountdownLoop() {
        pc.timer.add(0.01, () => {
            switch (this.timer) {
                case 0:
                    this.animationController.playAnimation('exploder_loop3_animation.glb', 0, null, null, false, 2);
                    break;
                case 1:
                    this.animationController.playAnimation('exploder_loop2_animation.glb', 0, null, null, false, 2);
                    break;
                case 2:
                    this.animationController.playAnimation('exploder_loop1_animation.glb', 0, null, null, false, 2);
                    break;
            }
        }, this);
    }

    canGetPointsFromDestroyedPowerTile() {
        return false;
    }
}

// //if you are gonna parse, uncomment this en comment it when you are done
// var tileColorEnum = Object.freeze({
//     NONE: 0,
//     BLUE: 1,
//     YELLOW: 2,
//     RED: 3,
//     PURPLE: 4,
//     GREEN: 5,
//     ORANGE: 6,
// });

Exploder.colorEnum = [
    { NONE: tileColorEnum.NONE },
    { BLUE: tileColorEnum.BLUE },
    { YELLOW: tileColorEnum.YELLOW },
    { RED: tileColorEnum.RED },
    { PURPLE: tileColorEnum.PURPLE },
    { GREEN: tileColorEnum.GREEN },
    { ORANGE: tileColorEnum.ORANGE }
];

pc.registerScript(Exploder);
Exploder.addAttributes();




// Coat.js
var Coat = pc.createScript('coat');

pc.extend(Coat.prototype, {
    initialize: function () {
        this.animationController = this.entity.script.tileAnimationController;
        this.animationController.on('enable', this._onExplodeAnimation, this);

        this.showTime = 0;
    },

    init: function (parent) {
        this.parent = parent;
        this.parent.typeID = backgroundTileEnum.COAT;
        this.parent.pulse = () => { };

        this.app.off('ObjectiveManager:onObjectiveSet', this.parent._onObjectiveSet, this.parent);
    },


    awake: function () {
        this.parent.hasExploded = false;
        this._explode = false;
        this.parent._modelComponent.entity.enabled = true;

        this.parent._modelComponent.show();
        this.showTime = 0;

        this.animationController.playAnimation('coat_idle_animation.glb');
        this.parent._isObjective = false;
        this.app.fire('BackgroundTile:OnSpawn', tileLayerEnum.BACKGROUND, this.parent.typeID);
    },

    explode: function () {
        this.parent._onLayerExplode();

        this.parent.currentLayer--;
        this.parent.hasExploded = true;
        this.parent._isDamaged = true;

        if (this.parent.currentLayer === 0) {
            this.parent.isDestroyed = true;
        }

        var isLastLayer = this.parent.currentLayer === 0;

        this.parent.scoreValue = 0;
        this.parent._onExplode(isLastLayer, 0, true);
    },

    _onExplode: function (isLastLayer, delay, ignoreTween) {
        var modelComponent = this.entity.findComponent('model');

        if (!modelComponent) {
            return;
        }

        var tweenEntity = modelComponent.entity;

        if (!tweenEntity) {
            return;
        }

        var scaleIncreaseTween = tweenEntity.tween(tweenEntity.getLocalScale()).to(this.parent._startModelScale.clone().scale(1.2), 0.1, pc.SineInOut);
        var scaleDownTween;
        if (isLastLayer) {
            if (!ignoreTween) {
                scaleDownTween = tweenEntity.tween(tweenEntity.getLocalScale()).to(pc.Vec3.ZERO, 0.15, pc.SineInOut);
            }

            this.app.fire('BackgroundTile:onExplode', tileLayerEnum.BACKGROUND, this.parent.typeID);

        } else {
            scaleDownTween = tweenEntity.tween(tweenEntity.getLocalScale()).to(this.parent._startModelScale.clone(), 0.1, pc.SineInOut);
        }

        scaleIncreaseTween.chain(scaleDownTween);
        scaleIncreaseTween.start();
    },

    spawn: function () {
        this.hideModel();
        this.animationController.reset();
        this.playAnimation('coat_spawn_animation.glb', 0, "enable", null, 1);

        var name = `coat_spawn_${Math.floor(Math.random() * 4) + 1}.mp3`;

        GridManager.instance.playSFX(name);
    },

    playAnimation: function (name, delay, eventStart, eventEnd, priority, loop) {
        this.animationController.playAnimation(name, delay, eventStart, eventEnd, priority, loop);
    },

    hideModel: function () {
        this.parent._modelComponent.hide();
    },

    update: function (dt) {
        if (this.showTime > 0) {

            this.showTime -= dt;

            if (this.showTime <= 0) {
                this.parent._modelComponent.show();
            }
        }
    },

    _onExplodeAnimation: function () {
        this.showTime = 0.1;
    },
});

// WiggleAnimation.js
var WiggleAnimation = pc.createScript('wiggleAnimation');

// initialize code called once per entity
WiggleAnimation.prototype.initialize = function() {
    WiggleAnimation.instance = this;
    this.reverse = false;
    this.time = 0;
};

// update code called every frame
WiggleAnimation.prototype.update = function(dt) {
    this.time += dt;
    
    if (this.time > WiggleAnimation.WIGGLE_DURATION) {
        this.time -= WiggleAnimation.WIGGLE_DURATION;
        this.reverse = !this.reverse;
    }
};

WiggleAnimation.WIGGLE_ANGLES = { min: -3, max: 3};
WiggleAnimation.WIGGLE_DURATION = 1.2;

// BoosterShopInterface.js
var BoosterShopInterface = pc.createScript('boosterShopInterface');

BoosterShopInterface.attributes.add('boosterImageEntity', { type: 'entity' });
BoosterShopInterface.attributes.add('boosterAmountTextEntity', { type: 'entity' });
BoosterShopInterface.attributes.add('boosterTitleTextEntity', { type: 'entity' });
BoosterShopInterface.attributes.add('boosterDescriptionTextEntity', { type: 'entity' });
BoosterShopInterface.attributes.add('boosterPriceTextEntity', { type: 'entity' });
BoosterShopInterface.attributes.add('boosterBuyButton', { type: 'entity' });

pc.extend(BoosterShopInterface.prototype, {
    initialize: function() {
        this.app.on('BoosterShopInterface:setBooster', this.setBoosterType, this);
        
        this.boosterBuyButton.script.elementInput.on(inputEvents.CLICK, this._onClick, this);
    },
    
    onUIEntityOpen: function() {
        this.app.fire('UIManager:showUI', 'FloatingUI');
    },

    onUIEntityClose: function() {
        if (AssetManager.instance.currentWorld.includes(AssetManager.WORLDS.WORLD)) {
            this.app.fire('UIManager:hideUI', 'FloatingUI');
        }
    },
    
    setBoosterType: function(inventoryKey) {
        this.stock = BoosterShopManager.instance._getStockByinventoryKey(inventoryKey);

        if (!this.stock) {
            Sentry.captureMessage("No stock found with inventory key: " + inventoryKey);
        }
        
        LocalizationManager.instance.setText(this.boosterTitleTextEntity, this.stock.title);
        LocalizationManager.instance.setText(this.boosterDescriptionTextEntity, this.stock.description);
        this.boosterAmountTextEntity.element.text = this.stock.amount + 'x';
        this.boosterPriceTextEntity.element.text = this.stock.price;
        this.boosterImageEntity.element.spriteAsset = this.stock.image;
    },
    
    _onClick: function() {
        if (!this.stock) {
            Sentry.captureMessage("No stock found with inventory key: " + inventoryKey);
        }

        BoosterShopManager.instance.purchase(this.stock, this.stock.amount).then((success) =>{
            if (success) this.app.fire('UIManager:hideUI', 'BoosterShop');
        });
    },
});


// DailyReward.js
var DailyReward = pc.createScript('dailyReward');

var cooldownStates = Object.freeze({ AVAILABLE: 0, ONCOOLDOWN: 1, INIT: 3 });

DailyReward.attributes.add('coinTemplate', { type: 'asset', assetType: 'template' });
DailyReward.attributes.add('coinAnimGroup', { type: 'entity' });
DailyReward.attributes.add('coinPerXAmount', { type: 'number', default: 10, title: '1 coin per this amount' });
DailyReward.attributes.add('endPoint', { type: 'entity' });
DailyReward.attributes.add('key', { type: 'string' });
DailyReward.attributes.add('coinSpawn', { type: 'entity' });
DailyReward.attributes.add('buyButtonEntity', { type: 'entity' });
DailyReward.attributes.add('timerText', { type: 'entity' });
DailyReward.attributes.add('coloredbackgroundEntity', { type: 'entity' });
DailyReward.attributes.add('borderEntity', { type: 'entity' });
DailyReward.attributes.add('coinReward', {
    type: 'json', schema: [{
        name: 'coinTextEntity',
        type: 'entity'
    }, {
        name: 'rewardAmount',
        type: 'number'
    }]
});
DailyReward.attributes.add('boosterRewards', {
    type: 'json', schema: [{
        name: 'rewardAmount',
        type: 'number'
    }, {
        name: 'inventoryKey',
        type: 'string'
    }], array: true
});
DailyReward.attributes.add('boosterRewardsTemplate', {
    type: 'json', schema: [{
        name: 'template',
        type: 'asset',
        assetType: 'template'
    }, {
        name: 'parent',
        type: 'entity'
    }]
});
DailyReward.attributes.add('adCost', {
    type: 'json', schema: [{
        name: 'amount',
        type: 'number'
    }, {
        name: 'textEntity',
        type: 'entity'
    }]
});
DailyReward.attributes.add('adProgression', {
    type: 'json', schema: [{
        name: 'template',
        type: 'asset',
        assetType: 'template'
    }, {
        name: 'parent',
        type: 'entity'
    }]
});


pc.extend(DailyReward.prototype, {

    init: function () {
        this.buyButtonEntity.script.elementInput.on(inputEvents.CLICK, this._onClick, this);
        this.setItemText();

        this.data = { time: 0 };
        this.timeTilNextDailyReward = 0;

        this.currentState = cooldownStates.INIT;

        this.app.on('DailyResetTimer:reset', this.resetCooldown, this);
    },

    setNotification: function () {
        NotificationBadgeManager.instance.setBadgeProperties('dailyReward', true);
    },

    update: function () {
        switch (this.currentState) {
            case cooldownStates.ONCOOLDOWN:
                this.setItemTextToTimer(pc.utils.millisecondsToTimeFormat(DailyResetManager.instance.timeTillReset));
        }
    },

    _onClick: function () {
        if (this.currentState === cooldownStates.AVAILABLE) {
            this.createNewCoins(this.amountOfCoins(this.coinReward.rewardAmount));
            Inventory.instance.addItem('COINS', this.coinReward.rewardAmount, 'reward', 'dailyBonus');
            Wrapper.instance.sendGAEvent(Wrapper.GA_EVENT_TYPE.DESIGN, {
                eventId: 'dailyCoinsClaimed'
            })

            this.hasBeenRewardedToday = true;
            this.data.time = Date.now();
            StatisticsManager.instance.incrementStatistic('daily_reward_received');
            StatisticsManager.instance.incrementStatistic('coins_received', {}, this.coinReward.rewardAmount);
            this.fire('updateAdSaveData');
            this.checkCooldown();
            GameManager.instance.trackCustomEvent('shop', 'daily_reward_claimed');
        }
    },

    setItemText: function () {
        this.coinReward.coinTextEntity.element.text = this.coinReward.rewardAmount;
    },

    setItemTextToTimer: function (time) {
        if (this.timerText.element.text !== time) {
            this.timerText.element.key = time;
        }
    },

    setData: function (data) {
        if (data) {
            this.data = data;
        }
    },

    checkCooldown: function () {
        if (!DailyResetManager.instance.isInCooldown(this.data.time)) {
            this.setState(cooldownStates.AVAILABLE);
        } else {
            this.setState(cooldownStates.ONCOOLDOWN);
        }
    },

    resetCooldown: function () {
        this.setState(cooldownStates.AVAILABLE);
    },

    setState: function (state) {
        if (this.currentState !== state) {
            this.currentState = state;
        }

        NotificationBadgeManager.instance.setBadgeProperties('dailyReward', this.currentState === cooldownStates.AVAILABLE);

        this.buyButtonEntity.enabled = this.currentState === cooldownStates.AVAILABLE;
        this.borderEntity.element.color = this.currentState === cooldownStates.AVAILABLE ? new pc.Color().fromString('781414') : new pc.Color().fromString('232323');
        this.coloredbackgroundEntity.enabled = this.currentState === cooldownStates.AVAILABLE;
        this.coinReward.coinTextEntity.element.outlineColor = this.currentState === cooldownStates.AVAILABLE ? new pc.Color().fromString('F35B00FF') : new pc.Color().fromString('000000FF');
        this.coinReward.coinTextEntity.element.shadowColor = this.currentState === cooldownStates.AVAILABLE ? new pc.Color().fromString('F35B00FF') : new pc.Color().fromString('000000FF');
    },

    createNewCoins(amount) {
        this.endPosition = this.endPoint.getLocalPosition();

        for (var i = 0; i < amount; i++) {
            var coin = this.coinTemplate.resource.instantiate();
            coin.reparent(this.coinAnimGroup);
            coin.setPosition(this.coinSpawn.getPosition());
            coin.script.coinAnimation.playAnimation(this.endPosition, amount, this.coinPerXAmount, 0.4, i);

        }
    },

    amountOfCoins(amount) {
        return amount / this.coinPerXAmount;
    },

    isAvailable() {
        return this.currentState === cooldownStates.AVAILABLE;
    },
});

// Sinker.js
class Sinker extends pc.ScriptType {
    static addAttributes() {
    }

    initialize() {

        this._layers = 1;

        this.highlightAnim = this.parent._highlightModel.animation;
        this.animationController = this.entity.script.tileAnimationController;
        this.animationController.on('explode', this._onExplodeAnimation, this);
        this.animationController.on('exploded', this._onCompleteAnimation, this);
    }

    despawnInstant() {
        this._explode = true;
    }

    init(parent) {
        this.parent = parent;
        this.parent.typeID = foregroundTileEnum.SINKER_1;
    }

    awake() {
        this._layers = 1;
        this.animation = null;
    }

    setLayers(layers) {
        this._layers = layers;

        this.animationController.setLayer(this._layers - 1);
    }

    hasExploded() {
        return this.parent.isMovedTile;
    }

    explode() {
        if (this._exploding) {
            return;
        }

        this._exploding = true;

        this.parent.isMovedTile = true;

        this._layers--;

        if (this._layers <= 0) {
            this.app.fire('ScoreManager:scoreBackgroundTile', this.parent.typeID, this.parent._isObjective, this.parent);

            this.parent.despawn();

            StatisticsManager.instance.incrementStatistic("obstacle_destroyed", { obstacle_type: 'anchor' }, 1);

            if (this.parent._isObjective && this.parent._state === ForegroundTile._States.INACTIVE) {
                if (!ObjectiveManager.instance.isObjectiveCompleted(tileLayerEnum.FOREGROUND, this.parent.typeID, this.parent.colorID)) {
                    this.app.fire('ForegroundTile:onExplode', tileLayerEnum.FOREGROUND, this.parent.typeID, this.parent.colorID);
                }
            }
            return true;
        } else {
            if (!this.animation) {
                this.animation = this.animationController.playExplode(this._layers, this.parent.despawnDelay, "explode");
            }
            return false;
        }
    }

    _onDelayDone() {
        if (!this.parent._ignoreDespawnStats) {
            if (this.parent.scoreValue) {
                GridManager.instance.showScore(this.parent, this.parent.scoreValue);
                this.parent.scoreValue = 0;
            }
        }

        if (this.parent._state === ForegroundTile._States.INACTIVE) {
            this.despawnAnimation();
        }

        if (this.parent._isObjective && this.parent._state === ForegroundTile._States.INACTIVE) {
            if (!ObjectiveManager.instance.isObjectiveCompleted(tileLayerEnum.FOREGROUND, this.parent.typeID, this.parent.colorID)) {
                this.app.fire('ModelToUIManager:showAnimation', this.entity.getLocalPosition(), { layerID: tileLayerEnum.FOREGROUND, typeID: this.parent.typeID, colorID: this.parent.colorID }, 0);
            }
        }
    }

    despawnAnimation() {
        var animationData = this.animationController.playExplode(0, 0, null, "exploded");
        this.parent.despawnDelay = 0;
    }

    _onExplodeAnimation(animationData) {
        var isLastLayer = this._layers === 0;

        this._exploding = false;

        this.animation = null;

        this.parent._preventDelay = false;
        this.parent.despawnDelay = 0;
        this.parent.despawnEndPosition = null;
        this.parent._hitByPower = false;

        if (this.parent.scoreValue > 0) {
            GridManager.instance.showScore(this.parent, this.parent.scoreValue);
            this.parent.scoreValue = 0;
        }

        if (isLastLayer) {
            GridManager.instance.playSFX("sinker_destroy.mp3");
        } else {
            this.highlightAnim.play(`sinker_idle_${this._layers}.glb`);
            GridManager.instance.playSFX("sinker_hit.mp3");
        }
    }

    _onCompleteAnimation() {
        this.parent._recycle();
    }

    getDespawnDelay(withoutEndDelay) {
        if (this.parent._preventDelay) {
            if (!this.animation) {
                if (this._layers <= 1) {
                    return this.parent.despawnDelay + this.getEndAnimationDuration();
                } else {
                    return 0;
                }
            }

            return this.parent.despawnDelay + (withoutEndDelay ? 0 : this.animation.duration);

        } else {
            return 0;
        }
    }

    setHighlight() {
        this.highlightAnim.play(`sinker_idle_${this._layers}.glb`);

        this.highlightAnim.entity.model.hide();

        pc.timer.add(0.01, () => {
            this.highlightAnim.entity.model.show();
        }, this);
    }

    setDespawnDelay(delay) {
        if (this.animation) {
            this.animation.delay = Math.min(delay, this.animation.delay);
        } else {
            if (GridManager.instance.canExplode(this.parent.x, this.parent.y)) {
                if (this._layers > 1)
                    this.animation = this.animationController.playExplode(this._layers - 1, delay, "explode");
            } else {
                pc.timer.add(0.01, () => {
                    this.parent._preventDelay = false;
                }, this);
            }
        }
    }

    getEndAnimationDuration() {
        return 0.4;
    }
}

pc.registerScript(Sinker);
Sinker.addAttributes();

// ExploderParticleAnimation.js
class ExploderParticleAnimation extends pc.ScriptType {
    static addAttributes() {
        this.attributes.add('particleEffects', { type: 'entity', array: true });
        this.attributes.add('delay', { type: 'number', default: 3 });
    }

    initialize() {
        this._active = false;
        this._timer = 0;
        this.app.on('ExploderParticleAnimation:startAnim', this.startAnim, this);
        this.app.on('LevelManager:onLevelStart', this.stopAnim, this);

        this.on('destroy', this._onDestroy, this);
    }

    _onDestroy() {        
        this.app.off('ExploderParticleAnimation:startAnim', this.startAnim, this);
        this.app.off('LevelManager:onLevelStart', this.stopAnim, this);
    }

    update(dt) {
        if (!this._active) {
            return;
        }

        this._timer += dt;

        if (this._timer >= this.delay) {
            LevelManager.instance.onLose();
            this._active = false;
        }
    }

    startAnim() {
        this._active = true;

        this._timer = 0;
        
        for (let i = 0; i < this.particleEffects.length; i ++) {
            var particleEffect = this.particleEffects[i];
            
            particleEffect.enabled = true;
            particleEffect.particlesystem.reset();
            particleEffect.particlesystem.play();
        }
        pc.timer.add(0.7, () => {
            this.app.fire('Audio:sfx', 'exploder_trigger.mp3');
        }, this);

        pc.timer.add(1.5, () => {
            this.app.fire('Audio:sfx', 'exploder_trigger_voice.mp3');
        }, this);

    }

    stopAnim() {
        for (let i = 0; i < this.particleEffects.length; i ++) {
            var particleEffect = this.particleEffects[i];

            particleEffect.particlesystem.reset();
            particleEffect.particlesystem.stop();
            particleEffect.enabled = false;
        }
    }
}
pc.registerScript(ExploderParticleAnimation);
ExploderParticleAnimation.addAttributes();

// LazyLoadOverlay.js
class LazyLoadOverlay extends pc.ScriptType {
    static addAttributes() {
        this.attributes.add('text', { type: 'entity' });
    }
    
    onUIEntityOpen() {
        this.index = 1;
        
        this.interval = setInterval(() => {
            this.index++;
            
            if (this.index > 3) {
                this.index = 1;
            }
            
            this.setText();
        }, 333);
        
        this.setText();
    }
    
    onUIEntityClose() {
        clearInterval(this.interval);
    }
    
    setText() {
        this.text.element.key = this.index + "_DOTS";
    }
}

pc.registerScript(LazyLoadOverlay);
LazyLoadOverlay.addAttributes();

// MoveUITween.js
class MoveUITween extends pc.ScriptType {
    static addAttributes() {
        this.attributes.add('useX', { type: 'boolean', default: true });
        this.attributes.add('useY', { type: 'boolean', default: true });
        this.attributes.add('addedDistance', { type: 'number', default: 0 });
        this.attributes.add('debug', { type: 'boolean' });
    }

    initialize() {
        this._isVisible = true;
        this._elementEntities = [];
        this._currentTweens = [];
        this._currentPromiseResolve = null;

        this._xySettings = new pc.Vec2(this.useX ? 1 : 0, this.useY ? 1 : 0);

        this._entityPosition = this.entity.getLocalPosition().clone();

        this._onResize(ViewportManager.instance.getOrientation(), ViewportManager.instance.width, ViewportManager.instance.height, ViewportManager.instance.getDevice());
        this.app.on('ViewportManager:onResize', this._onResize, this);
    }

    _onResize(orientation, width, height, device) {
        if (this.entity.script.dynamicElement) {
            this._entityPosition = this.entity.script.dynamicElement.getPosition();
        }

        if (this.debug) {
            console.log(this._entityPosition);
        }

        this.calculateOutOfScreenVector();

        var yScale = UIManager.instance.getReferenceResolution().y / ViewportManager.instance.height;
        this.moveDistance = width * yScale / 2 + this.addedDistance;
        this.stopAllTweens();
    }

    calculateOutOfScreenVector() {
        var screenCenter = pc.Vec2.ZERO;
        var entityPosition = this.entity.getPosition();
        var centerToPositionDifference = new pc.Vec2(entityPosition.x, entityPosition.y).sub(screenCenter);
        var direction = centerToPositionDifference.mul(this._xySettings).normalize();

        this.moveDirection = direction;
    }

    doOpenAnimation() {
        if (!this._entityPosition) {
            return;
        }

        this._isVisible = true;

        this.entity.setLocalPosition(this._entityPosition.x + this.moveDirection.x * this.moveDistance, this._entityPosition.y + this.moveDirection.y * this.moveDistance, this._entityPosition.z);

        var moveTween = this.entity
            .tween(this.entity.getLocalPosition())
            .to({ x: this._entityPosition.x, y: this._entityPosition.y, z: this._entityPosition.z }, 0.3, pc.SineOut)
            .start();
        this._currentTweens.push(moveTween);

        if (this.debug) {
            console.log(this._entityPosition, this.entity);
        }

        return new Promise(function (resolve, reject) {
            this._currentPromiseResolve = resolve;
            moveTween.once('complete', function () {
                this._currentTweens.length = 0;
                resolve();
            }.bind(this));
        }.bind(this));
    }

    doCloseAnimation() {
        if (!this._entityPosition) {
            return;
        }
        this._isVisible = false;

        var moveTween = this.entity
            .tween(this.entity.getLocalPosition())
            .to({ x: this._entityPosition.x + this.moveDirection.x * this.moveDistance, y: this._entityPosition.y + this.moveDirection.y * this.moveDistance, z: this._entityPosition.z }, 0.3, pc.SineOut)
            .start();
        this._currentTweens.push(moveTween);

        var self = this;
        return new Promise(function (resolve, reject) {
            this._currentPromiseResolve = resolve;
            moveTween.once('complete', function () {
                this._currentTweens.length = 0;
                resolve();
            }.bind(this));
        }.bind(this));
    }

    stopAllTweens() {
        for (let i = 0; i < this._currentTweens.length; i++) {
            this._currentTweens[i].stop();
        }

        if (this._isVisible) {
            this.entity.setLocalPosition(this._entityPosition.x, this._entityPosition.y, this._entityPosition.z);
        } else {
            this.entity.setLocalPosition(this._entityPosition.x + this.moveDirection.x * this.moveDistance, this._entityPosition.y + this.moveDirection.y * this.moveDistance, this._entityPosition.z);
        }


        this._currentTweens.length = 0;

        if (this._currentPromiseResolve) this._currentPromiseResolve();
    }
}

pc.registerScript(MoveUITween);
MoveUITween.addAttributes();

// CoatBorderHandler.js
var CoatBorderHandler = pc.createScript('coatBorderHandler');

CoatBorderHandler.attributes.add('material', { type: 'asset', assetType: 'material' });

CoatBorderHandler.attributes.add('cellWidth', { type: 'number', default: 1 });
CoatBorderHandler.attributes.add('cellHeight', { type: 'number', default: 1 });

CoatBorderHandler.attributes.add('radius', { type: 'number', default: 0.1 });
CoatBorderHandler.attributes.add('colors', {
    type: 'json', array: true,
    schema: [{
        name: 'borderColor',
        type: 'rgb'
    }]
});


// initialize code called once per entity
pc.extend(CoatBorderHandler.prototype, {
    initialize: function () {
        CoatBorderHandler.instance = this;

        this._grid = null;
        this._verticesX = [];
        this._verticesY = [];
        this._verticesZ = [];

        this._triangles = [];
        this._uvs = [];

        this._mesh = new pc.Mesh(this.app.graphicsDevice);

        this.on('destroy', this.onDestroy, this);
    },

    onDestroy: function () {
        if (this.meshInstance) {
            this.meshInstance.destroy();
            delete this.meshInstance;
        }

        if (this._mesh) {
            this._mesh.destroy();
            delete this._mesh;
        }
    },

    generateMesh: function (grid) {
        this._resetMesh();

        this._grid = grid;
        this._columns = grid.length;
        this._rows = grid[0].length;

        this._calculateGridBorderEdges();
        this._generateBorders();
        this._generateMesh();
    },

    reset: function () {
        this._resetMesh();
        this._mesh.clear();
        if (this.entity.model) {
            this.entity.model.model = null;
            this.entity.removeComponent('model');
        }
    },

    _resetMesh: function () {
        this._grid = null;
        this._verticesX.length = 0;
        this._verticesY.length = 0;
        this._verticesZ.length = 0;

        this._triangles.length = 0;
        this._uvs.length = 0;
    },

    _generateBorders: function () {
        var walls = this._getAllWallGroups();

        var gridEdges = this._calculateGridBorderEdges();
        var gridBorderWalls = [];

        for (var i = 0; i < walls.length; i++) {
            var atBorder = this._isGroupAtBorder(walls[i]);

            if (!atBorder) {
                this._generateBorder(walls[i]);
            } else {
                gridBorderWalls = gridBorderWalls.concat(walls[i]);
            }
        }

        this._generateBorder(gridBorderWalls, gridEdges);
    },

    _calculateGridBorderEdges: function () {
        var edges = [];

        var x = 0;
        var y = 0;

        for (x = 0; x < this._columns; x++) {
            y = 0;
            if (this._grid[x][y].entity.script.get('coat')) {
                var bottomLeft = (x * (this._rows + 1)) + y;
                var bottomRight = ((x + 1) * (this._rows + 1)) + y;

                edges.push({ node1: bottomLeft, node2: bottomRight });
            }

            y = this._rows - 1;

            if (this._grid[x][y].entity.script.get('coat')) {


                var topLeft = (x * (this._rows + 1)) + y + 1;
                var topRight = ((x + 1) * (this._rows + 1)) + y + 1;

                edges.push({ node1: topLeft, node2: topRight });

            }
        }

        for (y = 0; y < this._rows; y++) {
            x = 0;
            if (this._grid[x][y].entity.script.get('coat')) {
                var topLeft = (x * (this._rows + 1)) + y + 1;
                var bottomLeft = (x * (this._rows + 1)) + y;

                edges.push({ node1: topLeft, node2: bottomLeft });
            }

            x = this._columns - 1;

            if (this._grid[x][y].entity.script.get('coat')) {
                var bottomRight = ((x + 1) * (this._rows + 1)) + y;
                var topRight = ((x + 1) * (this._rows + 1)) + y + 1;

                edges.push({ node1: bottomRight, node2: topRight });

            }
        }

        return edges;
    },

    _getEdgesFromWalls: function (walls, edge) {

        var edges = edge || [];

        for (var i = 0; i < walls.length; i++) {
            var x = walls[i].x;
            var y = walls[i].y;

            this._getEdges(x, y, edges);
        }

        return edges;
    },

    _sortEdges: function (edges) {
        if (edges.length === 0) {
            return [];
        }
        var sortedEdges = [edges.shift()];

        while (edges.length !== 0) {
            var length = edges.length;
            var lastNode = sortedEdges[sortedEdges.length - 1].node2;

            for (var j = edges.length - 1; j >= 0; j--) {
                var edge = edges[j];

                if (edge.node1 === lastNode) {
                    sortedEdges.push(edges.splice(j, 1)[0]);
                    break;
                } else if (edge.node2 === lastNode) {
                    var removedEdge = edges.splice(j, 1)[0];

                    sortedEdges.push({ node1: removedEdge.node2, node2: removedEdge.node1 });
                    break;
                }
            }
            if (length === edges.length) {
                this._generateBorder([], edges);
                break;
            }
        }

        return sortedEdges;
    },

    _generateBorder: function (walls, edge) {
        var edges = this._getEdgesFromWalls(walls, edge);
        var sortedEdges = this._sortEdges(edges);

        for (var i = 0; i < sortedEdges.length; i++) {
            var edge = sortedEdges[i];

            var positionNode1 = this._numberToPosition(edge.node1);
            var positionNode2 = this._numberToPosition(edge.node2);

            var direction = new pc.Vec3().sub2(positionNode1, positionNode2);

            var radius = this.radius;

            var length = this._verticesX.length;

            if (direction.x < 0 && direction.y === 0) { // Left
                this._verticesX.push(positionNode1.x - radius);
                this._verticesY.push(positionNode1.y + radius);
                this._verticesZ.push(positionNode1.z);

                this._verticesX.push(positionNode1.x - radius);
                this._verticesY.push(positionNode1.y - radius);
                this._verticesZ.push(positionNode1.z);

                this._verticesX.push(positionNode2.x + radius);
                this._verticesY.push(positionNode2.y + radius);
                this._verticesZ.push(positionNode1.z);

                this._verticesX.push(positionNode2.x + radius);
                this._verticesY.push(positionNode2.y - radius);
                this._verticesZ.push(positionNode1.z);

            } else if (direction.x > 0 && direction.y === 0) { // Right
                this._verticesX.push(positionNode1.x + radius);
                this._verticesY.push(positionNode1.y - radius);
                this._verticesZ.push(positionNode1.z);

                this._verticesX.push(positionNode1.x + radius);
                this._verticesY.push(positionNode1.y + radius);
                this._verticesZ.push(positionNode1.z);

                this._verticesX.push(positionNode2.x - radius);
                this._verticesY.push(positionNode2.y - radius);
                this._verticesZ.push(positionNode1.z);

                this._verticesX.push(positionNode2.x - radius);
                this._verticesY.push(positionNode2.y + radius);
                this._verticesZ.push(positionNode1.z);

            } else if (direction.y > 0 && direction.x === 0) { // Up
                this._verticesX.push(positionNode1.x + radius);
                this._verticesY.push(positionNode1.y + radius);
                this._verticesZ.push(positionNode1.z);

                this._verticesX.push(positionNode1.x - radius);
                this._verticesY.push(positionNode1.y + radius);
                this._verticesZ.push(positionNode1.z);

                this._verticesX.push(positionNode2.x + radius);
                this._verticesY.push(positionNode2.y - radius);
                this._verticesZ.push(positionNode1.z);

                this._verticesX.push(positionNode2.x - radius);
                this._verticesY.push(positionNode2.y - radius);
                this._verticesZ.push(positionNode1.z);

            } else if (direction.y < 0 && direction.x === 0) { // Down
                this._verticesX.push(positionNode1.x - radius);
                this._verticesY.push(positionNode1.y - radius);
                this._verticesZ.push(positionNode1.z);

                this._verticesX.push(positionNode1.x + radius);
                this._verticesY.push(positionNode1.y - radius);
                this._verticesZ.push(positionNode1.z);

                this._verticesX.push(positionNode2.x - radius);
                this._verticesY.push(positionNode2.y + radius);
                this._verticesZ.push(positionNode1.z);

                this._verticesX.push(positionNode2.x + radius);
                this._verticesY.push(positionNode2.y + radius);
                this._verticesZ.push(positionNode1.z);

            } else {
                console.log("something went wrong", direction);
            }


            this._triangles.push(length + 0);
            this._triangles.push(length + 1);

            this._triangles.push(length + 2);

            this._triangles.push(length + 1);
            this._triangles.push(length + 3);
            this._triangles.push(length + 2);

            this._uvs.push(0, 0, 0, 0, 0, 0, 0, 0);
        }
    },

    _generateMesh: function () {
        if (this._verticesX.length === 0) {
            return;
        }
        var vertices = [];
        var uvs = [];

        for (var i = 0; i < this._verticesX.length; i++) {
            vertices.push(this._verticesX[i], this._verticesY[i], this._verticesZ[i]);
        }

        var normals = pc.calculateNormals(vertices, this._triangles);

        this._mesh.clear();
        this._mesh.setPositions(vertices);
        this._mesh.setUvs(0, this._uvs);
        this._mesh.setIndices(this._triangles);
        this._mesh.setNormals(normals);
        this._mesh.update();

        var node = new pc.GraphNode();
        this._material = this.material;
        var meshInstance = new pc.MeshInstance(node, this._mesh, this.material.resource);
        meshInstance.cull = false;

        this.meshInstance = meshInstance;
        // Create a model and add the mesh instance to it
        var model = new pc.Model();
        model.graph = node;
        model.meshInstances = [meshInstance];

        this.entity.addComponent('model', {
            type: 'asset',
        });

        this.entity.model.model = model;
        this.entity.model.receiveShadows = false;
        this.entity.model.castShadows = false;
    },

    _getEdges: function (x, y, edges) {
        var bottomLeft = (x * (this._rows + 1)) + y;
        var topLeft = (x * (this._rows + 1)) + y + 1;
        var bottomRight = ((x + 1) * (this._rows + 1)) + y;
        var topRight = ((x + 1) * (this._rows + 1)) + y + 1;

        if (this._grid[x - 1]) {
            var neighbourLeft = this._grid[x - 1][y];

            if (!neighbourLeft.entity.script.get('coat')) {
                edges.push({ node1: bottomLeft, node2: topLeft });
            }
        }

        if (this._grid[x + 1]) {

            var neighbourRight = this._grid[x + 1][y];

            if (!neighbourRight.entity.script.get('coat')) {
                edges.push({ node1: bottomRight, node2: topRight });
            }
        }

        if (this._grid[x][y + 1]) {
            var neighbourUp = this._grid[x][y + 1];

            if (!neighbourUp.entity.script.get('coat')) {
                edges.push({ node1: topLeft, node2: topRight });
            }
        }

        if (this._grid[x][y - 1]) {
            var neighbourDown = this._grid[x][y - 1];

            if (!neighbourDown.entity.script.get('coat')) {
                edges.push({ node1: bottomLeft, node2: bottomRight });
            }
        }
    },

    _getNeighbours: function (x, y) {
        var left = x - 1;
        var right = x + 1;
        var up = y + 1;
        var down = y - 1;

        return [this._grid[left][y], this._grid[right][y], this._grid[x][up], this._grid[x][down]];
    },

    _getAllWallGroups: function () {
        var allWallGroups = [];
        for (var x = 0; x < this._columns; x++) {
            for (var y = 0; y < this._rows; y++) {
                if (this._grid[x][y].entity.script.get('coat')) {

                    var found = false;

                    for (var i = 0; i < allWallGroups.length; i++) {
                        if (pc.utils.isElementInArray(this._grid[x][y], allWallGroups[i])) {
                            found = true;
                            break;
                        }
                    }

                    if (!found) {
                        var group = [this._grid[x][y]];

                        this._getWallNeighbours(x, y, group);

                        allWallGroups.push(group);
                    }
                }
            }
        }

        return allWallGroups;
    },

    _isGroupAtBorder: function (group) {
        for (var i = 0; i < group.length; i++) {
            var tile = group[i];

            if (tile.x === 0 || tile.x === this._columns - 1 || tile.y === 0 || tile.y === this._rows - 1) {
                return true;
            }
        }

        return false;
    },

    _getWallNeighbours: function (x, y, group) {
        var left = x - 1;
        var right = x + 1;
        var up = y + 1;
        var down = y - 1;

        // Left
        if (this._grid[left] && this._grid[left][y]) {
            var leftTile = this._grid[left][y];
            if (leftTile.entity.script.get('coat')) {
                if (pc.utils.isElementInArray(leftTile, group)) {
                    group.push(leftTile);

                    this._getWallNeighbours(left, y, group);
                }
            }
        }

        // Right
        if (this._grid[right] && this._grid[right][y]) {
            var rightTile = this._grid[right][y];
            if (rightTile.entity.script.get('coat')) {
                if (pc.utils.isElementInArray(rightTile, group)) {
                    group.push(rightTile);

                    this._getWallNeighbours(right, y, group);
                }
            }
        }

        // Up
        if (this._grid[x][up]) {
            var upTile = this._grid[x][up];
            if (upTile.entity.script.get('coat')) {
                if (pc.utils.isElementInArray(upTile, group)) {
                    group.push(upTile);

                    this._getWallNeighbours(x, up, group);
                }
            }
        }

        // Down
        if (this._grid[x][down]) {
            var downTile = this._grid[x][down];
            if (downTile.entity.script.get('coat')) {
                if (pc.utils.isElementInArray(downTile, group)) {
                    group.push(downTile);

                    this._getWallNeighbours(x, down, group);
                }
            }
        }
    },

    _numberToPosition: function (number) {
        var y = number % (this._rows + 1);
        var x = Math.floor(number / (this._rows + 1));

        var centerX = (this._columns) / 2;
        var centerY = (this._rows) / 2;
        var xPosition = (x - centerX) * this.cellWidth;
        var yPosition = (y - centerY) * this.cellHeight;

        return new pc.Vec3(xPosition, yPosition, 0.1);
    },

    getAABB: function () {
        return this._mesh.aabb;
    },
});


// Firebase.js
class Firebase {
    initialize() {
        Firebase.instance = this;

        this.app = pc.Application.getApplication();

        this.app.on('StorageManager:changedStorage', () => {
            this.invoices = -1;
        });

        // Live 
        this.firebaseConfig = {
            apiKey: "AIzaSyAwAOcg2Uzu-pFE4FjjmJ1vY0O7BuXWEuA",
            authDomain: "garden-bloom-b745a.firebaseapp.com",
            databaseURL: "https://garden-bloom-b745a-default-rtdb.firebaseio.com",
            projectId: "garden-bloom-b745a",
            storageBucket: "garden-bloom-b745a.appspot.com",
            messagingSenderId: "838220723653",
            appId: "1:838220723653:web:01e09b40a9ca1e7deb87ac"
        };

        // // Test
        // this.firebaseConfig = {
        //     apiKey: "AIzaSyDVivFjUyiO5nFpgwpLjxNeZnk9hzmWYDo",
        //     authDomain: "famobi-test.firebaseapp.com",
        //     databaseURL: "https://famobi-test-default-rtdb.europe-west1.firebasedatabase.app/",
        //     projectId: "famobi-test",
        //     storageBucket: "famobi-test.appspot.com",
        //     messagingSenderId: "784829812115",
        //     appId: "1:784829812115:web:65a9ae96ee742d6de12c66",
        //     measurementId: "G-3BR5CKY7ZF",
        // };

        this.initialized = false;

        this.nloaded = 0;
        this.loaded = false;

        this.logging = false;

        this.data = null;
        this.dataToSave = {};
        this.saving = false;
        this.invoices = -1;

        try {
            this.active = window.famobi.hasFeature('login') && !window.famobi.hasFeature('standalone');
        } catch (e) {
            console.log(e);
            this.active = false;
        }

        this.user = undefined;

        if (this.active) {
            this.load();

        }
    }

    load() {
        var s1 = document.createElement("script");
        s1.type = "text/javascript";
        s1.src = "https://www.gstatic.com/firebasejs/8.4.1/firebase-app.js";
        document.head.append(s1);

        s1.onload = () => {
            var s2 = document.createElement("script");
            s2.type = "text/javascript";
            s2.src = "https://www.gstatic.com/firebasejs/8.4.1/firebase-auth.js";
            document.head.append(s2);

            var s3 = document.createElement("script");
            s3.type = "text/javascript";
            s3.src = "https://www.gstatic.com/firebasejs/8.4.1/firebase-database.js";
            document.head.append(s3);

            var s4 = document.createElement("script");
            s4.type = "text/javascript";
            s4.src = "https://www.gstatic.com/firebasejs/8.4.1/firebase-functions.js";
            document.head.append(s4);

            this.scripts = [s2, s3, s4];

            for (var i = 0; i < this.scripts.length; i++) {
                const script = this.scripts[i];

                script.onload = this.onLoaded.bind(this);
            }
        };
    }

    onLoaded() {
        this.nloaded++;

        if (this.nloaded === this.scripts.length) {
            this.complete();
        }
    }

    complete() {
        // Initialize Firebase
        firebase.initializeApp(this.firebaseConfig);
        //firebase.analytics();

        firebase.auth().onAuthStateChanged((user) => {
            this.setUser(user);
        });

        // this.app.fire('Firebase:done');

        firebase.auth()
            .getRedirectResult()
            .then((result) => {
                if (result.credential) {
                    /** @type {firebase.auth.OAuthCredential} */
                    var credential = result.credential;

                    // This gives you a Google Access Token. You can use it to access the Google API.
                    var token = credential.accessToken;

                    console.log(result)
                    // ...
                }
                // The signed-in user info.
                var user = result.user;
            }).catch((error) => {
                // Handle Errors here.
                var errorCode = error.code;
                var errorMessage = error.message;
                // The email of the user's account used.
                var email = error.email;
                // The firebase.auth.AuthCredential type that was used.
                var credential = error.credential;
                // ...
                console.log(error)
            });
    }

    canLogIn() {
        return !this.logging && !this.user;
    }

    loggedIn() {
        return !!this.user;
    }

    googleLogin() {
        if (this.logging) {
            return;
        }

        this.logging = true;

        var provider = new firebase.auth.GoogleAuthProvider();

        var promise = firebase.auth().signInWithPopup(provider);

        if (promise) {
            return new Promise((resolve, reject) => {
                promise.then(resolve).catch((error) => {
                    console.log(error);

                    this.logging = false;
                    reject(error)
                });
            });
        }
    }

    googleLoginRedirect() {
        var provider = new firebase.auth.GoogleAuthProvider();

        var promise = firebase.auth().signInWithRedirect(provider);

        if (promise) {
            return promise.catch((error) => {
                console.log(error);

                this.logging = false;
            });
        } else {
            return new Promise((resolve, reject) => {
                reject('Error')
            });
        }
    }

    facebookLogin() {
        if (this.logging) {
            return;
        }

        this.logging = true;

        var provider = new firebase.auth.FacebookAuthProvider();
        return firebase.auth().signInWithPopup(provider)
            .catch((error) => {
                console.log(error);
                this.logging = false;
            });
    }

    facebookLoginRedirect() {
        var provider = new firebase.auth.FacebookAuthProvider();

        var promise = firebase.auth().signInWithRedirect(provider);

        if (promise) {
            return promise.catch((error) => {
                console.log(error);

                this.logging = false;
            });
        }
    }

    logout() {
        if (this.logging) {
            return;
        }

        this.logging = true;

        return firebase.auth().signOut().catch(() => {
            console.error(error);
            this.logging = false;
        });
    }

    setUser(user) {
        this.logging = false;

        var changedUser = this.user !== user;

        this.user = user;
        this.loaded = false;
        this.invoices = -1;

        if (this.user) {
            if (changedUser) {
                firebase.database().ref('data/' + user.uid).get().then((snapshot) => {
                    this.setData(snapshot);

                    if (!this.initialized) {
                        this.initialized = true;
                    }

                    this.loaded = true;

                    firebase.database().ref('data/' + user.uid).on('value', (snapshot) => {
                        this.setData(snapshot);
                    });

                    this.app.fire('Firebase:logchange', !!this.user);
                }).catch((e) => {
                    console.log(e);
                    this.logout();
                });
            }

            //console.log("trying")
            //firebase.database().ref('data/' + user.uid).update({ loggedIn: Date.now()});

        } else {
            this.loaded = true;

            this.data = {};
            this.initialized = true;

            if (changedUser) {
                this.app.fire('Firebase:logchange', !!this.user);
                changedUser = false;
            }
        }

    }

    setData(snapshot) {
        const data = snapshot.toJSON();
        const data2 = snapshot.val();

        if (this.data === null) {
            this.data = {};
        }

        const previousInvoicesLength = this.invoices;

        if (data) {
            Object.keys(data).forEach(key => {
                this.data[key] = data[key];
            });

            this.data.invoices = data2.invoices;

            if (!Array.isArray(this.data.invoices)) {
                this.data.invoices = [];
            }

            if (this.loaded) {
                try {
                    this.invoices = this.data.invoices.length;

                    if (this.invoices > previousInvoicesLength) {
                        if (previousInvoicesLength >= 0) {
                            this.app.fire('Firebase:invoice', this.data.invoices, this.data.inventory);
                        } else {
                            if (GameManager.instance) {
                                GameManager.instance.compareInvoices(this.data.invoices);
                            }
                        }
                    }
                } catch (e) {
                    console.log(e);
                }
            }
        }
    }

    addInvoice() {
        this.invoices++;
    }

    save(key, value) {
        if (value === undefined) {
            console.warn("Key", key, "is", value);
            return;
        }

        if (this.saving) {
            this.app.on('Firebase:saved', this.save.bind(this, key, value));
            return;
        }

        this.dataToSave[key] = value;

        clearTimeout(this.saveDelay);

        this.saveDelay = setTimeout(this.saveAfterDelay.bind(this), Firebase.SAVE_DELAY);

    }

    getData(key) {
        return this.data[key];
    }

    saveAfterDelay() {
        this.saving = true;

        firebase.database().ref('data/' + firebase.auth().currentUser.uid).update(this.dataToSave).then((test) => {
            this.dataToSave = {};
        }).catch((error) => {
            console.error(error);
        }).finally(() => {
            this.saving = false;
            this.app.fire('Firebase:saved');
        });
    }

    getXsollaAccessToken() {
        var getXsollaAccessToken = firebase.app().functions("europe-west1").httpsCallable('getXsollaAccessToken');

        return getXsollaAccessToken();
    }

    rewardUser(items) {
        var rewardUser = firebase.app().functions("europe-west1").httpsCallable('reward');

        return rewardUser(items);
    }

    revokeUser(items) {
        var revokeUser = firebase.app().functions("europe-west1").httpsCallable('revoke');

        return revokeUser(items);
    }

    getUID() {
        if (this.user) {
            return this.user.uid;
        }
    }
}

Firebase.SAVE_DELAY = 1000;

const firebaseClass = new Firebase();
firebaseClass.initialize();

// AddExploderTimerScreen.js
var AddExploderTimerScreen = pc.createScript('addExploderTimerScreen');

AddExploderTimerScreen.attributes.add('objectiveEntities', { type: 'entity', array: true });
AddExploderTimerScreen.attributes.add('addMovesButtonAd', { type: 'entity' });
AddExploderTimerScreen.attributes.add('addMovesButton', { type: 'entity' });
AddExploderTimerScreen.attributes.add('addMovesPriceText', { type: 'entity' });
AddExploderTimerScreen.attributes.add('addMovesPrice', { type: 'number', array: true });
AddExploderTimerScreen.attributes.add('closeButton', { type: 'entity' });

pc.extend(AddExploderTimerScreen.prototype, {
    initialize: function () {
        this.addMovesButton.script.elementInput.on(inputEvents.CLICK, this._onClick, this);
        this.addMovesButtonAd.script.elementInput.on(inputEvents.CLICK, this._onAdClick, this);
        this.closeButton.script.elementInput.on(inputEvents.CLICK, this._onCloseClick, this);
    },

    onUIEntityOpen: function () {
        const amount = GameManager.instance.amountOfExploderTimerAddedWithCoins;
        this.cost = this.addMovesPrice[amount];

        GridManager.instance.active(false);

        this.addMovesButton.enabled = !!this.cost;
        this.addMovesButtonAd.enabled = GameManager.instance.canUseAdsForExploderTimer();

        this.getObjectiveData();
        this.app.fire('UIManager:showUI', 'FloatingUI');
        this.addMovesPriceText.element.text = this.cost;
    },

    onUIEntityClose: function () {
        this.app.fire('UIManager:hideUI', 'FloatingUI');
    },

    _onCloseClick: function () {
        this.app.fire('UIManager:hideAll');
        this.app.fire('ExploderParticleAnimation:startAnim');
    },

    getObjectiveData: function () {
        var objectives = ObjectiveManager.instance.getObjectives();

        for (var i = 0; i < this.objectiveEntities.length; i += 1) {
            if (i >= objectives.length) {
                this.objectiveEntities[i].enabled = false;
                return;
            }
            this.objectiveEntities[i].enabled = true;

            this.objectiveEntities[i].script.popupObjectiveUI.setGoal(objectives[i].orderTypeObject, objectives[i].values.goal);
            this.objectiveEntities[i].script.popupObjectiveUI.setResult(objectives[i].values.current);
        }
    },

    _onClick: function () {
        if (this.clicked) {
            return;
        }

        var success = Inventory.instance.tryPayItem('COINS', this.cost, 'revive', 'exploder');

        if (success) {
            if (Xsolla.instance.loggedIn) {
                Xsolla.instance.revokeUser(Inventory.instance.getXsollaSKU('COINS'), this.cost);
            }

            this.app.fire('Audio:sfx', 'coin_pay.mp3');
            this.onSuccess(AddExploderTimerScreen.NUMBER_MOVES_COINS);
            GameManager.instance.increaseAmountOfExploderTimerAddedWithCoins();
            StatisticsManager.instance.incrementStatistic('revived');
        } else {
            this.app.fire('UIManager:showUI', 'Shop');
        }
    },

    _onAdClick: function () {
        if (this.clicked) {
            return;
        }

        this.clicked = true;

        Wrapper.instance.rewardedAd(this.rewardAd, this);
    },

    rewardAd: function (result) {
        this.clicked = false;

        if (result.rewardGranted) {
            StatisticsManager.instance.incrementStatistic('revived');
            GameManager.instance.increaseAmountOfExploderTimerAddedWithAds();
            this.onSuccess(AddExploderTimerScreen.NUMBER_MOVES_AD);
        }
    },

    onSuccess: function (amountOfMoves) {
        GridManager.instance.addExploderTimer(amountOfMoves);
        TrackingManager.instance.addRevive();

        GridManager.instance.checkAllPossibleMatches();

        this.app.fire('UIManager:hideAll');
        this.app.fire('UIManager:showUI', 'Game');
        this.app.fire('CoinInterface:updateCoins');
        this.app.fire("GameInput:toggleGameInput", true);
    },
});

AddExploderTimerScreen.NUMBER_MOVES_AD = 3;
AddExploderTimerScreen.NUMBER_MOVES_COINS = 5;

// ColoredStar.js
class ColoredStar extends pc.ScriptType {
    static addAttributes() {
        this.attributes.add('starImageEntity', { type: 'entity' });
        this.attributes.add('starBorderEntity', { type: 'entity' });
        this.attributes.add('setColorAutomatic', { type: 'boolean' });
    }

    initialize() {
        if (!this._color) {
            this._color = new pc.Color();
            this._worldID = null;
        }

        if (this.setColorAutomatic) {
            this.setStarBasedOnWorldIndex();
            this.on('enable', this.setStarBasedOnWorldIndex, this);
            this.app.on('WorldManager:changeWorldIndex', this.setStarBasedOnWorldIndex, this);
        }
        
        this.on('destroy', this.onDestroy, this);
    }
    
    onDestroy() {
        this.app.off('WorldManager:changeWorldIndex', this.setStarBasedOnWorldIndex, this);
    }
    
    setStarByWorld(worldIndex) {
        // console.warn("This function is deprecated");
        this.setStarBasedOnWorldIndex(worldIndex);
    }
    
    setStarBasedOnWorldIndex(worldIndex = WorldManager.instance.getWorldIndex()) {
        // if (worldIndex === this._worldID) {
        //     return;
        // }
        
        this._worldID = worldIndex;
        
        this.setStarImage(worldIndex);
        this.setBorderColor(worldIndex);
    }

    setStarImage(worldID) {
        if (!this.starImageEntity) return;
        
        var asset = WorldManager.instance.getStarAsset(worldID);
        if (!asset || !asset.resource) {
            return;
        }
        
        var image = asset.resource;
        if (!this.starImageEntity.element) {
            console.warn(this.starImageEntity);
        } else {
            this.starImageEntity.element.sprite = image;
        }
    }

    setBorderColor(worldID) {
        if (!this.starBorderEntity) return;

        var tint = ColoredStar.BORDER_COLORS[WorldManager.instance.getWorldIndexByID(worldID)];

        if (!tint) {
            return;
        }
        
        if (!this._color) {
            this._color = new pc.Color();
        }

        this.starBorderEntity.element.color = this._color.fromString(tint);
    }
    
    getBorderColor(){
        return this.starBorderEntity.element.color;
    }
}

pc.registerScript(ColoredStar, 'coloredStar');
ColoredStar.addAttributes();
ColoredStar.BORDER_COLORS = [
    '#197976',
    '#903E72',
    '#9a6900',
    '#147b00',
    '#770BE0',
    '#008490',
    '#1C79D9',
    '#0d3eb8',
    '#bf4801',
    '#d5130d'
];

// PopperBehaviour.js
var PopperBehaviour = function() {
    this.initialize();
};

PopperBehaviour.duration = new pc.Vec2(0, 0.2); // Duration/offset

pc.extend(PopperBehaviour.prototype, {
    initialize: function() {
        // this.combinationBehaviourScripts = Object.freeze({
        //     [foregroundTileEnum.LINE_H]: new LineBombHBehaviour(),
        //     [foregroundTileEnum.LINE_V]: new LineBombVBehaviour(),
        //     [foregroundTileEnum.COLORBOMB]: new BombColorBombBehaviour(),
        //     [foregroundTileEnum.BOMB]: new BigBombBehaviour(),
        // });

        this.lines = [];
        this.sinkers = [];

        this.app = pc.Application.getApplication();

        this.duration = new pc.Vec2(0, 0);
    },

    getAffectedTiles: function(tile, delay = 0) {
        var array = [];

        var affectedTiles = [];
        this.sinkers.length = 0;
        this.lines.length = 0;

        for (var x = tile.x - 1; x <= tile.x + 1; x++) {
            if (x < 0) continue;
            if (x >= MatchLogic.columns) continue;


            for (var y = tile.y - 1; y <= tile.y + 1; y++) {
                // fix grid edge seam

                if (tile.x === x && tile.y === y) {
                    continue;
                }

                if (y >= 0 && y < MatchLogic.rows) {
                    var _backgroundTile = GridManager.instance.getBackgroundTile(x, y);

                    affectedTiles.push({ x, y });

                    if (_backgroundTile.isSinker()) {
                        this.sinkers.push({ x, y });
                    }
                }
            }
        }

        for (var i = 0; i < this.sinkers.length; i++) {
            var x = this.sinkers[i].x;
            var y = this.sinkers[i].y;
            this.createLines(x, y);
        }

        var poppersPopped = [];

        this.filterLines();

        //RenderLine.instance.set(this.lines);

        for (var i = 0; i < affectedTiles.length; i++) {
            var x = affectedTiles[i].x;
            var y = affectedTiles[i].y;

            if (this.lineCollision(tile.x + 0.5, tile.y + 0.5, x + 0.5, y + 0.5)) {
                continue;
            }

            var _backgroundTile = GridManager.instance.getBackgroundTile(x, y);

            var dX = Math.abs(tile.x - x);
            var dY = Math.abs(tile.y - y);

            var despawnDelay = PowerTileManager.instance.calculateDespawnDelay(Math.max(dX, dY), PopperBehaviour.duration.x, PopperBehaviour.duration.y) + tile.getDespawnDelay(true);

            if (_backgroundTile.isPopper()) {
                if (!_backgroundTile.isPowerTriggered()) {

                    _backgroundTile.triggerPower();
                    _backgroundTile.explodeAll(despawnDelay, tile);

                    poppersPopped.push(_backgroundTile);
                }
            } else if (_backgroundTile.canExplode()) {
                _backgroundTile.explode(despawnDelay, tile);
            }

            if (_backgroundTile.onlyBackgroundExplodes) {
                continue;
            }

            var _tile = GridManager.instance.getTile(x, y);
            if (!_tile) {
                continue;
            }

            if (!_tile.canExplode) {
                continue;
            }

            if (_tile.isHitByPower()) {
                continue;
            }

            array.push(_tile);
            _tile.setHitByPower();


            if(_tile.typeID !== foregroundTileEnum.NONE && _tile.typeID !== foregroundTileEnum.DEFAULT) {
                _tile.setDespawnCause(foregroundTileEnum.BOMB);
            }

            PowerTileManager.instance.setTileDespawnDelay(tile, _tile, Math.max(dX, dY), PopperBehaviour.duration.x, PopperBehaviour.duration.y);
        }

        var animationData = [];

        for (var x = tile.x - 1; x <= tile.x + 1; x += 1) {
            for (var y = tile.y - 1; y <= tile.y + 1; y += 1) {

                if (x === tile.x && y === tile.y) {
                    continue;
                } 

                animationData.push(this.getLinePosition(tile.x + 0.5, tile.y + 0.5, x, y));
            }
        }

        tile.setPowerAnimation(animationData);

        ImpulseManager.applyPulse(tile.x, tile.y, 5, 1, 0.05 + tile.getDespawnDelay(true), 0.2);

        poppersPopped.forEach(popper => {
            var popperArray = PowerTileManager.instance.explodePopper(popper);

            pc.utils.fuseArray(array, popperArray);
        });       


        return array;
    },

    getCombinationScript: function(power2ID) {
        var combinationBehaviour = this.combinationBehaviourScripts[power2ID];
        if (!combinationBehaviour) {
            return null;
        }
        return combinationBehaviour;
    },

    doActivateAnimation: function(tile, delay) {
        return;
        var canPlaySound = true;

        GridManager.instance.playSFX('bomb_detonate_flowers.mp3');
        GameVibrationManager.instance.addVibration(GameVibrationManager.POPPER_PATTERN);

        var animationData = tile.getPowerAnimation();

        for (var i = 0; i < animationData.length; i++) {
            var data = animationData[i];

            var realX = data.x;
            var realY = data.y;

            var angle = this.calculateAngle(realX, realY, tile.x, tile.y);
            this.duration.set(PopperBehaviour.duration.x / Math.max(Math.abs(tile.x - realX), Math.abs(tile.y - realY)) * 2, PopperBehaviour.duration.y / Math.max(Math.abs(tile.x - realX), Math.abs(tile.y - realY)) * 2);
            PowerAnimationManager.instance.createBombAnimation(tile, this.duration, realX === tile.x, realX < tile.x, realX, realY, angle, Math.max(Math.abs(tile.x - realX), Math.abs(tile.y - realY)), tile.colorID, canPlaySound);
            canPlaySound = false;
        }
    },

    calculateAngle: function(x, y, centerx, centery) {
        var deltaX =  x - centerx;
        var deltaY =  y - centery;
        var degrees = Math.atan2(deltaY, deltaX) * 180.0 / Math.PI;
        return degrees * -1 + 90;
    },

    createLines: function(_x, _y) {
        this.lines.push({ x1: _x, y1: _y, x2: _x + 1, y2: _y });
        this.lines.push({ x1: _x, y1: _y, x2: _x, y2: _y + 1 });
        this.lines.push({ x1: _x + 1, y1: _y, x2: _x + 1, y2: _y + 1 });
        this.lines.push({ x1: _x, y1: _y + 1, x2: _x + 1, y2: _y + 1 });

        this.lines.push({ x1: _x, y1: _y, x2: _x + 1, y2: _y + 1 });
        this.lines.push({ x1: _x, y1: _y + 1, x2: _x + 1, y2: _y });

        if (this.sinkers.find(sinker => sinker.x === _x - 1 && sinker.y === _y + 1)) {
            this.lines.push({ x1: _x + 0.5 - 1, y1: _y + 0.5 + 1, x2: _x + 0.5, y2: _y + 0.5 });
            this.lines.push({ x1: _x + 0.5 - 1, y1: _y + 0.5, x2: _x + 0.5, y2: _y + 0.5 + 1 });
        } 

        if (this.sinkers.find(sinker => sinker.x === _x + 1 && sinker.y === _y + 1)) {
            this.lines.push({ x1: _x + 0.5, y1: _y + 0.5 + 1, x2: _x + 0.5 + 1, y2: _y + 0.5 });
            this.lines.push({ x1: _x + 0.5, y1: _y + 0.5, x2: _x + 0.5 + 1, y2: _y + 0.5 + 1 });
        } 
    },

    filterLines: function() {
        for (var i = this.lines.length - 1; i >= 0; i--) {
            var _x1 = this.lines[i].x1;
            var _y1 = this.lines[i].y1;

            var _x2 = this.lines[i].x2;
            var _y2 = this.lines[i].y2;

            for (var j = this.lines.length - 1; j >= 0; j--) {
                if (i === j) {
                    continue;
                }

                var x1 = this.lines[j].x1;
                var y1 = this.lines[j].y1;

                var x2 = this.lines[j].x2;
                var y2 = this.lines[j].y2;

                if ((_x1 === x1 && _y1 === y1 && _x2 === x2 && _y2 === y2) || (_x1 === x2 && _y1 === y2 && _x2 === x1 && _y2 === y1)) {
                    this.lines.splice(i, 1);
                    break;
                }
            } 
        }
    },

    lineCollision: function(x1, y1, x2, y2) {
        var count = 0; 
        for (var i = 0; i < this.lines.length; i++) {
            var line = this.lines[i];

            if (this.checkLineIntersection(x1, y1, x2, y2, line.x1, line.y1, line.x2, line.y2)) {
                count++;

                if (count > 1) {
                    return true;
                }
            }
        }  

        return count > 1;
    },

    checkLineIntersection: function(x1, y1, x2,y2, x3, y3, x4, y4) {        
        if (x1 === x3 && x2 === x4 && y1 === y3 && y2 === y4) {
            return true;
        }

        var denominator = (x2 - x1) * (y4 - y3) - (y2 - y1) * (x4 - x3);

        if (denominator === 0) {
            var x3Dif = x3 - x1;
            var x4Dif = x4 - x1;

            if ((x3Dif === 0 && y3 === y1 || this.equals((y3 - y1) / (x3 - x1), (y2 - y1) / (x2 - x1))) && (x4Dif === 0 && y4 === y1 || this.equals((y4 - y1) / (x4 - x1), (y2 - y1) / (x2 - x1)))) {
                if (x3 < Math.max(x1, x2) && x3 > Math.min(x1, x2)) {
                    return true;
                }

                if (x4 < Math.max(x1, x2) && x4 > Math.min(x1, x2)) {
                    return true;
                }

                if (y3 < Math.max(y1, y2) && y3 > Math.min(y1, y2)) {
                    return true;
                }

                if (y4 < Math.max(y1, y2) && y4 > Math.min(y1, y2)) {
                    return true;
                }

                return false;
            } else {
                return false;
            }
        }

        var numerator1 = (y1 - y3) * (x4 - x3) - (x1 - x3) * (y4 - y3);
        var numerator2 = (y1 - y3) * (x2 - x1) - (x1 - x3) * (y2 - y1);

        if (numerator1 === 0 || numerator2 === 0)
        {
            return false;
        }

        var r = numerator1 / denominator;
        var s = numerator2 / denominator;

        return (r > 0 && r < 1) && (s > 0 && s < 1);
    },

    getLinePosition: function(x1, y1, x2, y2) {
        var collisions = [];

        for (var i = 0; i < this.lines.length; i++) {
            var line = this.lines[i];

            var position = this.getLineIntersectionPosition(x1, y1, x2, y2, line.x1, line.y1, line.x2, line.y2);

            if (position instanceof pc.Vec3) {
                collisions.push(position);
            }
        }  

        if (collisions.length > 1) {
            collisions.sort((vec3_1, vec3_2) => (vec3_1.x - x1) * (vec3_1.x - x1) + (vec3_1.y - y1) * (vec3_1.y - y1) - (vec3_2.x - x1) * (vec3_2.x - x1) + (vec3_2.y - y1) * (vec3_2.y - y1));

            collisions[1].sub(new pc.Vec3(0.5, 0.5, 0.5));

            return collisions[1];
        } else {
            return new pc.Vec3(x2, y2, 1);
        }
    },

    getLineIntersectionPosition: function(x1, y1, x2,y2, x3, y3, x4, y4) {        
        if (x1 === x3 && x2 === x4 && y1 === y3 && y2 === y4) {
            return new pc.Vec3((x3 + x4) / 2, (y3 + y4) / 2, 0);
        }

        var denominator = (x2 - x1) * (y4 - y3) - (y2 - y1) * (x4 - x3);

        if (denominator === 0) {
            var x3Dif = x3 - x1;
            var x4Dif = x4 - x1;

            if ((x3Dif === 0 && y3 === y1 || this.equals((y3 - y1) / (x3 - x1), (y2 - y1) / (x2 - x1))) && (x4Dif === 0 && y4 === y1 || this.equals((y4 - y1) / (x4 - x1), (y2 - y1) / (x2 - x1)))) {
                if (x3 < Math.max(x1, x2) && x3 > Math.min(x1, x2)) {
                    return new pc.Vec3((x3 + x4) / 2, (y3 + y4) / 2, 0);
                }

                if (x4 < Math.max(x1, x2) && x4 > Math.min(x1, x2)) {
                    return new pc.Vec3((x3 + x4) / 2, (y3 + y4) / 2, 0);
                }

                if (y3 < Math.max(y1, y2) && y3 > Math.min(y1, y2)) {
                    return new pc.Vec3((x3 + x4) / 2, (y3 + y4) / 2, 0);
                }

                if (y4 < Math.max(y1, y2) && y4 > Math.min(y1, y2)) {
                    return new pc.Vec3((x3 + x4) / 2, (y3 + y4) / 2, 0);
                }

                return null;
            } else {
                return null;
            }
        }

        var numerator1 = (y1 - y3) * (x4 - x3) - (x1 - x3) * (y4 - y3);
        var numerator2 = (y1 - y3) * (x2 - x1) - (x1 - x3) * (y2 - y1);

        if (numerator1 === 0 || numerator2 === 0)
        {
            return null;
        }

        var r = numerator1 / denominator;
        var s = numerator2 / denominator;

        if ((r > 0 && r < 1) && (s > 0 && s < 1)) {
            var x = x1 + (r * (x2 - x1));
            var y = y1 + (r * (y2 - y1));
            return new pc.Vec3(x, y, 0);
        }
    },

    equals(a, b) {
        return a > b - PopperBehaviour.EPS && a < b + PopperBehaviour.EPS;
    }
});

PopperBehaviour.EPS = 0.0000001;


// AssetRegistery.js
pc.Application.getApplication().assets.load = function load(asset) {
    // do nothing if asset is already loaded
    // note: lots of code calls assets.load() assuming this check is present
    // don't remove it without updating calls to assets.load() with checks for the asset.loaded state
    if (asset.loading || asset.loaded) {
        return;
    }
    
    this.fire("load:begin", asset);

    var self = this;
    var file = asset.file;

    // open has completed on the resource
    var _opened = function (resource) {
        if (resource instanceof Array) {
            asset.resources = resource;
        } else {
            asset.resource = resource;
        }

        // let handler patch the resource
        self._loader.patch(asset, self);

        self.fire("load", asset);
        self.fire("load:" + asset.id, asset);
        if (file && file.url)
            self.fire("load:url:" + file.url, asset);
        asset.fire("load", asset);
    };

    // load has completed on the resource
    var _loaded = function (err, resource, extra) {
        asset.loaded = true;
        asset.loading = false;

        if (err) {
            self.fire("error", err, asset);
            self.fire("error:" + asset.id, err, asset);
            asset.fire("error", err, asset);
        } else {
            if (asset.type === 'script') {
                var handler = self._loader.getHandler('script');
                if (handler._cache[asset.id] && handler._cache[asset.id].parentNode === document.head) {
                    // remove old element
                    document.head.removeChild(handler._cache[asset.id]);
                }
                handler._cache[asset.id] = extra;
            }

            _opened(resource);
        }
    };

    if (file || asset.type === 'cubemap') {
        // start loading the resource
        this.fire("load:start", asset);
        this.fire("load:" + asset.id + ":start", asset);

        asset.loading = true;
        self._loader.load(asset.getFileUrl(), asset.type, _loaded, asset);
    } else {
        // asset has no file to load, open it directly
        var resource = self._loader.open(asset.type, asset.data);
        asset.loaded = true;
        _opened(resource);
    }
};


// Popper.js
class Popper extends pc.ScriptType {
    initialize() {

        this.parent = null;

        this._explode = false;
        this._destroyedInstantly = false;
        this._despawnDelay = 0;

        this.animationController = this.entity.script.tileAnimationController;
        this.animationController.on('explode', this._onExplodeAnimation, this);
        this.animationController.on('exploded', this._onCompleteAnimation, this);
    }

    despawnInstant() {
        this._explode = true;
    }

    init(parent) {
        this.parent = parent;
        this.parent.typeID = backgroundTileEnum.POPPER;
    }

    recycle() {
        if (this._explode) {
            console.warn("already recycled");
            return;
        }

        this._explode = true;

        this.entity.objectPool.recycle(this.entity);
    }

    awake() {
        this._despawnDelay = 0;
        this.parent.hasExploded = false;
        this._explode = false;
        this._destroyedInstantly = false;
        this.parent._modelComponent.entity.enabled = true;

        this.parent.maxLayers = 3;

        this.parent.ignorePulse = false;

        this.animationController.setLayer(this.parent.currentLayer - 1);
    }

    explode(delay) {
        if (this._destroyedInstantly) {
            return;
        }

        if (this.parent.hasExploded) {
            this.animationController.playExplode(this.parent.currentLayer, delay, true);

            return true;
        } else {

            this.parent._onLayerExplode();

            this.parent.currentLayer--;


            this.animationController.playExplode(this.parent.currentLayer, delay);

            this.parent.hasExploded = true;
            this.parent._isDamaged = true;

            if (this.parent.currentLayer === 0) {
                this.parent.ignorePulse = true;

                StatisticsManager.instance.incrementStatistic('obstacle_destroyed', {
                    obstacle_type: TileLibrary.instance.getObstacleName(this.parent.typeID),
                });
                this.parent.isDestroyed = true;
            }

            return true;
        }
    }

    explodeAll(delay) {
        this.parent.ignorePulse = true;

        this._destroyedInstantly = true;
        this.parent._onLayerExplode();

        this.parent.currentLayer = 0;

        this.animationController.playExplode(this.parent.currentLayer, delay);

        this.parent.hasExploded = true;
        this.parent._isDamaged = true;

        this.parent.isDestroyed = true;
        StatisticsManager.instance.incrementStatistic('obstacle_destroyed', {
            obstacle_type: TileLibrary.instance.getObstacleName(this.parent.typeID),
        });
        return true;
    }

    _onExplodeAnimation(animationData) {
        var isLastLayer = this.parent.currentLayer === 0;

        this.parent._onExplode(isLastLayer, animationData.delay, true);

        if (isLastLayer) {
            GridManager.instance.playSFX('bomb_hit_flowers.mp3');
            GridManager.instance.playSFX('popper_explode.mp3');
        } else {
            GridManager.instance.playSFX('popper_explode.mp3');
            GridManager.instance.playSFX('popper_hit.mp3');
        }
    }

    _onCompleteAnimation() {
        this.recycle();
    }

    getDespawnDelay(withoutEndDelay) {
        if (withoutEndDelay) {
            return this._despawnDelay + this.animationController.getDespawnDelay();
        }

        if (this.parent.currentLayer === 0) {
            return this.animationController.getAnimationDuration() || this._despawnDelay;

        } else {
            return this.animationController.getDespawnDelay() || this._despawnDelay;
        }
    }

    setDespawnDelay(delay) {
        this._despawnDelay = delay;
    }

    activateRegrow() {
        this._despawnDelay = 0;

        GridManager.instance.playSFX('popper_cooldown.mp3');

        switch (this.parent.previousLayer) {
            case 1:
                this.animationController.playAnimation("popper_cooloff_2.glb");
                break;

            case 2:
                this.animationController.playAnimation("popper_cooloff_1.glb");
                break;

            default:
                this.animationController.playAnimation("popper_cooloff_2.glb");
                console.warn("Something went wrong", this.parent.previousLayer);
                break;
        }
    }
}

pc.registerScript(Popper);

// CoinAnimation.js
class CoinAnimation extends pc.ScriptType {
    static addAttributes() {
    }

    initialize() {
        this.on('disable', this._onDisable, this);
    }

    _onDisable() {
        //this._disabled = true;
        pc.timer.add(0.01, () => {
            this.entity.destroy();
        }, this);
    }

    playAnimation(endPoint, amount, coins, time, index) {
        //amount is the amount of coins to spawn
        this._startNewAnimation(endPoint, amount, coins, time, index);
    }

    _startNewAnimation(endPoint, amount, coins, time, index) {
        this.coins = coins;

        var randomX = pc.math.random(-80, 80);
        var randomY = pc.math.random(-80, 80);
        var delay = index / 20;

        this.entity.setLocalScale(0, 0, 0);
        this.entity.tween(this.entity.getLocalScale()).to(CoinAnimation.FINAL_SCALE, 0.4, pc.SineOut, delay).start();

        var positionTween = this.entity.tween(this.entity.getLocalPosition())
            .to({ x: this.entity.getLocalPosition().x + randomX, y: this.entity.getLocalPosition().y + randomY, z: this.entity.getLocalPosition().z }, 0.4, pc.SineOut, delay)
            .start();

        if (delay === 0) {
            this.app.fire('Audio:sfx', 'coin_gain_single.mp3');
        } else {
            positionTween.on('delayDone', () => {
                this.app.fire('Audio:sfx', 'coin_gain_single.mp3');
            });
        }

        var timeToPlay;

        if (time) {
            timeToPlay = time;
        } else {
            timeToPlay = pc.math.random(0.3, 0.7);
        }

        var positionTween2 = this.entity.tween(this.entity.getLocalPosition()).to(endPoint, timeToPlay, pc.SineIn)
        positionTween2.on('complete', this.onComplete, this);
        positionTween.chain(positionTween2);
    }

    onComplete() {
        this.app.fire('Audio:sfx', 'coin_gain.mp3');
        // Inventory.instance.addItem('COINS', this.rewardPerCoin);
        this.app.fire('CoinInterface:addCoins', this.coins);
        this.entity.destroy();
    }
}
CoinAnimation.FINAL_SCALE = { x: 0.5, y: 0.5, z: 0.5 };
pc.registerScript(CoinAnimation, 'coinAnimation');
CoinAnimation.addAttributes();



// Copyer.js
class Copyer extends pc.ScriptType {
    static addAttributes() {
        this.attributes.add('coloredMaterials', { type: 'asset', array: true });
    }

    initialize() {
        this.parent = null;
        this.possibleExplodes = [];

        this._explode = false;

        this._allDestroyed = false;

        this.animationController = this.entity.script.tileAnimationController;
        this.animationController.on('explode', this._onExplodeAnimation, this);
        this.animationController.on('exploded', this._onCompleteAnimation, this);
        this.animationController.on('despawn', this._onDespawnAnimation, this);
    }

    init(parent) {
        this.parent = parent;
        this.parent.typeID = backgroundTileEnum.COPYER;

        this.parent.showModelToUI = false;
    }

    awake() {
        this.parent.colorID = tileColorEnum.NONE;
        this.parent.hasExploded = false;
        this._explode = false;
        this.parent._modelComponent.entity.enabled = true;

        if (this.parent.currentLayer !== 2) {
            console.warn("Copyer should always has 2 layers. It has", this.parent.currentLayer);

            this.parent.currentLayer = 2;
        }

        this.animationController.setLayer(this.parent.currentLayer - 1);

        this._allDestroyed = false;
        this._jelly = this.parent._modelComponent.model.meshInstances.find(mi => mi.node.name === "jelly001");
        this.possibleExplodes.length = 0;
    }

    setPossibleExplode(tile, delay) {
        if (this.parent.colorID === tileColorEnum.NONE) {
            var index = this.possibleExplodes.findIndex(possibleExplode => possibleExplode.tile === tile);

            if (index !== -1) {
                return;
            }

            this.possibleExplodes.push({
                tile: tile,
                delay: delay,
            });

            clearTimeout(this.timeout);

            this.timeout = setTimeout(() => {
                this.selectColor();
                clearTimeout(this.timeout);
            });
        }
    }

    selectColor() {
        if (this.possibleExplodes.length === 0) {
            console.warn("No possible explodes found");
            return;
        }

        var lowestDelay = Number.POSITIVE_INFINITY;

        for (var i = 0; i < this.possibleExplodes.length; i++) {
            const possibleExplode = this.possibleExplodes[i];

            if (possibleExplode.delay < lowestDelay) {
                lowestDelay = possibleExplode.delay;
            }
        }

        var array = this.possibleExplodes.filter(pe => pe.delay === lowestDelay);

        var randomIndex = Math.floor(Math.random() * array.length);

        var explode = array[randomIndex];

        this.setColor(this.getCorrectColorID(explode.tile));

        // this.animationController.playExplode(this.parent.currentLayer, explode.delay);

        // console.log(this.possibleExplodes[randomIndex])
    }

    getCorrectColorID(tile) {
        var tileColor = tile.colorID;

        if (tile instanceof ForegroundTile && tile.isSwitcher()) {
            tileColor = tile.entity.script.Switcher.previousColor;
        }

        return tileColor;
    }

    explode(delay, tile) {
        if (!tile) {
            console.warn("No tile found");
            return false;
        }

        if (this.parent.currentLayer === 0) {
            return;
        }

        var tileColor = this.getCorrectColorID(tile);

        if (this.parent.colorID === tileColorEnum.NONE) {
            if (tileColor !== tileColorEnum.NONE) {
                this.setPossibleExplode(tile, delay);
            } else {
                console.warn("What to do?");
            }
        } else if (tileColor !== this.parent.colorID) {
            return false;
        }

        if (this.parent.hasExploded) {
            // Set the shortest delay
            this.animationController.playExplode(this.parent.currentLayer, delay, true);
            return true;
        } else {
            this.parent._onLayerExplode();

            this.parent.currentLayer--;
            this.parent.hasExploded = true;
            var animationData = this.animationController.playExplode(this.parent.currentLayer, delay);


            if (this.parent.currentLayer === 0) {
                this.parent.isDestroyed = true;
                animationData.addCustomEvent("despawn", 1.5);
                StatisticsManager.instance.incrementStatistic('obstacle_destroyed', {
                    obstacle_type: TileLibrary.instance.getObstacleName(this.parent.typeID),
                });
            }

            return true;
        }

        return false;
    }

    _onExplodeAnimation(animationData) {
        var isLastLayer = this.parent.currentLayer === 0;

        this.parent._onExplode(isLastLayer, animationData.delay, true);

        if (isLastLayer) {
            GridManager.instance.playSFX('copyer_fill.mp3');

            pc.timer.add(1, () => { GridManager.instance.playSFX('copyer_complete.mp3'); }, this);
        } else {
            GridManager.instance.playSFX('copyer_fill.mp3');
        }
    }

    _onCompleteAnimation() {
        this.recycle();
    }

    _onDespawnAnimation() {
        if (this.parent._isObjective) {
            if (!ObjectiveManager.instance.isObjectiveCompleted(tileLayerEnum.BACKGROUND, this.parent.typeID, this.parent.colorID)) {
                this.app.fire('ModelToUIManager:showAnimation', this.entity.getLocalPosition(), { layerID: tileLayerEnum.BACKGROUND, typeID: this.parent.typeID, colorID: this.parent.colorID }, 0);
            }
        }
        GridManager.instance.playSFX('copyer_complete_2.mp3');
    }

    recycle() {
        if (this._explode) {
            console.warn("already recycled");
            return;
        }

        this._explode = true;

        this.entity.objectPool.recycle(this.entity);
    }

    setColor(id) {
        this.parent.colorID = id;

        let materialAsset = this.coloredMaterials[id - 1];

        if (!(materialAsset instanceof pc.Asset)) {
            console.warn("Color ID is invalid", this.parent.colorID);
            return;
        }

        this._jelly.material = materialAsset.resource;
    }

    getDespawnDelay() {
        return this.animationController.getAnimationDuration();
    }
}

pc.registerScript(Copyer);
Copyer.addAttributes();

// ComicToBookButton.js
var ComicToBookButton = pc.createScript('comicToBookButton');

ComicToBookButton.attributes.add('pageID', { type: 'number', default: 0 });
ComicToBookButton.attributes.add('worldID', { type: 'number', default: 1 });
ComicToBookButton.attributes.add('isUnlocked', { type: 'boolean', default: false });
ComicToBookButton.attributes.add('lockImage', { type: 'entity', });
ComicToBookButton.attributes.add('lockedOverlay', { type: 'entity', });

pc.extend(ComicToBookButton.prototype, {


    initialize: function () {
        this.entity.script.elementInput.on(inputEvents.CLICK, this._onCLick, this);
        this.app.on('BookUI:switchPage', this._onPageSwitch, this);
    },

    _onCLick: function () {
        if (this.isUnlocked) {
            this.app.fire('BookUI:levelSelect', this.worldID, this.pageID);
            this.app.fire('UIManager:hideUI', 'Comic');
            this.app.fire('LevelSelectPage:scrollTo', 0);
        }
    },

    setLockVisibility(value) {
        this.lockImage.enabled = value;
        this.lockedOverlay.enabled = value;
    },

    fadeOutLock() {
        this.lockImage.tween(this.lockImage.element).to({ opacity: 0 }, 1, pc.Linear).start().on('complete', () => {
            this.setLockVisibility(false);
        });

        this.lockedOverlay.tween(this.lockedOverlay.element).to({ opacity: 0 }, 1, pc.Linear).start();
    }
});

// PageFlipAnimation.js
class PageFlipAnimation extends pc.ScriptType {
    static addAttributes() {
        this.attributes.add("camera", { type: "entity" });
        this.attributes.add("layerName", { type: "string" });
        this.attributes.add("left", { type: 'entity' });
        this.attributes.add("right", { type: 'entity' });

        this.attributes.add("horizontalModelEntity", { type: 'entity' });
        this.attributes.add("verticalModelEntity", { type: 'entity' });

        this.attributes.add("middle", { type: 'entity' });
        this.attributes.add("screen", { type: 'entity' });

        this.attributes.add("uiCamera", { type: "entity" });
    }

    initialize() {
        PageFlipAnimation.instance = this;

        this.animHorizontal = this.horizontalModelEntity.anim;
        this.horizontalModel = this.horizontalModelEntity.model;
        this.horizontalModel.hide();

        this.animVertical = this.verticalModelEntity.anim;
        this.verticalModel = this.verticalModelEntity.model;
        this.verticalModel.hide();
    }

    postInitialize() {
        //var renderTarget = this.app.scene.layers.getLayerByName(this.layerName).renderTarget;   
        var renderTarget = this.camera.camera.renderTarget;
        // get the material on the first mesh instance this script is attached to
        // and apply the rendertarget from the layer to it's diffuse map

        if (!this.left._enabled) {
            console.log("Left page is disabled. Please turn it on");
        }

        if (!this.right._enabled) {
            console.log("Right page is disabled. Please turn it on");
        }

        if (renderTarget) {
            this.leftPageMaterial = this.horizontalModel.model.meshInstances[1].material;
            this.leftPageMaterial.diffuseMap = renderTarget.colorBuffer;
            this.leftPageMaterial.opacityMap = renderTarget.colorBuffer;

            this.leftPageMaterial.update();

            this.rightPageMaterial = this.horizontalModel.model.meshInstances[0].material;
            this.rightPageMaterial.diffuseMap = renderTarget.colorBuffer;
            this.rightPageMaterial.opacityMap = renderTarget.colorBuffer;

            this.rightPageMaterial.update();
        } else {
            console.log("no render target found");
        }

        this._onResize(ViewportManager.instance.getOrientation(), ViewportManager.instance.width, ViewportManager.instance.height, ViewportManager.instance.getDevice());

        this._boundaries = new pc.Vec4();

        // this.calculateNewBoundaries();
        // this.calculatePageDistance();

        this.app.on('ViewportManager:onResize', this._onResize, this);
    }

    _setCurrentProperties(orientation, device) {
        this._orientation = orientation;
        this._device = device;
    }

    _onResize(orientation, width, height, device) {
        this._setCorrectOrientation(orientation || 'landscape', device);

        this.fire('complete');
        this.hideModel();
    }

    _setCorrectOrientation(orientation, device) {
        this._setCurrentProperties(orientation, device);
    }

    _setPosition() {
        if (this._orientation === orientationEnum.PORTRAIT) {
            if (this._device === deviceEnum.MOBILE) {
                this.entity.setPosition(PageFlipAnimation.PORTRAIT_MOBILE_POSITION);
            } else {
                this.entity.setPosition(PageFlipAnimation.PORTRAIT_DESKTOP_POSITION);
            }
        } else if (this._orientation === orientationEnum.LANDSCAPE) {
            if (this._device === deviceEnum.MOBILE) {
                this.entity.setPosition(PageFlipAnimation.LANDSCAPE_MOBILE_POSITION);
            } else {
                this.entity.setPosition(PageFlipAnimation.LANDSCAPE_DESKTOP_POSITION);
            }
        } else {
            console.log("orientation not found", this._orientation);
        }
    }

    flipNextPage(current, next, scroll) {
        this.calculateNewBoundaries();

        this.showModel("flipNext");

        this.playSFX();

        FakeLevelSelectPage.instance.setLeftPage(next);
        FakeLevelSelectPage.instance.setRightPage(current, scroll);

        this.app.fire("PageFlipAnimation:renderTexture");

        return this;
    }

    playSFX() {
        pc.timer.add(0.15, () => {
            this.app.fire('Audio:sfx', 'page_flip.mp3');
        }, this);
    }

    showModel(animation) {
        setTimeout(() => {
            if (this._orientation === orientationEnum.PORTRAIT) {
                this.verticalModel.show();
                this.animVertical.setTrigger(animation);
            } else {
                this.horizontalModel.show();
                this.animHorizontal.setTrigger(animation);
            }
        });
    }

    hideModel() {
        this.horizontalModel.hide();
        this.verticalModel.hide();
    }

    flipPreviousPage(current, next, scroll) {
        this.calculateNewBoundaries();

        this.playSFX();

        this.showModel("flipPrevious");

        FakeLevelSelectPage.instance.setLeftPage(current);
        FakeLevelSelectPage.instance.setRightPage(next, 1);

        this.app.fire("PageFlipAnimation:renderTexture");

        return this;
    }

    postUpdate() {
        if (this.animHorizontal.baseLayer.activeState === 'End' || this.animVertical.baseLayer.activeState === 'End') {
            this.fire('complete');
            this.hideModel();
        }

        // this.calculateNewBoundaries();
    }

    calculateNewBoundaries() {
        var minX = Math.min(this.left.element.canvasCorners[0].x, this.left.element.canvasCorners[2].x);
        var minY = Math.min(this.left.element.canvasCorners[0].y, this.left.element.canvasCorners[2].y);

        var maxX = Math.max(this.right.element.canvasCorners[0].x, this.right.element.canvasCorners[2].x);
        var maxY = Math.max(this.right.element.canvasCorners[0].y, this.right.element.canvasCorners[2].y);

        if (this._orientation === orientationEnum.PORTRAIT) {
            PageFlipAnimation.VEC_4.set(minX, minY, maxX, maxY);

            var updated = !PageFlipAnimation.VEC_4.equals(this._boundaries);

            this._boundaries.copy(PageFlipAnimation.VEC_4);

            if (updated) {
                this.calculateOffsetAndTiling();
            }
        } else {
            PageFlipAnimation.VEC_4.set(minX, minY, maxX, maxY);

            var updated = !PageFlipAnimation.VEC_4.equals(this._boundaries);

            this._boundaries.copy(PageFlipAnimation.VEC_4);

            if (updated) {
                this.calculateOffsetAndTiling();
            }
        }
    }

    calculateOffsetAndTiling() {
        if (!this.camera.camera.renderTarget) {
            return;
        }

        if (this._orientation === orientationEnum.PORTRAIT) {
            var offsetX = this._boundaries.x / ViewportManager.instance.width;
            var offsetY = this._boundaries.y / ViewportManager.instance.height;
            var offsetY2 = this._boundaries.w / ViewportManager.instance.height;

            var tilingX = (this._boundaries.z - this._boundaries.x) / ViewportManager.instance.width;
            var tilingY = (this._boundaries.w - this._boundaries.y) / ViewportManager.instance.height / 2;

            this.rightPageMaterial.diffuseMapOffset.set(offsetX, offsetY);
            this.rightPageMaterial.diffuseMapTiling.set(tilingX, tilingY);
            this.rightPageMaterial.opacityMapOffset.set(offsetX, offsetY);
            this.rightPageMaterial.opacityMapTiling.set(tilingX, tilingY);
            this.rightPageMaterial.update();

            this.leftPageMaterial.diffuseMapOffset.set(offsetX, offsetY2);
            this.leftPageMaterial.diffuseMapTiling.set(tilingX, -tilingY);
            this.leftPageMaterial.opacityMapOffset.set(offsetX, offsetY2);
            this.leftPageMaterial.opacityMapTiling.set(tilingX, -tilingY);
            this.leftPageMaterial.update();

            this.calculatePageDistance();
        } else {
            var offsetY = this._boundaries.y / ViewportManager.instance.height;
            var offsetX2 = (this._boundaries.z + this._boundaries.x) / 2 / ViewportManager.instance.width;

            var tilingX = (this._boundaries.z - this._boundaries.x) / ViewportManager.instance.width / 2;
            var tilingY = (this._boundaries.w - this._boundaries.y) / ViewportManager.instance.height;

            this.rightPageMaterial.diffuseMapOffset.set(offsetX2, -offsetY);
            this.rightPageMaterial.diffuseMapTiling.set(-tilingX, -tilingY);
            this.rightPageMaterial.opacityMapOffset.set(offsetX2, -offsetY);
            this.rightPageMaterial.opacityMapTiling.set(-tilingX, -tilingY);
            this.rightPageMaterial.update();

            this.leftPageMaterial.diffuseMapOffset.set(offsetX2, -offsetY);
            this.leftPageMaterial.diffuseMapTiling.set(tilingX, -tilingY);
            this.leftPageMaterial.opacityMapOffset.set(offsetX2, -offsetY);
            this.leftPageMaterial.opacityMapTiling.set(tilingX, -tilingY);
            this.leftPageMaterial.update();
            this.calculatePageDistance();
        }
    }

    calculatePageDistance() {
        var fov = this.camera.camera.fov;

        if (this._orientation === orientationEnum.PORTRAIT) {

            var ratioY = (this._boundaries.w - this._boundaries.y) / ViewportManager.instance.height / 2;

            var width = PageFlipAnimation.PAGE_WIDTH / ratioY;

            var distance = width / Math.tan(fov / 2 * PageFlipAnimation.DEGREE_TO_RADIANS);

            var position = this.getCenterPosition(distance);

            this.entity.setLocalPosition(position);
        } else {
            var fov = this.camera.camera.fov;

            var ratioY = (this._boundaries.w - this._boundaries.y) / ViewportManager.instance.height;

            var height = PageFlipAnimation.PAGE_HEIGHT / ratioY;

            var distance = height / Math.tan(fov / 2 * PageFlipAnimation.DEGREE_TO_RADIANS);

            var position = this.getCenterPosition(distance);

            this.entity.setLocalPosition(position);
        }
    }

    getCenterPosition(distance) {
        var x = (this.middle.element.canvasCorners[2].x + this.middle.element.canvasCorners[0].x) / 2;
        var y = (this.middle.element.canvasCorners[2].y + this.middle.element.canvasCorners[0].y) / 2;

        var end = this.uiCamera.camera.screenToWorld(x, y, distance);

        return end;
    }
}

pc.registerScript(PageFlipAnimation);
PageFlipAnimation.addAttributes();
PageFlipAnimation.VEC_4 = new pc.Vec4();

PageFlipAnimation.PAGE_HEIGHT = 2.5;
PageFlipAnimation.PAGE_WIDTH = 2.7;

PageFlipAnimation.DEGREE_TO_RADIANS = Math.PI / 180;

PageFlipAnimation.OFFSET = new pc.Vec3();


// PopUpUITween.js
class PopUpUITween extends pc.ScriptType {
    static addAttributes() {
        this.attributes.add('debug', { type: "boolean" });
        this.attributes.add('redoGetElements', { type: 'boolean' });
    }

    initialize() {
        this._elementEntities = [];
        this._currentTweens = [];

        this._currentPromiseResolve = null;
    }

    postInitialize() {
        this._onResize(ViewportManager.instance.getOrientation(), ViewportManager.instance.width, ViewportManager.instance.height, ViewportManager.instance.getDevice());
        this.app.on('ViewportManager:onResize', this._onResize, this);

        if (!this.redoGetElements) {
            this._getAllElementComponents(this.entity);
        }
    }

    _onResize(orientation, width, height, device) {
        this.stopAllTweens();
        this.entityScale = this.entity.getLocalScale().clone();

        if (this.entity.script.maxElementScale) {
            // Should already be good.
        } else if (this.entity.script.dynamicElement) {
            this.entityScale = this.entity.script.dynamicElement.getScale();
            if (this.debug) {
                console.warn(this.entity.name, this.entityScale)

            }

        }
    }

    doOpenAnimation() {
        if (!this.entityScale) {
            return;
        }

        if (this.redoGetElements) {
            this._elementEntities.length = 0;
            this._getAllElementComponents(this.entity);
        }

        this.entity.setLocalScale(this.entityScale.x * 0.5, this.entityScale.y * 0.5, this.entityScale.z * 0.5);
        var scaleTween = this.entity
            .tween(this.entity.getLocalScale())
            .to(this.entityScale, 0.3, pc.BackOut)
            .start();
        this._currentTweens.push(scaleTween);

        this._elementEntities.forEach(function (entity) {
            var startOpacity = entity.element.opacity;
            entity.element.opacity = 0;
            var opacityTween = entity
                .tween(entity.element)
                .to({ opacity: startOpacity }, 0.15, pc.Linear)
                .start();
            this._currentTweens.push(opacityTween);
        }.bind(this));

        return new Promise(function (resolve, reject) {
            this._currentPromiseResolve = resolve;
            scaleTween.once('complete', function () {
                this._currentTweens.length = 0;
                resolve();
            }.bind(this));
        }.bind(this));
    }

    doCloseAnimation() {
        var scaleTween = this.entity
            .tween(this.entity.getLocalScale())
            .to({ x: this.entityScale.x * 0.7, y: this.entityScale.y * 0.7, z: this.entityScale.z * 0.7 }, 0.3, pc.BackIn)
            .start();
        this._currentTweens.push(scaleTween);

        this._elementEntities.forEach(function (entity) {
            var startOpacity = entity.element.opacity;
            var opacityTween = entity
                .tween(entity.element)
                .to({ opacity: 0 }, 0.15, pc.Linear)
                .delay(0.2)
                .start()
                .once('complete', function () {
                    entity.element.opacity = startOpacity;
                }.bind(this));
            this._currentTweens.push(opacityTween);
        }.bind(this));

        return new Promise(function (resolve, reject) {
            this._currentPromiseResolve = resolve;
            scaleTween.once('complete', function () {
                this._currentTweens.length = 0;
                resolve();
            }.bind(this));
        }.bind(this));
    }

    _getAllElementComponents(entity) {
        if (entity.tags.has('ignoreOpacityTween')) {
            return;
        }

        var element = entity.element;

        if (element !== undefined && element.opacity !== null && element.opacity !== undefined) {
            this._elementEntities.push(entity);
            element._originalOpacity = element.opacity;
        }

        var self = this;
        entity.children.forEach(function (child) {
            self._getAllElementComponents(child);
        });
    }

    stopAllTweens() {
        for (let i = 0; i < this._currentTweens.length; i++) {
            this._currentTweens[i].stop();
        }

        for (let i = 0; i < this._elementEntities.length; i++) {
            if (this._elementEntities[i].tags.has('ignore_original_opacity')) {
                continue;
            }
            this._elementEntities[i].element.opacity = this._elementEntities[i].element._originalOpacity;
        }

        this._currentTweens.length = 0;

        if (this._currentPromiseResolve) {
            this._currentPromiseResolve();
            delete this._currentPromiseResolve;
        }
    }
}

pc.registerScript(PopUpUITween);
PopUpUITween.addAttributes();

// GoogleLoginButton.js
class GoogleLoginButton extends pc.ScriptType {

    initialize() {
        this.entity.script.elementInput.on('click', this.login, this);
    }

    login() {
        const promise = Firebase.instance.googleLogin();

        if (!promise) {
            return;
        }

        promise.then(a => {
            this.app.fire('UIManager:hideUI', 'Login');
        }).catch(error => {
            console.log(error, error.code)

            if (error && error.code === 'auth/popup-blocked') {
                this.loginWithRedirect();
            }
        });
    }

    loginWithRedirect() {
        const promise = Firebase.instance.googleLoginRedirect();

        if (!promise) {
            return;
        }

        promise.then(a => {
            this.app.fire('UIManager:hideUI', 'Login');
        }).catch(error => {
            console.log(error, error.code)
            if (error && error.code === 'auth/popup-blocked') {
            }
        });
    }
}


pc.registerScript(GoogleLoginButton);


// GardenUpgradeDialog.js
class GardenUpgradeDialog extends pc.ScriptType{
    static addAttributes(){
        this.attributes.add('PreUpgradeKey', { type: 'string', default:""});
        this.attributes.add('PostUpgradeKey', { type: 'string', default:""});
    }
}
pc.registerScript(GardenUpgradeDialog, 'gardenUpgradeDialog');
GardenUpgradeDialog.addAttributes();

// PowerCombinationAnimation.js
class PowerCombinationAnimation extends pc.ScriptType {
    static addAttributes() {
        this.attributes.add('particles', { type: 'entity', array: true });
    }
    
    initialize() {
        this.mainParticleSystem = this.entity.particlesystem;
    }
    
    play(lifetime, amount) {
        this._playing = true;
        this.mainParticleSystem.lifetime = lifetime;
        this.mainParticleSystem.reset();
        this.mainParticleSystem.play();
        
        for (var i = 0; i < this.particles.length; i++) {
            var particleSystem = this.particles[i].particlesystem;
            particleSystem.numParticles = Math.round(lifetime * 3.75);
            particleSystem.reset();
            particleSystem.play();
        }
    }
    
    onComplete() {
        this._playing = false;
        this.entity.objectPool.recycle(this.entity);
    }
    
    update() {
        if (this._playing) {    
            var completed = true;
            
            completed = !this.mainParticleSystem.isPlaying();
            
            for (var i = 0; i < this.particles.length; i++) {
                var particleSystem = this.particles[i].particlesystem;
                
                if (this.particles[i].particlesystem.isPlaying()) {
                    completed = false;
                    break;
                }
            }
            
            if (completed) {
                this.onComplete();
            }
        }
    }
}

pc.registerScript(PowerCombinationAnimation);
PowerCombinationAnimation.addAttributes();

// RenderLayerToTexture.js
var RenderLayerTotexture = pc.createScript('renderLayerTotexture');

RenderLayerTotexture.attributes.add("layerName", {type: "string"});
RenderLayerTotexture.attributes.add("camera", { type: 'entity' });


// initialize code called once per entity
RenderLayerTotexture.prototype.initialize = function() {
    var device = this.app.graphicsDevice;
    
    var colorBuffer = new pc.Texture(device, {
        width: 1024,
        height: 1024,
        format: pc.PIXELFORMAT_R8_G8_B8_A8,
        autoMipmap: true,
    });
        
    var depthBuffer = new pc.Texture(device, {
        format: pc.PIXELFORMAT_DEPTHSTENCIL,
        width: 1024,
        height: 1024,
        mipmaps: false,
        addressU: pc.ADDRESS_CLAMP_TO_EDGE,
        addressV: pc.ADDRESS_CLAMP_TO_EDGE
    });
    
    colorBuffer.minFilter = pc.FILTER_LINEAR;
    colorBuffer.magFilter = pc.FILTER_LINEAR;
    
    var renderTarget = new pc.RenderTarget({
        colorBuffer: colorBuffer,
        depthBuffer: depthBuffer,
        samples: 4 // Enable anti-alias 
    });
        
    this.colorBuffer = colorBuffer;
    this.depthBuffer = depthBuffer;
            
    this.camera.camera.renderTarget = renderTarget;
};

// LogoutButton.js
class LogoutButton extends pc.ScriptType {
    postInitialize() {
        this.entity.script.elementInput.on('click', this._onClick, this);
    }
    
    _onClick() {
        Firebase.instance.logout();
    }
}

pc.registerScript(LogoutButton);

// Key.js
class Key extends pc.ScriptType {
    static addAttributes() {
        this.attributes.add('colorId', { type: 'number', enum: Key.colorEnum });
    }

    init(superClass) {
        this.superClass = superClass;

        this._triggered = false;

        this.superClass.typeID = foregroundTileEnum.KEY;
        this.superClass.colorID = this.colorId;
    }

    awake() {
        this._triggered = false;
    }

    explode() {
        this.app.fire('ScoreManager:scoreForegroundTile', this.superClass.typeID, this.superClass._isObjective, this.superClass);
        this.superClass.despawn();

        StatisticsManager.instance.incrementStatistic("obstacle_destroyed", { obstacle_type: 'key' }, 1);

        return true;
    }

    setDespawnDelay(delay) {
        if (this._triggered) {
            return;
        }

        if (!this.superClass.unableToExplode()) {
            GridManager.instance.onKeyDestroy(this.superClass, delay);
            this._triggered = true;
        }
    }
}

pc.registerScript(Key);

// // if you are gonna parse, uncomment this en comment it when you are done
// var tileColorEnum = Object.freeze({
//     NONE: 0,
//     BLUE: 1,
//     YELLOW: 2,
//     RED: 3,
//     PURPLE: 4,
//     GREEN: 5,
//     ORANGE: 6,
// });

Key.colorEnum = [
    { NONE: tileColorEnum.NONE },
    { BLUE: tileColorEnum.BLUE },
    { YELLOW: tileColorEnum.YELLOW },
    { RED: tileColorEnum.RED },
    { PURPLE: tileColorEnum.PURPLE },
    { GREEN: tileColorEnum.GREEN },
    { ORANGE: tileColorEnum.ORANGE }
];

Key.addAttributes();




// Menu.js
class Menu extends pc.ScriptType {
    static addAttributes() {
        this.attributes.add('logoutButton', { type: 'entity' });
        this.attributes.add('loginOptions', { type: 'entity' });
    }

    initialize() {
        this.app.on('Firebase:logchange', this.setLogButtons, this);
    }

    setLogButtons(loggedIn) {
        const loginSupport = firebaseClass.active;

        this.logoutButton.enabled = loggedIn && loginSupport;
        this.loginOptions.enabled = !loggedIn && loginSupport;
    }

    onUIEntityOpen() {
        this.setLogButtons(Firebase.instance.loggedIn());

        if (BackTogardenButton.showIntro && !this._hasObjectiveSet()) {
            Wrapper.instance.sendGAEvent(Wrapper.GA_EVENT_TYPE.DESIGN, { eventId: 'tutorialFunnel:start' });
        }

        // if (GameManager.instance.forcedMode) {
        //     this.app.fire("UIManager:showUI", "blackOverlay");
        // }
    }

    _hasObjectiveSet() {
        return GardenDataManager.instance.getNextUnlockableObject();
    }

    onUIEntityCloseFinish() {
        if (GameManager.instance.forcedMode) {
            // GameManager.instance.checkReady();

        }
    }
}

pc.registerScript(Menu);
Menu.addAttributes();

// FakeLevelSelectPage.js
class FakeLevelSelectPage extends pc.ScriptType {
    static addAttributes() {
        FakeLevelSelectPage.attributes.add('storyImage', { type: 'entity' });
        FakeLevelSelectPage.attributes.add('chapterText', { type: 'entity' });
        FakeLevelSelectPage.attributes.add('chapterImageEntity', { type: 'entity' });
        FakeLevelSelectPage.attributes.add('levelButtonTemplate', { type: 'asset' });
        FakeLevelSelectPage.attributes.add('levelGroup', { type: 'entity' });
        FakeLevelSelectPage.attributes.add('previousPageButtonGroup', { type: 'entity' });
        FakeLevelSelectPage.attributes.add('nextPageButtonGroup', { type: 'entity' });
        FakeLevelSelectPage.attributes.add('scrollviewBackgroundEntity', { type: 'entity' });
        FakeLevelSelectPage.attributes.add('backgroundImageEntity', { type: 'entity' });
        FakeLevelSelectPage.attributes.add('scrollBar', { type: 'entity' });
    }

    initialize() {
        FakeLevelSelectPage.instance = this;

        this.levelButtons = [];
        
        this.previousPageButtonGroup.reparent(this.levelGroup);
        this.previousPageButtonGroup.enabled = true; // temp
        
        for (var i = 0; i < 25; i += 1) {
            var button = this.levelButtonTemplate.resource.instantiate();
            this.levelGroup.addChild(button);
            this.levelButtons.push(button);
        }
                
        this.nextPageButtonGroup.reparent(this.levelGroup);
        this.nextPageButtonGroup.enabled = true; // temp
        this.levelGroup.element.height = this.getScrollViewHeight();
    }

    getScrollViewHeight() {
        var totalHeight = 0;

        for (var i = 0 ; i < this.levelGroup.children.length; i +=1) {
            totalHeight += this.levelGroup.children[i].element.height;
            totalHeight += this.levelGroup.layoutgroup.spacing.y;
        }

        totalHeight += this.levelGroup.layoutgroup.padding.w + this.levelGroup.layoutgroup.padding.y;
        return totalHeight;
    }

    setLeftPage(pageInformation) {
        var chapterID = pageInformation.pageInfo.chapterID;
        var starData = LevelDataManager.instance.getTotalStarData(chapterID);
        var worldInfo = WorldManager.instance.getWorldData(chapterID);
        var partsData = LevelDataManager.instance.getPartsData(chapterID);   
        LocalizationManager.instance.setText(this.chapterText, worldInfo.name);
        this.chapterImageEntity.element.sprite = WorldManager.instance.getWorldBackgroundImage(chapterID).resource;
        this.storyImage.element.spriteAsset = worldInfo.comics[pageInformation.pageInfo.pageID];

        this.app.fire('FakeChapterInformationBar:updateStats', starData, (worldInfo.nLevels * 3), partsData, worldInfo.nParts, chapterID);
    }

    setRightPage(pageInformation, scrollValue) {
        this.previousPageButtonGroup.script.switchPageOrChapterButton.onPageSwitch(pageInformation.pageInfo, this);
        this.nextPageButtonGroup.script.switchPageOrChapterButton.onPageSwitch(pageInformation.pageInfo, this);
        
        var chapterID = pageInformation.pageInfo.chapterID;
        var pageID = pageInformation.pageInfo.pageID;

        var worldInfo = WorldManager.instance.getWorldData(chapterID);
        
        this.scrollToValue(scrollValue);
        this.scrollviewBackgroundEntity.element.sprite = WorldManager.instance.getWorldBackgroundImage(chapterID).resource;
        //this.backgroundImageEntity.element.sprite = WorldManager.instance.getBlurredWorldBackgroundImage(chapterID).resource;
        
        this.containsCurrentLevel = false;

        for (var i = 0; i < this.levelButtons.length; i += 1) {
            if (i > (worldInfo.nLevels / worldInfo.nParts)) {
                this.levelButtons[i].enabled = false;
                continue;
            }
            this.levelButtons[i].enabled = true;
            var levelID = this.getLevelID(chapterID, pageID, i);
            this.levelButtons[i].script.FakeLevelButton.setButtonInformation(chapterID, levelID);

            if (levelID < LevelDataManager.instance.getCurrentLevel()) {
                this.levelButtons[i].script.FakeLevelButton.setState(LevelButton.buttonStates.UNLOCKED);
            } else if (levelID === LevelDataManager.instance.getCurrentLevel()){
                this.levelButtons[i].script.FakeLevelButton.setState(LevelButton.buttonStates.CURRENT);
                this.containsCurrentLevel = true;
            } else {
                this.levelButtons[i].script.FakeLevelButton.setState(LevelButton.buttonStates.LOCKED);
            }   
        }
    }
    
    getLevelID(chapterID, pageID, levelIndex) {
        var pageCounter = 0;
        var worldList = WorldManager.instance.getWorldList();
        for (var worldKey in worldList) {
            if (worldKey !== chapterID) {
                pageCounter += worldList[worldKey].nLevels;
            } else {
                for (var i = 0; i < worldList[worldKey].nParts; i += 1) {
                    if (i !== pageID) {
                        pageCounter += worldList[worldKey].nLevels / worldList[worldKey].nParts;
                    } else {
                        return pageCounter + levelIndex + 1;
                    }
                }
            }
        }
    }
    
    scrollToValue(value) {
        this.scrollBar.scrollbar.value = value;
    }
}   

pc.registerScript(FakeLevelSelectPage);
FakeLevelSelectPage.addAttributes();

// LoginScreen.js
class LoginScreen extends pc.ScriptType {
    
}


pc.registerScript(LoginScreen);

// DialogListener.js
class GardenDialogListener extends pc.ScriptType{
    static addAttributes(){
        this.attributes.add('fireToggleEvent1', {type: 'boolean'});
        this.attributes.add('fireToggleEvent2', {type: 'boolean'});
        this.attributes.add("dialogs", { type: 'json', array: true, schema: [
            {
                name: 'dialogKey',
                type: 'string',
                default: '',
            },{
                name: 'allowSkip',
                type: 'boolean',
                default: false,
            },{
                name: 'eventKey',
                type: 'string',
                default: '',
            }]
        });
    }
    initialize(){
        this.setDialogEvents();
    }
    
    setDialogEvents(){
        for(var i = 0; i < this.dialogs.length; i++){
            if(this.dialogs[i].eventKey)
            this.app.on(this.dialogs[i].eventKey, this.playDialog.bind(this, this.dialogs[i].dialogKey, this.dialogs[i].allowSkip));
        }
    }
    
    playDialog(key, allowSkip){
        this.app.fire('UIManager:hideUI', 'Garden');
        
        DialogManager.instance.setInterface(dialogTypes.CONVERSATION);
        if(DialogManager.instance._getDialog(key)[0]){
            DialogManager.instance.showDialog(key, this.afterDialogBehaviour, this, dialogTypes.CONVERSATION, allowSkip);
        }else{
            var style = "font-weight: bold;";
            console.warn(`${this.entity.name}: Wrong dialogue Key %c${key}`, style);
        }
    }
    afterDialogBehaviour(){
        this.app.fire('UIManager:showUI', 'Garden');
        this.app.fire('GardenDialogue:done');
    }
}
pc.registerScript(GardenDialogListener, 'gardenDialogListener');
GardenDialogListener.addAttributes();


// AssetManager.js
class AssetManager extends pc.ScriptType {
    static addAttributes() {
        this.attributes.add('ignoreWorldAsset', { type: 'asset', array: true })
        this.attributes.add('ignoreFTUEAsset', { type: 'asset', array: true })

    }

    initialize() {
        AssetManager.instance = this;

        this.currentWorld = '';
        this.previousWorld = '';


        this.assetsToUnload = [];

        this.subscribeEvents();

        this.extraAssets = [];
    }

    subscribeEvents() {
        this.app.on('UIManager:showUI', this.onUIEntityOpen, this);
        this.app.on('AssetManager:extraAssets', this.addExtraAssets, this);
    }

    onUIEntityOpen(args) {
        // TODO check if this is still used
        switch (args) {
            case 'Garden':
                //                 this.unloadAssetsByTag('world');
                //                 this.unloadAssetsByTag('world1');
                //                 this.unloadAssetsByTag('world2');
                //                 this.unloadAssetsByTag('world3');
                //                 this.unloadAssetsByTag('world4');
                //                 this.unloadAssetsByTag('world5');

                //                 this.unloadAssetsByTag('Menu');

                //                 this.loadAssetsByTag('Garden');
                //                 break;
                // this.setWorld(AssetManager.WORLDS.GARDEN, null, null, false);
                break;
            case 'Book':
                // this.setWorld(AssetManager.WORLDS.GARDEN);
                break;
        }
    }

    setBook(book, callback = null, context = null, showLoadingOverlay = true, unloadImmediatly = true) {
        if (book === AssetManager.WORLDS.BOOK) {
            book = AssetManager.WORLDS.WORLD + Number.parseInt(WorldManager.instance.getWorldIndex());
        }

        if (isFinite(book)) {
            book = AssetManager.WORLDS.BOOK + book;
        }

        if (book === this.currentWorld) {
            // console.log("Same world", world, this.currentWorld)

            if (callback) {
                callback.call(context);
            }
            return;
        }

        this.loadAndUnload(book, this.currentWorld, callback, context, showLoadingOverlay, unloadImmediatly);

        console.warn("New", book, "previous", this.currentWorld);
        this.previousWorld = this.currentWorld;
        this.currentWorld = book;
    }

    setWorld(world, callback = null, context = null, showLoadingOverlay = true, unloadImmediatly = true) {
        if (world === AssetManager.WORLDS.WORLD) {
            world = AssetManager.WORLDS.WORLD + Number.parseInt(WorldManager.instance.getWorldIndex());
        }

        if (world === this.currentWorld) {
            // console.log("Same world", world, this.currentWorld)

            if (callback) {
                callback.call(context);
            }
            return;
        }

        this.loadAndUnload(world, this.currentWorld, callback, context, showLoadingOverlay, unloadImmediatly);

        console.log("New", world, "previous", this.currentWorld);
        this.previousWorld = this.currentWorld;
        this.currentWorld = world;
    }

    setGarden(callback, context, showLoadingOverlay, reload, unloadImmediatly = true) {
        if (this.currentWorld === AssetManager.WORLDS.GARDEN) {
            console.warn("Already in the Garden");
            if (callback) {
                callback.call(context);
            }
            return;
        }

        if (reload) {
            this.extraAssets.length = 0;
            this.app.fire('AreaManager:loadAssets');
        }

        this.loadAndUnload(AssetManager.WORLDS.GARDEN, this.currentWorld, callback, context, showLoadingOverlay, unloadImmediatly);

        console.log("New", AssetManager.WORLDS.GARDEN, "previous", this.currentWorld);
        this.previousWorld = this.currentWorld;
        this.currentWorld = AssetManager.WORLDS.GARDEN;
    }

    loadAndUnload(next, previous, callback, context, showLoadingOverlay, unloadImmediatly = true, type) {
        showLoadingOverlay = false;
        // unloadImmediatly = true;

        var assetsToLoad = null;

        if (next.includes(AssetManager.WORLDS.WORLD)) {
            let worldID = next.replace(/\D/g, "");
            assetsToLoad = this.getWorldAssets(worldID);
        } else if (next.includes(AssetManager.WORLDS.BOOK)) {
            let worldID = next.replace(/\D/g, "");
            assetsToLoad = this.getBookAssets(worldID);
        } else {
            assetsToLoad = this.getAssetsByTag(next);
        }

        var assetsToUnload = [];

        if (next !== AssetManager.WORLDS.INTRO) {
            if (previous.includes(AssetManager.WORLDS.WORLD)) {
                let worldID = previous.replace(/\D/g, "");
                assetsToUnload = this.getWorldAssets(worldID);
            } else if (previous.includes(AssetManager.WORLDS.BOOK)) {
                let worldID = previous.replace(/\D/g, "");
                assetsToUnload = this.getBookAssets(worldID);
            } else {
                assetsToUnload = this.getAssetsByTag(previous);
            }
        }


        if (previous.includes(AssetManager.WORLDS.GARDEN)) {
            pc.utils.fuseUniqueArray(assetsToUnload, this.getAssetsByTag('Area'))
        }

        //         assetsToLoad = assetsToLoad.filter((asset) => !asset.loaded);
        //         assetsToUnload = assetsToUnload.filter((asset) => asset.loaded);

        pc.utils.fuseUniqueArray(this.assetsToUnload, assetsToUnload);

        this.assetsToUnload = this.assetsToUnload.filter(asset => assetsToLoad.indexOf(asset) === -1);
        //         console.log(assetsToLoad.some(asset => asset.name === 'ui-atlas.png'))
        //         console.log(assetsToUnload.some(asset => asset.name === 'ui-atlas.png'))

        pc.utils.fuseUniqueArray(assetsToLoad, this.extraAssets);

        if (GameManager.instance.forcedMode) {
            assetsToLoad = assetsToLoad.filter(asset => !asset.tags.has('ignore_in_forced_mode'));

        }

        assetsToLoad = assetsToLoad.filter(asset => asset && !asset.loaded);
        if (assetsToLoad.length === 0) {
            if (callback) {
                this._onLoaded(callback, context);

                if (unloadImmediatly) {
                    this.unloadAssets(this.assetsToUnload);
                }
            }
        } else {
            if (showLoadingOverlay) {
                this.app.fire('UIManager:showUI', 'loading');
            }
            this.loadAssetsInParallel(assetsToLoad, this._onLoaded.bind(this, callback, context, showLoadingOverlay, unloadImmediatly), this);
        }
    }

    loadIntro(callback, context) {
        this.loadAndUnload(AssetManager.WORLDS.INTRO, this.currentWorld, callback, context, true, true);
    }

    // --------------- LOADING ----------------------------

    loadExtra(asset, callback, context, showLoadingOverlay = true) {
        if (!Array.isArray(asset)) {
            asset = [asset];
        }

        if (showLoadingOverlay) {
            this.app.fire('UIManager:showUI', 'loading');
        }

        pc.utils.fuseUniqueArray(this.assetsToUnload, asset);

        this.loadAssetsInParallel(asset, () => {
            if (showLoadingOverlay) {
                this.app.fire('UIManager:hideUI', 'loading');
            }

            if (callback) {
                callback.call(context);
            }
        });
    }

    loadWorldAssets(worldID = WorldManager.instance.getWorldIndex(), callback = null, context = null, showLoadingOverlay = true, unloadImmediatly = true) {
        this.setWorld(AssetManager.WORLDS.WORLD + worldID, callback, context, showLoadingOverlay, unloadImmediatly);
    }

    loadBookAssets(worldID = WorldManager.instance.getWorldIndex(), callback = null, context = null, showLoadingOverlay = true, unloadImmediatly = true) {
        this.setWorld(AssetManager.WORLDS.BOOK + worldID, callback, context, showLoadingOverlay, unloadImmediatly);
    }

    _onLoaded(callback, context, showLoadingOverlay, unloadImmediatly) {
        if (unloadImmediatly) {
            this.unloadAssets(this.assetsToUnload);
        }

        if (showLoadingOverlay) {
            this.app.fire('UIManager:hideUI', 'loading');
        }

        this.app.fire('WorldManager:setWorld', WorldManager.instance.getWorldIndex());

        if (callback) {
            callback.call(context);
        }
    }

    loadWorldLevels(worldID = WorldManager.instance.getWorldIndex()) {
        return;
        var assets = this.getAssetsByTag([`world_${worldID}`, 'level']);

        this.loadAssetsInSeries(assets);
    }

    loadAssetsInParallel(assets, callback, context, showLoadingOverlay) {
        LazyLoader.instance.lazyLoadParallel(assets, this._onLoaded.bind(this, callback, context, showLoadingOverlay), this);
    }

    loadAssetsInSeries(assets) {
        LazyLoader.instance.lazyLoadSeries(assets);
    }

    // --------------- UNLOADING ----------------------------
    unloadAssets(assets) {
        assets.forEach(asset => {
            try {
                asset.unload();
            } catch (e) {

            }
        });

        assets.length = 0;
    }

    unloadPreviousAssets() {
        this.unloadAssets(this.assetsToUnload);
    }

    // --------------- GET ASSETS ----------------------------
    getAssetsByTag(tag) {
        if (!tag) {
            return [];
        }
        return this.app.assets.findByTag(tag);
    }

    getWorldAssets(worldID) {
        var assets = this.app.assets.findByTag(AssetManager.WORLDS.WORLD + worldID);

        for (var id = 1; id <= worldID; id++) {
            assets = [...assets, ...this.app.assets.findByTag(`${AssetManager.WORLDS.WORLD}${id}+`)];
        }

        if (!WorldManager.instance.isEndOfPage(LevelManager.instance.getCurrentLevelNumber())) {
            const parts = WorldManager.instance.getPartAssets(worldID);

            const completedModel = parts.completedModel;
            const partModel = parts.partModel;
            const array = [completedModel, partModel, ...parts.textures, ...this.ignoreWorldAsset];

            for (let i = 0; i < array.length; i++) {
                const asset = array[i];

                const index = assets.indexOf(asset);

                if (index === -1) {
                    console.log("nothing found", asset);
                    continue;
                }

                assets.splice(index, 1);
            }

        }

        if (this.ftue === true) {
            this.ftue = false;

            assets = assets.filter(asset => !asset.tags.has('ignore_in_ftue'));
        }

        return assets;
    }

    getBookAssets(worldID) {
        var assets = this.app.assets.findByTag(AssetManager.WORLDS.BOOK + worldID);

        for (var id = 1; id <= worldID; id++) {
            assets = [...assets, ...this.app.assets.findByTag(`${AssetManager.WORLDS.BOOK}${id}+`)];
        }
        return assets;
    }

    addExtraAssets(array) {
        pc.utils.fuseUniqueArray(this.extraAssets, array);
    }
}

pc.registerScript(AssetManager);

AssetManager.addAttributes()

AssetManager.WORLDS = {
    WORLD: 'world',
    GARDEN: 'Garden',
    BOOK: 'book',
    INTRO: 'intro',
    MENU: 'menu',
};

// spine.js
var Spine = pc.createScript("spine");

Spine.attributes.add("atlas", { type: "asset", assetType: "text" });
Spine.attributes.add("skeleton", { type: "asset", assetType: "json" });
Spine.attributes.add("textures", { type: "asset", array: true, assetType: "texture" });
Spine.attributes.add("priority", { type: "number", default: 1 });
Spine.attributes.add("layerName", { type: "string", default: "GUI3D" });


Spine.prototype.initialize = function () {
    if (this.atlas && this.textures && this.skeleton) {
        // If all assets are present, add the spine component to the entity
        this.entity.addComponent("spine", {
            atlasAsset: this.atlas.id,
            textureAssets: this.textures.map(function (a) {
                return a.id;
            }),
            skeletonAsset: this.skeleton.id
        });

        if (this.entity.spine && this.entity.spine.spine) {
            this.entity.layers = [this.app.scene.layers.getLayerByName(this.layerName).id];
            this.priority = this.priority ? this.priority : 0;
            this.entity.spine.spine.priority = this.priority;
            this.entity.spine.spine.removeFromLayers();
            this.entity.spine.spine._layers = [this.app.scene.layers.getLayerByName("GUI3D").id];
            this.entity.spine.spine.addToLayers();
        }
    }

    this.on('attr:priority', this.onPriotityChange, this);
};

Spine.prototype.onPriotityChange = function (val) {
    if (this.entity.spine) {
        this.entity.spine.spine.priority = val;
    }
};


// FacebookLoginButton.js
class FacebookLoginButton extends pc.ScriptType {

    initialize() {
        this.entity.script.elementInput.on('click', this.login, this);
    }

    login() {
        var promise = Firebase.instance.facebookLogin();

        if (!promise) {
            return;
        }

        promise.then(a => {
            this.app.fire('UIManager:hideUI', 'Login');
            console.log(a)
        }).catch(error => {
            console.log(error, error.code)

            if (error && error.code === 'auth/popup-blocked') {
                this.loginWithRedirect();
            }
        });
    }


    loginWithRedirect() {
        const promise = Firebase.instance.facebookLoginRedirect();

        if (!promise) {
            return;
        }

        promise.then(a => {
            this.app.fire('UIManager:hideUI', 'Login');
        }).catch(error => {
            console.log(error, error.code)
            if (error && error.code === 'auth/popup-blocked') {
            }
        });
    }
}


pc.registerScript(FacebookLoginButton);


// Chest.js
class Chest extends pc.ScriptType {
    static addAttributes() {
    }

    initialize() {
        this.animationController = this.entity.script.tileAnimationController;
        this.animationController.on('onExplode', this._onExplode, this);
        this.animationController.on('complete', this._onDestroyAnimation, this);
        this.animationController.on('increasContent', this._increaseContent, this);
    }

    init(superClass) {
        this.superClass = superClass;

        this.superClass.typeID = backgroundTileEnum.CHEST;
    }

    awake() {
        this.setLayers(this.superClass.currentLayer);
    }

    postAwake() {
        var tile = GridManager.instance.getTile(this.superClass.x, this.superClass.y);

        if (tile) {
            tile._setTileSize(Chest.CONTENT_SCALE);
            tile.putTileInChest(true);
        }
    }

    recycle() {
        this.entity.objectPool.recycle(this.entity);
    }

    setLayers(nLayer) {
        this.animationController.playAnimation(`chest_idle_${nLayer}.glb`);
    }

    explode(delay) {
        this.superClass.currentLayer--;

        this.superClass.hasExploded = true;

        var destroyed = this.superClass.currentLayer === 0;

        var animation = this.animationController.playAnimation(`chest_open_${this.superClass.currentLayer + 1}.glb`, this.animationController.playing ? 0 : delay, "onExplode", destroyed ? "complete" : null);

        if (destroyed) {
            animation.addCustomEvent("increasContent", 0.5);
            this.superClass.stopAllTweens();
            this.superClass.isDestroyed = true;
            StatisticsManager.instance.incrementStatistic('obstacle_destroyed', {
                obstacle_type: TileLibrary.instance.getObstacleName(this.superClass.typeID),
            });
        }

        return destroyed;
    }

    _onExplode() {
        if (this.superClass.currentLayer <= 0) {
            var tile = GridManager.instance.getTile(this.superClass.x, this.superClass.y);

            if (tile) {
                tile.isMovedTile = true;
            } else {
                console.warn("no tile found at", this.superClass.x, this.superClass.y);
            }
        }

        GridManager.instance.playSFX("chest_layer_broken_new.mp3");
    }

    _onDestroyAnimation() {
        GridManager.instance.removeChest(this.superClass);
        this.recycle();
    }

    getDespawnDelay() {
        var delay = this.animationController.getAnimationDuration();

        return delay;
    }

    _increaseContent() {
        var tile = GridManager.instance.getTile(this.superClass.x, this.superClass.y);

        if (!tile) {
            console.warn("has no content");
            return;
        }

        tile.putTileInChest(false)
        tile.tweenSize(1, 0.5);
    }
}

pc.registerScript(Chest);
Chest.addAttributes();
Chest.CONTENT_SCALE = 0.85;

// DataConflictScreen.js
class DataConflictScreen extends pc.ScriptType {
    static addAttributes() {
        this.attributes.add('localStorageButton', { type: 'entity' });
        this.attributes.add('firebaseButton', { type: 'entity' });
        this.attributes.add('saveButton', { type: 'entity' });
        this.attributes.add('closeButton', { type: 'entity' });

        this.attributes.add('localStorageLevel', { type: 'entity' });
        this.attributes.add('localStorageDate', { type: 'entity' });
        this.attributes.add('localStorageCoins', { type: 'entity' });
        this.attributes.add('localStorageStars', { type: 'entity' });
        this.attributes.add('localStorageCheckMark', { type: 'entity' });

        this.attributes.add('firebaseLevel', { type: 'entity' });
        this.attributes.add('firebaseDate', { type: 'entity' });
        this.attributes.add('firebaseCoins', { type: 'entity' });
        this.attributes.add('firebaseStars', { type: 'entity' });
        this.attributes.add('firebaseCheckMark', { type: 'entity' });

        this.attributes.add('tweenAlpha', { type: 'number', default: 0.7 });
    }

    initialize() {
        this.selected = null;

        this.localStorageButton.script.elementInput.on('click', this.onClick.bind(this, DataConflictScreen.DATA_TYPES.LOCAL_STORAGE), this);
        this.firebaseButton.script.elementInput.on('click', this.onClick.bind(this, DataConflictScreen.DATA_TYPES.FIREBASE), this);
        this.closeButton.script.elementInput.on('click', this.onCloseClick, this);

        this.saveButton.script.elementInput.on('click', this.onSaveClick, this);
    }

    onClick(data) {
        if (this.selected === data) {
            this.selected = null;
        } else {
            this.selected = data;
        }

        this.setButtonStates();
    }

    onSaveClick() {
        if (!this.ready) {
            console.log("wait");
            return;
        }

        switch(this.selected) {
            case 'localStorage':
                this.app.once('Firebase:saved', () => {
                    this.app.fire('Firebase:dataConflictDone', false);
                    this.app.fire('UIManager:hideUI', "DataConflict");
                });

                StorageManager.instance._saveToFirebase();
                break;
            case 'firebase':
                this.app.fire('Firebase:dataConflictDone', true);
                StorageManager.instance._saveToLocalStorage();
                this.app.fire('UIManager:hideUI', "DataConflict");
                break;
            default:
                console.warn(this.selected, "is not recognized");
        }
    }

    onCloseClick() {
        Firebase.instance.logout().then(() => {
            this.app.fire("UIManager:hideUI", "DataConflict", true); 
        });

        this.app.fire('Firebase:dataConflictDone', true);
    }

    setButtonStates() {
        var noneSelected = this.selected === null;
        var localStorageSelected = this.selected === DataConflictScreen.DATA_TYPES.LOCAL_STORAGE;
        var firebaseSelected = this.selected === DataConflictScreen.DATA_TYPES.FIREBASE;

        this.localStorageButton.script.tweenAlpha.startTween(
            this.localStorageButton.script.tweenAlpha.getCurrentOpacity(),
            localStorageSelected || noneSelected ? 1 : this.tweenAlpha
        );

        this.firebaseButton.script.tweenAlpha.startTween(
            this.firebaseButton.script.tweenAlpha.getCurrentOpacity(),
            firebaseSelected || noneSelected ? 1 : this.tweenAlpha
        );

        this.localStorageCheckMark.enabled = localStorageSelected;
        this.firebaseCheckMark.enabled = firebaseSelected;

        this.saveButton.enabled = !!this.selected;
    }

    onUIEntityOpen(args) {
        this.selected = null;
        this.setButtonStates();

        var localStorage = args.localStorage;
        var firebase = args.firebase;

        this.localStorageLevel.element.text = this.app.i18n.getText('LEVEL').replace('{0}', localStorage.levelData.currentLevel - 1);
        this.localStorageDate.element.text = this.getDateText(localStorage.timeSaved);
        this.localStorageCoins.element.text = localStorage.inventory.COINS;
        this.localStorageStars.element.text = this.getTotalStars(localStorage.levelData);

        this.firebaseLevel.element.text = this.app.i18n.getText('LEVEL').replace('{0}', firebase.levelData.currentLevel - 1);
        this.firebaseDate.element.text = this.getDateText(firebase.timeSaved);
        this.firebaseCoins.element.text = firebase.inventory.COINS;
        this.firebaseStars.element.text = this.getTotalStars(firebase.levelData);
        
        this.ready = false;
        firebaseClass.getXsollaAccessToken().then((result) => {
            console.log("result")
            Xsolla.instance.accessToken = result.data.token;
            Xsolla.instance.getItems().finally(() => {
                console.log("getItems")
                this.ready = true;
            });
        });
    }

    getTotalStars(levelData) {
        var totalStars = 0;

        var worldList = WorldManager.instance.getWorldList();

        for (var i = 1; i <= 10; i++) {
            var levels = levelData[i];
            if (levels) {
                var worldData = worldList[i];
                for (var j = worldData.minLevel; j <= worldData.maxLevel; j++) {
                    var level = levels[j];
                    if (level && typeof level.stars === 'number') {
                        totalStars += level.stars;
                    }
                }
            }
        }

        return totalStars;
    }

    getDateText(milliseconds = 0) {
        var date = new Date(milliseconds);

        return this.app.i18n.getText('DATA_CONFLICT_DATE').format(date.getDate(), date.getMonth() + 1, date.getFullYear());
    }
}

pc.registerScript(DataConflictScreen);
DataConflictScreen.addAttributes();

DataConflictScreen.DATA_TYPES = Object.freeze({
    LOCAL_STORAGE: 'localStorage',
    FIREBASE: 'firebase',
});

// String.js
pc.extend(String.prototype, {
    format: function() {
        var s = this,
            i = arguments.length;

        while (i--) {
            s = s.replace(new RegExp('\\{' + i + '\\}', 'gm'), arguments[i]);
        }
        return s;
    },
});

// playcanvas-spine.3.8.js
/* Copyright 2015-2021 PlayCanvas Ltd */
var __extends = (this && this.__extends) || (function () {
	var extendStatics = function (d, b) {
		extendStatics = Object.setPrototypeOf ||
			({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
			function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
		return extendStatics(d, b);
	};
	return function (d, b) {
		extendStatics(d, b);
		function __() { this.constructor = d; }
		d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
})();
var spine;
(function (spine) {
	var Animation = (function () {
		function Animation(name, timelines, duration) {
			if (name == null)
				throw new Error("name cannot be null.");
			if (timelines == null)
				throw new Error("timelines cannot be null.");
			this.name = name;
			this.timelines = timelines;
			this.timelineIds = [];
			for (var i = 0; i < timelines.length; i++)
				this.timelineIds[timelines[i].getPropertyId()] = true;
			this.duration = duration;
		}
		Animation.prototype.hasTimeline = function (id) {
			return this.timelineIds[id] == true;
		};
		Animation.prototype.apply = function (skeleton, lastTime, time, loop, events, alpha, blend, direction) {
			if (skeleton == null)
				throw new Error("skeleton cannot be null.");
			if (loop && this.duration != 0) {
				time %= this.duration;
				if (lastTime > 0)
					lastTime %= this.duration;
			}
			var timelines = this.timelines;
			for (var i = 0, n = timelines.length; i < n; i++)
				timelines[i].apply(skeleton, lastTime, time, events, alpha, blend, direction);
		};
		Animation.binarySearch = function (values, target, step) {
			if (step === void 0) { step = 1; }
			var low = 0;
			var high = values.length / step - 2;
			if (high == 0)
				return step;
			var current = high >>> 1;
			while (true) {
				if (values[(current + 1) * step] <= target)
					low = current + 1;
				else
					high = current;
				if (low == high)
					return (low + 1) * step;
				current = (low + high) >>> 1;
			}
		};
		Animation.linearSearch = function (values, target, step) {
			for (var i = 0, last = values.length - step; i <= last; i += step)
				if (values[i] > target)
					return i;
			return -1;
		};
		return Animation;
	}());
	spine.Animation = Animation;
	var MixBlend;
	(function (MixBlend) {
		MixBlend[MixBlend["setup"] = 0] = "setup";
		MixBlend[MixBlend["first"] = 1] = "first";
		MixBlend[MixBlend["replace"] = 2] = "replace";
		MixBlend[MixBlend["add"] = 3] = "add";
	})(MixBlend = spine.MixBlend || (spine.MixBlend = {}));
	var MixDirection;
	(function (MixDirection) {
		MixDirection[MixDirection["mixIn"] = 0] = "mixIn";
		MixDirection[MixDirection["mixOut"] = 1] = "mixOut";
	})(MixDirection = spine.MixDirection || (spine.MixDirection = {}));
	var TimelineType;
	(function (TimelineType) {
		TimelineType[TimelineType["rotate"] = 0] = "rotate";
		TimelineType[TimelineType["translate"] = 1] = "translate";
		TimelineType[TimelineType["scale"] = 2] = "scale";
		TimelineType[TimelineType["shear"] = 3] = "shear";
		TimelineType[TimelineType["attachment"] = 4] = "attachment";
		TimelineType[TimelineType["color"] = 5] = "color";
		TimelineType[TimelineType["deform"] = 6] = "deform";
		TimelineType[TimelineType["event"] = 7] = "event";
		TimelineType[TimelineType["drawOrder"] = 8] = "drawOrder";
		TimelineType[TimelineType["ikConstraint"] = 9] = "ikConstraint";
		TimelineType[TimelineType["transformConstraint"] = 10] = "transformConstraint";
		TimelineType[TimelineType["pathConstraintPosition"] = 11] = "pathConstraintPosition";
		TimelineType[TimelineType["pathConstraintSpacing"] = 12] = "pathConstraintSpacing";
		TimelineType[TimelineType["pathConstraintMix"] = 13] = "pathConstraintMix";
		TimelineType[TimelineType["twoColor"] = 14] = "twoColor";
	})(TimelineType = spine.TimelineType || (spine.TimelineType = {}));
	var CurveTimeline = (function () {
		function CurveTimeline(frameCount) {
			if (frameCount <= 0)
				throw new Error("frameCount must be > 0: " + frameCount);
			this.curves = spine.Utils.newFloatArray((frameCount - 1) * CurveTimeline.BEZIER_SIZE);
		}
		CurveTimeline.prototype.getFrameCount = function () {
			return this.curves.length / CurveTimeline.BEZIER_SIZE + 1;
		};
		CurveTimeline.prototype.setLinear = function (frameIndex) {
			this.curves[frameIndex * CurveTimeline.BEZIER_SIZE] = CurveTimeline.LINEAR;
		};
		CurveTimeline.prototype.setStepped = function (frameIndex) {
			this.curves[frameIndex * CurveTimeline.BEZIER_SIZE] = CurveTimeline.STEPPED;
		};
		CurveTimeline.prototype.getCurveType = function (frameIndex) {
			var index = frameIndex * CurveTimeline.BEZIER_SIZE;
			if (index == this.curves.length)
				return CurveTimeline.LINEAR;
			var type = this.curves[index];
			if (type == CurveTimeline.LINEAR)
				return CurveTimeline.LINEAR;
			if (type == CurveTimeline.STEPPED)
				return CurveTimeline.STEPPED;
			return CurveTimeline.BEZIER;
		};
		CurveTimeline.prototype.setCurve = function (frameIndex, cx1, cy1, cx2, cy2) {
			var tmpx = (-cx1 * 2 + cx2) * 0.03, tmpy = (-cy1 * 2 + cy2) * 0.03;
			var dddfx = ((cx1 - cx2) * 3 + 1) * 0.006, dddfy = ((cy1 - cy2) * 3 + 1) * 0.006;
			var ddfx = tmpx * 2 + dddfx, ddfy = tmpy * 2 + dddfy;
			var dfx = cx1 * 0.3 + tmpx + dddfx * 0.16666667, dfy = cy1 * 0.3 + tmpy + dddfy * 0.16666667;
			var i = frameIndex * CurveTimeline.BEZIER_SIZE;
			var curves = this.curves;
			curves[i++] = CurveTimeline.BEZIER;
			var x = dfx, y = dfy;
			for (var n = i + CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {
				curves[i] = x;
				curves[i + 1] = y;
				dfx += ddfx;
				dfy += ddfy;
				ddfx += dddfx;
				ddfy += dddfy;
				x += dfx;
				y += dfy;
			}
		};
		CurveTimeline.prototype.getCurvePercent = function (frameIndex, percent) {
			percent = spine.MathUtils.clamp(percent, 0, 1);
			var curves = this.curves;
			var i = frameIndex * CurveTimeline.BEZIER_SIZE;
			var type = curves[i];
			if (type == CurveTimeline.LINEAR)
				return percent;
			if (type == CurveTimeline.STEPPED)
				return 0;
			i++;
			var x = 0;
			for (var start = i, n = i + CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {
				x = curves[i];
				if (x >= percent) {
					var prevX = void 0, prevY = void 0;
					if (i == start) {
						prevX = 0;
						prevY = 0;
					}
					else {
						prevX = curves[i - 2];
						prevY = curves[i - 1];
					}
					return prevY + (curves[i + 1] - prevY) * (percent - prevX) / (x - prevX);
				}
			}
			var y = curves[i - 1];
			return y + (1 - y) * (percent - x) / (1 - x);
		};
		CurveTimeline.LINEAR = 0;
		CurveTimeline.STEPPED = 1;
		CurveTimeline.BEZIER = 2;
		CurveTimeline.BEZIER_SIZE = 10 * 2 - 1;
		return CurveTimeline;
	}());
	spine.CurveTimeline = CurveTimeline;
	var RotateTimeline = (function (_super) {
		__extends(RotateTimeline, _super);
		function RotateTimeline(frameCount) {
			var _this = _super.call(this, frameCount) || this;
			_this.frames = spine.Utils.newFloatArray(frameCount << 1);
			return _this;
		}
		RotateTimeline.prototype.getPropertyId = function () {
			return (TimelineType.rotate << 24) + this.boneIndex;
		};
		RotateTimeline.prototype.setFrame = function (frameIndex, time, degrees) {
			frameIndex <<= 1;
			this.frames[frameIndex] = time;
			this.frames[frameIndex + RotateTimeline.ROTATION] = degrees;
		};
		RotateTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, blend, direction) {
			var frames = this.frames;
			var bone = skeleton.bones[this.boneIndex];
			if (!bone.active)
				return;
			if (time < frames[0]) {
				switch (blend) {
					case MixBlend.setup:
						bone.rotation = bone.data.rotation;
						return;
					case MixBlend.first:
						var r_1 = bone.data.rotation - bone.rotation;
						bone.rotation += (r_1 - (16384 - ((16384.499999999996 - r_1 / 360) | 0)) * 360) * alpha;
				}
				return;
			}
			if (time >= frames[frames.length - RotateTimeline.ENTRIES]) {
				var r_2 = frames[frames.length + RotateTimeline.PREV_ROTATION];
				switch (blend) {
					case MixBlend.setup:
						bone.rotation = bone.data.rotation + r_2 * alpha;
						break;
					case MixBlend.first:
					case MixBlend.replace:
						r_2 += bone.data.rotation - bone.rotation;
						r_2 -= (16384 - ((16384.499999999996 - r_2 / 360) | 0)) * 360;
					case MixBlend.add:
						bone.rotation += r_2 * alpha;
				}
				return;
			}
			var frame = Animation.binarySearch(frames, time, RotateTimeline.ENTRIES);
			var prevRotation = frames[frame + RotateTimeline.PREV_ROTATION];
			var frameTime = frames[frame];
			var percent = this.getCurvePercent((frame >> 1) - 1, 1 - (time - frameTime) / (frames[frame + RotateTimeline.PREV_TIME] - frameTime));
			var r = frames[frame + RotateTimeline.ROTATION] - prevRotation;
			r = prevRotation + (r - (16384 - ((16384.499999999996 - r / 360) | 0)) * 360) * percent;
			switch (blend) {
				case MixBlend.setup:
					bone.rotation = bone.data.rotation + (r - (16384 - ((16384.499999999996 - r / 360) | 0)) * 360) * alpha;
					break;
				case MixBlend.first:
				case MixBlend.replace:
					r += bone.data.rotation - bone.rotation;
				case MixBlend.add:
					bone.rotation += (r - (16384 - ((16384.499999999996 - r / 360) | 0)) * 360) * alpha;
			}
		};
		RotateTimeline.ENTRIES = 2;
		RotateTimeline.PREV_TIME = -2;
		RotateTimeline.PREV_ROTATION = -1;
		RotateTimeline.ROTATION = 1;
		return RotateTimeline;
	}(CurveTimeline));
	spine.RotateTimeline = RotateTimeline;
	var TranslateTimeline = (function (_super) {
		__extends(TranslateTimeline, _super);
		function TranslateTimeline(frameCount) {
			var _this = _super.call(this, frameCount) || this;
			_this.frames = spine.Utils.newFloatArray(frameCount * TranslateTimeline.ENTRIES);
			return _this;
		}
		TranslateTimeline.prototype.getPropertyId = function () {
			return (TimelineType.translate << 24) + this.boneIndex;
		};
		TranslateTimeline.prototype.setFrame = function (frameIndex, time, x, y) {
			frameIndex *= TranslateTimeline.ENTRIES;
			this.frames[frameIndex] = time;
			this.frames[frameIndex + TranslateTimeline.X] = x;
			this.frames[frameIndex + TranslateTimeline.Y] = y;
		};
		TranslateTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, blend, direction) {
			var frames = this.frames;
			var bone = skeleton.bones[this.boneIndex];
			if (!bone.active)
				return;
			if (time < frames[0]) {
				switch (blend) {
					case MixBlend.setup:
						bone.x = bone.data.x;
						bone.y = bone.data.y;
						return;
					case MixBlend.first:
						bone.x += (bone.data.x - bone.x) * alpha;
						bone.y += (bone.data.y - bone.y) * alpha;
				}
				return;
			}
			var x = 0, y = 0;
			if (time >= frames[frames.length - TranslateTimeline.ENTRIES]) {
				x = frames[frames.length + TranslateTimeline.PREV_X];
				y = frames[frames.length + TranslateTimeline.PREV_Y];
			}
			else {
				var frame = Animation.binarySearch(frames, time, TranslateTimeline.ENTRIES);
				x = frames[frame + TranslateTimeline.PREV_X];
				y = frames[frame + TranslateTimeline.PREV_Y];
				var frameTime = frames[frame];
				var percent = this.getCurvePercent(frame / TranslateTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + TranslateTimeline.PREV_TIME] - frameTime));
				x += (frames[frame + TranslateTimeline.X] - x) * percent;
				y += (frames[frame + TranslateTimeline.Y] - y) * percent;
			}
			switch (blend) {
				case MixBlend.setup:
					bone.x = bone.data.x + x * alpha;
					bone.y = bone.data.y + y * alpha;
					break;
				case MixBlend.first:
				case MixBlend.replace:
					bone.x += (bone.data.x + x - bone.x) * alpha;
					bone.y += (bone.data.y + y - bone.y) * alpha;
					break;
				case MixBlend.add:
					bone.x += x * alpha;
					bone.y += y * alpha;
			}
		};
		TranslateTimeline.ENTRIES = 3;
		TranslateTimeline.PREV_TIME = -3;
		TranslateTimeline.PREV_X = -2;
		TranslateTimeline.PREV_Y = -1;
		TranslateTimeline.X = 1;
		TranslateTimeline.Y = 2;
		return TranslateTimeline;
	}(CurveTimeline));
	spine.TranslateTimeline = TranslateTimeline;
	var ScaleTimeline = (function (_super) {
		__extends(ScaleTimeline, _super);
		function ScaleTimeline(frameCount) {
			return _super.call(this, frameCount) || this;
		}
		ScaleTimeline.prototype.getPropertyId = function () {
			return (TimelineType.scale << 24) + this.boneIndex;
		};
		ScaleTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, blend, direction) {
			var frames = this.frames;
			var bone = skeleton.bones[this.boneIndex];
			if (!bone.active)
				return;
			if (time < frames[0]) {
				switch (blend) {
					case MixBlend.setup:
						bone.scaleX = bone.data.scaleX;
						bone.scaleY = bone.data.scaleY;
						return;
					case MixBlend.first:
						bone.scaleX += (bone.data.scaleX - bone.scaleX) * alpha;
						bone.scaleY += (bone.data.scaleY - bone.scaleY) * alpha;
				}
				return;
			}
			var x = 0, y = 0;
			if (time >= frames[frames.length - ScaleTimeline.ENTRIES]) {
				x = frames[frames.length + ScaleTimeline.PREV_X] * bone.data.scaleX;
				y = frames[frames.length + ScaleTimeline.PREV_Y] * bone.data.scaleY;
			}
			else {
				var frame = Animation.binarySearch(frames, time, ScaleTimeline.ENTRIES);
				x = frames[frame + ScaleTimeline.PREV_X];
				y = frames[frame + ScaleTimeline.PREV_Y];
				var frameTime = frames[frame];
				var percent = this.getCurvePercent(frame / ScaleTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ScaleTimeline.PREV_TIME] - frameTime));
				x = (x + (frames[frame + ScaleTimeline.X] - x) * percent) * bone.data.scaleX;
				y = (y + (frames[frame + ScaleTimeline.Y] - y) * percent) * bone.data.scaleY;
			}
			if (alpha == 1) {
				if (blend == MixBlend.add) {
					bone.scaleX += x - bone.data.scaleX;
					bone.scaleY += y - bone.data.scaleY;
				}
				else {
					bone.scaleX = x;
					bone.scaleY = y;
				}
			}
			else {
				var bx = 0, by = 0;
				if (direction == MixDirection.mixOut) {
					switch (blend) {
						case MixBlend.setup:
							bx = bone.data.scaleX;
							by = bone.data.scaleY;
							bone.scaleX = bx + (Math.abs(x) * spine.MathUtils.signum(bx) - bx) * alpha;
							bone.scaleY = by + (Math.abs(y) * spine.MathUtils.signum(by) - by) * alpha;
							break;
						case MixBlend.first:
						case MixBlend.replace:
							bx = bone.scaleX;
							by = bone.scaleY;
							bone.scaleX = bx + (Math.abs(x) * spine.MathUtils.signum(bx) - bx) * alpha;
							bone.scaleY = by + (Math.abs(y) * spine.MathUtils.signum(by) - by) * alpha;
							break;
						case MixBlend.add:
							bx = bone.scaleX;
							by = bone.scaleY;
							bone.scaleX = bx + (Math.abs(x) * spine.MathUtils.signum(bx) - bone.data.scaleX) * alpha;
							bone.scaleY = by + (Math.abs(y) * spine.MathUtils.signum(by) - bone.data.scaleY) * alpha;
					}
				}
				else {
					switch (blend) {
						case MixBlend.setup:
							bx = Math.abs(bone.data.scaleX) * spine.MathUtils.signum(x);
							by = Math.abs(bone.data.scaleY) * spine.MathUtils.signum(y);
							bone.scaleX = bx + (x - bx) * alpha;
							bone.scaleY = by + (y - by) * alpha;
							break;
						case MixBlend.first:
						case MixBlend.replace:
							bx = Math.abs(bone.scaleX) * spine.MathUtils.signum(x);
							by = Math.abs(bone.scaleY) * spine.MathUtils.signum(y);
							bone.scaleX = bx + (x - bx) * alpha;
							bone.scaleY = by + (y - by) * alpha;
							break;
						case MixBlend.add:
							bx = spine.MathUtils.signum(x);
							by = spine.MathUtils.signum(y);
							bone.scaleX = Math.abs(bone.scaleX) * bx + (x - Math.abs(bone.data.scaleX) * bx) * alpha;
							bone.scaleY = Math.abs(bone.scaleY) * by + (y - Math.abs(bone.data.scaleY) * by) * alpha;
					}
				}
			}
		};
		return ScaleTimeline;
	}(TranslateTimeline));
	spine.ScaleTimeline = ScaleTimeline;
	var ShearTimeline = (function (_super) {
		__extends(ShearTimeline, _super);
		function ShearTimeline(frameCount) {
			return _super.call(this, frameCount) || this;
		}
		ShearTimeline.prototype.getPropertyId = function () {
			return (TimelineType.shear << 24) + this.boneIndex;
		};
		ShearTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, blend, direction) {
			var frames = this.frames;
			var bone = skeleton.bones[this.boneIndex];
			if (!bone.active)
				return;
			if (time < frames[0]) {
				switch (blend) {
					case MixBlend.setup:
						bone.shearX = bone.data.shearX;
						bone.shearY = bone.data.shearY;
						return;
					case MixBlend.first:
						bone.shearX += (bone.data.shearX - bone.shearX) * alpha;
						bone.shearY += (bone.data.shearY - bone.shearY) * alpha;
				}
				return;
			}
			var x = 0, y = 0;
			if (time >= frames[frames.length - ShearTimeline.ENTRIES]) {
				x = frames[frames.length + ShearTimeline.PREV_X];
				y = frames[frames.length + ShearTimeline.PREV_Y];
			}
			else {
				var frame = Animation.binarySearch(frames, time, ShearTimeline.ENTRIES);
				x = frames[frame + ShearTimeline.PREV_X];
				y = frames[frame + ShearTimeline.PREV_Y];
				var frameTime = frames[frame];
				var percent = this.getCurvePercent(frame / ShearTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ShearTimeline.PREV_TIME] - frameTime));
				x = x + (frames[frame + ShearTimeline.X] - x) * percent;
				y = y + (frames[frame + ShearTimeline.Y] - y) * percent;
			}
			switch (blend) {
				case MixBlend.setup:
					bone.shearX = bone.data.shearX + x * alpha;
					bone.shearY = bone.data.shearY + y * alpha;
					break;
				case MixBlend.first:
				case MixBlend.replace:
					bone.shearX += (bone.data.shearX + x - bone.shearX) * alpha;
					bone.shearY += (bone.data.shearY + y - bone.shearY) * alpha;
					break;
				case MixBlend.add:
					bone.shearX += x * alpha;
					bone.shearY += y * alpha;
			}
		};
		return ShearTimeline;
	}(TranslateTimeline));
	spine.ShearTimeline = ShearTimeline;
	var ColorTimeline = (function (_super) {
		__extends(ColorTimeline, _super);
		function ColorTimeline(frameCount) {
			var _this = _super.call(this, frameCount) || this;
			_this.frames = spine.Utils.newFloatArray(frameCount * ColorTimeline.ENTRIES);
			return _this;
		}
		ColorTimeline.prototype.getPropertyId = function () {
			return (TimelineType.color << 24) + this.slotIndex;
		};
		ColorTimeline.prototype.setFrame = function (frameIndex, time, r, g, b, a) {
			frameIndex *= ColorTimeline.ENTRIES;
			this.frames[frameIndex] = time;
			this.frames[frameIndex + ColorTimeline.R] = r;
			this.frames[frameIndex + ColorTimeline.G] = g;
			this.frames[frameIndex + ColorTimeline.B] = b;
			this.frames[frameIndex + ColorTimeline.A] = a;
		};
		ColorTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, blend, direction) {
			var slot = skeleton.slots[this.slotIndex];
			if (!slot.bone.active)
				return;
			var frames = this.frames;
			if (time < frames[0]) {
				switch (blend) {
					case MixBlend.setup:
						slot.color.setFromColor(slot.data.color);
						return;
					case MixBlend.first:
						var color = slot.color, setup = slot.data.color;
						color.add((setup.r - color.r) * alpha, (setup.g - color.g) * alpha, (setup.b - color.b) * alpha, (setup.a - color.a) * alpha);
				}
				return;
			}
			var r = 0, g = 0, b = 0, a = 0;
			if (time >= frames[frames.length - ColorTimeline.ENTRIES]) {
				var i = frames.length;
				r = frames[i + ColorTimeline.PREV_R];
				g = frames[i + ColorTimeline.PREV_G];
				b = frames[i + ColorTimeline.PREV_B];
				a = frames[i + ColorTimeline.PREV_A];
			}
			else {
				var frame = Animation.binarySearch(frames, time, ColorTimeline.ENTRIES);
				r = frames[frame + ColorTimeline.PREV_R];
				g = frames[frame + ColorTimeline.PREV_G];
				b = frames[frame + ColorTimeline.PREV_B];
				a = frames[frame + ColorTimeline.PREV_A];
				var frameTime = frames[frame];
				var percent = this.getCurvePercent(frame / ColorTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ColorTimeline.PREV_TIME] - frameTime));
				r += (frames[frame + ColorTimeline.R] - r) * percent;
				g += (frames[frame + ColorTimeline.G] - g) * percent;
				b += (frames[frame + ColorTimeline.B] - b) * percent;
				a += (frames[frame + ColorTimeline.A] - a) * percent;
			}
			if (alpha == 1)
				slot.color.set(r, g, b, a);
			else {
				var color = slot.color;
				if (blend == MixBlend.setup)
					color.setFromColor(slot.data.color);
				color.add((r - color.r) * alpha, (g - color.g) * alpha, (b - color.b) * alpha, (a - color.a) * alpha);
			}
		};
		ColorTimeline.ENTRIES = 5;
		ColorTimeline.PREV_TIME = -5;
		ColorTimeline.PREV_R = -4;
		ColorTimeline.PREV_G = -3;
		ColorTimeline.PREV_B = -2;
		ColorTimeline.PREV_A = -1;
		ColorTimeline.R = 1;
		ColorTimeline.G = 2;
		ColorTimeline.B = 3;
		ColorTimeline.A = 4;
		return ColorTimeline;
	}(CurveTimeline));
	spine.ColorTimeline = ColorTimeline;
	var TwoColorTimeline = (function (_super) {
		__extends(TwoColorTimeline, _super);
		function TwoColorTimeline(frameCount) {
			var _this = _super.call(this, frameCount) || this;
			_this.frames = spine.Utils.newFloatArray(frameCount * TwoColorTimeline.ENTRIES);
			return _this;
		}
		TwoColorTimeline.prototype.getPropertyId = function () {
			return (TimelineType.twoColor << 24) + this.slotIndex;
		};
		TwoColorTimeline.prototype.setFrame = function (frameIndex, time, r, g, b, a, r2, g2, b2) {
			frameIndex *= TwoColorTimeline.ENTRIES;
			this.frames[frameIndex] = time;
			this.frames[frameIndex + TwoColorTimeline.R] = r;
			this.frames[frameIndex + TwoColorTimeline.G] = g;
			this.frames[frameIndex + TwoColorTimeline.B] = b;
			this.frames[frameIndex + TwoColorTimeline.A] = a;
			this.frames[frameIndex + TwoColorTimeline.R2] = r2;
			this.frames[frameIndex + TwoColorTimeline.G2] = g2;
			this.frames[frameIndex + TwoColorTimeline.B2] = b2;
		};
		TwoColorTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, blend, direction) {
			var slot = skeleton.slots[this.slotIndex];
			if (!slot.bone.active)
				return;
			var frames = this.frames;
			if (time < frames[0]) {
				switch (blend) {
					case MixBlend.setup:
						slot.color.setFromColor(slot.data.color);
						slot.darkColor.setFromColor(slot.data.darkColor);
						return;
					case MixBlend.first:
						var light = slot.color, dark = slot.darkColor, setupLight = slot.data.color, setupDark = slot.data.darkColor;
						light.add((setupLight.r - light.r) * alpha, (setupLight.g - light.g) * alpha, (setupLight.b - light.b) * alpha, (setupLight.a - light.a) * alpha);
						dark.add((setupDark.r - dark.r) * alpha, (setupDark.g - dark.g) * alpha, (setupDark.b - dark.b) * alpha, 0);
				}
				return;
			}
			var r = 0, g = 0, b = 0, a = 0, r2 = 0, g2 = 0, b2 = 0;
			if (time >= frames[frames.length - TwoColorTimeline.ENTRIES]) {
				var i = frames.length;
				r = frames[i + TwoColorTimeline.PREV_R];
				g = frames[i + TwoColorTimeline.PREV_G];
				b = frames[i + TwoColorTimeline.PREV_B];
				a = frames[i + TwoColorTimeline.PREV_A];
				r2 = frames[i + TwoColorTimeline.PREV_R2];
				g2 = frames[i + TwoColorTimeline.PREV_G2];
				b2 = frames[i + TwoColorTimeline.PREV_B2];
			}
			else {
				var frame = Animation.binarySearch(frames, time, TwoColorTimeline.ENTRIES);
				r = frames[frame + TwoColorTimeline.PREV_R];
				g = frames[frame + TwoColorTimeline.PREV_G];
				b = frames[frame + TwoColorTimeline.PREV_B];
				a = frames[frame + TwoColorTimeline.PREV_A];
				r2 = frames[frame + TwoColorTimeline.PREV_R2];
				g2 = frames[frame + TwoColorTimeline.PREV_G2];
				b2 = frames[frame + TwoColorTimeline.PREV_B2];
				var frameTime = frames[frame];
				var percent = this.getCurvePercent(frame / TwoColorTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + TwoColorTimeline.PREV_TIME] - frameTime));
				r += (frames[frame + TwoColorTimeline.R] - r) * percent;
				g += (frames[frame + TwoColorTimeline.G] - g) * percent;
				b += (frames[frame + TwoColorTimeline.B] - b) * percent;
				a += (frames[frame + TwoColorTimeline.A] - a) * percent;
				r2 += (frames[frame + TwoColorTimeline.R2] - r2) * percent;
				g2 += (frames[frame + TwoColorTimeline.G2] - g2) * percent;
				b2 += (frames[frame + TwoColorTimeline.B2] - b2) * percent;
			}
			if (alpha == 1) {
				slot.color.set(r, g, b, a);
				slot.darkColor.set(r2, g2, b2, 1);
			}
			else {
				var light = slot.color, dark = slot.darkColor;
				if (blend == MixBlend.setup) {
					light.setFromColor(slot.data.color);
					dark.setFromColor(slot.data.darkColor);
				}
				light.add((r - light.r) * alpha, (g - light.g) * alpha, (b - light.b) * alpha, (a - light.a) * alpha);
				dark.add((r2 - dark.r) * alpha, (g2 - dark.g) * alpha, (b2 - dark.b) * alpha, 0);
			}
		};
		TwoColorTimeline.ENTRIES = 8;
		TwoColorTimeline.PREV_TIME = -8;
		TwoColorTimeline.PREV_R = -7;
		TwoColorTimeline.PREV_G = -6;
		TwoColorTimeline.PREV_B = -5;
		TwoColorTimeline.PREV_A = -4;
		TwoColorTimeline.PREV_R2 = -3;
		TwoColorTimeline.PREV_G2 = -2;
		TwoColorTimeline.PREV_B2 = -1;
		TwoColorTimeline.R = 1;
		TwoColorTimeline.G = 2;
		TwoColorTimeline.B = 3;
		TwoColorTimeline.A = 4;
		TwoColorTimeline.R2 = 5;
		TwoColorTimeline.G2 = 6;
		TwoColorTimeline.B2 = 7;
		return TwoColorTimeline;
	}(CurveTimeline));
	spine.TwoColorTimeline = TwoColorTimeline;
	var AttachmentTimeline = (function () {
		function AttachmentTimeline(frameCount) {
			this.frames = spine.Utils.newFloatArray(frameCount);
			this.attachmentNames = new Array(frameCount);
		}
		AttachmentTimeline.prototype.getPropertyId = function () {
			return (TimelineType.attachment << 24) + this.slotIndex;
		};
		AttachmentTimeline.prototype.getFrameCount = function () {
			return this.frames.length;
		};
		AttachmentTimeline.prototype.setFrame = function (frameIndex, time, attachmentName) {
			this.frames[frameIndex] = time;
			this.attachmentNames[frameIndex] = attachmentName;
		};
		AttachmentTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, blend, direction) {
			var slot = skeleton.slots[this.slotIndex];
			if (!slot.bone.active)
				return;
			if (direction == MixDirection.mixOut && blend == MixBlend.setup) {
				var attachmentName_1 = slot.data.attachmentName;
				slot.setAttachment(attachmentName_1 == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName_1));
				return;
			}
			var frames = this.frames;
			if (time < frames[0]) {
				if (blend == MixBlend.setup || blend == MixBlend.first) {
					var attachmentName_2 = slot.data.attachmentName;
					slot.setAttachment(attachmentName_2 == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName_2));
				}
				return;
			}
			var frameIndex = 0;
			if (time >= frames[frames.length - 1])
				frameIndex = frames.length - 1;
			else
				frameIndex = Animation.binarySearch(frames, time, 1) - 1;
			var attachmentName = this.attachmentNames[frameIndex];
			skeleton.slots[this.slotIndex]
				.setAttachment(attachmentName == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName));
		};
		return AttachmentTimeline;
	}());
	spine.AttachmentTimeline = AttachmentTimeline;
	var zeros = null;
	var DeformTimeline = (function (_super) {
		__extends(DeformTimeline, _super);
		function DeformTimeline(frameCount) {
			var _this = _super.call(this, frameCount) || this;
			_this.frames = spine.Utils.newFloatArray(frameCount);
			_this.frameVertices = new Array(frameCount);
			if (zeros == null)
				zeros = spine.Utils.newFloatArray(64);
			return _this;
		}
		DeformTimeline.prototype.getPropertyId = function () {
			return (TimelineType.deform << 27) + +this.attachment.id + this.slotIndex;
		};
		DeformTimeline.prototype.setFrame = function (frameIndex, time, vertices) {
			this.frames[frameIndex] = time;
			this.frameVertices[frameIndex] = vertices;
		};
		DeformTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
			var slot = skeleton.slots[this.slotIndex];
			if (!slot.bone.active)
				return;
			var slotAttachment = slot.getAttachment();
			if (!(slotAttachment instanceof spine.VertexAttachment) || !(slotAttachment.deformAttachment == this.attachment))
				return;
			var deformArray = slot.deform;
			if (deformArray.length == 0)
				blend = MixBlend.setup;
			var frameVertices = this.frameVertices;
			var vertexCount = frameVertices[0].length;
			var frames = this.frames;
			if (time < frames[0]) {
				var vertexAttachment = slotAttachment;
				switch (blend) {
					case MixBlend.setup:
						deformArray.length = 0;
						return;
					case MixBlend.first:
						if (alpha == 1) {
							deformArray.length = 0;
							break;
						}
						var deform_1 = spine.Utils.setArraySize(deformArray, vertexCount);
						if (vertexAttachment.bones == null) {
							var setupVertices = vertexAttachment.vertices;
							for (var i = 0; i < vertexCount; i++)
								deform_1[i] += (setupVertices[i] - deform_1[i]) * alpha;
						}
						else {
							alpha = 1 - alpha;
							for (var i = 0; i < vertexCount; i++)
								deform_1[i] *= alpha;
						}
				}
				return;
			}
			var deform = spine.Utils.setArraySize(deformArray, vertexCount);
			if (time >= frames[frames.length - 1]) {
				var lastVertices = frameVertices[frames.length - 1];
				if (alpha == 1) {
					if (blend == MixBlend.add) {
						var vertexAttachment = slotAttachment;
						if (vertexAttachment.bones == null) {
							var setupVertices = vertexAttachment.vertices;
							for (var i_1 = 0; i_1 < vertexCount; i_1++) {
								deform[i_1] += lastVertices[i_1] - setupVertices[i_1];
							}
						}
						else {
							for (var i_2 = 0; i_2 < vertexCount; i_2++)
								deform[i_2] += lastVertices[i_2];
						}
					}
					else {
						spine.Utils.arrayCopy(lastVertices, 0, deform, 0, vertexCount);
					}
				}
				else {
					switch (blend) {
						case MixBlend.setup: {
							var vertexAttachment_1 = slotAttachment;
							if (vertexAttachment_1.bones == null) {
								var setupVertices = vertexAttachment_1.vertices;
								for (var i_3 = 0; i_3 < vertexCount; i_3++) {
									var setup = setupVertices[i_3];
									deform[i_3] = setup + (lastVertices[i_3] - setup) * alpha;
								}
							}
							else {
								for (var i_4 = 0; i_4 < vertexCount; i_4++)
									deform[i_4] = lastVertices[i_4] * alpha;
							}
							break;
						}
						case MixBlend.first:
						case MixBlend.replace:
							for (var i_5 = 0; i_5 < vertexCount; i_5++)
								deform[i_5] += (lastVertices[i_5] - deform[i_5]) * alpha;
							break;
						case MixBlend.add:
							var vertexAttachment = slotAttachment;
							if (vertexAttachment.bones == null) {
								var setupVertices = vertexAttachment.vertices;
								for (var i_6 = 0; i_6 < vertexCount; i_6++) {
									deform[i_6] += (lastVertices[i_6] - setupVertices[i_6]) * alpha;
								}
							}
							else {
								for (var i_7 = 0; i_7 < vertexCount; i_7++)
									deform[i_7] += lastVertices[i_7] * alpha;
							}
					}
				}
				return;
			}
			var frame = Animation.binarySearch(frames, time);
			var prevVertices = frameVertices[frame - 1];
			var nextVertices = frameVertices[frame];
			var frameTime = frames[frame];
			var percent = this.getCurvePercent(frame - 1, 1 - (time - frameTime) / (frames[frame - 1] - frameTime));
			if (alpha == 1) {
				if (blend == MixBlend.add) {
					var vertexAttachment = slotAttachment;
					if (vertexAttachment.bones == null) {
						var setupVertices = vertexAttachment.vertices;
						for (var i_8 = 0; i_8 < vertexCount; i_8++) {
							var prev = prevVertices[i_8];
							deform[i_8] += prev + (nextVertices[i_8] - prev) * percent - setupVertices[i_8];
						}
					}
					else {
						for (var i_9 = 0; i_9 < vertexCount; i_9++) {
							var prev = prevVertices[i_9];
							deform[i_9] += prev + (nextVertices[i_9] - prev) * percent;
						}
					}
				}
				else {
					for (var i_10 = 0; i_10 < vertexCount; i_10++) {
						var prev = prevVertices[i_10];
						deform[i_10] = prev + (nextVertices[i_10] - prev) * percent;
					}
				}
			}
			else {
				switch (blend) {
					case MixBlend.setup: {
						var vertexAttachment_2 = slotAttachment;
						if (vertexAttachment_2.bones == null) {
							var setupVertices = vertexAttachment_2.vertices;
							for (var i_11 = 0; i_11 < vertexCount; i_11++) {
								var prev = prevVertices[i_11], setup = setupVertices[i_11];
								deform[i_11] = setup + (prev + (nextVertices[i_11] - prev) * percent - setup) * alpha;
							}
						}
						else {
							for (var i_12 = 0; i_12 < vertexCount; i_12++) {
								var prev = prevVertices[i_12];
								deform[i_12] = (prev + (nextVertices[i_12] - prev) * percent) * alpha;
							}
						}
						break;
					}
					case MixBlend.first:
					case MixBlend.replace:
						for (var i_13 = 0; i_13 < vertexCount; i_13++) {
							var prev = prevVertices[i_13];
							deform[i_13] += (prev + (nextVertices[i_13] - prev) * percent - deform[i_13]) * alpha;
						}
						break;
					case MixBlend.add:
						var vertexAttachment = slotAttachment;
						if (vertexAttachment.bones == null) {
							var setupVertices = vertexAttachment.vertices;
							for (var i_14 = 0; i_14 < vertexCount; i_14++) {
								var prev = prevVertices[i_14];
								deform[i_14] += (prev + (nextVertices[i_14] - prev) * percent - setupVertices[i_14]) * alpha;
							}
						}
						else {
							for (var i_15 = 0; i_15 < vertexCount; i_15++) {
								var prev = prevVertices[i_15];
								deform[i_15] += (prev + (nextVertices[i_15] - prev) * percent) * alpha;
							}
						}
				}
			}
		};
		return DeformTimeline;
	}(CurveTimeline));
	spine.DeformTimeline = DeformTimeline;
	var EventTimeline = (function () {
		function EventTimeline(frameCount) {
			this.frames = spine.Utils.newFloatArray(frameCount);
			this.events = new Array(frameCount);
		}
		EventTimeline.prototype.getPropertyId = function () {
			return TimelineType.event << 24;
		};
		EventTimeline.prototype.getFrameCount = function () {
			return this.frames.length;
		};
		EventTimeline.prototype.setFrame = function (frameIndex, event) {
			this.frames[frameIndex] = event.time;
			this.events[frameIndex] = event;
		};
		EventTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
			if (firedEvents == null)
				return;
			var frames = this.frames;
			var frameCount = this.frames.length;
			if (lastTime > time) {
				this.apply(skeleton, lastTime, Number.MAX_VALUE, firedEvents, alpha, blend, direction);
				lastTime = -1;
			}
			else if (lastTime >= frames[frameCount - 1])
				return;
			if (time < frames[0])
				return;
			var frame = 0;
			if (lastTime < frames[0])
				frame = 0;
			else {
				frame = Animation.binarySearch(frames, lastTime);
				var frameTime = frames[frame];
				while (frame > 0) {
					if (frames[frame - 1] != frameTime)
						break;
					frame--;
				}
			}
			for (; frame < frameCount && time >= frames[frame]; frame++)
				firedEvents.push(this.events[frame]);
		};
		return EventTimeline;
	}());
	spine.EventTimeline = EventTimeline;
	var DrawOrderTimeline = (function () {
		function DrawOrderTimeline(frameCount) {
			this.frames = spine.Utils.newFloatArray(frameCount);
			this.drawOrders = new Array(frameCount);
		}
		DrawOrderTimeline.prototype.getPropertyId = function () {
			return TimelineType.drawOrder << 24;
		};
		DrawOrderTimeline.prototype.getFrameCount = function () {
			return this.frames.length;
		};
		DrawOrderTimeline.prototype.setFrame = function (frameIndex, time, drawOrder) {
			this.frames[frameIndex] = time;
			this.drawOrders[frameIndex] = drawOrder;
		};
		DrawOrderTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
			var drawOrder = skeleton.drawOrder;
			var slots = skeleton.slots;
			if (direction == MixDirection.mixOut && blend == MixBlend.setup) {
				spine.Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);
				return;
			}
			var frames = this.frames;
			if (time < frames[0]) {
				if (blend == MixBlend.setup || blend == MixBlend.first)
					spine.Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);
				return;
			}
			var frame = 0;
			if (time >= frames[frames.length - 1])
				frame = frames.length - 1;
			else
				frame = Animation.binarySearch(frames, time) - 1;
			var drawOrderToSetupIndex = this.drawOrders[frame];
			if (drawOrderToSetupIndex == null)
				spine.Utils.arrayCopy(slots, 0, drawOrder, 0, slots.length);
			else {
				for (var i = 0, n = drawOrderToSetupIndex.length; i < n; i++)
					drawOrder[i] = slots[drawOrderToSetupIndex[i]];
			}
		};
		return DrawOrderTimeline;
	}());
	spine.DrawOrderTimeline = DrawOrderTimeline;
	var IkConstraintTimeline = (function (_super) {
		__extends(IkConstraintTimeline, _super);
		function IkConstraintTimeline(frameCount) {
			var _this = _super.call(this, frameCount) || this;
			_this.frames = spine.Utils.newFloatArray(frameCount * IkConstraintTimeline.ENTRIES);
			return _this;
		}
		IkConstraintTimeline.prototype.getPropertyId = function () {
			return (TimelineType.ikConstraint << 24) + this.ikConstraintIndex;
		};
		IkConstraintTimeline.prototype.setFrame = function (frameIndex, time, mix, softness, bendDirection, compress, stretch) {
			frameIndex *= IkConstraintTimeline.ENTRIES;
			this.frames[frameIndex] = time;
			this.frames[frameIndex + IkConstraintTimeline.MIX] = mix;
			this.frames[frameIndex + IkConstraintTimeline.SOFTNESS] = softness;
			this.frames[frameIndex + IkConstraintTimeline.BEND_DIRECTION] = bendDirection;
			this.frames[frameIndex + IkConstraintTimeline.COMPRESS] = compress ? 1 : 0;
			this.frames[frameIndex + IkConstraintTimeline.STRETCH] = stretch ? 1 : 0;
		};
		IkConstraintTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
			var frames = this.frames;
			var constraint = skeleton.ikConstraints[this.ikConstraintIndex];
			if (!constraint.active)
				return;
			if (time < frames[0]) {
				switch (blend) {
					case MixBlend.setup:
						constraint.mix = constraint.data.mix;
						constraint.softness = constraint.data.softness;
						constraint.bendDirection = constraint.data.bendDirection;
						constraint.compress = constraint.data.compress;
						constraint.stretch = constraint.data.stretch;
						return;
					case MixBlend.first:
						constraint.mix += (constraint.data.mix - constraint.mix) * alpha;
						constraint.softness += (constraint.data.softness - constraint.softness) * alpha;
						constraint.bendDirection = constraint.data.bendDirection;
						constraint.compress = constraint.data.compress;
						constraint.stretch = constraint.data.stretch;
				}
				return;
			}
			if (time >= frames[frames.length - IkConstraintTimeline.ENTRIES]) {
				if (blend == MixBlend.setup) {
					constraint.mix = constraint.data.mix + (frames[frames.length + IkConstraintTimeline.PREV_MIX] - constraint.data.mix) * alpha;
					constraint.softness = constraint.data.softness
						+ (frames[frames.length + IkConstraintTimeline.PREV_SOFTNESS] - constraint.data.softness) * alpha;
					if (direction == MixDirection.mixOut) {
						constraint.bendDirection = constraint.data.bendDirection;
						constraint.compress = constraint.data.compress;
						constraint.stretch = constraint.data.stretch;
					}
					else {
						constraint.bendDirection = frames[frames.length + IkConstraintTimeline.PREV_BEND_DIRECTION];
						constraint.compress = frames[frames.length + IkConstraintTimeline.PREV_COMPRESS] != 0;
						constraint.stretch = frames[frames.length + IkConstraintTimeline.PREV_STRETCH] != 0;
					}
				}
				else {
					constraint.mix += (frames[frames.length + IkConstraintTimeline.PREV_MIX] - constraint.mix) * alpha;
					constraint.softness += (frames[frames.length + IkConstraintTimeline.PREV_SOFTNESS] - constraint.softness) * alpha;
					if (direction == MixDirection.mixIn) {
						constraint.bendDirection = frames[frames.length + IkConstraintTimeline.PREV_BEND_DIRECTION];
						constraint.compress = frames[frames.length + IkConstraintTimeline.PREV_COMPRESS] != 0;
						constraint.stretch = frames[frames.length + IkConstraintTimeline.PREV_STRETCH] != 0;
					}
				}
				return;
			}
			var frame = Animation.binarySearch(frames, time, IkConstraintTimeline.ENTRIES);
			var mix = frames[frame + IkConstraintTimeline.PREV_MIX];
			var softness = frames[frame + IkConstraintTimeline.PREV_SOFTNESS];
			var frameTime = frames[frame];
			var percent = this.getCurvePercent(frame / IkConstraintTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + IkConstraintTimeline.PREV_TIME] - frameTime));
			if (blend == MixBlend.setup) {
				constraint.mix = constraint.data.mix + (mix + (frames[frame + IkConstraintTimeline.MIX] - mix) * percent - constraint.data.mix) * alpha;
				constraint.softness = constraint.data.softness
					+ (softness + (frames[frame + IkConstraintTimeline.SOFTNESS] - softness) * percent - constraint.data.softness) * alpha;
				if (direction == MixDirection.mixOut) {
					constraint.bendDirection = constraint.data.bendDirection;
					constraint.compress = constraint.data.compress;
					constraint.stretch = constraint.data.stretch;
				}
				else {
					constraint.bendDirection = frames[frame + IkConstraintTimeline.PREV_BEND_DIRECTION];
					constraint.compress = frames[frame + IkConstraintTimeline.PREV_COMPRESS] != 0;
					constraint.stretch = frames[frame + IkConstraintTimeline.PREV_STRETCH] != 0;
				}
			}
			else {
				constraint.mix += (mix + (frames[frame + IkConstraintTimeline.MIX] - mix) * percent - constraint.mix) * alpha;
				constraint.softness += (softness + (frames[frame + IkConstraintTimeline.SOFTNESS] - softness) * percent - constraint.softness) * alpha;
				if (direction == MixDirection.mixIn) {
					constraint.bendDirection = frames[frame + IkConstraintTimeline.PREV_BEND_DIRECTION];
					constraint.compress = frames[frame + IkConstraintTimeline.PREV_COMPRESS] != 0;
					constraint.stretch = frames[frame + IkConstraintTimeline.PREV_STRETCH] != 0;
				}
			}
		};
		IkConstraintTimeline.ENTRIES = 6;
		IkConstraintTimeline.PREV_TIME = -6;
		IkConstraintTimeline.PREV_MIX = -5;
		IkConstraintTimeline.PREV_SOFTNESS = -4;
		IkConstraintTimeline.PREV_BEND_DIRECTION = -3;
		IkConstraintTimeline.PREV_COMPRESS = -2;
		IkConstraintTimeline.PREV_STRETCH = -1;
		IkConstraintTimeline.MIX = 1;
		IkConstraintTimeline.SOFTNESS = 2;
		IkConstraintTimeline.BEND_DIRECTION = 3;
		IkConstraintTimeline.COMPRESS = 4;
		IkConstraintTimeline.STRETCH = 5;
		return IkConstraintTimeline;
	}(CurveTimeline));
	spine.IkConstraintTimeline = IkConstraintTimeline;
	var TransformConstraintTimeline = (function (_super) {
		__extends(TransformConstraintTimeline, _super);
		function TransformConstraintTimeline(frameCount) {
			var _this = _super.call(this, frameCount) || this;
			_this.frames = spine.Utils.newFloatArray(frameCount * TransformConstraintTimeline.ENTRIES);
			return _this;
		}
		TransformConstraintTimeline.prototype.getPropertyId = function () {
			return (TimelineType.transformConstraint << 24) + this.transformConstraintIndex;
		};
		TransformConstraintTimeline.prototype.setFrame = function (frameIndex, time, rotateMix, translateMix, scaleMix, shearMix) {
			frameIndex *= TransformConstraintTimeline.ENTRIES;
			this.frames[frameIndex] = time;
			this.frames[frameIndex + TransformConstraintTimeline.ROTATE] = rotateMix;
			this.frames[frameIndex + TransformConstraintTimeline.TRANSLATE] = translateMix;
			this.frames[frameIndex + TransformConstraintTimeline.SCALE] = scaleMix;
			this.frames[frameIndex + TransformConstraintTimeline.SHEAR] = shearMix;
		};
		TransformConstraintTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
			var frames = this.frames;
			var constraint = skeleton.transformConstraints[this.transformConstraintIndex];
			if (!constraint.active)
				return;
			if (time < frames[0]) {
				var data = constraint.data;
				switch (blend) {
					case MixBlend.setup:
						constraint.rotateMix = data.rotateMix;
						constraint.translateMix = data.translateMix;
						constraint.scaleMix = data.scaleMix;
						constraint.shearMix = data.shearMix;
						return;
					case MixBlend.first:
						constraint.rotateMix += (data.rotateMix - constraint.rotateMix) * alpha;
						constraint.translateMix += (data.translateMix - constraint.translateMix) * alpha;
						constraint.scaleMix += (data.scaleMix - constraint.scaleMix) * alpha;
						constraint.shearMix += (data.shearMix - constraint.shearMix) * alpha;
				}
				return;
			}
			var rotate = 0, translate = 0, scale = 0, shear = 0;
			if (time >= frames[frames.length - TransformConstraintTimeline.ENTRIES]) {
				var i = frames.length;
				rotate = frames[i + TransformConstraintTimeline.PREV_ROTATE];
				translate = frames[i + TransformConstraintTimeline.PREV_TRANSLATE];
				scale = frames[i + TransformConstraintTimeline.PREV_SCALE];
				shear = frames[i + TransformConstraintTimeline.PREV_SHEAR];
			}
			else {
				var frame = Animation.binarySearch(frames, time, TransformConstraintTimeline.ENTRIES);
				rotate = frames[frame + TransformConstraintTimeline.PREV_ROTATE];
				translate = frames[frame + TransformConstraintTimeline.PREV_TRANSLATE];
				scale = frames[frame + TransformConstraintTimeline.PREV_SCALE];
				shear = frames[frame + TransformConstraintTimeline.PREV_SHEAR];
				var frameTime = frames[frame];
				var percent = this.getCurvePercent(frame / TransformConstraintTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + TransformConstraintTimeline.PREV_TIME] - frameTime));
				rotate += (frames[frame + TransformConstraintTimeline.ROTATE] - rotate) * percent;
				translate += (frames[frame + TransformConstraintTimeline.TRANSLATE] - translate) * percent;
				scale += (frames[frame + TransformConstraintTimeline.SCALE] - scale) * percent;
				shear += (frames[frame + TransformConstraintTimeline.SHEAR] - shear) * percent;
			}
			if (blend == MixBlend.setup) {
				var data = constraint.data;
				constraint.rotateMix = data.rotateMix + (rotate - data.rotateMix) * alpha;
				constraint.translateMix = data.translateMix + (translate - data.translateMix) * alpha;
				constraint.scaleMix = data.scaleMix + (scale - data.scaleMix) * alpha;
				constraint.shearMix = data.shearMix + (shear - data.shearMix) * alpha;
			}
			else {
				constraint.rotateMix += (rotate - constraint.rotateMix) * alpha;
				constraint.translateMix += (translate - constraint.translateMix) * alpha;
				constraint.scaleMix += (scale - constraint.scaleMix) * alpha;
				constraint.shearMix += (shear - constraint.shearMix) * alpha;
			}
		};
		TransformConstraintTimeline.ENTRIES = 5;
		TransformConstraintTimeline.PREV_TIME = -5;
		TransformConstraintTimeline.PREV_ROTATE = -4;
		TransformConstraintTimeline.PREV_TRANSLATE = -3;
		TransformConstraintTimeline.PREV_SCALE = -2;
		TransformConstraintTimeline.PREV_SHEAR = -1;
		TransformConstraintTimeline.ROTATE = 1;
		TransformConstraintTimeline.TRANSLATE = 2;
		TransformConstraintTimeline.SCALE = 3;
		TransformConstraintTimeline.SHEAR = 4;
		return TransformConstraintTimeline;
	}(CurveTimeline));
	spine.TransformConstraintTimeline = TransformConstraintTimeline;
	var PathConstraintPositionTimeline = (function (_super) {
		__extends(PathConstraintPositionTimeline, _super);
		function PathConstraintPositionTimeline(frameCount) {
			var _this = _super.call(this, frameCount) || this;
			_this.frames = spine.Utils.newFloatArray(frameCount * PathConstraintPositionTimeline.ENTRIES);
			return _this;
		}
		PathConstraintPositionTimeline.prototype.getPropertyId = function () {
			return (TimelineType.pathConstraintPosition << 24) + this.pathConstraintIndex;
		};
		PathConstraintPositionTimeline.prototype.setFrame = function (frameIndex, time, value) {
			frameIndex *= PathConstraintPositionTimeline.ENTRIES;
			this.frames[frameIndex] = time;
			this.frames[frameIndex + PathConstraintPositionTimeline.VALUE] = value;
		};
		PathConstraintPositionTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
			var frames = this.frames;
			var constraint = skeleton.pathConstraints[this.pathConstraintIndex];
			if (!constraint.active)
				return;
			if (time < frames[0]) {
				switch (blend) {
					case MixBlend.setup:
						constraint.position = constraint.data.position;
						return;
					case MixBlend.first:
						constraint.position += (constraint.data.position - constraint.position) * alpha;
				}
				return;
			}
			var position = 0;
			if (time >= frames[frames.length - PathConstraintPositionTimeline.ENTRIES])
				position = frames[frames.length + PathConstraintPositionTimeline.PREV_VALUE];
			else {
				var frame = Animation.binarySearch(frames, time, PathConstraintPositionTimeline.ENTRIES);
				position = frames[frame + PathConstraintPositionTimeline.PREV_VALUE];
				var frameTime = frames[frame];
				var percent = this.getCurvePercent(frame / PathConstraintPositionTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + PathConstraintPositionTimeline.PREV_TIME] - frameTime));
				position += (frames[frame + PathConstraintPositionTimeline.VALUE] - position) * percent;
			}
			if (blend == MixBlend.setup)
				constraint.position = constraint.data.position + (position - constraint.data.position) * alpha;
			else
				constraint.position += (position - constraint.position) * alpha;
		};
		PathConstraintPositionTimeline.ENTRIES = 2;
		PathConstraintPositionTimeline.PREV_TIME = -2;
		PathConstraintPositionTimeline.PREV_VALUE = -1;
		PathConstraintPositionTimeline.VALUE = 1;
		return PathConstraintPositionTimeline;
	}(CurveTimeline));
	spine.PathConstraintPositionTimeline = PathConstraintPositionTimeline;
	var PathConstraintSpacingTimeline = (function (_super) {
		__extends(PathConstraintSpacingTimeline, _super);
		function PathConstraintSpacingTimeline(frameCount) {
			return _super.call(this, frameCount) || this;
		}
		PathConstraintSpacingTimeline.prototype.getPropertyId = function () {
			return (TimelineType.pathConstraintSpacing << 24) + this.pathConstraintIndex;
		};
		PathConstraintSpacingTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
			var frames = this.frames;
			var constraint = skeleton.pathConstraints[this.pathConstraintIndex];
			if (!constraint.active)
				return;
			if (time < frames[0]) {
				switch (blend) {
					case MixBlend.setup:
						constraint.spacing = constraint.data.spacing;
						return;
					case MixBlend.first:
						constraint.spacing += (constraint.data.spacing - constraint.spacing) * alpha;
				}
				return;
			}
			var spacing = 0;
			if (time >= frames[frames.length - PathConstraintSpacingTimeline.ENTRIES])
				spacing = frames[frames.length + PathConstraintSpacingTimeline.PREV_VALUE];
			else {
				var frame = Animation.binarySearch(frames, time, PathConstraintSpacingTimeline.ENTRIES);
				spacing = frames[frame + PathConstraintSpacingTimeline.PREV_VALUE];
				var frameTime = frames[frame];
				var percent = this.getCurvePercent(frame / PathConstraintSpacingTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + PathConstraintSpacingTimeline.PREV_TIME] - frameTime));
				spacing += (frames[frame + PathConstraintSpacingTimeline.VALUE] - spacing) * percent;
			}
			if (blend == MixBlend.setup)
				constraint.spacing = constraint.data.spacing + (spacing - constraint.data.spacing) * alpha;
			else
				constraint.spacing += (spacing - constraint.spacing) * alpha;
		};
		return PathConstraintSpacingTimeline;
	}(PathConstraintPositionTimeline));
	spine.PathConstraintSpacingTimeline = PathConstraintSpacingTimeline;
	var PathConstraintMixTimeline = (function (_super) {
		__extends(PathConstraintMixTimeline, _super);
		function PathConstraintMixTimeline(frameCount) {
			var _this = _super.call(this, frameCount) || this;
			_this.frames = spine.Utils.newFloatArray(frameCount * PathConstraintMixTimeline.ENTRIES);
			return _this;
		}
		PathConstraintMixTimeline.prototype.getPropertyId = function () {
			return (TimelineType.pathConstraintMix << 24) + this.pathConstraintIndex;
		};
		PathConstraintMixTimeline.prototype.setFrame = function (frameIndex, time, rotateMix, translateMix) {
			frameIndex *= PathConstraintMixTimeline.ENTRIES;
			this.frames[frameIndex] = time;
			this.frames[frameIndex + PathConstraintMixTimeline.ROTATE] = rotateMix;
			this.frames[frameIndex + PathConstraintMixTimeline.TRANSLATE] = translateMix;
		};
		PathConstraintMixTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
			var frames = this.frames;
			var constraint = skeleton.pathConstraints[this.pathConstraintIndex];
			if (!constraint.active)
				return;
			if (time < frames[0]) {
				switch (blend) {
					case MixBlend.setup:
						constraint.rotateMix = constraint.data.rotateMix;
						constraint.translateMix = constraint.data.translateMix;
						return;
					case MixBlend.first:
						constraint.rotateMix += (constraint.data.rotateMix - constraint.rotateMix) * alpha;
						constraint.translateMix += (constraint.data.translateMix - constraint.translateMix) * alpha;
				}
				return;
			}
			var rotate = 0, translate = 0;
			if (time >= frames[frames.length - PathConstraintMixTimeline.ENTRIES]) {
				rotate = frames[frames.length + PathConstraintMixTimeline.PREV_ROTATE];
				translate = frames[frames.length + PathConstraintMixTimeline.PREV_TRANSLATE];
			}
			else {
				var frame = Animation.binarySearch(frames, time, PathConstraintMixTimeline.ENTRIES);
				rotate = frames[frame + PathConstraintMixTimeline.PREV_ROTATE];
				translate = frames[frame + PathConstraintMixTimeline.PREV_TRANSLATE];
				var frameTime = frames[frame];
				var percent = this.getCurvePercent(frame / PathConstraintMixTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + PathConstraintMixTimeline.PREV_TIME] - frameTime));
				rotate += (frames[frame + PathConstraintMixTimeline.ROTATE] - rotate) * percent;
				translate += (frames[frame + PathConstraintMixTimeline.TRANSLATE] - translate) * percent;
			}
			if (blend == MixBlend.setup) {
				constraint.rotateMix = constraint.data.rotateMix + (rotate - constraint.data.rotateMix) * alpha;
				constraint.translateMix = constraint.data.translateMix + (translate - constraint.data.translateMix) * alpha;
			}
			else {
				constraint.rotateMix += (rotate - constraint.rotateMix) * alpha;
				constraint.translateMix += (translate - constraint.translateMix) * alpha;
			}
		};
		PathConstraintMixTimeline.ENTRIES = 3;
		PathConstraintMixTimeline.PREV_TIME = -3;
		PathConstraintMixTimeline.PREV_ROTATE = -2;
		PathConstraintMixTimeline.PREV_TRANSLATE = -1;
		PathConstraintMixTimeline.ROTATE = 1;
		PathConstraintMixTimeline.TRANSLATE = 2;
		return PathConstraintMixTimeline;
	}(CurveTimeline));
	spine.PathConstraintMixTimeline = PathConstraintMixTimeline;
})(spine || (spine = {}));
var spine;
(function (spine) {
	var AnimationState = (function () {
		function AnimationState(data) {
			this.tracks = new Array();
			this.timeScale = 1;
			this.events = new Array();
			this.listeners = new Array();
			this.queue = new EventQueue(this);
			this.propertyIDs = new spine.IntSet();
			this.animationsChanged = false;
			this.trackEntryPool = new spine.Pool(function () { return new TrackEntry(); });
			this.data = data;
		}
		AnimationState.prototype.update = function (delta) {
			delta *= this.timeScale;
			var tracks = this.tracks;
			for (var i = 0, n = tracks.length; i < n; i++) {
				var current = tracks[i];
				if (current == null)
					continue;
				current.animationLast = current.nextAnimationLast;
				current.trackLast = current.nextTrackLast;
				var currentDelta = delta * current.timeScale;
				if (current.delay > 0) {
					current.delay -= currentDelta;
					if (current.delay > 0)
						continue;
					currentDelta = -current.delay;
					current.delay = 0;
				}
				var next = current.next;
				if (next != null) {
					var nextTime = current.trackLast - next.delay;
					if (nextTime >= 0) {
						next.delay = 0;
						next.trackTime += current.timeScale == 0 ? 0 : (nextTime / current.timeScale + delta) * next.timeScale;
						current.trackTime += currentDelta;
						this.setCurrent(i, next, true);
						while (next.mixingFrom != null) {
							next.mixTime += delta;
							next = next.mixingFrom;
						}
						continue;
					}
				}
				else if (current.trackLast >= current.trackEnd && current.mixingFrom == null) {
					tracks[i] = null;
					this.queue.end(current);
					this.disposeNext(current);
					continue;
				}
				if (current.mixingFrom != null && this.updateMixingFrom(current, delta)) {
					var from = current.mixingFrom;
					current.mixingFrom = null;
					if (from != null)
						from.mixingTo = null;
					while (from != null) {
						this.queue.end(from);
						from = from.mixingFrom;
					}
				}
				current.trackTime += currentDelta;
			}
			this.queue.drain();
		};
		AnimationState.prototype.updateMixingFrom = function (to, delta) {
			var from = to.mixingFrom;
			if (from == null)
				return true;
			var finished = this.updateMixingFrom(from, delta);
			from.animationLast = from.nextAnimationLast;
			from.trackLast = from.nextTrackLast;
			if (to.mixTime > 0 && to.mixTime >= to.mixDuration) {
				if (from.totalAlpha == 0 || to.mixDuration == 0) {
					to.mixingFrom = from.mixingFrom;
					if (from.mixingFrom != null)
						from.mixingFrom.mixingTo = to;
					to.interruptAlpha = from.interruptAlpha;
					this.queue.end(from);
				}
				return finished;
			}
			from.trackTime += delta * from.timeScale;
			to.mixTime += delta;
			return false;
		};
		AnimationState.prototype.apply = function (skeleton) {
			if (skeleton == null)
				throw new Error("skeleton cannot be null.");
			if (this.animationsChanged)
				this._animationsChanged();
			var events = this.events;
			var tracks = this.tracks;
			var applied = false;
			for (var i = 0, n = tracks.length; i < n; i++) {
				var current = tracks[i];
				if (current == null || current.delay > 0)
					continue;
				applied = true;
				var blend = i == 0 ? spine.MixBlend.first : current.mixBlend;
				var mix = current.alpha;
				if (current.mixingFrom != null)
					mix *= this.applyMixingFrom(current, skeleton, blend);
				else if (current.trackTime >= current.trackEnd && current.next == null)
					mix = 0;
				var animationLast = current.animationLast, animationTime = current.getAnimationTime();
				var timelineCount = current.animation.timelines.length;
				var timelines = current.animation.timelines;
				if ((i == 0 && mix == 1) || blend == spine.MixBlend.add) {
					for (var ii = 0; ii < timelineCount; ii++) {
						spine.Utils.webkit602BugfixHelper(mix, blend);
						timelines[ii].apply(skeleton, animationLast, animationTime, events, mix, blend, spine.MixDirection.mixIn);
					}
				}
				else {
					var timelineMode = current.timelineMode;
					var firstFrame = current.timelinesRotation.length == 0;
					if (firstFrame)
						spine.Utils.setArraySize(current.timelinesRotation, timelineCount << 1, null);
					var timelinesRotation = current.timelinesRotation;
					for (var ii = 0; ii < timelineCount; ii++) {
						var timeline = timelines[ii];
						var timelineBlend = (timelineMode[ii] & (AnimationState.NOT_LAST - 1)) == AnimationState.SUBSEQUENT ? blend : spine.MixBlend.setup;
						if (timeline instanceof spine.RotateTimeline) {
							this.applyRotateTimeline(timeline, skeleton, animationTime, mix, timelineBlend, timelinesRotation, ii << 1, firstFrame);
						}
						else {
							spine.Utils.webkit602BugfixHelper(mix, blend);
							timeline.apply(skeleton, animationLast, animationTime, events, mix, timelineBlend, spine.MixDirection.mixIn);
						}
					}
				}
				this.queueEvents(current, animationTime);
				events.length = 0;
				current.nextAnimationLast = animationTime;
				current.nextTrackLast = current.trackTime;
			}
			this.queue.drain();
			return applied;
		};
		AnimationState.prototype.applyMixingFrom = function (to, skeleton, blend) {
			var from = to.mixingFrom;
			if (from.mixingFrom != null)
				this.applyMixingFrom(from, skeleton, blend);
			var mix = 0;
			if (to.mixDuration == 0) {
				mix = 1;
				if (blend == spine.MixBlend.first)
					blend = spine.MixBlend.setup;
			}
			else {
				mix = to.mixTime / to.mixDuration;
				if (mix > 1)
					mix = 1;
				if (blend != spine.MixBlend.first)
					blend = from.mixBlend;
			}
			var events = mix < from.eventThreshold ? this.events : null;
			var attachments = mix < from.attachmentThreshold, drawOrder = mix < from.drawOrderThreshold;
			var animationLast = from.animationLast, animationTime = from.getAnimationTime();
			var timelineCount = from.animation.timelines.length;
			var timelines = from.animation.timelines;
			var alphaHold = from.alpha * to.interruptAlpha, alphaMix = alphaHold * (1 - mix);
			if (blend == spine.MixBlend.add) {
				for (var i = 0; i < timelineCount; i++)
					timelines[i].apply(skeleton, animationLast, animationTime, events, alphaMix, blend, spine.MixDirection.mixOut);
			}
			else {
				var timelineMode = from.timelineMode;
				var timelineHoldMix = from.timelineHoldMix;
				var firstFrame = from.timelinesRotation.length == 0;
				if (firstFrame)
					spine.Utils.setArraySize(from.timelinesRotation, timelineCount << 1, null);
				var timelinesRotation = from.timelinesRotation;
				from.totalAlpha = 0;
				for (var i = 0; i < timelineCount; i++) {
					var timeline = timelines[i];
					var direction = spine.MixDirection.mixOut;
					var timelineBlend = void 0;
					var alpha = 0;
					switch (timelineMode[i] & (AnimationState.NOT_LAST - 1)) {
						case AnimationState.SUBSEQUENT:
							timelineBlend = blend;
							if (!attachments && timeline instanceof spine.AttachmentTimeline) {
								if ((timelineMode[i] & AnimationState.NOT_LAST) == AnimationState.NOT_LAST)
									continue;
								timelineBlend = spine.MixBlend.setup;
							}
							if (!drawOrder && timeline instanceof spine.DrawOrderTimeline)
								continue;
							alpha = alphaMix;
							break;
						case AnimationState.FIRST:
							timelineBlend = spine.MixBlend.setup;
							alpha = alphaMix;
							break;
						case AnimationState.HOLD:
							timelineBlend = spine.MixBlend.setup;
							alpha = alphaHold;
							break;
						default:
							timelineBlend = spine.MixBlend.setup;
							var holdMix = timelineHoldMix[i];
							alpha = alphaHold * Math.max(0, 1 - holdMix.mixTime / holdMix.mixDuration);
							break;
					}
					from.totalAlpha += alpha;
					if (timeline instanceof spine.RotateTimeline)
						this.applyRotateTimeline(timeline, skeleton, animationTime, alpha, timelineBlend, timelinesRotation, i << 1, firstFrame);
					else {
						spine.Utils.webkit602BugfixHelper(alpha, blend);
						if (timelineBlend == spine.MixBlend.setup) {
							if (timeline instanceof spine.AttachmentTimeline) {
								if (attachments || (timelineMode[i] & AnimationState.NOT_LAST) == AnimationState.NOT_LAST)
									direction = spine.MixDirection.mixIn;
							}
							else if (timeline instanceof spine.DrawOrderTimeline) {
								if (drawOrder)
									direction = spine.MixDirection.mixIn;
							}
						}
						timeline.apply(skeleton, animationLast, animationTime, events, alpha, timelineBlend, direction);
					}
				}
			}
			if (to.mixDuration > 0)
				this.queueEvents(from, animationTime);
			this.events.length = 0;
			from.nextAnimationLast = animationTime;
			from.nextTrackLast = from.trackTime;
			return mix;
		};
		AnimationState.prototype.applyRotateTimeline = function (timeline, skeleton, time, alpha, blend, timelinesRotation, i, firstFrame) {
			if (firstFrame)
				timelinesRotation[i] = 0;
			if (alpha == 1) {
				timeline.apply(skeleton, 0, time, null, 1, blend, spine.MixDirection.mixIn);
				return;
			}
			var rotateTimeline = timeline;
			var frames = rotateTimeline.frames;
			var bone = skeleton.bones[rotateTimeline.boneIndex];
			if (!bone.active)
				return;
			var r1 = 0, r2 = 0;
			if (time < frames[0]) {
				switch (blend) {
					case spine.MixBlend.setup:
						bone.rotation = bone.data.rotation;
					default:
						return;
					case spine.MixBlend.first:
						r1 = bone.rotation;
						r2 = bone.data.rotation;
				}
			}
			else {
				r1 = blend == spine.MixBlend.setup ? bone.data.rotation : bone.rotation;
				if (time >= frames[frames.length - spine.RotateTimeline.ENTRIES])
					r2 = bone.data.rotation + frames[frames.length + spine.RotateTimeline.PREV_ROTATION];
				else {
					var frame = spine.Animation.binarySearch(frames, time, spine.RotateTimeline.ENTRIES);
					var prevRotation = frames[frame + spine.RotateTimeline.PREV_ROTATION];
					var frameTime = frames[frame];
					var percent = rotateTimeline.getCurvePercent((frame >> 1) - 1, 1 - (time - frameTime) / (frames[frame + spine.RotateTimeline.PREV_TIME] - frameTime));
					r2 = frames[frame + spine.RotateTimeline.ROTATION] - prevRotation;
					r2 -= (16384 - ((16384.499999999996 - r2 / 360) | 0)) * 360;
					r2 = prevRotation + r2 * percent + bone.data.rotation;
					r2 -= (16384 - ((16384.499999999996 - r2 / 360) | 0)) * 360;
				}
			}
			var total = 0, diff = r2 - r1;
			diff -= (16384 - ((16384.499999999996 - diff / 360) | 0)) * 360;
			if (diff == 0) {
				total = timelinesRotation[i];
			}
			else {
				var lastTotal = 0, lastDiff = 0;
				if (firstFrame) {
					lastTotal = 0;
					lastDiff = diff;
				}
				else {
					lastTotal = timelinesRotation[i];
					lastDiff = timelinesRotation[i + 1];
				}
				var current = diff > 0, dir = lastTotal >= 0;
				if (spine.MathUtils.signum(lastDiff) != spine.MathUtils.signum(diff) && Math.abs(lastDiff) <= 90) {
					if (Math.abs(lastTotal) > 180)
						lastTotal += 360 * spine.MathUtils.signum(lastTotal);
					dir = current;
				}
				total = diff + lastTotal - lastTotal % 360;
				if (dir != current)
					total += 360 * spine.MathUtils.signum(lastTotal);
				timelinesRotation[i] = total;
			}
			timelinesRotation[i + 1] = diff;
			r1 += total * alpha;
			bone.rotation = r1 - (16384 - ((16384.499999999996 - r1 / 360) | 0)) * 360;
		};
		AnimationState.prototype.queueEvents = function (entry, animationTime) {
			var animationStart = entry.animationStart, animationEnd = entry.animationEnd;
			var duration = animationEnd - animationStart;
			var trackLastWrapped = entry.trackLast % duration;
			var events = this.events;
			var i = 0, n = events.length;
			for (; i < n; i++) {
				var event_1 = events[i];
				if (event_1.time < trackLastWrapped)
					break;
				if (event_1.time > animationEnd)
					continue;
				this.queue.event(entry, event_1);
			}
			var complete = false;
			if (entry.loop)
				complete = duration == 0 || trackLastWrapped > entry.trackTime % duration;
			else
				complete = animationTime >= animationEnd && entry.animationLast < animationEnd;
			if (complete)
				this.queue.complete(entry);
			for (; i < n; i++) {
				var event_2 = events[i];
				if (event_2.time < animationStart)
					continue;
				this.queue.event(entry, events[i]);
			}
		};
		AnimationState.prototype.clearTracks = function () {
			var oldDrainDisabled = this.queue.drainDisabled;
			this.queue.drainDisabled = true;
			for (var i = 0, n = this.tracks.length; i < n; i++)
				this.clearTrack(i);
			this.tracks.length = 0;
			this.queue.drainDisabled = oldDrainDisabled;
			this.queue.drain();
		};
		AnimationState.prototype.clearTrack = function (trackIndex) {
			if (trackIndex >= this.tracks.length)
				return;
			var current = this.tracks[trackIndex];
			if (current == null)
				return;
			this.queue.end(current);
			this.disposeNext(current);
			var entry = current;
			while (true) {
				var from = entry.mixingFrom;
				if (from == null)
					break;
				this.queue.end(from);
				entry.mixingFrom = null;
				entry.mixingTo = null;
				entry = from;
			}
			this.tracks[current.trackIndex] = null;
			this.queue.drain();
		};
		AnimationState.prototype.setCurrent = function (index, current, interrupt) {
			var from = this.expandToIndex(index);
			this.tracks[index] = current;
			if (from != null) {
				if (interrupt)
					this.queue.interrupt(from);
				current.mixingFrom = from;
				from.mixingTo = current;
				current.mixTime = 0;
				if (from.mixingFrom != null && from.mixDuration > 0)
					current.interruptAlpha *= Math.min(1, from.mixTime / from.mixDuration);
				from.timelinesRotation.length = 0;
			}
			this.queue.start(current);
		};
		AnimationState.prototype.setAnimation = function (trackIndex, animationName, loop) {
			var animation = this.data.skeletonData.findAnimation(animationName);
			if (animation == null)
				throw new Error("Animation not found: " + animationName);
			return this.setAnimationWith(trackIndex, animation, loop);
		};
		AnimationState.prototype.setAnimationWith = function (trackIndex, animation, loop) {
			if (animation == null)
				throw new Error("animation cannot be null.");
			var interrupt = true;
			var current = this.expandToIndex(trackIndex);
			if (current != null) {
				if (current.nextTrackLast == -1) {
					this.tracks[trackIndex] = current.mixingFrom;
					this.queue.interrupt(current);
					this.queue.end(current);
					this.disposeNext(current);
					current = current.mixingFrom;
					interrupt = false;
				}
				else
					this.disposeNext(current);
			}
			var entry = this.trackEntry(trackIndex, animation, loop, current);
			this.setCurrent(trackIndex, entry, interrupt);
			this.queue.drain();
			return entry;
		};
		AnimationState.prototype.addAnimation = function (trackIndex, animationName, loop, delay) {
			var animation = this.data.skeletonData.findAnimation(animationName);
			if (animation == null)
				throw new Error("Animation not found: " + animationName);
			return this.addAnimationWith(trackIndex, animation, loop, delay);
		};
		AnimationState.prototype.addAnimationWith = function (trackIndex, animation, loop, delay) {
			if (animation == null)
				throw new Error("animation cannot be null.");
			var last = this.expandToIndex(trackIndex);
			if (last != null) {
				while (last.next != null)
					last = last.next;
			}
			var entry = this.trackEntry(trackIndex, animation, loop, last);
			if (last == null) {
				this.setCurrent(trackIndex, entry, true);
				this.queue.drain();
			}
			else {
				last.next = entry;
				if (delay <= 0) {
					var duration = last.animationEnd - last.animationStart;
					if (duration != 0) {
						if (last.loop)
							delay += duration * (1 + ((last.trackTime / duration) | 0));
						else
							delay += Math.max(duration, last.trackTime);
						delay -= this.data.getMix(last.animation, animation);
					}
					else
						delay = last.trackTime;
				}
			}
			entry.delay = delay;
			return entry;
		};
		AnimationState.prototype.setEmptyAnimation = function (trackIndex, mixDuration) {
			var entry = this.setAnimationWith(trackIndex, AnimationState.emptyAnimation, false);
			entry.mixDuration = mixDuration;
			entry.trackEnd = mixDuration;
			return entry;
		};
		AnimationState.prototype.addEmptyAnimation = function (trackIndex, mixDuration, delay) {
			if (delay <= 0)
				delay -= mixDuration;
			var entry = this.addAnimationWith(trackIndex, AnimationState.emptyAnimation, false, delay);
			entry.mixDuration = mixDuration;
			entry.trackEnd = mixDuration;
			return entry;
		};
		AnimationState.prototype.setEmptyAnimations = function (mixDuration) {
			var oldDrainDisabled = this.queue.drainDisabled;
			this.queue.drainDisabled = true;
			for (var i = 0, n = this.tracks.length; i < n; i++) {
				var current = this.tracks[i];
				if (current != null)
					this.setEmptyAnimation(current.trackIndex, mixDuration);
			}
			this.queue.drainDisabled = oldDrainDisabled;
			this.queue.drain();
		};
		AnimationState.prototype.expandToIndex = function (index) {
			if (index < this.tracks.length)
				return this.tracks[index];
			spine.Utils.ensureArrayCapacity(this.tracks, index + 1, null);
			this.tracks.length = index + 1;
			return null;
		};
		AnimationState.prototype.trackEntry = function (trackIndex, animation, loop, last) {
			var entry = this.trackEntryPool.obtain();
			entry.trackIndex = trackIndex;
			entry.animation = animation;
			entry.loop = loop;
			entry.holdPrevious = false;
			entry.eventThreshold = 0;
			entry.attachmentThreshold = 0;
			entry.drawOrderThreshold = 0;
			entry.animationStart = 0;
			entry.animationEnd = animation.duration;
			entry.animationLast = -1;
			entry.nextAnimationLast = -1;
			entry.delay = 0;
			entry.trackTime = 0;
			entry.trackLast = -1;
			entry.nextTrackLast = -1;
			entry.trackEnd = Number.MAX_VALUE;
			entry.timeScale = 1;
			entry.alpha = 1;
			entry.interruptAlpha = 1;
			entry.mixTime = 0;
			entry.mixDuration = last == null ? 0 : this.data.getMix(last.animation, animation);
			entry.mixBlend = spine.MixBlend.replace;
			return entry;
		};
		AnimationState.prototype.disposeNext = function (entry) {
			var next = entry.next;
			while (next != null) {
				this.queue.dispose(next);
				next = next.next;
			}
			entry.next = null;
		};
		AnimationState.prototype._animationsChanged = function () {
			this.animationsChanged = false;
			this.propertyIDs.clear();
			for (var i = 0, n = this.tracks.length; i < n; i++) {
				var entry = this.tracks[i];
				if (entry == null)
					continue;
				while (entry.mixingFrom != null)
					entry = entry.mixingFrom;
				do {
					if (entry.mixingFrom == null || entry.mixBlend != spine.MixBlend.add)
						this.computeHold(entry);
					entry = entry.mixingTo;
				} while (entry != null);
			}
			this.propertyIDs.clear();
			for (var i = this.tracks.length - 1; i >= 0; i--) {
				var entry = this.tracks[i];
				while (entry != null) {
					this.computeNotLast(entry);
					entry = entry.mixingFrom;
				}
			}
		};
		AnimationState.prototype.computeHold = function (entry) {
			var to = entry.mixingTo;
			var timelines = entry.animation.timelines;
			var timelinesCount = entry.animation.timelines.length;
			var timelineMode = spine.Utils.setArraySize(entry.timelineMode, timelinesCount);
			entry.timelineHoldMix.length = 0;
			var timelineDipMix = spine.Utils.setArraySize(entry.timelineHoldMix, timelinesCount);
			var propertyIDs = this.propertyIDs;
			if (to != null && to.holdPrevious) {
				for (var i = 0; i < timelinesCount; i++) {
					propertyIDs.add(timelines[i].getPropertyId());
					timelineMode[i] = AnimationState.HOLD;
				}
				return;
			}
			outer: for (var i = 0; i < timelinesCount; i++) {
				var timeline = timelines[i];
				var id = timeline.getPropertyId();
				if (!propertyIDs.add(id))
					timelineMode[i] = AnimationState.SUBSEQUENT;
				else if (to == null || timeline instanceof spine.AttachmentTimeline || timeline instanceof spine.DrawOrderTimeline
					|| timeline instanceof spine.EventTimeline || !to.animation.hasTimeline(id)) {
					timelineMode[i] = AnimationState.FIRST;
				}
				else {
					for (var next = to.mixingTo; next != null; next = next.mixingTo) {
						if (next.animation.hasTimeline(id))
							continue;
						if (entry.mixDuration > 0) {
							timelineMode[i] = AnimationState.HOLD_MIX;
							timelineDipMix[i] = next;
							continue outer;
						}
						break;
					}
					timelineMode[i] = AnimationState.HOLD;
				}
			}
		};
		AnimationState.prototype.computeNotLast = function (entry) {
			var timelines = entry.animation.timelines;
			var timelinesCount = entry.animation.timelines.length;
			var timelineMode = entry.timelineMode;
			var propertyIDs = this.propertyIDs;
			for (var i = 0; i < timelinesCount; i++) {
				if (timelines[i] instanceof spine.AttachmentTimeline) {
					var timeline = timelines[i];
					if (!propertyIDs.add(timeline.slotIndex))
						timelineMode[i] |= AnimationState.NOT_LAST;
				}
			}
		};
		AnimationState.prototype.getCurrent = function (trackIndex) {
			if (trackIndex >= this.tracks.length)
				return null;
			return this.tracks[trackIndex];
		};
		AnimationState.prototype.addListener = function (listener) {
			if (listener == null)
				throw new Error("listener cannot be null.");
			this.listeners.push(listener);
		};
		AnimationState.prototype.removeListener = function (listener) {
			var index = this.listeners.indexOf(listener);
			if (index >= 0)
				this.listeners.splice(index, 1);
		};
		AnimationState.prototype.clearListeners = function () {
			this.listeners.length = 0;
		};
		AnimationState.prototype.clearListenerNotifications = function () {
			this.queue.clear();
		};
		AnimationState.emptyAnimation = new spine.Animation("<empty>", [], 0);
		AnimationState.SUBSEQUENT = 0;
		AnimationState.FIRST = 1;
		AnimationState.HOLD = 2;
		AnimationState.HOLD_MIX = 3;
		AnimationState.NOT_LAST = 4;
		return AnimationState;
	}());
	spine.AnimationState = AnimationState;
	var TrackEntry = (function () {
		function TrackEntry() {
			this.mixBlend = spine.MixBlend.replace;
			this.timelineMode = new Array();
			this.timelineHoldMix = new Array();
			this.timelinesRotation = new Array();
		}
		TrackEntry.prototype.reset = function () {
			this.next = null;
			this.mixingFrom = null;
			this.mixingTo = null;
			this.animation = null;
			this.listener = null;
			this.timelineMode.length = 0;
			this.timelineHoldMix.length = 0;
			this.timelinesRotation.length = 0;
		};
		TrackEntry.prototype.getAnimationTime = function () {
			if (this.loop) {
				var duration = this.animationEnd - this.animationStart;
				if (duration == 0)
					return this.animationStart;
				return (this.trackTime % duration) + this.animationStart;
			}
			return Math.min(this.trackTime + this.animationStart, this.animationEnd);
		};
		TrackEntry.prototype.setAnimationLast = function (animationLast) {
			this.animationLast = animationLast;
			this.nextAnimationLast = animationLast;
		};
		TrackEntry.prototype.isComplete = function () {
			return this.trackTime >= this.animationEnd - this.animationStart;
		};
		TrackEntry.prototype.resetRotationDirections = function () {
			this.timelinesRotation.length = 0;
		};
		return TrackEntry;
	}());
	spine.TrackEntry = TrackEntry;
	var EventQueue = (function () {
		function EventQueue(animState) {
			this.objects = [];
			this.drainDisabled = false;
			this.animState = animState;
		}
		EventQueue.prototype.start = function (entry) {
			this.objects.push(EventType.start);
			this.objects.push(entry);
			this.animState.animationsChanged = true;
		};
		EventQueue.prototype.interrupt = function (entry) {
			this.objects.push(EventType.interrupt);
			this.objects.push(entry);
		};
		EventQueue.prototype.end = function (entry) {
			this.objects.push(EventType.end);
			this.objects.push(entry);
			this.animState.animationsChanged = true;
		};
		EventQueue.prototype.dispose = function (entry) {
			this.objects.push(EventType.dispose);
			this.objects.push(entry);
		};
		EventQueue.prototype.complete = function (entry) {
			this.objects.push(EventType.complete);
			this.objects.push(entry);
		};
		EventQueue.prototype.event = function (entry, event) {
			this.objects.push(EventType.event);
			this.objects.push(entry);
			this.objects.push(event);
		};
		EventQueue.prototype.drain = function () {
			if (this.drainDisabled)
				return;
			this.drainDisabled = true;
			var objects = this.objects;
			var listeners = this.animState.listeners;
			for (var i = 0; i < objects.length; i += 2) {
				var type = objects[i];
				var entry = objects[i + 1];
				switch (type) {
					case EventType.start:
						if (entry.listener != null && entry.listener.start)
							entry.listener.start(entry);
						for (var ii = 0; ii < listeners.length; ii++)
							if (listeners[ii].start)
								listeners[ii].start(entry);
						break;
					case EventType.interrupt:
						if (entry.listener != null && entry.listener.interrupt)
							entry.listener.interrupt(entry);
						for (var ii = 0; ii < listeners.length; ii++)
							if (listeners[ii].interrupt)
								listeners[ii].interrupt(entry);
						break;
					case EventType.end:
						if (entry.listener != null && entry.listener.end)
							entry.listener.end(entry);
						for (var ii = 0; ii < listeners.length; ii++)
							if (listeners[ii].end)
								listeners[ii].end(entry);
					case EventType.dispose:
						if (entry.listener != null && entry.listener.dispose)
							entry.listener.dispose(entry);
						for (var ii = 0; ii < listeners.length; ii++)
							if (listeners[ii].dispose)
								listeners[ii].dispose(entry);
						this.animState.trackEntryPool.free(entry);
						break;
					case EventType.complete:
						if (entry.listener != null && entry.listener.complete)
							entry.listener.complete(entry);
						for (var ii = 0; ii < listeners.length; ii++)
							if (listeners[ii].complete)
								listeners[ii].complete(entry);
						break;
					case EventType.event:
						var event_3 = objects[i++ + 2];
						if (entry.listener != null && entry.listener.event)
							entry.listener.event(entry, event_3);
						for (var ii = 0; ii < listeners.length; ii++)
							if (listeners[ii].event)
								listeners[ii].event(entry, event_3);
						break;
				}
			}
			this.clear();
			this.drainDisabled = false;
		};
		EventQueue.prototype.clear = function () {
			this.objects.length = 0;
		};
		return EventQueue;
	}());
	spine.EventQueue = EventQueue;
	var EventType;
	(function (EventType) {
		EventType[EventType["start"] = 0] = "start";
		EventType[EventType["interrupt"] = 1] = "interrupt";
		EventType[EventType["end"] = 2] = "end";
		EventType[EventType["dispose"] = 3] = "dispose";
		EventType[EventType["complete"] = 4] = "complete";
		EventType[EventType["event"] = 5] = "event";
	})(EventType = spine.EventType || (spine.EventType = {}));
	var AnimationStateAdapter = (function () {
		function AnimationStateAdapter() {
		}
		AnimationStateAdapter.prototype.start = function (entry) {
		};
		AnimationStateAdapter.prototype.interrupt = function (entry) {
		};
		AnimationStateAdapter.prototype.end = function (entry) {
		};
		AnimationStateAdapter.prototype.dispose = function (entry) {
		};
		AnimationStateAdapter.prototype.complete = function (entry) {
		};
		AnimationStateAdapter.prototype.event = function (entry, event) {
		};
		return AnimationStateAdapter;
	}());
	spine.AnimationStateAdapter = AnimationStateAdapter;
})(spine || (spine = {}));
var spine;
(function (spine) {
	var AnimationStateData = (function () {
		function AnimationStateData(skeletonData) {
			this.animationToMixTime = {};
			this.defaultMix = 0;
			if (skeletonData == null)
				throw new Error("skeletonData cannot be null.");
			this.skeletonData = skeletonData;
		}
		AnimationStateData.prototype.setMix = function (fromName, toName, duration) {
			var from = this.skeletonData.findAnimation(fromName);
			if (from == null)
				throw new Error("Animation not found: " + fromName);
			var to = this.skeletonData.findAnimation(toName);
			if (to == null)
				throw new Error("Animation not found: " + toName);
			this.setMixWith(from, to, duration);
		};
		AnimationStateData.prototype.setMixWith = function (from, to, duration) {
			if (from == null)
				throw new Error("from cannot be null.");
			if (to == null)
				throw new Error("to cannot be null.");
			var key = from.name + "." + to.name;
			this.animationToMixTime[key] = duration;
		};
		AnimationStateData.prototype.getMix = function (from, to) {
			var key = from.name + "." + to.name;
			var value = this.animationToMixTime[key];
			return value === undefined ? this.defaultMix : value;
		};
		return AnimationStateData;
	}());
	spine.AnimationStateData = AnimationStateData;
})(spine || (spine = {}));
var spine;
(function (spine) {
	var AssetManager = (function () {
		function AssetManager(textureLoader, pathPrefix) {
			if (pathPrefix === void 0) { pathPrefix = ""; }
			this.assets = {};
			this.errors = {};
			this.toLoad = 0;
			this.loaded = 0;
			this.rawDataUris = {};
			this.textureLoader = textureLoader;
			this.pathPrefix = pathPrefix;
		}
		AssetManager.prototype.downloadText = function (url, success, error) {
			var request = new XMLHttpRequest();
			request.overrideMimeType("text/html");
			if (this.rawDataUris[url])
				url = this.rawDataUris[url];
			request.open("GET", url, true);
			request.onload = function () {
				if (request.status == 200) {
					success(request.responseText);
				}
				else {
					error(request.status, request.responseText);
				}
			};
			request.onerror = function () {
				error(request.status, request.responseText);
			};
			request.send();
		};
		AssetManager.prototype.downloadBinary = function (url, success, error) {
			var request = new XMLHttpRequest();
			if (this.rawDataUris[url])
				url = this.rawDataUris[url];
			request.open("GET", url, true);
			request.responseType = "arraybuffer";
			request.onload = function () {
				if (request.status == 200) {
					success(new Uint8Array(request.response));
				}
				else {
					error(request.status, request.responseText);
				}
			};
			request.onerror = function () {
				error(request.status, request.responseText);
			};
			request.send();
		};
		AssetManager.prototype.setRawDataURI = function (path, data) {
			this.rawDataUris[this.pathPrefix + path] = data;
		};
		AssetManager.prototype.loadBinary = function (path, success, error) {
			var _this = this;
			if (success === void 0) { success = null; }
			if (error === void 0) { error = null; }
			path = this.pathPrefix + path;
			this.toLoad++;
			this.downloadBinary(path, function (data) {
				_this.assets[path] = data;
				if (success)
					success(path, data);
				_this.toLoad--;
				_this.loaded++;
			}, function (state, responseText) {
				_this.errors[path] = "Couldn't load binary " + path + ": status " + status + ", " + responseText;
				if (error)
					error(path, "Couldn't load binary " + path + ": status " + status + ", " + responseText);
				_this.toLoad--;
				_this.loaded++;
			});
		};
		AssetManager.prototype.loadText = function (path, success, error) {
			var _this = this;
			if (success === void 0) { success = null; }
			if (error === void 0) { error = null; }
			path = this.pathPrefix + path;
			this.toLoad++;
			this.downloadText(path, function (data) {
				_this.assets[path] = data;
				if (success)
					success(path, data);
				_this.toLoad--;
				_this.loaded++;
			}, function (state, responseText) {
				_this.errors[path] = "Couldn't load text " + path + ": status " + status + ", " + responseText;
				if (error)
					error(path, "Couldn't load text " + path + ": status " + status + ", " + responseText);
				_this.toLoad--;
				_this.loaded++;
			});
		};
		AssetManager.prototype.loadTexture = function (path, success, error) {
			var _this = this;
			if (success === void 0) { success = null; }
			if (error === void 0) { error = null; }
			path = this.pathPrefix + path;
			var storagePath = path;
			this.toLoad++;
			var img = new Image();
			img.crossOrigin = "anonymous";
			img.onload = function (ev) {
				var texture = _this.textureLoader(img);
				_this.assets[storagePath] = texture;
				_this.toLoad--;
				_this.loaded++;
				if (success)
					success(path, img);
			};
			img.onerror = function (ev) {
				_this.errors[path] = "Couldn't load image " + path;
				_this.toLoad--;
				_this.loaded++;
				if (error)
					error(path, "Couldn't load image " + path);
			};
			if (this.rawDataUris[path])
				path = this.rawDataUris[path];
			img.src = path;
		};
		AssetManager.prototype.loadTextureAtlas = function (path, success, error) {
			var _this = this;
			if (success === void 0) { success = null; }
			if (error === void 0) { error = null; }
			var parent = path.lastIndexOf("/") >= 0 ? path.substring(0, path.lastIndexOf("/")) : "";
			path = this.pathPrefix + path;
			this.toLoad++;
			this.downloadText(path, function (atlasData) {
				var pagesLoaded = { count: 0 };
				var atlasPages = new Array();
				try {
					var atlas = new spine.TextureAtlas(atlasData, function (path) {
						atlasPages.push(parent == "" ? path : parent + "/" + path);
						var image = document.createElement("img");
						image.width = 16;
						image.height = 16;
						return new spine.FakeTexture(image);
					});
				}
				catch (e) {
					var ex = e;
					_this.errors[path] = "Couldn't load texture atlas " + path + ": " + ex.message;
					if (error)
						error(path, "Couldn't load texture atlas " + path + ": " + ex.message);
					_this.toLoad--;
					_this.loaded++;
					return;
				}
				var _loop_1 = function (atlasPage) {
					var pageLoadError = false;
					_this.loadTexture(atlasPage, function (imagePath, image) {
						pagesLoaded.count++;
						if (pagesLoaded.count == atlasPages.length) {
							if (!pageLoadError) {
								try {
									var atlas = new spine.TextureAtlas(atlasData, function (path) {
										return _this.get(parent == "" ? path : parent + "/" + path);
									});
									_this.assets[path] = atlas;
									if (success)
										success(path, atlas);
									_this.toLoad--;
									_this.loaded++;
								}
								catch (e) {
									var ex = e;
									_this.errors[path] = "Couldn't load texture atlas " + path + ": " + ex.message;
									if (error)
										error(path, "Couldn't load texture atlas " + path + ": " + ex.message);
									_this.toLoad--;
									_this.loaded++;
								}
							}
							else {
								_this.errors[path] = "Couldn't load texture atlas page " + imagePath + "} of atlas " + path;
								if (error)
									error(path, "Couldn't load texture atlas page " + imagePath + " of atlas " + path);
								_this.toLoad--;
								_this.loaded++;
							}
						}
					}, function (imagePath, errorMessage) {
						pageLoadError = true;
						pagesLoaded.count++;
						if (pagesLoaded.count == atlasPages.length) {
							_this.errors[path] = "Couldn't load texture atlas page " + imagePath + "} of atlas " + path;
							if (error)
								error(path, "Couldn't load texture atlas page " + imagePath + " of atlas " + path);
							_this.toLoad--;
							_this.loaded++;
						}
					});
				};
				for (var _i = 0, atlasPages_1 = atlasPages; _i < atlasPages_1.length; _i++) {
					var atlasPage = atlasPages_1[_i];
					_loop_1(atlasPage);
				}
			}, function (state, responseText) {
				_this.errors[path] = "Couldn't load texture atlas " + path + ": status " + status + ", " + responseText;
				if (error)
					error(path, "Couldn't load texture atlas " + path + ": status " + status + ", " + responseText);
				_this.toLoad--;
				_this.loaded++;
			});
		};
		AssetManager.prototype.get = function (path) {
			path = this.pathPrefix + path;
			return this.assets[path];
		};
		AssetManager.prototype.remove = function (path) {
			path = this.pathPrefix + path;
			var asset = this.assets[path];
			if (asset.dispose)
				asset.dispose();
			this.assets[path] = null;
		};
		AssetManager.prototype.removeAll = function () {
			for (var key in this.assets) {
				var asset = this.assets[key];
				if (asset.dispose)
					asset.dispose();
			}
			this.assets = {};
		};
		AssetManager.prototype.isLoadingComplete = function () {
			return this.toLoad == 0;
		};
		AssetManager.prototype.getToLoad = function () {
			return this.toLoad;
		};
		AssetManager.prototype.getLoaded = function () {
			return this.loaded;
		};
		AssetManager.prototype.dispose = function () {
			this.removeAll();
		};
		AssetManager.prototype.hasErrors = function () {
			return Object.keys(this.errors).length > 0;
		};
		AssetManager.prototype.getErrors = function () {
			return this.errors;
		};
		return AssetManager;
	}());
	spine.AssetManager = AssetManager;
})(spine || (spine = {}));
var spine;
(function (spine) {
	var AtlasAttachmentLoader = (function () {
		function AtlasAttachmentLoader(atlas) {
			this.atlas = atlas;
		}
		AtlasAttachmentLoader.prototype.newRegionAttachment = function (skin, name, path) {
			var region = this.atlas.findRegion(path);
			if (region == null)
				throw new Error("Region not found in atlas: " + path + " (region attachment: " + name + ")");
			region.renderObject = region;
			var attachment = new spine.RegionAttachment(name);
			attachment.setRegion(region);
			return attachment;
		};
		AtlasAttachmentLoader.prototype.newMeshAttachment = function (skin, name, path) {
			var region = this.atlas.findRegion(path);
			if (region == null)
				throw new Error("Region not found in atlas: " + path + " (mesh attachment: " + name + ")");
			region.renderObject = region;
			var attachment = new spine.MeshAttachment(name);
			attachment.region = region;
			return attachment;
		};
		AtlasAttachmentLoader.prototype.newBoundingBoxAttachment = function (skin, name) {
			return new spine.BoundingBoxAttachment(name);
		};
		AtlasAttachmentLoader.prototype.newPathAttachment = function (skin, name) {
			return new spine.PathAttachment(name);
		};
		AtlasAttachmentLoader.prototype.newPointAttachment = function (skin, name) {
			return new spine.PointAttachment(name);
		};
		AtlasAttachmentLoader.prototype.newClippingAttachment = function (skin, name) {
			return new spine.ClippingAttachment(name);
		};
		return AtlasAttachmentLoader;
	}());
	spine.AtlasAttachmentLoader = AtlasAttachmentLoader;
})(spine || (spine = {}));
var spine;
(function (spine) {
	var BlendMode;
	(function (BlendMode) {
		BlendMode[BlendMode["Normal"] = 0] = "Normal";
		BlendMode[BlendMode["Additive"] = 1] = "Additive";
		BlendMode[BlendMode["Multiply"] = 2] = "Multiply";
		BlendMode[BlendMode["Screen"] = 3] = "Screen";
	})(BlendMode = spine.BlendMode || (spine.BlendMode = {}));
})(spine || (spine = {}));
var spine;
(function (spine) {
	var Bone = (function () {
		function Bone(data, skeleton, parent) {
			this.children = new Array();
			this.x = 0;
			this.y = 0;
			this.rotation = 0;
			this.scaleX = 0;
			this.scaleY = 0;
			this.shearX = 0;
			this.shearY = 0;
			this.ax = 0;
			this.ay = 0;
			this.arotation = 0;
			this.ascaleX = 0;
			this.ascaleY = 0;
			this.ashearX = 0;
			this.ashearY = 0;
			this.appliedValid = false;
			this.a = 0;
			this.b = 0;
			this.c = 0;
			this.d = 0;
			this.worldY = 0;
			this.worldX = 0;
			this.sorted = false;
			this.active = false;
			if (data == null)
				throw new Error("data cannot be null.");
			if (skeleton == null)
				throw new Error("skeleton cannot be null.");
			this.data = data;
			this.skeleton = skeleton;
			this.parent = parent;
			this.setToSetupPose();
		}
		Bone.prototype.isActive = function () {
			return this.active;
		};
		Bone.prototype.update = function () {
			this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);
		};
		Bone.prototype.updateWorldTransform = function () {
			this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);
		};
		Bone.prototype.updateWorldTransformWith = function (x, y, rotation, scaleX, scaleY, shearX, shearY) {
			this.ax = x;
			this.ay = y;
			this.arotation = rotation;
			this.ascaleX = scaleX;
			this.ascaleY = scaleY;
			this.ashearX = shearX;
			this.ashearY = shearY;
			this.appliedValid = true;
			var parent = this.parent;
			if (parent == null) {
				var skeleton = this.skeleton;
				var rotationY = rotation + 90 + shearY;
				var sx = skeleton.scaleX;
				var sy = skeleton.scaleY;
				this.a = spine.MathUtils.cosDeg(rotation + shearX) * scaleX * sx;
				this.b = spine.MathUtils.cosDeg(rotationY) * scaleY * sx;
				this.c = spine.MathUtils.sinDeg(rotation + shearX) * scaleX * sy;
				this.d = spine.MathUtils.sinDeg(rotationY) * scaleY * sy;
				this.worldX = x * sx + skeleton.x;
				this.worldY = y * sy + skeleton.y;
				return;
			}
			var pa = parent.a, pb = parent.b, pc = parent.c, pd = parent.d;
			this.worldX = pa * x + pb * y + parent.worldX;
			this.worldY = pc * x + pd * y + parent.worldY;
			switch (this.data.transformMode) {
				case spine.TransformMode.Normal: {
					var rotationY = rotation + 90 + shearY;
					var la = spine.MathUtils.cosDeg(rotation + shearX) * scaleX;
					var lb = spine.MathUtils.cosDeg(rotationY) * scaleY;
					var lc = spine.MathUtils.sinDeg(rotation + shearX) * scaleX;
					var ld = spine.MathUtils.sinDeg(rotationY) * scaleY;
					this.a = pa * la + pb * lc;
					this.b = pa * lb + pb * ld;
					this.c = pc * la + pd * lc;
					this.d = pc * lb + pd * ld;
					return;
				}
				case spine.TransformMode.OnlyTranslation: {
					var rotationY = rotation + 90 + shearY;
					this.a = spine.MathUtils.cosDeg(rotation + shearX) * scaleX;
					this.b = spine.MathUtils.cosDeg(rotationY) * scaleY;
					this.c = spine.MathUtils.sinDeg(rotation + shearX) * scaleX;
					this.d = spine.MathUtils.sinDeg(rotationY) * scaleY;
					break;
				}
				case spine.TransformMode.NoRotationOrReflection: {
					var s = pa * pa + pc * pc;
					var prx = 0;
					if (s > 0.0001) {
						s = Math.abs(pa * pd - pb * pc) / s;
						pb = pc * s;
						pd = pa * s;
						prx = Math.atan2(pc, pa) * spine.MathUtils.radDeg;
					}
					else {
						pa = 0;
						pc = 0;
						prx = 90 - Math.atan2(pd, pb) * spine.MathUtils.radDeg;
					}
					var rx = rotation + shearX - prx;
					var ry = rotation + shearY - prx + 90;
					var la = spine.MathUtils.cosDeg(rx) * scaleX;
					var lb = spine.MathUtils.cosDeg(ry) * scaleY;
					var lc = spine.MathUtils.sinDeg(rx) * scaleX;
					var ld = spine.MathUtils.sinDeg(ry) * scaleY;
					this.a = pa * la - pb * lc;
					this.b = pa * lb - pb * ld;
					this.c = pc * la + pd * lc;
					this.d = pc * lb + pd * ld;
					break;
				}
				case spine.TransformMode.NoScale:
				case spine.TransformMode.NoScaleOrReflection: {
					var cos = spine.MathUtils.cosDeg(rotation);
					var sin = spine.MathUtils.sinDeg(rotation);
					var za = (pa * cos + pb * sin) / this.skeleton.scaleX;
					var zc = (pc * cos + pd * sin) / this.skeleton.scaleY;
					var s = Math.sqrt(za * za + zc * zc);
					if (s > 0.00001)
						s = 1 / s;
					za *= s;
					zc *= s;
					s = Math.sqrt(za * za + zc * zc);
					if (this.data.transformMode == spine.TransformMode.NoScale
						&& (pa * pd - pb * pc < 0) != (this.skeleton.scaleX < 0 != this.skeleton.scaleY < 0))
						s = -s;
					var r = Math.PI / 2 + Math.atan2(zc, za);
					var zb = Math.cos(r) * s;
					var zd = Math.sin(r) * s;
					var la = spine.MathUtils.cosDeg(shearX) * scaleX;
					var lb = spine.MathUtils.cosDeg(90 + shearY) * scaleY;
					var lc = spine.MathUtils.sinDeg(shearX) * scaleX;
					var ld = spine.MathUtils.sinDeg(90 + shearY) * scaleY;
					this.a = za * la + zb * lc;
					this.b = za * lb + zb * ld;
					this.c = zc * la + zd * lc;
					this.d = zc * lb + zd * ld;
					break;
				}
			}
			this.a *= this.skeleton.scaleX;
			this.b *= this.skeleton.scaleX;
			this.c *= this.skeleton.scaleY;
			this.d *= this.skeleton.scaleY;
		};
		Bone.prototype.setToSetupPose = function () {
			var data = this.data;
			this.x = data.x;
			this.y = data.y;
			this.rotation = data.rotation;
			this.scaleX = data.scaleX;
			this.scaleY = data.scaleY;
			this.shearX = data.shearX;
			this.shearY = data.shearY;
		};
		Bone.prototype.getWorldRotationX = function () {
			return Math.atan2(this.c, this.a) * spine.MathUtils.radDeg;
		};
		Bone.prototype.getWorldRotationY = function () {
			return Math.atan2(this.d, this.b) * spine.MathUtils.radDeg;
		};
		Bone.prototype.getWorldScaleX = function () {
			return Math.sqrt(this.a * this.a + this.c * this.c);
		};
		Bone.prototype.getWorldScaleY = function () {
			return Math.sqrt(this.b * this.b + this.d * this.d);
		};
		Bone.prototype.updateAppliedTransform = function () {
			this.appliedValid = true;
			var parent = this.parent;
			if (parent == null) {
				this.ax = this.worldX;
				this.ay = this.worldY;
				this.arotation = Math.atan2(this.c, this.a) * spine.MathUtils.radDeg;
				this.ascaleX = Math.sqrt(this.a * this.a + this.c * this.c);
				this.ascaleY = Math.sqrt(this.b * this.b + this.d * this.d);
				this.ashearX = 0;
				this.ashearY = Math.atan2(this.a * this.b + this.c * this.d, this.a * this.d - this.b * this.c) * spine.MathUtils.radDeg;
				return;
			}
			var pa = parent.a, pb = parent.b, pc = parent.c, pd = parent.d;
			var pid = 1 / (pa * pd - pb * pc);
			var dx = this.worldX - parent.worldX, dy = this.worldY - parent.worldY;
			this.ax = (dx * pd * pid - dy * pb * pid);
			this.ay = (dy * pa * pid - dx * pc * pid);
			var ia = pid * pd;
			var id = pid * pa;
			var ib = pid * pb;
			var ic = pid * pc;
			var ra = ia * this.a - ib * this.c;
			var rb = ia * this.b - ib * this.d;
			var rc = id * this.c - ic * this.a;
			var rd = id * this.d - ic * this.b;
			this.ashearX = 0;
			this.ascaleX = Math.sqrt(ra * ra + rc * rc);
			if (this.ascaleX > 0.0001) {
				var det = ra * rd - rb * rc;
				this.ascaleY = det / this.ascaleX;
				this.ashearY = Math.atan2(ra * rb + rc * rd, det) * spine.MathUtils.radDeg;
				this.arotation = Math.atan2(rc, ra) * spine.MathUtils.radDeg;
			}
			else {
				this.ascaleX = 0;
				this.ascaleY = Math.sqrt(rb * rb + rd * rd);
				this.ashearY = 0;
				this.arotation = 90 - Math.atan2(rd, rb) * spine.MathUtils.radDeg;
			}
		};
		Bone.prototype.worldToLocal = function (world) {
			var a = this.a, b = this.b, c = this.c, d = this.d;
			var invDet = 1 / (a * d - b * c);
			var x = world.x - this.worldX, y = world.y - this.worldY;
			world.x = (x * d * invDet - y * b * invDet);
			world.y = (y * a * invDet - x * c * invDet);
			return world;
		};
		Bone.prototype.localToWorld = function (local) {
			var x = local.x, y = local.y;
			local.x = x * this.a + y * this.b + this.worldX;
			local.y = x * this.c + y * this.d + this.worldY;
			return local;
		};
		Bone.prototype.worldToLocalRotation = function (worldRotation) {
			var sin = spine.MathUtils.sinDeg(worldRotation), cos = spine.MathUtils.cosDeg(worldRotation);
			return Math.atan2(this.a * sin - this.c * cos, this.d * cos - this.b * sin) * spine.MathUtils.radDeg + this.rotation - this.shearX;
		};
		Bone.prototype.localToWorldRotation = function (localRotation) {
			localRotation -= this.rotation - this.shearX;
			var sin = spine.MathUtils.sinDeg(localRotation), cos = spine.MathUtils.cosDeg(localRotation);
			return Math.atan2(cos * this.c + sin * this.d, cos * this.a + sin * this.b) * spine.MathUtils.radDeg;
		};
		Bone.prototype.rotateWorld = function (degrees) {
			var a = this.a, b = this.b, c = this.c, d = this.d;
			var cos = spine.MathUtils.cosDeg(degrees), sin = spine.MathUtils.sinDeg(degrees);
			this.a = cos * a - sin * c;
			this.b = cos * b - sin * d;
			this.c = sin * a + cos * c;
			this.d = sin * b + cos * d;
			this.appliedValid = false;
		};
		return Bone;
	}());
	spine.Bone = Bone;
})(spine || (spine = {}));
var spine;
(function (spine) {
	var BoneData = (function () {
		function BoneData(index, name, parent) {
			this.x = 0;
			this.y = 0;
			this.rotation = 0;
			this.scaleX = 1;
			this.scaleY = 1;
			this.shearX = 0;
			this.shearY = 0;
			this.transformMode = TransformMode.Normal;
			this.skinRequired = false;
			this.color = new spine.Color();
			if (index < 0)
				throw new Error("index must be >= 0.");
			if (name == null)
				throw new Error("name cannot be null.");
			this.index = index;
			this.name = name;
			this.parent = parent;
		}
		return BoneData;
	}());
	spine.BoneData = BoneData;
	var TransformMode;
	(function (TransformMode) {
		TransformMode[TransformMode["Normal"] = 0] = "Normal";
		TransformMode[TransformMode["OnlyTranslation"] = 1] = "OnlyTranslation";
		TransformMode[TransformMode["NoRotationOrReflection"] = 2] = "NoRotationOrReflection";
		TransformMode[TransformMode["NoScale"] = 3] = "NoScale";
		TransformMode[TransformMode["NoScaleOrReflection"] = 4] = "NoScaleOrReflection";
	})(TransformMode = spine.TransformMode || (spine.TransformMode = {}));
})(spine || (spine = {}));
var spine;
(function (spine) {
	var ConstraintData = (function () {
		function ConstraintData(name, order, skinRequired) {
			this.name = name;
			this.order = order;
			this.skinRequired = skinRequired;
		}
		return ConstraintData;
	}());
	spine.ConstraintData = ConstraintData;
})(spine || (spine = {}));
var spine;
(function (spine) {
	var Event = (function () {
		function Event(time, data) {
			if (data == null)
				throw new Error("data cannot be null.");
			this.time = time;
			this.data = data;
		}
		return Event;
	}());
	spine.Event = Event;
})(spine || (spine = {}));
var spine;
(function (spine) {
	var EventData = (function () {
		function EventData(name) {
			this.name = name;
		}
		return EventData;
	}());
	spine.EventData = EventData;
})(spine || (spine = {}));
var spine;
(function (spine) {
	var IkConstraint = (function () {
		function IkConstraint(data, skeleton) {
			this.bendDirection = 0;
			this.compress = false;
			this.stretch = false;
			this.mix = 1;
			this.softness = 0;
			this.active = false;
			if (data == null)
				throw new Error("data cannot be null.");
			if (skeleton == null)
				throw new Error("skeleton cannot be null.");
			this.data = data;
			this.mix = data.mix;
			this.softness = data.softness;
			this.bendDirection = data.bendDirection;
			this.compress = data.compress;
			this.stretch = data.stretch;
			this.bones = new Array();
			for (var i = 0; i < data.bones.length; i++)
				this.bones.push(skeleton.findBone(data.bones[i].name));
			this.target = skeleton.findBone(data.target.name);
		}
		IkConstraint.prototype.isActive = function () {
			return this.active;
		};
		IkConstraint.prototype.apply = function () {
			this.update();
		};
		IkConstraint.prototype.update = function () {
			var target = this.target;
			var bones = this.bones;
			switch (bones.length) {
				case 1:
					this.apply1(bones[0], target.worldX, target.worldY, this.compress, this.stretch, this.data.uniform, this.mix);
					break;
				case 2:
					this.apply2(bones[0], bones[1], target.worldX, target.worldY, this.bendDirection, this.stretch, this.softness, this.mix);
					break;
			}
		};
		IkConstraint.prototype.apply1 = function (bone, targetX, targetY, compress, stretch, uniform, alpha) {
			if (!bone.appliedValid)
				bone.updateAppliedTransform();
			var p = bone.parent;
			var pa = p.a, pb = p.b, pc = p.c, pd = p.d;
			var rotationIK = -bone.ashearX - bone.arotation, tx = 0, ty = 0;
			switch (bone.data.transformMode) {
				case spine.TransformMode.OnlyTranslation:
					tx = targetX - bone.worldX;
					ty = targetY - bone.worldY;
					break;
				case spine.TransformMode.NoRotationOrReflection:
					rotationIK += Math.atan2(pc, pa) * spine.MathUtils.radDeg;
					var ps = Math.abs(pa * pd - pb * pc) / (pa * pa + pc * pc);
					pb = -pc * ps;
					pd = pa * ps;
				default:
					var x = targetX - p.worldX, y = targetY - p.worldY;
					var d = pa * pd - pb * pc;
					tx = (x * pd - y * pb) / d - bone.ax;
					ty = (y * pa - x * pc) / d - bone.ay;
			}
			rotationIK += Math.atan2(ty, tx) * spine.MathUtils.radDeg;
			if (bone.ascaleX < 0)
				rotationIK += 180;
			if (rotationIK > 180)
				rotationIK -= 360;
			else if (rotationIK < -180)
				rotationIK += 360;
			var sx = bone.ascaleX, sy = bone.ascaleY;
			if (compress || stretch) {
				switch (bone.data.transformMode) {
					case spine.TransformMode.NoScale:
					case spine.TransformMode.NoScaleOrReflection:
						tx = targetX - bone.worldX;
						ty = targetY - bone.worldY;
				}
				var b = bone.data.length * sx, dd = Math.sqrt(tx * tx + ty * ty);
				if ((compress && dd < b) || (stretch && dd > b) && b > 0.0001) {
					var s = (dd / b - 1) * alpha + 1;
					sx *= s;
					if (uniform)
						sy *= s;
				}
			}
			bone.updateWorldTransformWith(bone.ax, bone.ay, bone.arotation + rotationIK * alpha, sx, sy, bone.ashearX, bone.ashearY);
		};
		IkConstraint.prototype.apply2 = function (parent, child, targetX, targetY, bendDir, stretch, softness, alpha) {
			if (alpha == 0) {
				child.updateWorldTransform();
				return;
			}
			if (!parent.appliedValid)
				parent.updateAppliedTransform();
			if (!child.appliedValid)
				child.updateAppliedTransform();
			var px = parent.ax, py = parent.ay, psx = parent.ascaleX, sx = psx, psy = parent.ascaleY, csx = child.ascaleX;
			var os1 = 0, os2 = 0, s2 = 0;
			if (psx < 0) {
				psx = -psx;
				os1 = 180;
				s2 = -1;
			}
			else {
				os1 = 0;
				s2 = 1;
			}
			if (psy < 0) {
				psy = -psy;
				s2 = -s2;
			}
			if (csx < 0) {
				csx = -csx;
				os2 = 180;
			}
			else
				os2 = 0;
			var cx = child.ax, cy = 0, cwx = 0, cwy = 0, a = parent.a, b = parent.b, c = parent.c, d = parent.d;
			var u = Math.abs(psx - psy) <= 0.0001;
			if (!u) {
				cy = 0;
				cwx = a * cx + parent.worldX;
				cwy = c * cx + parent.worldY;
			}
			else {
				cy = child.ay;
				cwx = a * cx + b * cy + parent.worldX;
				cwy = c * cx + d * cy + parent.worldY;
			}
			var pp = parent.parent;
			a = pp.a;
			b = pp.b;
			c = pp.c;
			d = pp.d;
			var id = 1 / (a * d - b * c), x = cwx - pp.worldX, y = cwy - pp.worldY;
			var dx = (x * d - y * b) * id - px, dy = (y * a - x * c) * id - py;
			var l1 = Math.sqrt(dx * dx + dy * dy), l2 = child.data.length * csx, a1, a2;
			if (l1 < 0.0001) {
				this.apply1(parent, targetX, targetY, false, stretch, false, alpha);
				child.updateWorldTransformWith(cx, cy, 0, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);
				return;
			}
			x = targetX - pp.worldX;
			y = targetY - pp.worldY;
			var tx = (x * d - y * b) * id - px, ty = (y * a - x * c) * id - py;
			var dd = tx * tx + ty * ty;
			if (softness != 0) {
				softness *= psx * (csx + 1) / 2;
				var td = Math.sqrt(dd), sd = td - l1 - l2 * psx + softness;
				if (sd > 0) {
					var p = Math.min(1, sd / (softness * 2)) - 1;
					p = (sd - softness * (1 - p * p)) / td;
					tx -= p * tx;
					ty -= p * ty;
					dd = tx * tx + ty * ty;
				}
			}
			outer: if (u) {
				l2 *= psx;
				var cos = (dd - l1 * l1 - l2 * l2) / (2 * l1 * l2);
				if (cos < -1)
					cos = -1;
				else if (cos > 1) {
					cos = 1;
					if (stretch)
						sx *= (Math.sqrt(dd) / (l1 + l2) - 1) * alpha + 1;
				}
				a2 = Math.acos(cos) * bendDir;
				a = l1 + l2 * cos;
				b = l2 * Math.sin(a2);
				a1 = Math.atan2(ty * a - tx * b, tx * a + ty * b);
			}
			else {
				a = psx * l2;
				b = psy * l2;
				var aa = a * a, bb = b * b, ta = Math.atan2(ty, tx);
				c = bb * l1 * l1 + aa * dd - aa * bb;
				var c1 = -2 * bb * l1, c2 = bb - aa;
				d = c1 * c1 - 4 * c2 * c;
				if (d >= 0) {
					var q = Math.sqrt(d);
					if (c1 < 0)
						q = -q;
					q = -(c1 + q) / 2;
					var r0 = q / c2, r1 = c / q;
					var r = Math.abs(r0) < Math.abs(r1) ? r0 : r1;
					if (r * r <= dd) {
						y = Math.sqrt(dd - r * r) * bendDir;
						a1 = ta - Math.atan2(y, r);
						a2 = Math.atan2(y / psy, (r - l1) / psx);
						break outer;
					}
				}
				var minAngle = spine.MathUtils.PI, minX = l1 - a, minDist = minX * minX, minY = 0;
				var maxAngle = 0, maxX = l1 + a, maxDist = maxX * maxX, maxY = 0;
				c = -a * l1 / (aa - bb);
				if (c >= -1 && c <= 1) {
					c = Math.acos(c);
					x = a * Math.cos(c) + l1;
					y = b * Math.sin(c);
					d = x * x + y * y;
					if (d < minDist) {
						minAngle = c;
						minDist = d;
						minX = x;
						minY = y;
					}
					if (d > maxDist) {
						maxAngle = c;
						maxDist = d;
						maxX = x;
						maxY = y;
					}
				}
				if (dd <= (minDist + maxDist) / 2) {
					a1 = ta - Math.atan2(minY * bendDir, minX);
					a2 = minAngle * bendDir;
				}
				else {
					a1 = ta - Math.atan2(maxY * bendDir, maxX);
					a2 = maxAngle * bendDir;
				}
			}
			var os = Math.atan2(cy, cx) * s2;
			var rotation = parent.arotation;
			a1 = (a1 - os) * spine.MathUtils.radDeg + os1 - rotation;
			if (a1 > 180)
				a1 -= 360;
			else if (a1 < -180)
				a1 += 360;
			parent.updateWorldTransformWith(px, py, rotation + a1 * alpha, sx, parent.ascaleY, 0, 0);
			rotation = child.arotation;
			a2 = ((a2 + os) * spine.MathUtils.radDeg - child.ashearX) * s2 + os2 - rotation;
			if (a2 > 180)
				a2 -= 360;
			else if (a2 < -180)
				a2 += 360;
			child.updateWorldTransformWith(cx, cy, rotation + a2 * alpha, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);
		};
		return IkConstraint;
	}());
	spine.IkConstraint = IkConstraint;
})(spine || (spine = {}));
var spine;
(function (spine) {
	var IkConstraintData = (function (_super) {
		__extends(IkConstraintData, _super);
		function IkConstraintData(name) {
			var _this = _super.call(this, name, 0, false) || this;
			_this.bones = new Array();
			_this.bendDirection = 1;
			_this.compress = false;
			_this.stretch = false;
			_this.uniform = false;
			_this.mix = 1;
			_this.softness = 0;
			return _this;
		}
		return IkConstraintData;
	}(spine.ConstraintData));
	spine.IkConstraintData = IkConstraintData;
})(spine || (spine = {}));
var spine;
(function (spine) {
	var PathConstraint = (function () {
		function PathConstraint(data, skeleton) {
			this.position = 0;
			this.spacing = 0;
			this.rotateMix = 0;
			this.translateMix = 0;
			this.spaces = new Array();
			this.positions = new Array();
			this.world = new Array();
			this.curves = new Array();
			this.lengths = new Array();
			this.segments = new Array();
			this.active = false;
			if (data == null)
				throw new Error("data cannot be null.");
			if (skeleton == null)
				throw new Error("skeleton cannot be null.");
			this.data = data;
			this.bones = new Array();
			for (var i = 0, n = data.bones.length; i < n; i++)
				this.bones.push(skeleton.findBone(data.bones[i].name));
			this.target = skeleton.findSlot(data.target.name);
			this.position = data.position;
			this.spacing = data.spacing;
			this.rotateMix = data.rotateMix;
			this.translateMix = data.translateMix;
		}
		PathConstraint.prototype.isActive = function () {
			return this.active;
		};
		PathConstraint.prototype.apply = function () {
			this.update();
		};
		PathConstraint.prototype.update = function () {
			var attachment = this.target.getAttachment();
			if (!(attachment instanceof spine.PathAttachment))
				return;
			var rotateMix = this.rotateMix, translateMix = this.translateMix;
			var translate = translateMix > 0, rotate = rotateMix > 0;
			if (!translate && !rotate)
				return;
			var data = this.data;
			var percentSpacing = data.spacingMode == spine.SpacingMode.Percent;
			var rotateMode = data.rotateMode;
			var tangents = rotateMode == spine.RotateMode.Tangent, scale = rotateMode == spine.RotateMode.ChainScale;
			var boneCount = this.bones.length, spacesCount = tangents ? boneCount : boneCount + 1;
			var bones = this.bones;
			var spaces = spine.Utils.setArraySize(this.spaces, spacesCount), lengths = null;
			var spacing = this.spacing;
			if (scale || !percentSpacing) {
				if (scale)
					lengths = spine.Utils.setArraySize(this.lengths, boneCount);
				var lengthSpacing = data.spacingMode == spine.SpacingMode.Length;
				for (var i = 0, n = spacesCount - 1; i < n;) {
					var bone = bones[i];
					var setupLength = bone.data.length;
					if (setupLength < PathConstraint.epsilon) {
						if (scale)
							lengths[i] = 0;
						spaces[++i] = 0;
					}
					else if (percentSpacing) {
						if (scale) {
							var x = setupLength * bone.a, y = setupLength * bone.c;
							var length_1 = Math.sqrt(x * x + y * y);
							lengths[i] = length_1;
						}
						spaces[++i] = spacing;
					}
					else {
						var x = setupLength * bone.a, y = setupLength * bone.c;
						var length_2 = Math.sqrt(x * x + y * y);
						if (scale)
							lengths[i] = length_2;
						spaces[++i] = (lengthSpacing ? setupLength + spacing : spacing) * length_2 / setupLength;
					}
				}
			}
			else {
				for (var i = 1; i < spacesCount; i++)
					spaces[i] = spacing;
			}
			var positions = this.computeWorldPositions(attachment, spacesCount, tangents, data.positionMode == spine.PositionMode.Percent, percentSpacing);
			var boneX = positions[0], boneY = positions[1], offsetRotation = data.offsetRotation;
			var tip = false;
			if (offsetRotation == 0)
				tip = rotateMode == spine.RotateMode.Chain;
			else {
				tip = false;
				var p = this.target.bone;
				offsetRotation *= p.a * p.d - p.b * p.c > 0 ? spine.MathUtils.degRad : -spine.MathUtils.degRad;
			}
			for (var i = 0, p = 3; i < boneCount; i++, p += 3) {
				var bone = bones[i];
				bone.worldX += (boneX - bone.worldX) * translateMix;
				bone.worldY += (boneY - bone.worldY) * translateMix;
				var x = positions[p], y = positions[p + 1], dx = x - boneX, dy = y - boneY;
				if (scale) {
					var length_3 = lengths[i];
					if (length_3 != 0) {
						var s = (Math.sqrt(dx * dx + dy * dy) / length_3 - 1) * rotateMix + 1;
						bone.a *= s;
						bone.c *= s;
					}
				}
				boneX = x;
				boneY = y;
				if (rotate) {
					var a = bone.a, b = bone.b, c = bone.c, d = bone.d, r = 0, cos = 0, sin = 0;
					if (tangents)
						r = positions[p - 1];
					else if (spaces[i + 1] == 0)
						r = positions[p + 2];
					else
						r = Math.atan2(dy, dx);
					r -= Math.atan2(c, a);
					if (tip) {
						cos = Math.cos(r);
						sin = Math.sin(r);
						var length_4 = bone.data.length;
						boneX += (length_4 * (cos * a - sin * c) - dx) * rotateMix;
						boneY += (length_4 * (sin * a + cos * c) - dy) * rotateMix;
					}
					else {
						r += offsetRotation;
					}
					if (r > spine.MathUtils.PI)
						r -= spine.MathUtils.PI2;
					else if (r < -spine.MathUtils.PI)
						r += spine.MathUtils.PI2;
					r *= rotateMix;
					cos = Math.cos(r);
					sin = Math.sin(r);
					bone.a = cos * a - sin * c;
					bone.b = cos * b - sin * d;
					bone.c = sin * a + cos * c;
					bone.d = sin * b + cos * d;
				}
				bone.appliedValid = false;
			}
		};
		PathConstraint.prototype.computeWorldPositions = function (path, spacesCount, tangents, percentPosition, percentSpacing) {
			var target = this.target;
			var position = this.position;
			var spaces = this.spaces, out = spine.Utils.setArraySize(this.positions, spacesCount * 3 + 2), world = null;
			var closed = path.closed;
			var verticesLength = path.worldVerticesLength, curveCount = verticesLength / 6, prevCurve = PathConstraint.NONE;
			if (!path.constantSpeed) {
				var lengths = path.lengths;
				curveCount -= closed ? 1 : 2;
				var pathLength_1 = lengths[curveCount];
				if (percentPosition)
					position *= pathLength_1;
				if (percentSpacing) {
					for (var i = 1; i < spacesCount; i++)
						spaces[i] *= pathLength_1;
				}
				world = spine.Utils.setArraySize(this.world, 8);
				for (var i = 0, o = 0, curve = 0; i < spacesCount; i++, o += 3) {
					var space = spaces[i];
					position += space;
					var p = position;
					if (closed) {
						p %= pathLength_1;
						if (p < 0)
							p += pathLength_1;
						curve = 0;
					}
					else if (p < 0) {
						if (prevCurve != PathConstraint.BEFORE) {
							prevCurve = PathConstraint.BEFORE;
							path.computeWorldVertices(target, 2, 4, world, 0, 2);
						}
						this.addBeforePosition(p, world, 0, out, o);
						continue;
					}
					else if (p > pathLength_1) {
						if (prevCurve != PathConstraint.AFTER) {
							prevCurve = PathConstraint.AFTER;
							path.computeWorldVertices(target, verticesLength - 6, 4, world, 0, 2);
						}
						this.addAfterPosition(p - pathLength_1, world, 0, out, o);
						continue;
					}
					for (;; curve++) {
						var length_5 = lengths[curve];
						if (p > length_5)
							continue;
						if (curve == 0)
							p /= length_5;
						else {
							var prev = lengths[curve - 1];
							p = (p - prev) / (length_5 - prev);
						}
						break;
					}
					if (curve != prevCurve) {
						prevCurve = curve;
						if (closed && curve == curveCount) {
							path.computeWorldVertices(target, verticesLength - 4, 4, world, 0, 2);
							path.computeWorldVertices(target, 0, 4, world, 4, 2);
						}
						else
							path.computeWorldVertices(target, curve * 6 + 2, 8, world, 0, 2);
					}
					this.addCurvePosition(p, world[0], world[1], world[2], world[3], world[4], world[5], world[6], world[7], out, o, tangents || (i > 0 && space == 0));
				}
				return out;
			}
			if (closed) {
				verticesLength += 2;
				world = spine.Utils.setArraySize(this.world, verticesLength);
				path.computeWorldVertices(target, 2, verticesLength - 4, world, 0, 2);
				path.computeWorldVertices(target, 0, 2, world, verticesLength - 4, 2);
				world[verticesLength - 2] = world[0];
				world[verticesLength - 1] = world[1];
			}
			else {
				curveCount--;
				verticesLength -= 4;
				world = spine.Utils.setArraySize(this.world, verticesLength);
				path.computeWorldVertices(target, 2, verticesLength, world, 0, 2);
			}
			var curves = spine.Utils.setArraySize(this.curves, curveCount);
			var pathLength = 0;
			var x1 = world[0], y1 = world[1], cx1 = 0, cy1 = 0, cx2 = 0, cy2 = 0, x2 = 0, y2 = 0;
			var tmpx = 0, tmpy = 0, dddfx = 0, dddfy = 0, ddfx = 0, ddfy = 0, dfx = 0, dfy = 0;
			for (var i = 0, w = 2; i < curveCount; i++, w += 6) {
				cx1 = world[w];
				cy1 = world[w + 1];
				cx2 = world[w + 2];
				cy2 = world[w + 3];
				x2 = world[w + 4];
				y2 = world[w + 5];
				tmpx = (x1 - cx1 * 2 + cx2) * 0.1875;
				tmpy = (y1 - cy1 * 2 + cy2) * 0.1875;
				dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.09375;
				dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.09375;
				ddfx = tmpx * 2 + dddfx;
				ddfy = tmpy * 2 + dddfy;
				dfx = (cx1 - x1) * 0.75 + tmpx + dddfx * 0.16666667;
				dfy = (cy1 - y1) * 0.75 + tmpy + dddfy * 0.16666667;
				pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
				dfx += ddfx;
				dfy += ddfy;
				ddfx += dddfx;
				ddfy += dddfy;
				pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
				dfx += ddfx;
				dfy += ddfy;
				pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
				dfx += ddfx + dddfx;
				dfy += ddfy + dddfy;
				pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
				curves[i] = pathLength;
				x1 = x2;
				y1 = y2;
			}
			if (percentPosition)
				position *= pathLength;
			else
				position *= pathLength / path.lengths[curveCount - 1];
			if (percentSpacing) {
				for (var i = 1; i < spacesCount; i++)
					spaces[i] *= pathLength;
			}
			var segments = this.segments;
			var curveLength = 0;
			for (var i = 0, o = 0, curve = 0, segment = 0; i < spacesCount; i++, o += 3) {
				var space = spaces[i];
				position += space;
				var p = position;
				if (closed) {
					p %= pathLength;
					if (p < 0)
						p += pathLength;
					curve = 0;
				}
				else if (p < 0) {
					this.addBeforePosition(p, world, 0, out, o);
					continue;
				}
				else if (p > pathLength) {
					this.addAfterPosition(p - pathLength, world, verticesLength - 4, out, o);
					continue;
				}
				for (;; curve++) {
					var length_6 = curves[curve];
					if (p > length_6)
						continue;
					if (curve == 0)
						p /= length_6;
					else {
						var prev = curves[curve - 1];
						p = (p - prev) / (length_6 - prev);
					}
					break;
				}
				if (curve != prevCurve) {
					prevCurve = curve;
					var ii = curve * 6;
					x1 = world[ii];
					y1 = world[ii + 1];
					cx1 = world[ii + 2];
					cy1 = world[ii + 3];
					cx2 = world[ii + 4];
					cy2 = world[ii + 5];
					x2 = world[ii + 6];
					y2 = world[ii + 7];
					tmpx = (x1 - cx1 * 2 + cx2) * 0.03;
					tmpy = (y1 - cy1 * 2 + cy2) * 0.03;
					dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.006;
					dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.006;
					ddfx = tmpx * 2 + dddfx;
					ddfy = tmpy * 2 + dddfy;
					dfx = (cx1 - x1) * 0.3 + tmpx + dddfx * 0.16666667;
					dfy = (cy1 - y1) * 0.3 + tmpy + dddfy * 0.16666667;
					curveLength = Math.sqrt(dfx * dfx + dfy * dfy);
					segments[0] = curveLength;
					for (ii = 1; ii < 8; ii++) {
						dfx += ddfx;
						dfy += ddfy;
						ddfx += dddfx;
						ddfy += dddfy;
						curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
						segments[ii] = curveLength;
					}
					dfx += ddfx;
					dfy += ddfy;
					curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
					segments[8] = curveLength;
					dfx += ddfx + dddfx;
					dfy += ddfy + dddfy;
					curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
					segments[9] = curveLength;
					segment = 0;
				}
				p *= curveLength;
				for (;; segment++) {
					var length_7 = segments[segment];
					if (p > length_7)
						continue;
					if (segment == 0)
						p /= length_7;
					else {
						var prev = segments[segment - 1];
						p = segment + (p - prev) / (length_7 - prev);
					}
					break;
				}
				this.addCurvePosition(p * 0.1, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents || (i > 0 && space == 0));
			}
			return out;
		};
		PathConstraint.prototype.addBeforePosition = function (p, temp, i, out, o) {
			var x1 = temp[i], y1 = temp[i + 1], dx = temp[i + 2] - x1, dy = temp[i + 3] - y1, r = Math.atan2(dy, dx);
			out[o] = x1 + p * Math.cos(r);
			out[o + 1] = y1 + p * Math.sin(r);
			out[o + 2] = r;
		};
		PathConstraint.prototype.addAfterPosition = function (p, temp, i, out, o) {
			var x1 = temp[i + 2], y1 = temp[i + 3], dx = x1 - temp[i], dy = y1 - temp[i + 1], r = Math.atan2(dy, dx);
			out[o] = x1 + p * Math.cos(r);
			out[o + 1] = y1 + p * Math.sin(r);
			out[o + 2] = r;
		};
		PathConstraint.prototype.addCurvePosition = function (p, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents) {
			if (p == 0 || isNaN(p)) {
				out[o] = x1;
				out[o + 1] = y1;
				out[o + 2] = Math.atan2(cy1 - y1, cx1 - x1);
				return;
			}
			var tt = p * p, ttt = tt * p, u = 1 - p, uu = u * u, uuu = uu * u;
			var ut = u * p, ut3 = ut * 3, uut3 = u * ut3, utt3 = ut3 * p;
			var x = x1 * uuu + cx1 * uut3 + cx2 * utt3 + x2 * ttt, y = y1 * uuu + cy1 * uut3 + cy2 * utt3 + y2 * ttt;
			out[o] = x;
			out[o + 1] = y;
			if (tangents) {
				if (p < 0.001)
					out[o + 2] = Math.atan2(cy1 - y1, cx1 - x1);
				else
					out[o + 2] = Math.atan2(y - (y1 * uu + cy1 * ut * 2 + cy2 * tt), x - (x1 * uu + cx1 * ut * 2 + cx2 * tt));
			}
		};
		PathConstraint.NONE = -1;
		PathConstraint.BEFORE = -2;
		PathConstraint.AFTER = -3;
		PathConstraint.epsilon = 0.00001;
		return PathConstraint;
	}());
	spine.PathConstraint = PathConstraint;
})(spine || (spine = {}));
var spine;
(function (spine) {
	var PathConstraintData = (function (_super) {
		__extends(PathConstraintData, _super);
		function PathConstraintData(name) {
			var _this = _super.call(this, name, 0, false) || this;
			_this.bones = new Array();
			return _this;
		}
		return PathConstraintData;
	}(spine.ConstraintData));
	spine.PathConstraintData = PathConstraintData;
	var PositionMode;
	(function (PositionMode) {
		PositionMode[PositionMode["Fixed"] = 0] = "Fixed";
		PositionMode[PositionMode["Percent"] = 1] = "Percent";
	})(PositionMode = spine.PositionMode || (spine.PositionMode = {}));
	var SpacingMode;
	(function (SpacingMode) {
		SpacingMode[SpacingMode["Length"] = 0] = "Length";
		SpacingMode[SpacingMode["Fixed"] = 1] = "Fixed";
		SpacingMode[SpacingMode["Percent"] = 2] = "Percent";
	})(SpacingMode = spine.SpacingMode || (spine.SpacingMode = {}));
	var RotateMode;
	(function (RotateMode) {
		RotateMode[RotateMode["Tangent"] = 0] = "Tangent";
		RotateMode[RotateMode["Chain"] = 1] = "Chain";
		RotateMode[RotateMode["ChainScale"] = 2] = "ChainScale";
	})(RotateMode = spine.RotateMode || (spine.RotateMode = {}));
})(spine || (spine = {}));
var spine;
(function (spine) {
	var Assets = (function () {
		function Assets(clientId) {
			this.toLoad = new Array();
			this.assets = {};
			this.clientId = clientId;
		}
		Assets.prototype.loaded = function () {
			var i = 0;
			for (var v in this.assets)
				i++;
			return i;
		};
		return Assets;
	}());
	var SharedAssetManager = (function () {
		function SharedAssetManager(pathPrefix) {
			if (pathPrefix === void 0) { pathPrefix = ""; }
			this.clientAssets = {};
			this.queuedAssets = {};
			this.rawAssets = {};
			this.errors = {};
			this.pathPrefix = pathPrefix;
		}
		SharedAssetManager.prototype.queueAsset = function (clientId, textureLoader, path) {
			var clientAssets = this.clientAssets[clientId];
			if (clientAssets === null || clientAssets === undefined) {
				clientAssets = new Assets(clientId);
				this.clientAssets[clientId] = clientAssets;
			}
			if (textureLoader !== null)
				clientAssets.textureLoader = textureLoader;
			clientAssets.toLoad.push(path);
			if (this.queuedAssets[path] === path) {
				return false;
			}
			else {
				this.queuedAssets[path] = path;
				return true;
			}
		};
		SharedAssetManager.prototype.loadText = function (clientId, path) {
			var _this = this;
			path = this.pathPrefix + path;
			if (!this.queueAsset(clientId, null, path))
				return;
			var request = new XMLHttpRequest();
			request.overrideMimeType("text/html");
			request.onreadystatechange = function () {
				if (request.readyState == XMLHttpRequest.DONE) {
					if (request.status >= 200 && request.status < 300) {
						_this.rawAssets[path] = request.responseText;
					}
					else {
						_this.errors[path] = "Couldn't load text " + path + ": status " + request.status + ", " + request.responseText;
					}
				}
			};
			request.open("GET", path, true);
			request.send();
		};
		SharedAssetManager.prototype.loadJson = function (clientId, path) {
			var _this = this;
			path = this.pathPrefix + path;
			if (!this.queueAsset(clientId, null, path))
				return;
			var request = new XMLHttpRequest();
			request.overrideMimeType("text/html");
			request.onreadystatechange = function () {
				if (request.readyState == XMLHttpRequest.DONE) {
					if (request.status >= 200 && request.status < 300) {
						_this.rawAssets[path] = JSON.parse(request.responseText);
					}
					else {
						_this.errors[path] = "Couldn't load text " + path + ": status " + request.status + ", " + request.responseText;
					}
				}
			};
			request.open("GET", path, true);
			request.send();
		};
		SharedAssetManager.prototype.loadTexture = function (clientId, textureLoader, path) {
			var _this = this;
			path = this.pathPrefix + path;
			if (!this.queueAsset(clientId, textureLoader, path))
				return;
			var img = new Image();
			img.crossOrigin = "anonymous";
			img.onload = function (ev) {
				_this.rawAssets[path] = img;
			};
			img.onerror = function (ev) {
				_this.errors[path] = "Couldn't load image " + path;
			};
			img.src = path;
		};
		SharedAssetManager.prototype.get = function (clientId, path) {
			path = this.pathPrefix + path;
			var clientAssets = this.clientAssets[clientId];
			if (clientAssets === null || clientAssets === undefined)
				return true;
			return clientAssets.assets[path];
		};
		SharedAssetManager.prototype.updateClientAssets = function (clientAssets) {
			for (var i = 0; i < clientAssets.toLoad.length; i++) {
				var path = clientAssets.toLoad[i];
				var asset = clientAssets.assets[path];
				if (asset === null || asset === undefined) {
					var rawAsset = this.rawAssets[path];
					if (rawAsset === null || rawAsset === undefined)
						continue;
					if (rawAsset instanceof HTMLImageElement) {
						clientAssets.assets[path] = clientAssets.textureLoader(rawAsset);
					}
					else {
						clientAssets.assets[path] = rawAsset;
					}
				}
			}
		};
		SharedAssetManager.prototype.isLoadingComplete = function (clientId) {
			var clientAssets = this.clientAssets[clientId];
			if (clientAssets === null || clientAssets === undefined)
				return true;
			this.updateClientAssets(clientAssets);
			return clientAssets.toLoad.length == clientAssets.loaded();
		};
		SharedAssetManager.prototype.dispose = function () {
		};
		SharedAssetManager.prototype.hasErrors = function () {
			return Object.keys(this.errors).length > 0;
		};
		SharedAssetManager.prototype.getErrors = function () {
			return this.errors;
		};
		return SharedAssetManager;
	}());
	spine.SharedAssetManager = SharedAssetManager;
})(spine || (spine = {}));
var spine;
(function (spine) {
	var Skeleton = (function () {
		function Skeleton(data) {
			this._updateCache = new Array();
			this.updateCacheReset = new Array();
			this.time = 0;
			this.scaleX = 1;
			this.scaleY = 1;
			this.x = 0;
			this.y = 0;
			if (data == null)
				throw new Error("data cannot be null.");
			this.data = data;
			this.bones = new Array();
			for (var i = 0; i < data.bones.length; i++) {
				var boneData = data.bones[i];
				var bone = void 0;
				if (boneData.parent == null)
					bone = new spine.Bone(boneData, this, null);
				else {
					var parent_1 = this.bones[boneData.parent.index];
					bone = new spine.Bone(boneData, this, parent_1);
					parent_1.children.push(bone);
				}
				this.bones.push(bone);
			}
			this.slots = new Array();
			this.drawOrder = new Array();
			for (var i = 0; i < data.slots.length; i++) {
				var slotData = data.slots[i];
				var bone = this.bones[slotData.boneData.index];
				var slot = new spine.Slot(slotData, bone);
				this.slots.push(slot);
				this.drawOrder.push(slot);
			}
			this.ikConstraints = new Array();
			for (var i = 0; i < data.ikConstraints.length; i++) {
				var ikConstraintData = data.ikConstraints[i];
				this.ikConstraints.push(new spine.IkConstraint(ikConstraintData, this));
			}
			this.transformConstraints = new Array();
			for (var i = 0; i < data.transformConstraints.length; i++) {
				var transformConstraintData = data.transformConstraints[i];
				this.transformConstraints.push(new spine.TransformConstraint(transformConstraintData, this));
			}
			this.pathConstraints = new Array();
			for (var i = 0; i < data.pathConstraints.length; i++) {
				var pathConstraintData = data.pathConstraints[i];
				this.pathConstraints.push(new spine.PathConstraint(pathConstraintData, this));
			}
			this.color = new spine.Color(1, 1, 1, 1);
			this.updateCache();
		}
		Skeleton.prototype.updateCache = function () {
			var updateCache = this._updateCache;
			updateCache.length = 0;
			this.updateCacheReset.length = 0;
			var bones = this.bones;
			for (var i = 0, n = bones.length; i < n; i++) {
				var bone = bones[i];
				bone.sorted = bone.data.skinRequired;
				bone.active = !bone.sorted;
			}
			if (this.skin != null) {
				var skinBones = this.skin.bones;
				for (var i = 0, n = this.skin.bones.length; i < n; i++) {
					var bone = this.bones[skinBones[i].index];
					do {
						bone.sorted = false;
						bone.active = true;
						bone = bone.parent;
					} while (bone != null);
				}
			}
			var ikConstraints = this.ikConstraints;
			var transformConstraints = this.transformConstraints;
			var pathConstraints = this.pathConstraints;
			var ikCount = ikConstraints.length, transformCount = transformConstraints.length, pathCount = pathConstraints.length;
			var constraintCount = ikCount + transformCount + pathCount;
			outer: for (var i = 0; i < constraintCount; i++) {
				for (var ii = 0; ii < ikCount; ii++) {
					var constraint = ikConstraints[ii];
					if (constraint.data.order == i) {
						this.sortIkConstraint(constraint);
						continue outer;
					}
				}
				for (var ii = 0; ii < transformCount; ii++) {
					var constraint = transformConstraints[ii];
					if (constraint.data.order == i) {
						this.sortTransformConstraint(constraint);
						continue outer;
					}
				}
				for (var ii = 0; ii < pathCount; ii++) {
					var constraint = pathConstraints[ii];
					if (constraint.data.order == i) {
						this.sortPathConstraint(constraint);
						continue outer;
					}
				}
			}
			for (var i = 0, n = bones.length; i < n; i++)
				this.sortBone(bones[i]);
		};
		Skeleton.prototype.sortIkConstraint = function (constraint) {
			constraint.active = constraint.target.isActive() && (!constraint.data.skinRequired || (this.skin != null && spine.Utils.contains(this.skin.constraints, constraint.data, true)));
			if (!constraint.active)
				return;
			var target = constraint.target;
			this.sortBone(target);
			var constrained = constraint.bones;
			var parent = constrained[0];
			this.sortBone(parent);
			if (constrained.length > 1) {
				var child = constrained[constrained.length - 1];
				if (!(this._updateCache.indexOf(child) > -1))
					this.updateCacheReset.push(child);
			}
			this._updateCache.push(constraint);
			this.sortReset(parent.children);
			constrained[constrained.length - 1].sorted = true;
		};
		Skeleton.prototype.sortPathConstraint = function (constraint) {
			constraint.active = constraint.target.bone.isActive() && (!constraint.data.skinRequired || (this.skin != null && spine.Utils.contains(this.skin.constraints, constraint.data, true)));
			if (!constraint.active)
				return;
			var slot = constraint.target;
			var slotIndex = slot.data.index;
			var slotBone = slot.bone;
			if (this.skin != null)
				this.sortPathConstraintAttachment(this.skin, slotIndex, slotBone);
			if (this.data.defaultSkin != null && this.data.defaultSkin != this.skin)
				this.sortPathConstraintAttachment(this.data.defaultSkin, slotIndex, slotBone);
			for (var i = 0, n = this.data.skins.length; i < n; i++)
				this.sortPathConstraintAttachment(this.data.skins[i], slotIndex, slotBone);
			var attachment = slot.getAttachment();
			if (attachment instanceof spine.PathAttachment)
				this.sortPathConstraintAttachmentWith(attachment, slotBone);
			var constrained = constraint.bones;
			var boneCount = constrained.length;
			for (var i = 0; i < boneCount; i++)
				this.sortBone(constrained[i]);
			this._updateCache.push(constraint);
			for (var i = 0; i < boneCount; i++)
				this.sortReset(constrained[i].children);
			for (var i = 0; i < boneCount; i++)
				constrained[i].sorted = true;
		};
		Skeleton.prototype.sortTransformConstraint = function (constraint) {
			constraint.active = constraint.target.isActive() && (!constraint.data.skinRequired || (this.skin != null && spine.Utils.contains(this.skin.constraints, constraint.data, true)));
			if (!constraint.active)
				return;
			this.sortBone(constraint.target);
			var constrained = constraint.bones;
			var boneCount = constrained.length;
			if (constraint.data.local) {
				for (var i = 0; i < boneCount; i++) {
					var child = constrained[i];
					this.sortBone(child.parent);
					if (!(this._updateCache.indexOf(child) > -1))
						this.updateCacheReset.push(child);
				}
			}
			else {
				for (var i = 0; i < boneCount; i++) {
					this.sortBone(constrained[i]);
				}
			}
			this._updateCache.push(constraint);
			for (var ii = 0; ii < boneCount; ii++)
				this.sortReset(constrained[ii].children);
			for (var ii = 0; ii < boneCount; ii++)
				constrained[ii].sorted = true;
		};
		Skeleton.prototype.sortPathConstraintAttachment = function (skin, slotIndex, slotBone) {
			var attachments = skin.attachments[slotIndex];
			if (!attachments)
				return;
			for (var key in attachments) {
				this.sortPathConstraintAttachmentWith(attachments[key], slotBone);
			}
		};
		Skeleton.prototype.sortPathConstraintAttachmentWith = function (attachment, slotBone) {
			if (!(attachment instanceof spine.PathAttachment))
				return;
			var pathBones = attachment.bones;
			if (pathBones == null)
				this.sortBone(slotBone);
			else {
				var bones = this.bones;
				var i = 0;
				while (i < pathBones.length) {
					var boneCount = pathBones[i++];
					for (var n = i + boneCount; i < n; i++) {
						var boneIndex = pathBones[i];
						this.sortBone(bones[boneIndex]);
					}
				}
			}
		};
		Skeleton.prototype.sortBone = function (bone) {
			if (bone.sorted)
				return;
			var parent = bone.parent;
			if (parent != null)
				this.sortBone(parent);
			bone.sorted = true;
			this._updateCache.push(bone);
		};
		Skeleton.prototype.sortReset = function (bones) {
			for (var i = 0, n = bones.length; i < n; i++) {
				var bone = bones[i];
				if (!bone.active)
					continue;
				if (bone.sorted)
					this.sortReset(bone.children);
				bone.sorted = false;
			}
		};
		Skeleton.prototype.updateWorldTransform = function () {
			var updateCacheReset = this.updateCacheReset;
			for (var i = 0, n = updateCacheReset.length; i < n; i++) {
				var bone = updateCacheReset[i];
				bone.ax = bone.x;
				bone.ay = bone.y;
				bone.arotation = bone.rotation;
				bone.ascaleX = bone.scaleX;
				bone.ascaleY = bone.scaleY;
				bone.ashearX = bone.shearX;
				bone.ashearY = bone.shearY;
				bone.appliedValid = true;
			}
			var updateCache = this._updateCache;
			for (var i = 0, n = updateCache.length; i < n; i++)
				updateCache[i].update();
		};
		Skeleton.prototype.setToSetupPose = function () {
			this.setBonesToSetupPose();
			this.setSlotsToSetupPose();
		};
		Skeleton.prototype.setBonesToSetupPose = function () {
			var bones = this.bones;
			for (var i = 0, n = bones.length; i < n; i++)
				bones[i].setToSetupPose();
			var ikConstraints = this.ikConstraints;
			for (var i = 0, n = ikConstraints.length; i < n; i++) {
				var constraint = ikConstraints[i];
				constraint.mix = constraint.data.mix;
				constraint.softness = constraint.data.softness;
				constraint.bendDirection = constraint.data.bendDirection;
				constraint.compress = constraint.data.compress;
				constraint.stretch = constraint.data.stretch;
			}
			var transformConstraints = this.transformConstraints;
			for (var i = 0, n = transformConstraints.length; i < n; i++) {
				var constraint = transformConstraints[i];
				var data = constraint.data;
				constraint.rotateMix = data.rotateMix;
				constraint.translateMix = data.translateMix;
				constraint.scaleMix = data.scaleMix;
				constraint.shearMix = data.shearMix;
			}
			var pathConstraints = this.pathConstraints;
			for (var i = 0, n = pathConstraints.length; i < n; i++) {
				var constraint = pathConstraints[i];
				var data = constraint.data;
				constraint.position = data.position;
				constraint.spacing = data.spacing;
				constraint.rotateMix = data.rotateMix;
				constraint.translateMix = data.translateMix;
			}
		};
		Skeleton.prototype.setSlotsToSetupPose = function () {
			var slots = this.slots;
			spine.Utils.arrayCopy(slots, 0, this.drawOrder, 0, slots.length);
			for (var i = 0, n = slots.length; i < n; i++)
				slots[i].setToSetupPose();
		};
		Skeleton.prototype.getRootBone = function () {
			if (this.bones.length == 0)
				return null;
			return this.bones[0];
		};
		Skeleton.prototype.findBone = function (boneName) {
			if (boneName == null)
				throw new Error("boneName cannot be null.");
			var bones = this.bones;
			for (var i = 0, n = bones.length; i < n; i++) {
				var bone = bones[i];
				if (bone.data.name == boneName)
					return bone;
			}
			return null;
		};
		Skeleton.prototype.findBoneIndex = function (boneName) {
			if (boneName == null)
				throw new Error("boneName cannot be null.");
			var bones = this.bones;
			for (var i = 0, n = bones.length; i < n; i++)
				if (bones[i].data.name == boneName)
					return i;
			return -1;
		};
		Skeleton.prototype.findSlot = function (slotName) {
			if (slotName == null)
				throw new Error("slotName cannot be null.");
			var slots = this.slots;
			for (var i = 0, n = slots.length; i < n; i++) {
				var slot = slots[i];
				if (slot.data.name == slotName)
					return slot;
			}
			return null;
		};
		Skeleton.prototype.findSlotIndex = function (slotName) {
			if (slotName == null)
				throw new Error("slotName cannot be null.");
			var slots = this.slots;
			for (var i = 0, n = slots.length; i < n; i++)
				if (slots[i].data.name == slotName)
					return i;
			return -1;
		};
		Skeleton.prototype.setSkinByName = function (skinName) {
			var skin = this.data.findSkin(skinName);
			if (skin == null)
				throw new Error("Skin not found: " + skinName);
			this.setSkin(skin);
		};
		Skeleton.prototype.setSkin = function (newSkin) {
			if (newSkin == this.skin)
				return;
			if (newSkin != null) {
				if (this.skin != null)
					newSkin.attachAll(this, this.skin);
				else {
					var slots = this.slots;
					for (var i = 0, n = slots.length; i < n; i++) {
						var slot = slots[i];
						var name_1 = slot.data.attachmentName;
						if (name_1 != null) {
							var attachment = newSkin.getAttachment(i, name_1);
							if (attachment != null)
								slot.setAttachment(attachment);
						}
					}
				}
			}
			this.skin = newSkin;
			this.updateCache();
		};
		Skeleton.prototype.getAttachmentByName = function (slotName, attachmentName) {
			return this.getAttachment(this.data.findSlotIndex(slotName), attachmentName);
		};
		Skeleton.prototype.getAttachment = function (slotIndex, attachmentName) {
			if (attachmentName == null)
				throw new Error("attachmentName cannot be null.");
			if (this.skin != null) {
				var attachment = this.skin.getAttachment(slotIndex, attachmentName);
				if (attachment != null)
					return attachment;
			}
			if (this.data.defaultSkin != null)
				return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);
			return null;
		};
		Skeleton.prototype.setAttachment = function (slotName, attachmentName) {
			if (slotName == null)
				throw new Error("slotName cannot be null.");
			var slots = this.slots;
			for (var i = 0, n = slots.length; i < n; i++) {
				var slot = slots[i];
				if (slot.data.name == slotName) {
					var attachment = null;
					if (attachmentName != null) {
						attachment = this.getAttachment(i, attachmentName);
						if (attachment == null)
							throw new Error("Attachment not found: " + attachmentName + ", for slot: " + slotName);
					}
					slot.setAttachment(attachment);
					return;
				}
			}
			throw new Error("Slot not found: " + slotName);
		};
		Skeleton.prototype.findIkConstraint = function (constraintName) {
			if (constraintName == null)
				throw new Error("constraintName cannot be null.");
			var ikConstraints = this.ikConstraints;
			for (var i = 0, n = ikConstraints.length; i < n; i++) {
				var ikConstraint = ikConstraints[i];
				if (ikConstraint.data.name == constraintName)
					return ikConstraint;
			}
			return null;
		};
		Skeleton.prototype.findTransformConstraint = function (constraintName) {
			if (constraintName == null)
				throw new Error("constraintName cannot be null.");
			var transformConstraints = this.transformConstraints;
			for (var i = 0, n = transformConstraints.length; i < n; i++) {
				var constraint = transformConstraints[i];
				if (constraint.data.name == constraintName)
					return constraint;
			}
			return null;
		};
		Skeleton.prototype.findPathConstraint = function (constraintName) {
			if (constraintName == null)
				throw new Error("constraintName cannot be null.");
			var pathConstraints = this.pathConstraints;
			for (var i = 0, n = pathConstraints.length; i < n; i++) {
				var constraint = pathConstraints[i];
				if (constraint.data.name == constraintName)
					return constraint;
			}
			return null;
		};
		Skeleton.prototype.getBounds = function (offset, size, temp) {
			if (temp === void 0) { temp = new Array(2); }
			if (offset == null)
				throw new Error("offset cannot be null.");
			if (size == null)
				throw new Error("size cannot be null.");
			var drawOrder = this.drawOrder;
			var minX = Number.POSITIVE_INFINITY, minY = Number.POSITIVE_INFINITY, maxX = Number.NEGATIVE_INFINITY, maxY = Number.NEGATIVE_INFINITY;
			for (var i = 0, n = drawOrder.length; i < n; i++) {
				var slot = drawOrder[i];
				if (!slot.bone.active)
					continue;
				var verticesLength = 0;
				var vertices = null;
				var attachment = slot.getAttachment();
				if (attachment instanceof spine.RegionAttachment) {
					verticesLength = 8;
					vertices = spine.Utils.setArraySize(temp, verticesLength, 0);
					attachment.computeWorldVertices(slot.bone, vertices, 0, 2);
				}
				else if (attachment instanceof spine.MeshAttachment) {
					var mesh = attachment;
					verticesLength = mesh.worldVerticesLength;
					vertices = spine.Utils.setArraySize(temp, verticesLength, 0);
					mesh.computeWorldVertices(slot, 0, verticesLength, vertices, 0, 2);
				}
				if (vertices != null) {
					for (var ii = 0, nn = vertices.length; ii < nn; ii += 2) {
						var x = vertices[ii], y = vertices[ii + 1];
						minX = Math.min(minX, x);
						minY = Math.min(minY, y);
						maxX = Math.max(maxX, x);
						maxY = Math.max(maxY, y);
					}
				}
			}
			offset.set(minX, minY);
			size.set(maxX - minX, maxY - minY);
		};
		Skeleton.prototype.update = function (delta) {
			this.time += delta;
		};
		return Skeleton;
	}());
	spine.Skeleton = Skeleton;
})(spine || (spine = {}));
var spine;
(function (spine) {
	var SkeletonBinary = (function () {
		function SkeletonBinary(attachmentLoader) {
			this.scale = 1;
			this.linkedMeshes = new Array();
			this.attachmentLoader = attachmentLoader;
		}
		SkeletonBinary.prototype.readSkeletonData = function (binary) {
			var scale = this.scale;
			var skeletonData = new spine.SkeletonData();
			skeletonData.name = "";
			var input = new BinaryInput(binary);
			skeletonData.hash = input.readString();
			skeletonData.version = input.readString();
			if ("3.8.75" == skeletonData.version)
				throw new Error("Unsupported skeleton data, please export with a newer version of Spine.");
			skeletonData.x = input.readFloat();
			skeletonData.y = input.readFloat();
			skeletonData.width = input.readFloat();
			skeletonData.height = input.readFloat();
			var nonessential = input.readBoolean();
			if (nonessential) {
				skeletonData.fps = input.readFloat();
				skeletonData.imagesPath = input.readString();
				skeletonData.audioPath = input.readString();
			}
			var n = 0;
			n = input.readInt(true);
			for (var i = 0; i < n; i++)
				input.strings.push(input.readString());
			n = input.readInt(true);
			for (var i = 0; i < n; i++) {
				var name_2 = input.readString();
				var parent_2 = i == 0 ? null : skeletonData.bones[input.readInt(true)];
				var data = new spine.BoneData(i, name_2, parent_2);
				data.rotation = input.readFloat();
				data.x = input.readFloat() * scale;
				data.y = input.readFloat() * scale;
				data.scaleX = input.readFloat();
				data.scaleY = input.readFloat();
				data.shearX = input.readFloat();
				data.shearY = input.readFloat();
				data.length = input.readFloat() * scale;
				data.transformMode = SkeletonBinary.TransformModeValues[input.readInt(true)];
				data.skinRequired = input.readBoolean();
				if (nonessential)
					spine.Color.rgba8888ToColor(data.color, input.readInt32());
				skeletonData.bones.push(data);
			}
			n = input.readInt(true);
			for (var i = 0; i < n; i++) {
				var slotName = input.readString();
				var boneData = skeletonData.bones[input.readInt(true)];
				var data = new spine.SlotData(i, slotName, boneData);
				spine.Color.rgba8888ToColor(data.color, input.readInt32());
				var darkColor = input.readInt32();
				if (darkColor != -1)
					spine.Color.rgb888ToColor(data.darkColor = new spine.Color(), darkColor);
				data.attachmentName = input.readStringRef();
				data.blendMode = SkeletonBinary.BlendModeValues[input.readInt(true)];
				skeletonData.slots.push(data);
			}
			n = input.readInt(true);
			for (var i = 0, nn = void 0; i < n; i++) {
				var data = new spine.IkConstraintData(input.readString());
				data.order = input.readInt(true);
				data.skinRequired = input.readBoolean();
				nn = input.readInt(true);
				for (var ii = 0; ii < nn; ii++)
					data.bones.push(skeletonData.bones[input.readInt(true)]);
				data.target = skeletonData.bones[input.readInt(true)];
				data.mix = input.readFloat();
				data.softness = input.readFloat() * scale;
				data.bendDirection = input.readByte();
				data.compress = input.readBoolean();
				data.stretch = input.readBoolean();
				data.uniform = input.readBoolean();
				skeletonData.ikConstraints.push(data);
			}
			n = input.readInt(true);
			for (var i = 0, nn = void 0; i < n; i++) {
				var data = new spine.TransformConstraintData(input.readString());
				data.order = input.readInt(true);
				data.skinRequired = input.readBoolean();
				nn = input.readInt(true);
				for (var ii = 0; ii < nn; ii++)
					data.bones.push(skeletonData.bones[input.readInt(true)]);
				data.target = skeletonData.bones[input.readInt(true)];
				data.local = input.readBoolean();
				data.relative = input.readBoolean();
				data.offsetRotation = input.readFloat();
				data.offsetX = input.readFloat() * scale;
				data.offsetY = input.readFloat() * scale;
				data.offsetScaleX = input.readFloat();
				data.offsetScaleY = input.readFloat();
				data.offsetShearY = input.readFloat();
				data.rotateMix = input.readFloat();
				data.translateMix = input.readFloat();
				data.scaleMix = input.readFloat();
				data.shearMix = input.readFloat();
				skeletonData.transformConstraints.push(data);
			}
			n = input.readInt(true);
			for (var i = 0, nn = void 0; i < n; i++) {
				var data = new spine.PathConstraintData(input.readString());
				data.order = input.readInt(true);
				data.skinRequired = input.readBoolean();
				nn = input.readInt(true);
				for (var ii = 0; ii < nn; ii++)
					data.bones.push(skeletonData.bones[input.readInt(true)]);
				data.target = skeletonData.slots[input.readInt(true)];
				data.positionMode = SkeletonBinary.PositionModeValues[input.readInt(true)];
				data.spacingMode = SkeletonBinary.SpacingModeValues[input.readInt(true)];
				data.rotateMode = SkeletonBinary.RotateModeValues[input.readInt(true)];
				data.offsetRotation = input.readFloat();
				data.position = input.readFloat();
				if (data.positionMode == spine.PositionMode.Fixed)
					data.position *= scale;
				data.spacing = input.readFloat();
				if (data.spacingMode == spine.SpacingMode.Length || data.spacingMode == spine.SpacingMode.Fixed)
					data.spacing *= scale;
				data.rotateMix = input.readFloat();
				data.translateMix = input.readFloat();
				skeletonData.pathConstraints.push(data);
			}
			var defaultSkin = this.readSkin(input, skeletonData, true, nonessential);
			if (defaultSkin != null) {
				skeletonData.defaultSkin = defaultSkin;
				skeletonData.skins.push(defaultSkin);
			}
			{
				var i = skeletonData.skins.length;
				spine.Utils.setArraySize(skeletonData.skins, n = i + input.readInt(true));
				for (; i < n; i++)
					skeletonData.skins[i] = this.readSkin(input, skeletonData, false, nonessential);
			}
			n = this.linkedMeshes.length;
			for (var i = 0; i < n; i++) {
				var linkedMesh = this.linkedMeshes[i];
				var skin = linkedMesh.skin == null ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);
				if (skin == null)
					throw new Error("Skin not found: " + linkedMesh.skin);
				var parent_3 = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);
				if (parent_3 == null)
					throw new Error("Parent mesh not found: " + linkedMesh.parent);
				linkedMesh.mesh.deformAttachment = linkedMesh.inheritDeform ? parent_3 : linkedMesh.mesh;
				linkedMesh.mesh.setParentMesh(parent_3);
				linkedMesh.mesh.updateUVs();
			}
			this.linkedMeshes.length = 0;
			n = input.readInt(true);
			for (var i = 0; i < n; i++) {
				var data = new spine.EventData(input.readStringRef());
				data.intValue = input.readInt(false);
				data.floatValue = input.readFloat();
				data.stringValue = input.readString();
				data.audioPath = input.readString();
				if (data.audioPath != null) {
					data.volume = input.readFloat();
					data.balance = input.readFloat();
				}
				skeletonData.events.push(data);
			}
			n = input.readInt(true);
			for (var i = 0; i < n; i++)
				skeletonData.animations.push(this.readAnimation(input, input.readString(), skeletonData));
			return skeletonData;
		};
		SkeletonBinary.prototype.readSkin = function (input, skeletonData, defaultSkin, nonessential) {
			var skin = null;
			var slotCount = 0;
			if (defaultSkin) {
				slotCount = input.readInt(true);
				if (slotCount == 0)
					return null;
				skin = new spine.Skin("default");
			}
			else {
				skin = new spine.Skin(input.readStringRef());
				skin.bones.length = input.readInt(true);
				for (var i = 0, n = skin.bones.length; i < n; i++)
					skin.bones[i] = skeletonData.bones[input.readInt(true)];
				for (var i = 0, n = input.readInt(true); i < n; i++)
					skin.constraints.push(skeletonData.ikConstraints[input.readInt(true)]);
				for (var i = 0, n = input.readInt(true); i < n; i++)
					skin.constraints.push(skeletonData.transformConstraints[input.readInt(true)]);
				for (var i = 0, n = input.readInt(true); i < n; i++)
					skin.constraints.push(skeletonData.pathConstraints[input.readInt(true)]);
				slotCount = input.readInt(true);
			}
			for (var i = 0; i < slotCount; i++) {
				var slotIndex = input.readInt(true);
				for (var ii = 0, nn = input.readInt(true); ii < nn; ii++) {
					var name_3 = input.readStringRef();
					var attachment = this.readAttachment(input, skeletonData, skin, slotIndex, name_3, nonessential);
					if (attachment != null)
						skin.setAttachment(slotIndex, name_3, attachment);
				}
			}
			return skin;
		};
		SkeletonBinary.prototype.readAttachment = function (input, skeletonData, skin, slotIndex, attachmentName, nonessential) {
			var scale = this.scale;
			var name = input.readStringRef();
			if (name == null)
				name = attachmentName;
			var typeIndex = input.readByte();
			var type = SkeletonBinary.AttachmentTypeValues[typeIndex];
			switch (type) {
				case spine.AttachmentType.Region: {
					var path = input.readStringRef();
					var rotation = input.readFloat();
					var x = input.readFloat();
					var y = input.readFloat();
					var scaleX = input.readFloat();
					var scaleY = input.readFloat();
					var width = input.readFloat();
					var height = input.readFloat();
					var color = input.readInt32();
					if (path == null)
						path = name;
					var region = this.attachmentLoader.newRegionAttachment(skin, name, path);
					if (region == null)
						return null;
					region.path = path;
					region.x = x * scale;
					region.y = y * scale;
					region.scaleX = scaleX;
					region.scaleY = scaleY;
					region.rotation = rotation;
					region.width = width * scale;
					region.height = height * scale;
					spine.Color.rgba8888ToColor(region.color, color);
					region.updateOffset();
					return region;
				}
				case spine.AttachmentType.BoundingBox: {
					var vertexCount = input.readInt(true);
					var vertices = this.readVertices(input, vertexCount);
					var color = nonessential ? input.readInt32() : 0;
					var box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);
					if (box == null)
						return null;
					box.worldVerticesLength = vertexCount << 1;
					box.vertices = vertices.vertices;
					box.bones = vertices.bones;
					if (nonessential)
						spine.Color.rgba8888ToColor(box.color, color);
					return box;
				}
				case spine.AttachmentType.Mesh: {
					var path = input.readStringRef();
					var color = input.readInt32();
					var vertexCount = input.readInt(true);
					var uvs = this.readFloatArray(input, vertexCount << 1, 1);
					var triangles = this.readShortArray(input);
					var vertices = this.readVertices(input, vertexCount);
					var hullLength = input.readInt(true);
					var edges = null;
					var width = 0, height = 0;
					if (nonessential) {
						edges = this.readShortArray(input);
						width = input.readFloat();
						height = input.readFloat();
					}
					if (path == null)
						path = name;
					var mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);
					if (mesh == null)
						return null;
					mesh.path = path;
					spine.Color.rgba8888ToColor(mesh.color, color);
					mesh.bones = vertices.bones;
					mesh.vertices = vertices.vertices;
					mesh.worldVerticesLength = vertexCount << 1;
					mesh.triangles = triangles;
					mesh.regionUVs = uvs;
					mesh.updateUVs();
					mesh.hullLength = hullLength << 1;
					if (nonessential) {
						mesh.edges = edges;
						mesh.width = width * scale;
						mesh.height = height * scale;
					}
					return mesh;
				}
				case spine.AttachmentType.LinkedMesh: {
					var path = input.readStringRef();
					var color = input.readInt32();
					var skinName = input.readStringRef();
					var parent_4 = input.readStringRef();
					var inheritDeform = input.readBoolean();
					var width = 0, height = 0;
					if (nonessential) {
						width = input.readFloat();
						height = input.readFloat();
					}
					if (path == null)
						path = name;
					var mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);
					if (mesh == null)
						return null;
					mesh.path = path;
					spine.Color.rgba8888ToColor(mesh.color, color);
					if (nonessential) {
						mesh.width = width * scale;
						mesh.height = height * scale;
					}
					this.linkedMeshes.push(new LinkedMesh(mesh, skinName, slotIndex, parent_4, inheritDeform));
					return mesh;
				}
				case spine.AttachmentType.Path: {
					var closed_1 = input.readBoolean();
					var constantSpeed = input.readBoolean();
					var vertexCount = input.readInt(true);
					var vertices = this.readVertices(input, vertexCount);
					var lengths = spine.Utils.newArray(vertexCount / 3, 0);
					for (var i = 0, n = lengths.length; i < n; i++)
						lengths[i] = input.readFloat() * scale;
					var color = nonessential ? input.readInt32() : 0;
					var path = this.attachmentLoader.newPathAttachment(skin, name);
					if (path == null)
						return null;
					path.closed = closed_1;
					path.constantSpeed = constantSpeed;
					path.worldVerticesLength = vertexCount << 1;
					path.vertices = vertices.vertices;
					path.bones = vertices.bones;
					path.lengths = lengths;
					if (nonessential)
						spine.Color.rgba8888ToColor(path.color, color);
					return path;
				}
				case spine.AttachmentType.Point: {
					var rotation = input.readFloat();
					var x = input.readFloat();
					var y = input.readFloat();
					var color = nonessential ? input.readInt32() : 0;
					var point = this.attachmentLoader.newPointAttachment(skin, name);
					if (point == null)
						return null;
					point.x = x * scale;
					point.y = y * scale;
					point.rotation = rotation;
					if (nonessential)
						spine.Color.rgba8888ToColor(point.color, color);
					return point;
				}
				case spine.AttachmentType.Clipping: {
					var endSlotIndex = input.readInt(true);
					var vertexCount = input.readInt(true);
					var vertices = this.readVertices(input, vertexCount);
					var color = nonessential ? input.readInt32() : 0;
					var clip = this.attachmentLoader.newClippingAttachment(skin, name);
					if (clip == null)
						return null;
					clip.endSlot = skeletonData.slots[endSlotIndex];
					clip.worldVerticesLength = vertexCount << 1;
					clip.vertices = vertices.vertices;
					clip.bones = vertices.bones;
					if (nonessential)
						spine.Color.rgba8888ToColor(clip.color, color);
					return clip;
				}
			}
			return null;
		};
		SkeletonBinary.prototype.readVertices = function (input, vertexCount) {
			var verticesLength = vertexCount << 1;
			var vertices = new Vertices();
			var scale = this.scale;
			if (!input.readBoolean()) {
				vertices.vertices = this.readFloatArray(input, verticesLength, scale);
				return vertices;
			}
			var weights = new Array();
			var bonesArray = new Array();
			for (var i = 0; i < vertexCount; i++) {
				var boneCount = input.readInt(true);
				bonesArray.push(boneCount);
				for (var ii = 0; ii < boneCount; ii++) {
					bonesArray.push(input.readInt(true));
					weights.push(input.readFloat() * scale);
					weights.push(input.readFloat() * scale);
					weights.push(input.readFloat());
				}
			}
			vertices.vertices = spine.Utils.toFloatArray(weights);
			vertices.bones = bonesArray;
			return vertices;
		};
		SkeletonBinary.prototype.readFloatArray = function (input, n, scale) {
			var array = new Array(n);
			if (scale == 1) {
				for (var i = 0; i < n; i++)
					array[i] = input.readFloat();
			}
			else {
				for (var i = 0; i < n; i++)
					array[i] = input.readFloat() * scale;
			}
			return array;
		};
		SkeletonBinary.prototype.readShortArray = function (input) {
			var n = input.readInt(true);
			var array = new Array(n);
			for (var i = 0; i < n; i++)
				array[i] = input.readShort();
			return array;
		};
		SkeletonBinary.prototype.readAnimation = function (input, name, skeletonData) {
			var timelines = new Array();
			var scale = this.scale;
			var duration = 0;
			var tempColor1 = new spine.Color();
			var tempColor2 = new spine.Color();
			for (var i = 0, n = input.readInt(true); i < n; i++) {
				var slotIndex = input.readInt(true);
				for (var ii = 0, nn = input.readInt(true); ii < nn; ii++) {
					var timelineType = input.readByte();
					var frameCount = input.readInt(true);
					switch (timelineType) {
						case SkeletonBinary.SLOT_ATTACHMENT: {
							var timeline = new spine.AttachmentTimeline(frameCount);
							timeline.slotIndex = slotIndex;
							for (var frameIndex = 0; frameIndex < frameCount; frameIndex++)
								timeline.setFrame(frameIndex, input.readFloat(), input.readStringRef());
							timelines.push(timeline);
							duration = Math.max(duration, timeline.frames[frameCount - 1]);
							break;
						}
						case SkeletonBinary.SLOT_COLOR: {
							var timeline = new spine.ColorTimeline(frameCount);
							timeline.slotIndex = slotIndex;
							for (var frameIndex = 0; frameIndex < frameCount; frameIndex++) {
								var time = input.readFloat();
								spine.Color.rgba8888ToColor(tempColor1, input.readInt32());
								timeline.setFrame(frameIndex, time, tempColor1.r, tempColor1.g, tempColor1.b, tempColor1.a);
								if (frameIndex < frameCount - 1)
									this.readCurve(input, frameIndex, timeline);
							}
							timelines.push(timeline);
							duration = Math.max(duration, timeline.frames[(frameCount - 1) * spine.ColorTimeline.ENTRIES]);
							break;
						}
						case SkeletonBinary.SLOT_TWO_COLOR: {
							var timeline = new spine.TwoColorTimeline(frameCount);
							timeline.slotIndex = slotIndex;
							for (var frameIndex = 0; frameIndex < frameCount; frameIndex++) {
								var time = input.readFloat();
								spine.Color.rgba8888ToColor(tempColor1, input.readInt32());
								spine.Color.rgb888ToColor(tempColor2, input.readInt32());
								timeline.setFrame(frameIndex, time, tempColor1.r, tempColor1.g, tempColor1.b, tempColor1.a, tempColor2.r, tempColor2.g, tempColor2.b);
								if (frameIndex < frameCount - 1)
									this.readCurve(input, frameIndex, timeline);
							}
							timelines.push(timeline);
							duration = Math.max(duration, timeline.frames[(frameCount - 1) * spine.TwoColorTimeline.ENTRIES]);
							break;
						}
					}
				}
			}
			for (var i = 0, n = input.readInt(true); i < n; i++) {
				var boneIndex = input.readInt(true);
				for (var ii = 0, nn = input.readInt(true); ii < nn; ii++) {
					var timelineType = input.readByte();
					var frameCount = input.readInt(true);
					switch (timelineType) {
						case SkeletonBinary.BONE_ROTATE: {
							var timeline = new spine.RotateTimeline(frameCount);
							timeline.boneIndex = boneIndex;
							for (var frameIndex = 0; frameIndex < frameCount; frameIndex++) {
								timeline.setFrame(frameIndex, input.readFloat(), input.readFloat());
								if (frameIndex < frameCount - 1)
									this.readCurve(input, frameIndex, timeline);
							}
							timelines.push(timeline);
							duration = Math.max(duration, timeline.frames[(frameCount - 1) * spine.RotateTimeline.ENTRIES]);
							break;
						}
						case SkeletonBinary.BONE_TRANSLATE:
						case SkeletonBinary.BONE_SCALE:
						case SkeletonBinary.BONE_SHEAR: {
							var timeline = void 0;
							var timelineScale = 1;
							if (timelineType == SkeletonBinary.BONE_SCALE)
								timeline = new spine.ScaleTimeline(frameCount);
							else if (timelineType == SkeletonBinary.BONE_SHEAR)
								timeline = new spine.ShearTimeline(frameCount);
							else {
								timeline = new spine.TranslateTimeline(frameCount);
								timelineScale = scale;
							}
							timeline.boneIndex = boneIndex;
							for (var frameIndex = 0; frameIndex < frameCount; frameIndex++) {
								timeline.setFrame(frameIndex, input.readFloat(), input.readFloat() * timelineScale, input.readFloat() * timelineScale);
								if (frameIndex < frameCount - 1)
									this.readCurve(input, frameIndex, timeline);
							}
							timelines.push(timeline);
							duration = Math.max(duration, timeline.frames[(frameCount - 1) * spine.TranslateTimeline.ENTRIES]);
							break;
						}
					}
				}
			}
			for (var i = 0, n = input.readInt(true); i < n; i++) {
				var index = input.readInt(true);
				var frameCount = input.readInt(true);
				var timeline = new spine.IkConstraintTimeline(frameCount);
				timeline.ikConstraintIndex = index;
				for (var frameIndex = 0; frameIndex < frameCount; frameIndex++) {
					timeline.setFrame(frameIndex, input.readFloat(), input.readFloat(), input.readFloat() * scale, input.readByte(), input.readBoolean(), input.readBoolean());
					if (frameIndex < frameCount - 1)
						this.readCurve(input, frameIndex, timeline);
				}
				timelines.push(timeline);
				duration = Math.max(duration, timeline.frames[(frameCount - 1) * spine.IkConstraintTimeline.ENTRIES]);
			}
			for (var i = 0, n = input.readInt(true); i < n; i++) {
				var index = input.readInt(true);
				var frameCount = input.readInt(true);
				var timeline = new spine.TransformConstraintTimeline(frameCount);
				timeline.transformConstraintIndex = index;
				for (var frameIndex = 0; frameIndex < frameCount; frameIndex++) {
					timeline.setFrame(frameIndex, input.readFloat(), input.readFloat(), input.readFloat(), input.readFloat(), input.readFloat());
					if (frameIndex < frameCount - 1)
						this.readCurve(input, frameIndex, timeline);
				}
				timelines.push(timeline);
				duration = Math.max(duration, timeline.frames[(frameCount - 1) * spine.TransformConstraintTimeline.ENTRIES]);
			}
			for (var i = 0, n = input.readInt(true); i < n; i++) {
				var index = input.readInt(true);
				var data = skeletonData.pathConstraints[index];
				for (var ii = 0, nn = input.readInt(true); ii < nn; ii++) {
					var timelineType = input.readByte();
					var frameCount = input.readInt(true);
					switch (timelineType) {
						case SkeletonBinary.PATH_POSITION:
						case SkeletonBinary.PATH_SPACING: {
							var timeline = void 0;
							var timelineScale = 1;
							if (timelineType == SkeletonBinary.PATH_SPACING) {
								timeline = new spine.PathConstraintSpacingTimeline(frameCount);
								if (data.spacingMode == spine.SpacingMode.Length || data.spacingMode == spine.SpacingMode.Fixed)
									timelineScale = scale;
							}
							else {
								timeline = new spine.PathConstraintPositionTimeline(frameCount);
								if (data.positionMode == spine.PositionMode.Fixed)
									timelineScale = scale;
							}
							timeline.pathConstraintIndex = index;
							for (var frameIndex = 0; frameIndex < frameCount; frameIndex++) {
								timeline.setFrame(frameIndex, input.readFloat(), input.readFloat() * timelineScale);
								if (frameIndex < frameCount - 1)
									this.readCurve(input, frameIndex, timeline);
							}
							timelines.push(timeline);
							duration = Math.max(duration, timeline.frames[(frameCount - 1) * spine.PathConstraintPositionTimeline.ENTRIES]);
							break;
						}
						case SkeletonBinary.PATH_MIX: {
							var timeline = new spine.PathConstraintMixTimeline(frameCount);
							timeline.pathConstraintIndex = index;
							for (var frameIndex = 0; frameIndex < frameCount; frameIndex++) {
								timeline.setFrame(frameIndex, input.readFloat(), input.readFloat(), input.readFloat());
								if (frameIndex < frameCount - 1)
									this.readCurve(input, frameIndex, timeline);
							}
							timelines.push(timeline);
							duration = Math.max(duration, timeline.frames[(frameCount - 1) * spine.PathConstraintMixTimeline.ENTRIES]);
							break;
						}
					}
				}
			}
			for (var i = 0, n = input.readInt(true); i < n; i++) {
				var skin = skeletonData.skins[input.readInt(true)];
				for (var ii = 0, nn = input.readInt(true); ii < nn; ii++) {
					var slotIndex = input.readInt(true);
					for (var iii = 0, nnn = input.readInt(true); iii < nnn; iii++) {
						var attachment = skin.getAttachment(slotIndex, input.readStringRef());
						var weighted = attachment.bones != null;
						var vertices = attachment.vertices;
						var deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;
						var frameCount = input.readInt(true);
						var timeline = new spine.DeformTimeline(frameCount);
						timeline.slotIndex = slotIndex;
						timeline.attachment = attachment;
						for (var frameIndex = 0; frameIndex < frameCount; frameIndex++) {
							var time = input.readFloat();
							var deform = void 0;
							var end = input.readInt(true);
							if (end == 0)
								deform = weighted ? spine.Utils.newFloatArray(deformLength) : vertices;
							else {
								deform = spine.Utils.newFloatArray(deformLength);
								var start = input.readInt(true);
								end += start;
								if (scale == 1) {
									for (var v = start; v < end; v++)
										deform[v] = input.readFloat();
								}
								else {
									for (var v = start; v < end; v++)
										deform[v] = input.readFloat() * scale;
								}
								if (!weighted) {
									for (var v = 0, vn = deform.length; v < vn; v++)
										deform[v] += vertices[v];
								}
							}
							timeline.setFrame(frameIndex, time, deform);
							if (frameIndex < frameCount - 1)
								this.readCurve(input, frameIndex, timeline);
						}
						timelines.push(timeline);
						duration = Math.max(duration, timeline.frames[frameCount - 1]);
					}
				}
			}
			var drawOrderCount = input.readInt(true);
			if (drawOrderCount > 0) {
				var timeline = new spine.DrawOrderTimeline(drawOrderCount);
				var slotCount = skeletonData.slots.length;
				for (var i = 0; i < drawOrderCount; i++) {
					var time = input.readFloat();
					var offsetCount = input.readInt(true);
					var drawOrder = spine.Utils.newArray(slotCount, 0);
					for (var ii = slotCount - 1; ii >= 0; ii--)
						drawOrder[ii] = -1;
					var unchanged = spine.Utils.newArray(slotCount - offsetCount, 0);
					var originalIndex = 0, unchangedIndex = 0;
					for (var ii = 0; ii < offsetCount; ii++) {
						var slotIndex = input.readInt(true);
						while (originalIndex != slotIndex)
							unchanged[unchangedIndex++] = originalIndex++;
						drawOrder[originalIndex + input.readInt(true)] = originalIndex++;
					}
					while (originalIndex < slotCount)
						unchanged[unchangedIndex++] = originalIndex++;
					for (var ii = slotCount - 1; ii >= 0; ii--)
						if (drawOrder[ii] == -1)
							drawOrder[ii] = unchanged[--unchangedIndex];
					timeline.setFrame(i, time, drawOrder);
				}
				timelines.push(timeline);
				duration = Math.max(duration, timeline.frames[drawOrderCount - 1]);
			}
			var eventCount = input.readInt(true);
			if (eventCount > 0) {
				var timeline = new spine.EventTimeline(eventCount);
				for (var i = 0; i < eventCount; i++) {
					var time = input.readFloat();
					var eventData = skeletonData.events[input.readInt(true)];
					var event_4 = new spine.Event(time, eventData);
					event_4.intValue = input.readInt(false);
					event_4.floatValue = input.readFloat();
					event_4.stringValue = input.readBoolean() ? input.readString() : eventData.stringValue;
					if (event_4.data.audioPath != null) {
						event_4.volume = input.readFloat();
						event_4.balance = input.readFloat();
					}
					timeline.setFrame(i, event_4);
				}
				timelines.push(timeline);
				duration = Math.max(duration, timeline.frames[eventCount - 1]);
			}
			return new spine.Animation(name, timelines, duration);
		};
		SkeletonBinary.prototype.readCurve = function (input, frameIndex, timeline) {
			switch (input.readByte()) {
				case SkeletonBinary.CURVE_STEPPED:
					timeline.setStepped(frameIndex);
					break;
				case SkeletonBinary.CURVE_BEZIER:
					this.setCurve(timeline, frameIndex, input.readFloat(), input.readFloat(), input.readFloat(), input.readFloat());
					break;
			}
		};
		SkeletonBinary.prototype.setCurve = function (timeline, frameIndex, cx1, cy1, cx2, cy2) {
			timeline.setCurve(frameIndex, cx1, cy1, cx2, cy2);
		};
		SkeletonBinary.AttachmentTypeValues = [0, 1, 2, 3, 4, 5, 6];
		SkeletonBinary.TransformModeValues = [spine.TransformMode.Normal, spine.TransformMode.OnlyTranslation, spine.TransformMode.NoRotationOrReflection, spine.TransformMode.NoScale, spine.TransformMode.NoScaleOrReflection];
		SkeletonBinary.PositionModeValues = [spine.PositionMode.Fixed, spine.PositionMode.Percent];
		SkeletonBinary.SpacingModeValues = [spine.SpacingMode.Length, spine.SpacingMode.Fixed, spine.SpacingMode.Percent];
		SkeletonBinary.RotateModeValues = [spine.RotateMode.Tangent, spine.RotateMode.Chain, spine.RotateMode.ChainScale];
		SkeletonBinary.BlendModeValues = [spine.BlendMode.Normal, spine.BlendMode.Additive, spine.BlendMode.Multiply, spine.BlendMode.Screen];
		SkeletonBinary.BONE_ROTATE = 0;
		SkeletonBinary.BONE_TRANSLATE = 1;
		SkeletonBinary.BONE_SCALE = 2;
		SkeletonBinary.BONE_SHEAR = 3;
		SkeletonBinary.SLOT_ATTACHMENT = 0;
		SkeletonBinary.SLOT_COLOR = 1;
		SkeletonBinary.SLOT_TWO_COLOR = 2;
		SkeletonBinary.PATH_POSITION = 0;
		SkeletonBinary.PATH_SPACING = 1;
		SkeletonBinary.PATH_MIX = 2;
		SkeletonBinary.CURVE_LINEAR = 0;
		SkeletonBinary.CURVE_STEPPED = 1;
		SkeletonBinary.CURVE_BEZIER = 2;
		return SkeletonBinary;
	}());
	spine.SkeletonBinary = SkeletonBinary;
	var BinaryInput = (function () {
		function BinaryInput(data, strings, index, buffer) {
			if (strings === void 0) { strings = new Array(); }
			if (index === void 0) { index = 0; }
			if (buffer === void 0) { buffer = new DataView(data.buffer); }
			this.strings = strings;
			this.index = index;
			this.buffer = buffer;
		}
		BinaryInput.prototype.readByte = function () {
			return this.buffer.getInt8(this.index++);
		};
		BinaryInput.prototype.readShort = function () {
			var value = this.buffer.getInt16(this.index);
			this.index += 2;
			return value;
		};
		BinaryInput.prototype.readInt32 = function () {
			var value = this.buffer.getInt32(this.index);
			this.index += 4;
			return value;
		};
		BinaryInput.prototype.readInt = function (optimizePositive) {
			var b = this.readByte();
			var result = b & 0x7F;
			if ((b & 0x80) != 0) {
				b = this.readByte();
				result |= (b & 0x7F) << 7;
				if ((b & 0x80) != 0) {
					b = this.readByte();
					result |= (b & 0x7F) << 14;
					if ((b & 0x80) != 0) {
						b = this.readByte();
						result |= (b & 0x7F) << 21;
						if ((b & 0x80) != 0) {
							b = this.readByte();
							result |= (b & 0x7F) << 28;
						}
					}
				}
			}
			return optimizePositive ? result : ((result >>> 1) ^ -(result & 1));
		};
		BinaryInput.prototype.readStringRef = function () {
			var index = this.readInt(true);
			return index == 0 ? null : this.strings[index - 1];
		};
		BinaryInput.prototype.readString = function () {
			var byteCount = this.readInt(true);
			switch (byteCount) {
				case 0:
					return null;
				case 1:
					return "";
			}
			byteCount--;
			var chars = "";
			var charCount = 0;
			for (var i = 0; i < byteCount;) {
				var b = this.readByte();
				switch (b >> 4) {
					case 12:
					case 13:
						chars += String.fromCharCode(((b & 0x1F) << 6 | this.readByte() & 0x3F));
						i += 2;
						break;
					case 14:
						chars += String.fromCharCode(((b & 0x0F) << 12 | (this.readByte() & 0x3F) << 6 | this.readByte() & 0x3F));
						i += 3;
						break;
					default:
						chars += String.fromCharCode(b);
						i++;
				}
			}
			return chars;
		};
		BinaryInput.prototype.readFloat = function () {
			var value = this.buffer.getFloat32(this.index);
			this.index += 4;
			return value;
		};
		BinaryInput.prototype.readBoolean = function () {
			return this.readByte() != 0;
		};
		return BinaryInput;
	}());
	var LinkedMesh = (function () {
		function LinkedMesh(mesh, skin, slotIndex, parent, inheritDeform) {
			this.mesh = mesh;
			this.skin = skin;
			this.slotIndex = slotIndex;
			this.parent = parent;
			this.inheritDeform = inheritDeform;
		}
		return LinkedMesh;
	}());
	var Vertices = (function () {
		function Vertices(bones, vertices) {
			if (bones === void 0) { bones = null; }
			if (vertices === void 0) { vertices = null; }
			this.bones = bones;
			this.vertices = vertices;
		}
		return Vertices;
	}());
})(spine || (spine = {}));
var spine;
(function (spine) {
	var SkeletonBounds = (function () {
		function SkeletonBounds() {
			this.minX = 0;
			this.minY = 0;
			this.maxX = 0;
			this.maxY = 0;
			this.boundingBoxes = new Array();
			this.polygons = new Array();
			this.polygonPool = new spine.Pool(function () {
				return spine.Utils.newFloatArray(16);
			});
		}
		SkeletonBounds.prototype.update = function (skeleton, updateAabb) {
			if (skeleton == null)
				throw new Error("skeleton cannot be null.");
			var boundingBoxes = this.boundingBoxes;
			var polygons = this.polygons;
			var polygonPool = this.polygonPool;
			var slots = skeleton.slots;
			var slotCount = slots.length;
			boundingBoxes.length = 0;
			polygonPool.freeAll(polygons);
			polygons.length = 0;
			for (var i = 0; i < slotCount; i++) {
				var slot = slots[i];
				if (!slot.bone.active)
					continue;
				var attachment = slot.getAttachment();
				if (attachment instanceof spine.BoundingBoxAttachment) {
					var boundingBox = attachment;
					boundingBoxes.push(boundingBox);
					var polygon = polygonPool.obtain();
					if (polygon.length != boundingBox.worldVerticesLength) {
						polygon = spine.Utils.newFloatArray(boundingBox.worldVerticesLength);
					}
					polygons.push(polygon);
					boundingBox.computeWorldVertices(slot, 0, boundingBox.worldVerticesLength, polygon, 0, 2);
				}
			}
			if (updateAabb) {
				this.aabbCompute();
			}
			else {
				this.minX = Number.POSITIVE_INFINITY;
				this.minY = Number.POSITIVE_INFINITY;
				this.maxX = Number.NEGATIVE_INFINITY;
				this.maxY = Number.NEGATIVE_INFINITY;
			}
		};
		SkeletonBounds.prototype.aabbCompute = function () {
			var minX = Number.POSITIVE_INFINITY, minY = Number.POSITIVE_INFINITY, maxX = Number.NEGATIVE_INFINITY, maxY = Number.NEGATIVE_INFINITY;
			var polygons = this.polygons;
			for (var i = 0, n = polygons.length; i < n; i++) {
				var polygon = polygons[i];
				var vertices = polygon;
				for (var ii = 0, nn = polygon.length; ii < nn; ii += 2) {
					var x = vertices[ii];
					var y = vertices[ii + 1];
					minX = Math.min(minX, x);
					minY = Math.min(minY, y);
					maxX = Math.max(maxX, x);
					maxY = Math.max(maxY, y);
				}
			}
			this.minX = minX;
			this.minY = minY;
			this.maxX = maxX;
			this.maxY = maxY;
		};
		SkeletonBounds.prototype.aabbContainsPoint = function (x, y) {
			return x >= this.minX && x <= this.maxX && y >= this.minY && y <= this.maxY;
		};
		SkeletonBounds.prototype.aabbIntersectsSegment = function (x1, y1, x2, y2) {
			var minX = this.minX;
			var minY = this.minY;
			var maxX = this.maxX;
			var maxY = this.maxY;
			if ((x1 <= minX && x2 <= minX) || (y1 <= minY && y2 <= minY) || (x1 >= maxX && x2 >= maxX) || (y1 >= maxY && y2 >= maxY))
				return false;
			var m = (y2 - y1) / (x2 - x1);
			var y = m * (minX - x1) + y1;
			if (y > minY && y < maxY)
				return true;
			y = m * (maxX - x1) + y1;
			if (y > minY && y < maxY)
				return true;
			var x = (minY - y1) / m + x1;
			if (x > minX && x < maxX)
				return true;
			x = (maxY - y1) / m + x1;
			if (x > minX && x < maxX)
				return true;
			return false;
		};
		SkeletonBounds.prototype.aabbIntersectsSkeleton = function (bounds) {
			return this.minX < bounds.maxX && this.maxX > bounds.minX && this.minY < bounds.maxY && this.maxY > bounds.minY;
		};
		SkeletonBounds.prototype.containsPoint = function (x, y) {
			var polygons = this.polygons;
			for (var i = 0, n = polygons.length; i < n; i++)
				if (this.containsPointPolygon(polygons[i], x, y))
					return this.boundingBoxes[i];
			return null;
		};
		SkeletonBounds.prototype.containsPointPolygon = function (polygon, x, y) {
			var vertices = polygon;
			var nn = polygon.length;
			var prevIndex = nn - 2;
			var inside = false;
			for (var ii = 0; ii < nn; ii += 2) {
				var vertexY = vertices[ii + 1];
				var prevY = vertices[prevIndex + 1];
				if ((vertexY < y && prevY >= y) || (prevY < y && vertexY >= y)) {
					var vertexX = vertices[ii];
					if (vertexX + (y - vertexY) / (prevY - vertexY) * (vertices[prevIndex] - vertexX) < x)
						inside = !inside;
				}
				prevIndex = ii;
			}
			return inside;
		};
		SkeletonBounds.prototype.intersectsSegment = function (x1, y1, x2, y2) {
			var polygons = this.polygons;
			for (var i = 0, n = polygons.length; i < n; i++)
				if (this.intersectsSegmentPolygon(polygons[i], x1, y1, x2, y2))
					return this.boundingBoxes[i];
			return null;
		};
		SkeletonBounds.prototype.intersectsSegmentPolygon = function (polygon, x1, y1, x2, y2) {
			var vertices = polygon;
			var nn = polygon.length;
			var width12 = x1 - x2, height12 = y1 - y2;
			var det1 = x1 * y2 - y1 * x2;
			var x3 = vertices[nn - 2], y3 = vertices[nn - 1];
			for (var ii = 0; ii < nn; ii += 2) {
				var x4 = vertices[ii], y4 = vertices[ii + 1];
				var det2 = x3 * y4 - y3 * x4;
				var width34 = x3 - x4, height34 = y3 - y4;
				var det3 = width12 * height34 - height12 * width34;
				var x = (det1 * width34 - width12 * det2) / det3;
				if (((x >= x3 && x <= x4) || (x >= x4 && x <= x3)) && ((x >= x1 && x <= x2) || (x >= x2 && x <= x1))) {
					var y = (det1 * height34 - height12 * det2) / det3;
					if (((y >= y3 && y <= y4) || (y >= y4 && y <= y3)) && ((y >= y1 && y <= y2) || (y >= y2 && y <= y1)))
						return true;
				}
				x3 = x4;
				y3 = y4;
			}
			return false;
		};
		SkeletonBounds.prototype.getPolygon = function (boundingBox) {
			if (boundingBox == null)
				throw new Error("boundingBox cannot be null.");
			var index = this.boundingBoxes.indexOf(boundingBox);
			return index == -1 ? null : this.polygons[index];
		};
		SkeletonBounds.prototype.getWidth = function () {
			return this.maxX - this.minX;
		};
		SkeletonBounds.prototype.getHeight = function () {
			return this.maxY - this.minY;
		};
		return SkeletonBounds;
	}());
	spine.SkeletonBounds = SkeletonBounds;
})(spine || (spine = {}));
var spine;
(function (spine) {
	var SkeletonClipping = (function () {
		function SkeletonClipping() {
			this.triangulator = new spine.Triangulator();
			this.clippingPolygon = new Array();
			this.clipOutput = new Array();
			this.clippedVertices = new Array();
			this.clippedTriangles = new Array();
			this.scratch = new Array();
		}
		SkeletonClipping.prototype.clipStart = function (slot, clip) {
			if (this.clipAttachment != null)
				return 0;
			this.clipAttachment = clip;
			var n = clip.worldVerticesLength;
			var vertices = spine.Utils.setArraySize(this.clippingPolygon, n);
			clip.computeWorldVertices(slot, 0, n, vertices, 0, 2);
			var clippingPolygon = this.clippingPolygon;
			SkeletonClipping.makeClockwise(clippingPolygon);
			var clippingPolygons = this.clippingPolygons = this.triangulator.decompose(clippingPolygon, this.triangulator.triangulate(clippingPolygon));
			for (var i = 0, n_1 = clippingPolygons.length; i < n_1; i++) {
				var polygon = clippingPolygons[i];
				SkeletonClipping.makeClockwise(polygon);
				polygon.push(polygon[0]);
				polygon.push(polygon[1]);
			}
			return clippingPolygons.length;
		};
		SkeletonClipping.prototype.clipEndWithSlot = function (slot) {
			if (this.clipAttachment != null && this.clipAttachment.endSlot == slot.data)
				this.clipEnd();
		};
		SkeletonClipping.prototype.clipEnd = function () {
			if (this.clipAttachment == null)
				return;
			this.clipAttachment = null;
			this.clippingPolygons = null;
			this.clippedVertices.length = 0;
			this.clippedTriangles.length = 0;
			this.clippingPolygon.length = 0;
		};
		SkeletonClipping.prototype.isClipping = function () {
			return this.clipAttachment != null;
		};
		SkeletonClipping.prototype.clipTriangles = function (vertices, verticesLength, triangles, trianglesLength, uvs, light, dark, twoColor) {
			var clipOutput = this.clipOutput, clippedVertices = this.clippedVertices;
			var clippedTriangles = this.clippedTriangles;
			var polygons = this.clippingPolygons;
			var polygonsCount = this.clippingPolygons.length;
			var vertexSize = twoColor ? 12 : 8;
			var index = 0;
			clippedVertices.length = 0;
			clippedTriangles.length = 0;
			outer: for (var i = 0; i < trianglesLength; i += 3) {
				var vertexOffset = triangles[i] << 1;
				var x1 = vertices[vertexOffset], y1 = vertices[vertexOffset + 1];
				var u1 = uvs[vertexOffset], v1 = uvs[vertexOffset + 1];
				vertexOffset = triangles[i + 1] << 1;
				var x2 = vertices[vertexOffset], y2 = vertices[vertexOffset + 1];
				var u2 = uvs[vertexOffset], v2 = uvs[vertexOffset + 1];
				vertexOffset = triangles[i + 2] << 1;
				var x3 = vertices[vertexOffset], y3 = vertices[vertexOffset + 1];
				var u3 = uvs[vertexOffset], v3 = uvs[vertexOffset + 1];
				for (var p = 0; p < polygonsCount; p++) {
					var s = clippedVertices.length;
					if (this.clip(x1, y1, x2, y2, x3, y3, polygons[p], clipOutput)) {
						var clipOutputLength = clipOutput.length;
						if (clipOutputLength == 0)
							continue;
						var d0 = y2 - y3, d1 = x3 - x2, d2 = x1 - x3, d4 = y3 - y1;
						var d = 1 / (d0 * d2 + d1 * (y1 - y3));
						var clipOutputCount = clipOutputLength >> 1;
						var clipOutputItems = this.clipOutput;
						var clippedVerticesItems = spine.Utils.setArraySize(clippedVertices, s + clipOutputCount * vertexSize);
						for (var ii = 0; ii < clipOutputLength; ii += 2) {
							var x = clipOutputItems[ii], y = clipOutputItems[ii + 1];
							clippedVerticesItems[s] = x;
							clippedVerticesItems[s + 1] = y;
							clippedVerticesItems[s + 2] = light.r;
							clippedVerticesItems[s + 3] = light.g;
							clippedVerticesItems[s + 4] = light.b;
							clippedVerticesItems[s + 5] = light.a;
							var c0 = x - x3, c1 = y - y3;
							var a = (d0 * c0 + d1 * c1) * d;
							var b = (d4 * c0 + d2 * c1) * d;
							var c = 1 - a - b;
							clippedVerticesItems[s + 6] = u1 * a + u2 * b + u3 * c;
							clippedVerticesItems[s + 7] = v1 * a + v2 * b + v3 * c;
							if (twoColor) {
								clippedVerticesItems[s + 8] = dark.r;
								clippedVerticesItems[s + 9] = dark.g;
								clippedVerticesItems[s + 10] = dark.b;
								clippedVerticesItems[s + 11] = dark.a;
							}
							s += vertexSize;
						}
						s = clippedTriangles.length;
						var clippedTrianglesItems = spine.Utils.setArraySize(clippedTriangles, s + 3 * (clipOutputCount - 2));
						clipOutputCount--;
						for (var ii = 1; ii < clipOutputCount; ii++) {
							clippedTrianglesItems[s] = index;
							clippedTrianglesItems[s + 1] = (index + ii);
							clippedTrianglesItems[s + 2] = (index + ii + 1);
							s += 3;
						}
						index += clipOutputCount + 1;
					}
					else {
						var clippedVerticesItems = spine.Utils.setArraySize(clippedVertices, s + 3 * vertexSize);
						clippedVerticesItems[s] = x1;
						clippedVerticesItems[s + 1] = y1;
						clippedVerticesItems[s + 2] = light.r;
						clippedVerticesItems[s + 3] = light.g;
						clippedVerticesItems[s + 4] = light.b;
						clippedVerticesItems[s + 5] = light.a;
						if (!twoColor) {
							clippedVerticesItems[s + 6] = u1;
							clippedVerticesItems[s + 7] = v1;
							clippedVerticesItems[s + 8] = x2;
							clippedVerticesItems[s + 9] = y2;
							clippedVerticesItems[s + 10] = light.r;
							clippedVerticesItems[s + 11] = light.g;
							clippedVerticesItems[s + 12] = light.b;
							clippedVerticesItems[s + 13] = light.a;
							clippedVerticesItems[s + 14] = u2;
							clippedVerticesItems[s + 15] = v2;
							clippedVerticesItems[s + 16] = x3;
							clippedVerticesItems[s + 17] = y3;
							clippedVerticesItems[s + 18] = light.r;
							clippedVerticesItems[s + 19] = light.g;
							clippedVerticesItems[s + 20] = light.b;
							clippedVerticesItems[s + 21] = light.a;
							clippedVerticesItems[s + 22] = u3;
							clippedVerticesItems[s + 23] = v3;
						}
						else {
							clippedVerticesItems[s + 6] = u1;
							clippedVerticesItems[s + 7] = v1;
							clippedVerticesItems[s + 8] = dark.r;
							clippedVerticesItems[s + 9] = dark.g;
							clippedVerticesItems[s + 10] = dark.b;
							clippedVerticesItems[s + 11] = dark.a;
							clippedVerticesItems[s + 12] = x2;
							clippedVerticesItems[s + 13] = y2;
							clippedVerticesItems[s + 14] = light.r;
							clippedVerticesItems[s + 15] = light.g;
							clippedVerticesItems[s + 16] = light.b;
							clippedVerticesItems[s + 17] = light.a;
							clippedVerticesItems[s + 18] = u2;
							clippedVerticesItems[s + 19] = v2;
							clippedVerticesItems[s + 20] = dark.r;
							clippedVerticesItems[s + 21] = dark.g;
							clippedVerticesItems[s + 22] = dark.b;
							clippedVerticesItems[s + 23] = dark.a;
							clippedVerticesItems[s + 24] = x3;
							clippedVerticesItems[s + 25] = y3;
							clippedVerticesItems[s + 26] = light.r;
							clippedVerticesItems[s + 27] = light.g;
							clippedVerticesItems[s + 28] = light.b;
							clippedVerticesItems[s + 29] = light.a;
							clippedVerticesItems[s + 30] = u3;
							clippedVerticesItems[s + 31] = v3;
							clippedVerticesItems[s + 32] = dark.r;
							clippedVerticesItems[s + 33] = dark.g;
							clippedVerticesItems[s + 34] = dark.b;
							clippedVerticesItems[s + 35] = dark.a;
						}
						s = clippedTriangles.length;
						var clippedTrianglesItems = spine.Utils.setArraySize(clippedTriangles, s + 3);
						clippedTrianglesItems[s] = index;
						clippedTrianglesItems[s + 1] = (index + 1);
						clippedTrianglesItems[s + 2] = (index + 2);
						index += 3;
						continue outer;
					}
				}
			}
		};
		SkeletonClipping.prototype.clip = function (x1, y1, x2, y2, x3, y3, clippingArea, output) {
			var originalOutput = output;
			var clipped = false;
			var input = null;
			if (clippingArea.length % 4 >= 2) {
				input = output;
				output = this.scratch;
			}
			else
				input = this.scratch;
			input.length = 0;
			input.push(x1);
			input.push(y1);
			input.push(x2);
			input.push(y2);
			input.push(x3);
			input.push(y3);
			input.push(x1);
			input.push(y1);
			output.length = 0;
			var clippingVertices = clippingArea;
			var clippingVerticesLast = clippingArea.length - 4;
			for (var i = 0;; i += 2) {
				var edgeX = clippingVertices[i], edgeY = clippingVertices[i + 1];
				var edgeX2 = clippingVertices[i + 2], edgeY2 = clippingVertices[i + 3];
				var deltaX = edgeX - edgeX2, deltaY = edgeY - edgeY2;
				var inputVertices = input;
				var inputVerticesLength = input.length - 2, outputStart = output.length;
				for (var ii = 0; ii < inputVerticesLength; ii += 2) {
					var inputX = inputVertices[ii], inputY = inputVertices[ii + 1];
					var inputX2 = inputVertices[ii + 2], inputY2 = inputVertices[ii + 3];
					var side2 = deltaX * (inputY2 - edgeY2) - deltaY * (inputX2 - edgeX2) > 0;
					if (deltaX * (inputY - edgeY2) - deltaY * (inputX - edgeX2) > 0) {
						if (side2) {
							output.push(inputX2);
							output.push(inputY2);
							continue;
						}
						var c0 = inputY2 - inputY, c2 = inputX2 - inputX;
						var s = c0 * (edgeX2 - edgeX) - c2 * (edgeY2 - edgeY);
						if (Math.abs(s) > 0.000001) {
							var ua = (c2 * (edgeY - inputY) - c0 * (edgeX - inputX)) / s;
							output.push(edgeX + (edgeX2 - edgeX) * ua);
							output.push(edgeY + (edgeY2 - edgeY) * ua);
						}
						else {
							output.push(edgeX);
							output.push(edgeY);
						}
					}
					else if (side2) {
						var c0 = inputY2 - inputY, c2 = inputX2 - inputX;
						var s = c0 * (edgeX2 - edgeX) - c2 * (edgeY2 - edgeY);
						if (Math.abs(s) > 0.000001) {
							var ua = (c2 * (edgeY - inputY) - c0 * (edgeX - inputX)) / s;
							output.push(edgeX + (edgeX2 - edgeX) * ua);
							output.push(edgeY + (edgeY2 - edgeY) * ua);
						}
						else {
							output.push(edgeX);
							output.push(edgeY);
						}
						output.push(inputX2);
						output.push(inputY2);
					}
					clipped = true;
				}
				if (outputStart == output.length) {
					originalOutput.length = 0;
					return true;
				}
				output.push(output[0]);
				output.push(output[1]);
				if (i == clippingVerticesLast)
					break;
				var temp = output;
				output = input;
				output.length = 0;
				input = temp;
			}
			if (originalOutput != output) {
				originalOutput.length = 0;
				for (var i = 0, n = output.length - 2; i < n; i++)
					originalOutput[i] = output[i];
			}
			else
				originalOutput.length = originalOutput.length - 2;
			return clipped;
		};
		SkeletonClipping.makeClockwise = function (polygon) {
			var vertices = polygon;
			var verticeslength = polygon.length;
			var area = vertices[verticeslength - 2] * vertices[1] - vertices[0] * vertices[verticeslength - 1], p1x = 0, p1y = 0, p2x = 0, p2y = 0;
			for (var i = 0, n = verticeslength - 3; i < n; i += 2) {
				p1x = vertices[i];
				p1y = vertices[i + 1];
				p2x = vertices[i + 2];
				p2y = vertices[i + 3];
				area += p1x * p2y - p2x * p1y;
			}
			if (area < 0)
				return;
			for (var i = 0, lastX = verticeslength - 2, n = verticeslength >> 1; i < n; i += 2) {
				var x = vertices[i], y = vertices[i + 1];
				var other = lastX - i;
				vertices[i] = vertices[other];
				vertices[i + 1] = vertices[other + 1];
				vertices[other] = x;
				vertices[other + 1] = y;
			}
		};
		return SkeletonClipping;
	}());
	spine.SkeletonClipping = SkeletonClipping;
})(spine || (spine = {}));
var spine;
(function (spine) {
	var SkeletonData = (function () {
		function SkeletonData() {
			this.bones = new Array();
			this.slots = new Array();
			this.skins = new Array();
			this.events = new Array();
			this.animations = new Array();
			this.ikConstraints = new Array();
			this.transformConstraints = new Array();
			this.pathConstraints = new Array();
			this.fps = 0;
		}
		SkeletonData.prototype.findBone = function (boneName) {
			if (boneName == null)
				throw new Error("boneName cannot be null.");
			var bones = this.bones;
			for (var i = 0, n = bones.length; i < n; i++) {
				var bone = bones[i];
				if (bone.name == boneName)
					return bone;
			}
			return null;
		};
		SkeletonData.prototype.findBoneIndex = function (boneName) {
			if (boneName == null)
				throw new Error("boneName cannot be null.");
			var bones = this.bones;
			for (var i = 0, n = bones.length; i < n; i++)
				if (bones[i].name == boneName)
					return i;
			return -1;
		};
		SkeletonData.prototype.findSlot = function (slotName) {
			if (slotName == null)
				throw new Error("slotName cannot be null.");
			var slots = this.slots;
			for (var i = 0, n = slots.length; i < n; i++) {
				var slot = slots[i];
				if (slot.name == slotName)
					return slot;
			}
			return null;
		};
		SkeletonData.prototype.findSlotIndex = function (slotName) {
			if (slotName == null)
				throw new Error("slotName cannot be null.");
			var slots = this.slots;
			for (var i = 0, n = slots.length; i < n; i++)
				if (slots[i].name == slotName)
					return i;
			return -1;
		};
		SkeletonData.prototype.findSkin = function (skinName) {
			if (skinName == null)
				throw new Error("skinName cannot be null.");
			var skins = this.skins;
			for (var i = 0, n = skins.length; i < n; i++) {
				var skin = skins[i];
				if (skin.name == skinName)
					return skin;
			}
			return null;
		};
		SkeletonData.prototype.findEvent = function (eventDataName) {
			if (eventDataName == null)
				throw new Error("eventDataName cannot be null.");
			var events = this.events;
			for (var i = 0, n = events.length; i < n; i++) {
				var event_5 = events[i];
				if (event_5.name == eventDataName)
					return event_5;
			}
			return null;
		};
		SkeletonData.prototype.findAnimation = function (animationName) {
			if (animationName == null)
				throw new Error("animationName cannot be null.");
			var animations = this.animations;
			for (var i = 0, n = animations.length; i < n; i++) {
				var animation = animations[i];
				if (animation.name == animationName)
					return animation;
			}
			return null;
		};
		SkeletonData.prototype.findIkConstraint = function (constraintName) {
			if (constraintName == null)
				throw new Error("constraintName cannot be null.");
			var ikConstraints = this.ikConstraints;
			for (var i = 0, n = ikConstraints.length; i < n; i++) {
				var constraint = ikConstraints[i];
				if (constraint.name == constraintName)
					return constraint;
			}
			return null;
		};
		SkeletonData.prototype.findTransformConstraint = function (constraintName) {
			if (constraintName == null)
				throw new Error("constraintName cannot be null.");
			var transformConstraints = this.transformConstraints;
			for (var i = 0, n = transformConstraints.length; i < n; i++) {
				var constraint = transformConstraints[i];
				if (constraint.name == constraintName)
					return constraint;
			}
			return null;
		};
		SkeletonData.prototype.findPathConstraint = function (constraintName) {
			if (constraintName == null)
				throw new Error("constraintName cannot be null.");
			var pathConstraints = this.pathConstraints;
			for (var i = 0, n = pathConstraints.length; i < n; i++) {
				var constraint = pathConstraints[i];
				if (constraint.name == constraintName)
					return constraint;
			}
			return null;
		};
		SkeletonData.prototype.findPathConstraintIndex = function (pathConstraintName) {
			if (pathConstraintName == null)
				throw new Error("pathConstraintName cannot be null.");
			var pathConstraints = this.pathConstraints;
			for (var i = 0, n = pathConstraints.length; i < n; i++)
				if (pathConstraints[i].name == pathConstraintName)
					return i;
			return -1;
		};
		return SkeletonData;
	}());
	spine.SkeletonData = SkeletonData;
})(spine || (spine = {}));
var spine;
(function (spine) {
	var SkeletonJson = (function () {
		function SkeletonJson(attachmentLoader) {
			this.scale = 1;
			this.linkedMeshes = new Array();
			this.attachmentLoader = attachmentLoader;
		}
		SkeletonJson.prototype.readSkeletonData = function (json) {
			var scale = this.scale;
			var skeletonData = new spine.SkeletonData();
			var root = typeof (json) === "string" ? JSON.parse(json) : json;
			var skeletonMap = root.skeleton;
			if (skeletonMap != null) {
				skeletonData.hash = skeletonMap.hash;
				skeletonData.version = skeletonMap.spine;
				if ("3.8.75" == skeletonData.version)
					throw new Error("Unsupported skeleton data, please export with a newer version of Spine.");
				skeletonData.x = skeletonMap.x;
				skeletonData.y = skeletonMap.y;
				skeletonData.width = skeletonMap.width;
				skeletonData.height = skeletonMap.height;
				skeletonData.fps = skeletonMap.fps;
				skeletonData.imagesPath = skeletonMap.images;
			}
			if (root.bones) {
				for (var i = 0; i < root.bones.length; i++) {
					var boneMap = root.bones[i];
					var parent_5 = null;
					var parentName = this.getValue(boneMap, "parent", null);
					if (parentName != null) {
						parent_5 = skeletonData.findBone(parentName);
						if (parent_5 == null)
							throw new Error("Parent bone not found: " + parentName);
					}
					var data = new spine.BoneData(skeletonData.bones.length, boneMap.name, parent_5);
					data.length = this.getValue(boneMap, "length", 0) * scale;
					data.x = this.getValue(boneMap, "x", 0) * scale;
					data.y = this.getValue(boneMap, "y", 0) * scale;
					data.rotation = this.getValue(boneMap, "rotation", 0);
					data.scaleX = this.getValue(boneMap, "scaleX", 1);
					data.scaleY = this.getValue(boneMap, "scaleY", 1);
					data.shearX = this.getValue(boneMap, "shearX", 0);
					data.shearY = this.getValue(boneMap, "shearY", 0);
					data.transformMode = SkeletonJson.transformModeFromString(this.getValue(boneMap, "transform", "normal"));
					data.skinRequired = this.getValue(boneMap, "skin", false);
					skeletonData.bones.push(data);
				}
			}
			if (root.slots) {
				for (var i = 0; i < root.slots.length; i++) {
					var slotMap = root.slots[i];
					var slotName = slotMap.name;
					var boneName = slotMap.bone;
					var boneData = skeletonData.findBone(boneName);
					if (boneData == null)
						throw new Error("Slot bone not found: " + boneName);
					var data = new spine.SlotData(skeletonData.slots.length, slotName, boneData);
					var color = this.getValue(slotMap, "color", null);
					if (color != null)
						data.color.setFromString(color);
					var dark = this.getValue(slotMap, "dark", null);
					if (dark != null) {
						data.darkColor = new spine.Color(1, 1, 1, 1);
						data.darkColor.setFromString(dark);
					}
					data.attachmentName = this.getValue(slotMap, "attachment", null);
					data.blendMode = SkeletonJson.blendModeFromString(this.getValue(slotMap, "blend", "normal"));
					skeletonData.slots.push(data);
				}
			}
			if (root.ik) {
				for (var i = 0; i < root.ik.length; i++) {
					var constraintMap = root.ik[i];
					var data = new spine.IkConstraintData(constraintMap.name);
					data.order = this.getValue(constraintMap, "order", 0);
					data.skinRequired = this.getValue(constraintMap, "skin", false);
					for (var j = 0; j < constraintMap.bones.length; j++) {
						var boneName = constraintMap.bones[j];
						var bone = skeletonData.findBone(boneName);
						if (bone == null)
							throw new Error("IK bone not found: " + boneName);
						data.bones.push(bone);
					}
					var targetName = constraintMap.target;
					data.target = skeletonData.findBone(targetName);
					if (data.target == null)
						throw new Error("IK target bone not found: " + targetName);
					data.mix = this.getValue(constraintMap, "mix", 1);
					data.softness = this.getValue(constraintMap, "softness", 0) * scale;
					data.bendDirection = this.getValue(constraintMap, "bendPositive", true) ? 1 : -1;
					data.compress = this.getValue(constraintMap, "compress", false);
					data.stretch = this.getValue(constraintMap, "stretch", false);
					data.uniform = this.getValue(constraintMap, "uniform", false);
					skeletonData.ikConstraints.push(data);
				}
			}
			if (root.transform) {
				for (var i = 0; i < root.transform.length; i++) {
					var constraintMap = root.transform[i];
					var data = new spine.TransformConstraintData(constraintMap.name);
					data.order = this.getValue(constraintMap, "order", 0);
					data.skinRequired = this.getValue(constraintMap, "skin", false);
					for (var j = 0; j < constraintMap.bones.length; j++) {
						var boneName = constraintMap.bones[j];
						var bone = skeletonData.findBone(boneName);
						if (bone == null)
							throw new Error("Transform constraint bone not found: " + boneName);
						data.bones.push(bone);
					}
					var targetName = constraintMap.target;
					data.target = skeletonData.findBone(targetName);
					if (data.target == null)
						throw new Error("Transform constraint target bone not found: " + targetName);
					data.local = this.getValue(constraintMap, "local", false);
					data.relative = this.getValue(constraintMap, "relative", false);
					data.offsetRotation = this.getValue(constraintMap, "rotation", 0);
					data.offsetX = this.getValue(constraintMap, "x", 0) * scale;
					data.offsetY = this.getValue(constraintMap, "y", 0) * scale;
					data.offsetScaleX = this.getValue(constraintMap, "scaleX", 0);
					data.offsetScaleY = this.getValue(constraintMap, "scaleY", 0);
					data.offsetShearY = this.getValue(constraintMap, "shearY", 0);
					data.rotateMix = this.getValue(constraintMap, "rotateMix", 1);
					data.translateMix = this.getValue(constraintMap, "translateMix", 1);
					data.scaleMix = this.getValue(constraintMap, "scaleMix", 1);
					data.shearMix = this.getValue(constraintMap, "shearMix", 1);
					skeletonData.transformConstraints.push(data);
				}
			}
			if (root.path) {
				for (var i = 0; i < root.path.length; i++) {
					var constraintMap = root.path[i];
					var data = new spine.PathConstraintData(constraintMap.name);
					data.order = this.getValue(constraintMap, "order", 0);
					data.skinRequired = this.getValue(constraintMap, "skin", false);
					for (var j = 0; j < constraintMap.bones.length; j++) {
						var boneName = constraintMap.bones[j];
						var bone = skeletonData.findBone(boneName);
						if (bone == null)
							throw new Error("Transform constraint bone not found: " + boneName);
						data.bones.push(bone);
					}
					var targetName = constraintMap.target;
					data.target = skeletonData.findSlot(targetName);
					if (data.target == null)
						throw new Error("Path target slot not found: " + targetName);
					data.positionMode = SkeletonJson.positionModeFromString(this.getValue(constraintMap, "positionMode", "percent"));
					data.spacingMode = SkeletonJson.spacingModeFromString(this.getValue(constraintMap, "spacingMode", "length"));
					data.rotateMode = SkeletonJson.rotateModeFromString(this.getValue(constraintMap, "rotateMode", "tangent"));
					data.offsetRotation = this.getValue(constraintMap, "rotation", 0);
					data.position = this.getValue(constraintMap, "position", 0);
					if (data.positionMode == spine.PositionMode.Fixed)
						data.position *= scale;
					data.spacing = this.getValue(constraintMap, "spacing", 0);
					if (data.spacingMode == spine.SpacingMode.Length || data.spacingMode == spine.SpacingMode.Fixed)
						data.spacing *= scale;
					data.rotateMix = this.getValue(constraintMap, "rotateMix", 1);
					data.translateMix = this.getValue(constraintMap, "translateMix", 1);
					skeletonData.pathConstraints.push(data);
				}
			}
			if (root.skins) {
				for (var i = 0; i < root.skins.length; i++) {
					var skinMap = root.skins[i];
					var skin = new spine.Skin(skinMap.name);
					if (skinMap.bones) {
						for (var ii = 0; ii < skinMap.bones.length; ii++) {
							var bone = skeletonData.findBone(skinMap.bones[ii]);
							if (bone == null)
								throw new Error("Skin bone not found: " + skinMap.bones[i]);
							skin.bones.push(bone);
						}
					}
					if (skinMap.ik) {
						for (var ii = 0; ii < skinMap.ik.length; ii++) {
							var constraint = skeletonData.findIkConstraint(skinMap.ik[ii]);
							if (constraint == null)
								throw new Error("Skin IK constraint not found: " + skinMap.ik[i]);
							skin.constraints.push(constraint);
						}
					}
					if (skinMap.transform) {
						for (var ii = 0; ii < skinMap.transform.length; ii++) {
							var constraint = skeletonData.findTransformConstraint(skinMap.transform[ii]);
							if (constraint == null)
								throw new Error("Skin transform constraint not found: " + skinMap.transform[i]);
							skin.constraints.push(constraint);
						}
					}
					if (skinMap.path) {
						for (var ii = 0; ii < skinMap.path.length; ii++) {
							var constraint = skeletonData.findPathConstraint(skinMap.path[ii]);
							if (constraint == null)
								throw new Error("Skin path constraint not found: " + skinMap.path[i]);
							skin.constraints.push(constraint);
						}
					}
					for (var slotName in skinMap.attachments) {
						var slot = skeletonData.findSlot(slotName);
						if (slot == null)
							throw new Error("Slot not found: " + slotName);
						var slotMap = skinMap.attachments[slotName];
						for (var entryName in slotMap) {
							var attachment = this.readAttachment(slotMap[entryName], skin, slot.index, entryName, skeletonData);
							if (attachment != null)
								skin.setAttachment(slot.index, entryName, attachment);
						}
					}
					skeletonData.skins.push(skin);
					if (skin.name == "default")
						skeletonData.defaultSkin = skin;
				}
			}
			for (var i = 0, n = this.linkedMeshes.length; i < n; i++) {
				var linkedMesh = this.linkedMeshes[i];
				var skin = linkedMesh.skin == null ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);
				if (skin == null)
					throw new Error("Skin not found: " + linkedMesh.skin);
				var parent_6 = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);
				if (parent_6 == null)
					throw new Error("Parent mesh not found: " + linkedMesh.parent);
				linkedMesh.mesh.deformAttachment = linkedMesh.inheritDeform ? parent_6 : linkedMesh.mesh;
				linkedMesh.mesh.setParentMesh(parent_6);
				linkedMesh.mesh.updateUVs();
			}
			this.linkedMeshes.length = 0;
			if (root.events) {
				for (var eventName in root.events) {
					var eventMap = root.events[eventName];
					var data = new spine.EventData(eventName);
					data.intValue = this.getValue(eventMap, "int", 0);
					data.floatValue = this.getValue(eventMap, "float", 0);
					data.stringValue = this.getValue(eventMap, "string", "");
					data.audioPath = this.getValue(eventMap, "audio", null);
					if (data.audioPath != null) {
						data.volume = this.getValue(eventMap, "volume", 1);
						data.balance = this.getValue(eventMap, "balance", 0);
					}
					skeletonData.events.push(data);
				}
			}
			if (root.animations) {
				for (var animationName in root.animations) {
					var animationMap = root.animations[animationName];
					this.readAnimation(animationMap, animationName, skeletonData);
				}
			}
			return skeletonData;
		};
		SkeletonJson.prototype.readAttachment = function (map, skin, slotIndex, name, skeletonData) {
			var scale = this.scale;
			name = this.getValue(map, "name", name);
			var type = this.getValue(map, "type", "region");
			switch (type) {
				case "region": {
					var path = this.getValue(map, "path", name);
					var region = this.attachmentLoader.newRegionAttachment(skin, name, path);
					if (region == null)
						return null;
					region.path = path;
					region.x = this.getValue(map, "x", 0) * scale;
					region.y = this.getValue(map, "y", 0) * scale;
					region.scaleX = this.getValue(map, "scaleX", 1);
					region.scaleY = this.getValue(map, "scaleY", 1);
					region.rotation = this.getValue(map, "rotation", 0);
					region.width = map.width * scale;
					region.height = map.height * scale;
					var color = this.getValue(map, "color", null);
					if (color != null)
						region.color.setFromString(color);
					region.updateOffset();
					return region;
				}
				case "boundingbox": {
					var box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);
					if (box == null)
						return null;
					this.readVertices(map, box, map.vertexCount << 1);
					var color = this.getValue(map, "color", null);
					if (color != null)
						box.color.setFromString(color);
					return box;
				}
				case "mesh":
				case "linkedmesh": {
					var path = this.getValue(map, "path", name);
					var mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);
					if (mesh == null)
						return null;
					mesh.path = path;
					var color = this.getValue(map, "color", null);
					if (color != null)
						mesh.color.setFromString(color);
					mesh.width = this.getValue(map, "width", 0) * scale;
					mesh.height = this.getValue(map, "height", 0) * scale;
					var parent_7 = this.getValue(map, "parent", null);
					if (parent_7 != null) {
						this.linkedMeshes.push(new LinkedMesh(mesh, this.getValue(map, "skin", null), slotIndex, parent_7, this.getValue(map, "deform", true)));
						return mesh;
					}
					var uvs = map.uvs;
					this.readVertices(map, mesh, uvs.length);
					mesh.triangles = map.triangles;
					mesh.regionUVs = uvs;
					mesh.updateUVs();
					mesh.edges = this.getValue(map, "edges", null);
					mesh.hullLength = this.getValue(map, "hull", 0) * 2;
					return mesh;
				}
				case "path": {
					var path = this.attachmentLoader.newPathAttachment(skin, name);
					if (path == null)
						return null;
					path.closed = this.getValue(map, "closed", false);
					path.constantSpeed = this.getValue(map, "constantSpeed", true);
					var vertexCount = map.vertexCount;
					this.readVertices(map, path, vertexCount << 1);
					var lengths = spine.Utils.newArray(vertexCount / 3, 0);
					for (var i = 0; i < map.lengths.length; i++)
						lengths[i] = map.lengths[i] * scale;
					path.lengths = lengths;
					var color = this.getValue(map, "color", null);
					if (color != null)
						path.color.setFromString(color);
					return path;
				}
				case "point": {
					var point = this.attachmentLoader.newPointAttachment(skin, name);
					if (point == null)
						return null;
					point.x = this.getValue(map, "x", 0) * scale;
					point.y = this.getValue(map, "y", 0) * scale;
					point.rotation = this.getValue(map, "rotation", 0);
					var color = this.getValue(map, "color", null);
					if (color != null)
						point.color.setFromString(color);
					return point;
				}
				case "clipping": {
					var clip = this.attachmentLoader.newClippingAttachment(skin, name);
					if (clip == null)
						return null;
					var end = this.getValue(map, "end", null);
					if (end != null) {
						var slot = skeletonData.findSlot(end);
						if (slot == null)
							throw new Error("Clipping end slot not found: " + end);
						clip.endSlot = slot;
					}
					var vertexCount = map.vertexCount;
					this.readVertices(map, clip, vertexCount << 1);
					var color = this.getValue(map, "color", null);
					if (color != null)
						clip.color.setFromString(color);
					return clip;
				}
			}
			return null;
		};
		SkeletonJson.prototype.readVertices = function (map, attachment, verticesLength) {
			var scale = this.scale;
			attachment.worldVerticesLength = verticesLength;
			var vertices = map.vertices;
			if (verticesLength == vertices.length) {
				var scaledVertices = spine.Utils.toFloatArray(vertices);
				if (scale != 1) {
					for (var i = 0, n = vertices.length; i < n; i++)
						scaledVertices[i] *= scale;
				}
				attachment.vertices = scaledVertices;
				return;
			}
			var weights = new Array();
			var bones = new Array();
			for (var i = 0, n = vertices.length; i < n;) {
				var boneCount = vertices[i++];
				bones.push(boneCount);
				for (var nn = i + boneCount * 4; i < nn; i += 4) {
					bones.push(vertices[i]);
					weights.push(vertices[i + 1] * scale);
					weights.push(vertices[i + 2] * scale);
					weights.push(vertices[i + 3]);
				}
			}
			attachment.bones = bones;
			attachment.vertices = spine.Utils.toFloatArray(weights);
		};
		SkeletonJson.prototype.readAnimation = function (map, name, skeletonData) {
			var scale = this.scale;
			var timelines = new Array();
			var duration = 0;
			if (map.slots) {
				for (var slotName in map.slots) {
					var slotMap = map.slots[slotName];
					var slotIndex = skeletonData.findSlotIndex(slotName);
					if (slotIndex == -1)
						throw new Error("Slot not found: " + slotName);
					for (var timelineName in slotMap) {
						var timelineMap = slotMap[timelineName];
						if (timelineName == "attachment") {
							var timeline = new spine.AttachmentTimeline(timelineMap.length);
							timeline.slotIndex = slotIndex;
							var frameIndex = 0;
							for (var i = 0; i < timelineMap.length; i++) {
								var valueMap = timelineMap[i];
								timeline.setFrame(frameIndex++, this.getValue(valueMap, "time", 0), valueMap.name);
							}
							timelines.push(timeline);
							duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
						}
						else if (timelineName == "color") {
							var timeline = new spine.ColorTimeline(timelineMap.length);
							timeline.slotIndex = slotIndex;
							var frameIndex = 0;
							for (var i = 0; i < timelineMap.length; i++) {
								var valueMap = timelineMap[i];
								var color = new spine.Color();
								color.setFromString(valueMap.color);
								timeline.setFrame(frameIndex, this.getValue(valueMap, "time", 0), color.r, color.g, color.b, color.a);
								this.readCurve(valueMap, timeline, frameIndex);
								frameIndex++;
							}
							timelines.push(timeline);
							duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.ColorTimeline.ENTRIES]);
						}
						else if (timelineName == "twoColor") {
							var timeline = new spine.TwoColorTimeline(timelineMap.length);
							timeline.slotIndex = slotIndex;
							var frameIndex = 0;
							for (var i = 0; i < timelineMap.length; i++) {
								var valueMap = timelineMap[i];
								var light = new spine.Color();
								var dark = new spine.Color();
								light.setFromString(valueMap.light);
								dark.setFromString(valueMap.dark);
								timeline.setFrame(frameIndex, this.getValue(valueMap, "time", 0), light.r, light.g, light.b, light.a, dark.r, dark.g, dark.b);
								this.readCurve(valueMap, timeline, frameIndex);
								frameIndex++;
							}
							timelines.push(timeline);
							duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.TwoColorTimeline.ENTRIES]);
						}
						else
							throw new Error("Invalid timeline type for a slot: " + timelineName + " (" + slotName + ")");
					}
				}
			}
			if (map.bones) {
				for (var boneName in map.bones) {
					var boneMap = map.bones[boneName];
					var boneIndex = skeletonData.findBoneIndex(boneName);
					if (boneIndex == -1)
						throw new Error("Bone not found: " + boneName);
					for (var timelineName in boneMap) {
						var timelineMap = boneMap[timelineName];
						if (timelineName === "rotate") {
							var timeline = new spine.RotateTimeline(timelineMap.length);
							timeline.boneIndex = boneIndex;
							var frameIndex = 0;
							for (var i = 0; i < timelineMap.length; i++) {
								var valueMap = timelineMap[i];
								timeline.setFrame(frameIndex, this.getValue(valueMap, "time", 0), this.getValue(valueMap, "angle", 0));
								this.readCurve(valueMap, timeline, frameIndex);
								frameIndex++;
							}
							timelines.push(timeline);
							duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.RotateTimeline.ENTRIES]);
						}
						else if (timelineName === "translate" || timelineName === "scale" || timelineName === "shear") {
							var timeline = null;
							var timelineScale = 1, defaultValue = 0;
							if (timelineName === "scale") {
								timeline = new spine.ScaleTimeline(timelineMap.length);
								defaultValue = 1;
							}
							else if (timelineName === "shear")
								timeline = new spine.ShearTimeline(timelineMap.length);
							else {
								timeline = new spine.TranslateTimeline(timelineMap.length);
								timelineScale = scale;
							}
							timeline.boneIndex = boneIndex;
							var frameIndex = 0;
							for (var i = 0; i < timelineMap.length; i++) {
								var valueMap = timelineMap[i];
								var x = this.getValue(valueMap, "x", defaultValue), y = this.getValue(valueMap, "y", defaultValue);
								timeline.setFrame(frameIndex, this.getValue(valueMap, "time", 0), x * timelineScale, y * timelineScale);
								this.readCurve(valueMap, timeline, frameIndex);
								frameIndex++;
							}
							timelines.push(timeline);
							duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.TranslateTimeline.ENTRIES]);
						}
						else
							throw new Error("Invalid timeline type for a bone: " + timelineName + " (" + boneName + ")");
					}
				}
			}
			if (map.ik) {
				for (var constraintName in map.ik) {
					var constraintMap = map.ik[constraintName];
					var constraint = skeletonData.findIkConstraint(constraintName);
					var timeline = new spine.IkConstraintTimeline(constraintMap.length);
					timeline.ikConstraintIndex = skeletonData.ikConstraints.indexOf(constraint);
					var frameIndex = 0;
					for (var i = 0; i < constraintMap.length; i++) {
						var valueMap = constraintMap[i];
						timeline.setFrame(frameIndex, this.getValue(valueMap, "time", 0), this.getValue(valueMap, "mix", 1), this.getValue(valueMap, "softness", 0) * scale, this.getValue(valueMap, "bendPositive", true) ? 1 : -1, this.getValue(valueMap, "compress", false), this.getValue(valueMap, "stretch", false));
						this.readCurve(valueMap, timeline, frameIndex);
						frameIndex++;
					}
					timelines.push(timeline);
					duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.IkConstraintTimeline.ENTRIES]);
				}
			}
			if (map.transform) {
				for (var constraintName in map.transform) {
					var constraintMap = map.transform[constraintName];
					var constraint = skeletonData.findTransformConstraint(constraintName);
					var timeline = new spine.TransformConstraintTimeline(constraintMap.length);
					timeline.transformConstraintIndex = skeletonData.transformConstraints.indexOf(constraint);
					var frameIndex = 0;
					for (var i = 0; i < constraintMap.length; i++) {
						var valueMap = constraintMap[i];
						timeline.setFrame(frameIndex, this.getValue(valueMap, "time", 0), this.getValue(valueMap, "rotateMix", 1), this.getValue(valueMap, "translateMix", 1), this.getValue(valueMap, "scaleMix", 1), this.getValue(valueMap, "shearMix", 1));
						this.readCurve(valueMap, timeline, frameIndex);
						frameIndex++;
					}
					timelines.push(timeline);
					duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.TransformConstraintTimeline.ENTRIES]);
				}
			}
			if (map.path) {
				for (var constraintName in map.path) {
					var constraintMap = map.path[constraintName];
					var index = skeletonData.findPathConstraintIndex(constraintName);
					if (index == -1)
						throw new Error("Path constraint not found: " + constraintName);
					var data = skeletonData.pathConstraints[index];
					for (var timelineName in constraintMap) {
						var timelineMap = constraintMap[timelineName];
						if (timelineName === "position" || timelineName === "spacing") {
							var timeline = null;
							var timelineScale = 1;
							if (timelineName === "spacing") {
								timeline = new spine.PathConstraintSpacingTimeline(timelineMap.length);
								if (data.spacingMode == spine.SpacingMode.Length || data.spacingMode == spine.SpacingMode.Fixed)
									timelineScale = scale;
							}
							else {
								timeline = new spine.PathConstraintPositionTimeline(timelineMap.length);
								if (data.positionMode == spine.PositionMode.Fixed)
									timelineScale = scale;
							}
							timeline.pathConstraintIndex = index;
							var frameIndex = 0;
							for (var i = 0; i < timelineMap.length; i++) {
								var valueMap = timelineMap[i];
								timeline.setFrame(frameIndex, this.getValue(valueMap, "time", 0), this.getValue(valueMap, timelineName, 0) * timelineScale);
								this.readCurve(valueMap, timeline, frameIndex);
								frameIndex++;
							}
							timelines.push(timeline);
							duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.PathConstraintPositionTimeline.ENTRIES]);
						}
						else if (timelineName === "mix") {
							var timeline = new spine.PathConstraintMixTimeline(timelineMap.length);
							timeline.pathConstraintIndex = index;
							var frameIndex = 0;
							for (var i = 0; i < timelineMap.length; i++) {
								var valueMap = timelineMap[i];
								timeline.setFrame(frameIndex, this.getValue(valueMap, "time", 0), this.getValue(valueMap, "rotateMix", 1), this.getValue(valueMap, "translateMix", 1));
								this.readCurve(valueMap, timeline, frameIndex);
								frameIndex++;
							}
							timelines.push(timeline);
							duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.PathConstraintMixTimeline.ENTRIES]);
						}
					}
				}
			}
			if (map.deform) {
				for (var deformName in map.deform) {
					var deformMap = map.deform[deformName];
					var skin = skeletonData.findSkin(deformName);
					if (skin == null)
						throw new Error("Skin not found: " + deformName);
					for (var slotName in deformMap) {
						var slotMap = deformMap[slotName];
						var slotIndex = skeletonData.findSlotIndex(slotName);
						if (slotIndex == -1)
							throw new Error("Slot not found: " + slotMap.name);
						for (var timelineName in slotMap) {
							var timelineMap = slotMap[timelineName];
							var attachment = skin.getAttachment(slotIndex, timelineName);
							if (attachment == null)
								throw new Error("Deform attachment not found: " + timelineMap.name);
							var weighted = attachment.bones != null;
							var vertices = attachment.vertices;
							var deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;
							var timeline = new spine.DeformTimeline(timelineMap.length);
							timeline.slotIndex = slotIndex;
							timeline.attachment = attachment;
							var frameIndex = 0;
							for (var j = 0; j < timelineMap.length; j++) {
								var valueMap = timelineMap[j];
								var deform = void 0;
								var verticesValue = this.getValue(valueMap, "vertices", null);
								if (verticesValue == null)
									deform = weighted ? spine.Utils.newFloatArray(deformLength) : vertices;
								else {
									deform = spine.Utils.newFloatArray(deformLength);
									var start = this.getValue(valueMap, "offset", 0);
									spine.Utils.arrayCopy(verticesValue, 0, deform, start, verticesValue.length);
									if (scale != 1) {
										for (var i = start, n = i + verticesValue.length; i < n; i++)
											deform[i] *= scale;
									}
									if (!weighted) {
										for (var i = 0; i < deformLength; i++)
											deform[i] += vertices[i];
									}
								}
								timeline.setFrame(frameIndex, this.getValue(valueMap, "time", 0), deform);
								this.readCurve(valueMap, timeline, frameIndex);
								frameIndex++;
							}
							timelines.push(timeline);
							duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
						}
					}
				}
			}
			var drawOrderNode = map.drawOrder;
			if (drawOrderNode == null)
				drawOrderNode = map.draworder;
			if (drawOrderNode != null) {
				var timeline = new spine.DrawOrderTimeline(drawOrderNode.length);
				var slotCount = skeletonData.slots.length;
				var frameIndex = 0;
				for (var j = 0; j < drawOrderNode.length; j++) {
					var drawOrderMap = drawOrderNode[j];
					var drawOrder = null;
					var offsets = this.getValue(drawOrderMap, "offsets", null);
					if (offsets != null) {
						drawOrder = spine.Utils.newArray(slotCount, -1);
						var unchanged = spine.Utils.newArray(slotCount - offsets.length, 0);
						var originalIndex = 0, unchangedIndex = 0;
						for (var i = 0; i < offsets.length; i++) {
							var offsetMap = offsets[i];
							var slotIndex = skeletonData.findSlotIndex(offsetMap.slot);
							if (slotIndex == -1)
								throw new Error("Slot not found: " + offsetMap.slot);
							while (originalIndex != slotIndex)
								unchanged[unchangedIndex++] = originalIndex++;
							drawOrder[originalIndex + offsetMap.offset] = originalIndex++;
						}
						while (originalIndex < slotCount)
							unchanged[unchangedIndex++] = originalIndex++;
						for (var i = slotCount - 1; i >= 0; i--)
							if (drawOrder[i] == -1)
								drawOrder[i] = unchanged[--unchangedIndex];
					}
					timeline.setFrame(frameIndex++, this.getValue(drawOrderMap, "time", 0), drawOrder);
				}
				timelines.push(timeline);
				duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
			}
			if (map.events) {
				var timeline = new spine.EventTimeline(map.events.length);
				var frameIndex = 0;
				for (var i = 0; i < map.events.length; i++) {
					var eventMap = map.events[i];
					var eventData = skeletonData.findEvent(eventMap.name);
					if (eventData == null)
						throw new Error("Event not found: " + eventMap.name);
					var event_6 = new spine.Event(spine.Utils.toSinglePrecision(this.getValue(eventMap, "time", 0)), eventData);
					event_6.intValue = this.getValue(eventMap, "int", eventData.intValue);
					event_6.floatValue = this.getValue(eventMap, "float", eventData.floatValue);
					event_6.stringValue = this.getValue(eventMap, "string", eventData.stringValue);
					if (event_6.data.audioPath != null) {
						event_6.volume = this.getValue(eventMap, "volume", 1);
						event_6.balance = this.getValue(eventMap, "balance", 0);
					}
					timeline.setFrame(frameIndex++, event_6);
				}
				timelines.push(timeline);
				duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
			}
			if (isNaN(duration)) {
				throw new Error("Error while parsing animation, duration is NaN");
			}
			skeletonData.animations.push(new spine.Animation(name, timelines, duration));
		};
		SkeletonJson.prototype.readCurve = function (map, timeline, frameIndex) {
			if (!map.hasOwnProperty("curve"))
				return;
			if (map.curve == "stepped")
				timeline.setStepped(frameIndex);
			else {
				var curve = map.curve;
				timeline.setCurve(frameIndex, curve, this.getValue(map, "c2", 0), this.getValue(map, "c3", 1), this.getValue(map, "c4", 1));
			}
		};
		SkeletonJson.prototype.getValue = function (map, prop, defaultValue) {
			return map[prop] !== undefined ? map[prop] : defaultValue;
		};
		SkeletonJson.blendModeFromString = function (str) {
			str = str.toLowerCase();
			if (str == "normal")
				return spine.BlendMode.Normal;
			if (str == "additive")
				return spine.BlendMode.Additive;
			if (str == "multiply")
				return spine.BlendMode.Multiply;
			if (str == "screen")
				return spine.BlendMode.Screen;
			throw new Error("Unknown blend mode: " + str);
		};
		SkeletonJson.positionModeFromString = function (str) {
			str = str.toLowerCase();
			if (str == "fixed")
				return spine.PositionMode.Fixed;
			if (str == "percent")
				return spine.PositionMode.Percent;
			throw new Error("Unknown position mode: " + str);
		};
		SkeletonJson.spacingModeFromString = function (str) {
			str = str.toLowerCase();
			if (str == "length")
				return spine.SpacingMode.Length;
			if (str == "fixed")
				return spine.SpacingMode.Fixed;
			if (str == "percent")
				return spine.SpacingMode.Percent;
			throw new Error("Unknown position mode: " + str);
		};
		SkeletonJson.rotateModeFromString = function (str) {
			str = str.toLowerCase();
			if (str == "tangent")
				return spine.RotateMode.Tangent;
			if (str == "chain")
				return spine.RotateMode.Chain;
			if (str == "chainscale")
				return spine.RotateMode.ChainScale;
			throw new Error("Unknown rotate mode: " + str);
		};
		SkeletonJson.transformModeFromString = function (str) {
			str = str.toLowerCase();
			if (str == "normal")
				return spine.TransformMode.Normal;
			if (str == "onlytranslation")
				return spine.TransformMode.OnlyTranslation;
			if (str == "norotationorreflection")
				return spine.TransformMode.NoRotationOrReflection;
			if (str == "noscale")
				return spine.TransformMode.NoScale;
			if (str == "noscaleorreflection")
				return spine.TransformMode.NoScaleOrReflection;
			throw new Error("Unknown transform mode: " + str);
		};
		return SkeletonJson;
	}());
	spine.SkeletonJson = SkeletonJson;
	var LinkedMesh = (function () {
		function LinkedMesh(mesh, skin, slotIndex, parent, inheritDeform) {
			this.mesh = mesh;
			this.skin = skin;
			this.slotIndex = slotIndex;
			this.parent = parent;
			this.inheritDeform = inheritDeform;
		}
		return LinkedMesh;
	}());
})(spine || (spine = {}));
var spine;
(function (spine) {
	var SkinEntry = (function () {
		function SkinEntry(slotIndex, name, attachment) {
			this.slotIndex = slotIndex;
			this.name = name;
			this.attachment = attachment;
		}
		return SkinEntry;
	}());
	spine.SkinEntry = SkinEntry;
	var Skin = (function () {
		function Skin(name) {
			this.attachments = new Array();
			this.bones = Array();
			this.constraints = new Array();
			if (name == null)
				throw new Error("name cannot be null.");
			this.name = name;
		}
		Skin.prototype.setAttachment = function (slotIndex, name, attachment) {
			if (attachment == null)
				throw new Error("attachment cannot be null.");
			var attachments = this.attachments;
			if (slotIndex >= attachments.length)
				attachments.length = slotIndex + 1;
			if (!attachments[slotIndex])
				attachments[slotIndex] = {};
			attachments[slotIndex][name] = attachment;
		};
		Skin.prototype.addSkin = function (skin) {
			for (var i = 0; i < skin.bones.length; i++) {
				var bone = skin.bones[i];
				var contained = false;
				for (var j = 0; j < this.bones.length; j++) {
					if (this.bones[j] == bone) {
						contained = true;
						break;
					}
				}
				if (!contained)
					this.bones.push(bone);
			}
			for (var i = 0; i < skin.constraints.length; i++) {
				var constraint = skin.constraints[i];
				var contained = false;
				for (var j = 0; j < this.constraints.length; j++) {
					if (this.constraints[j] == constraint) {
						contained = true;
						break;
					}
				}
				if (!contained)
					this.constraints.push(constraint);
			}
			var attachments = skin.getAttachments();
			for (var i = 0; i < attachments.length; i++) {
				var attachment = attachments[i];
				this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);
			}
		};
		Skin.prototype.copySkin = function (skin) {
			for (var i = 0; i < skin.bones.length; i++) {
				var bone = skin.bones[i];
				var contained = false;
				for (var j = 0; j < this.bones.length; j++) {
					if (this.bones[j] == bone) {
						contained = true;
						break;
					}
				}
				if (!contained)
					this.bones.push(bone);
			}
			for (var i = 0; i < skin.constraints.length; i++) {
				var constraint = skin.constraints[i];
				var contained = false;
				for (var j = 0; j < this.constraints.length; j++) {
					if (this.constraints[j] == constraint) {
						contained = true;
						break;
					}
				}
				if (!contained)
					this.constraints.push(constraint);
			}
			var attachments = skin.getAttachments();
			for (var i = 0; i < attachments.length; i++) {
				var attachment = attachments[i];
				if (attachment.attachment == null)
					continue;
				if (attachment.attachment instanceof spine.MeshAttachment) {
					attachment.attachment = attachment.attachment.newLinkedMesh();
					this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);
				}
				else {
					attachment.attachment = attachment.attachment.copy();
					this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);
				}
			}
		};
		Skin.prototype.getAttachment = function (slotIndex, name) {
			var dictionary = this.attachments[slotIndex];
			return dictionary ? dictionary[name] : null;
		};
		Skin.prototype.removeAttachment = function (slotIndex, name) {
			var dictionary = this.attachments[slotIndex];
			if (dictionary)
				dictionary[name] = null;
		};
		Skin.prototype.getAttachments = function () {
			var entries = new Array();
			for (var i = 0; i < this.attachments.length; i++) {
				var slotAttachments = this.attachments[i];
				if (slotAttachments) {
					for (var name_4 in slotAttachments) {
						var attachment = slotAttachments[name_4];
						if (attachment)
							entries.push(new SkinEntry(i, name_4, attachment));
					}
				}
			}
			return entries;
		};
		Skin.prototype.getAttachmentsForSlot = function (slotIndex, attachments) {
			var slotAttachments = this.attachments[slotIndex];
			if (slotAttachments) {
				for (var name_5 in slotAttachments) {
					var attachment = slotAttachments[name_5];
					if (attachment)
						attachments.push(new SkinEntry(slotIndex, name_5, attachment));
				}
			}
		};
		Skin.prototype.clear = function () {
			this.attachments.length = 0;
			this.bones.length = 0;
			this.constraints.length = 0;
		};
		Skin.prototype.attachAll = function (skeleton, oldSkin) {
			var slotIndex = 0;
			for (var i = 0; i < skeleton.slots.length; i++) {
				var slot = skeleton.slots[i];
				var slotAttachment = slot.getAttachment();
				if (slotAttachment && slotIndex < oldSkin.attachments.length) {
					var dictionary = oldSkin.attachments[slotIndex];
					for (var key in dictionary) {
						var skinAttachment = dictionary[key];
						if (slotAttachment == skinAttachment) {
							var attachment = this.getAttachment(slotIndex, key);
							if (attachment != null)
								slot.setAttachment(attachment);
							break;
						}
					}
				}
				slotIndex++;
			}
		};
		return Skin;
	}());
	spine.Skin = Skin;
})(spine || (spine = {}));
var spine;
(function (spine) {
	var Slot = (function () {
		function Slot(data, bone) {
			this.deform = new Array();
			if (data == null)
				throw new Error("data cannot be null.");
			if (bone == null)
				throw new Error("bone cannot be null.");
			this.data = data;
			this.bone = bone;
			this.color = new spine.Color();
			this.darkColor = data.darkColor == null ? null : new spine.Color();
			this.setToSetupPose();
		}
		Slot.prototype.getSkeleton = function () {
			return this.bone.skeleton;
		};
		Slot.prototype.getAttachment = function () {
			return this.attachment;
		};
		Slot.prototype.setAttachment = function (attachment) {
			if (this.attachment == attachment)
				return;
			this.attachment = attachment;
			this.attachmentTime = this.bone.skeleton.time;
			this.deform.length = 0;
		};
		Slot.prototype.setAttachmentTime = function (time) {
			this.attachmentTime = this.bone.skeleton.time - time;
		};
		Slot.prototype.getAttachmentTime = function () {
			return this.bone.skeleton.time - this.attachmentTime;
		};
		Slot.prototype.setToSetupPose = function () {
			this.color.setFromColor(this.data.color);
			if (this.darkColor != null)
				this.darkColor.setFromColor(this.data.darkColor);
			if (this.data.attachmentName == null)
				this.attachment = null;
			else {
				this.attachment = null;
				this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName));
			}
		};
		return Slot;
	}());
	spine.Slot = Slot;
})(spine || (spine = {}));
var spine;
(function (spine) {
	var SlotData = (function () {
		function SlotData(index, name, boneData) {
			this.color = new spine.Color(1, 1, 1, 1);
			if (index < 0)
				throw new Error("index must be >= 0.");
			if (name == null)
				throw new Error("name cannot be null.");
			if (boneData == null)
				throw new Error("boneData cannot be null.");
			this.index = index;
			this.name = name;
			this.boneData = boneData;
		}
		return SlotData;
	}());
	spine.SlotData = SlotData;
})(spine || (spine = {}));
var spine;
(function (spine) {
	var Texture = (function () {
		function Texture(image) {
			this._image = image;
		}
		Texture.prototype.getImage = function () {
			return this._image;
		};
		Texture.filterFromString = function (text) {
			switch (text.toLowerCase()) {
				case "nearest": return TextureFilter.Nearest;
				case "linear": return TextureFilter.Linear;
				case "mipmap": return TextureFilter.MipMap;
				case "mipmapnearestnearest": return TextureFilter.MipMapNearestNearest;
				case "mipmaplinearnearest": return TextureFilter.MipMapLinearNearest;
				case "mipmapnearestlinear": return TextureFilter.MipMapNearestLinear;
				case "mipmaplinearlinear": return TextureFilter.MipMapLinearLinear;
				default: throw new Error("Unknown texture filter " + text);
			}
		};
		Texture.wrapFromString = function (text) {
			switch (text.toLowerCase()) {
				case "mirroredtepeat": return TextureWrap.MirroredRepeat;
				case "clamptoedge": return TextureWrap.ClampToEdge;
				case "repeat": return TextureWrap.Repeat;
				default: throw new Error("Unknown texture wrap " + text);
			}
		};
		return Texture;
	}());
	spine.Texture = Texture;
	var TextureFilter;
	(function (TextureFilter) {
		TextureFilter[TextureFilter["Nearest"] = 9728] = "Nearest";
		TextureFilter[TextureFilter["Linear"] = 9729] = "Linear";
		TextureFilter[TextureFilter["MipMap"] = 9987] = "MipMap";
		TextureFilter[TextureFilter["MipMapNearestNearest"] = 9984] = "MipMapNearestNearest";
		TextureFilter[TextureFilter["MipMapLinearNearest"] = 9985] = "MipMapLinearNearest";
		TextureFilter[TextureFilter["MipMapNearestLinear"] = 9986] = "MipMapNearestLinear";
		TextureFilter[TextureFilter["MipMapLinearLinear"] = 9987] = "MipMapLinearLinear";
	})(TextureFilter = spine.TextureFilter || (spine.TextureFilter = {}));
	var TextureWrap;
	(function (TextureWrap) {
		TextureWrap[TextureWrap["MirroredRepeat"] = 33648] = "MirroredRepeat";
		TextureWrap[TextureWrap["ClampToEdge"] = 33071] = "ClampToEdge";
		TextureWrap[TextureWrap["Repeat"] = 10497] = "Repeat";
	})(TextureWrap = spine.TextureWrap || (spine.TextureWrap = {}));
	var TextureRegion = (function () {
		function TextureRegion() {
			this.u = 0;
			this.v = 0;
			this.u2 = 0;
			this.v2 = 0;
			this.width = 0;
			this.height = 0;
			this.rotate = false;
			this.offsetX = 0;
			this.offsetY = 0;
			this.originalWidth = 0;
			this.originalHeight = 0;
		}
		return TextureRegion;
	}());
	spine.TextureRegion = TextureRegion;
	var FakeTexture = (function (_super) {
		__extends(FakeTexture, _super);
		function FakeTexture() {
			return _super !== null && _super.apply(this, arguments) || this;
		}
		FakeTexture.prototype.setFilters = function (minFilter, magFilter) { };
		FakeTexture.prototype.setWraps = function (uWrap, vWrap) { };
		FakeTexture.prototype.dispose = function () { };
		return FakeTexture;
	}(Texture));
	spine.FakeTexture = FakeTexture;
})(spine || (spine = {}));
var spine;
(function (spine) {
	var TextureAtlas = (function () {
		function TextureAtlas(atlasText, textureLoader) {
			this.pages = new Array();
			this.regions = new Array();
			this.load(atlasText, textureLoader);
		}
		TextureAtlas.prototype.load = function (atlasText, textureLoader) {
			if (textureLoader == null)
				throw new Error("textureLoader cannot be null.");
			var reader = new TextureAtlasReader(atlasText);
			var tuple = new Array(4);
			var page = null;
			while (true) {
				var line = reader.readLine();
				if (line == null)
					break;
				line = line.trim();
				if (line.length == 0)
					page = null;
				else if (!page) {
					page = new TextureAtlasPage();
					page.name = line;
					if (reader.readTuple(tuple) == 2) {
						page.width = parseInt(tuple[0]);
						page.height = parseInt(tuple[1]);
						reader.readTuple(tuple);
					}
					reader.readTuple(tuple);
					page.minFilter = spine.Texture.filterFromString(tuple[0]);
					page.magFilter = spine.Texture.filterFromString(tuple[1]);
					var direction = reader.readValue();
					page.uWrap = spine.TextureWrap.ClampToEdge;
					page.vWrap = spine.TextureWrap.ClampToEdge;
					if (direction == "x")
						page.uWrap = spine.TextureWrap.Repeat;
					else if (direction == "y")
						page.vWrap = spine.TextureWrap.Repeat;
					else if (direction == "xy")
						page.uWrap = page.vWrap = spine.TextureWrap.Repeat;
					page.texture = textureLoader(line);
					page.texture.setFilters(page.minFilter, page.magFilter);
					page.texture.setWraps(page.uWrap, page.vWrap);
					page.width = page.texture.getImage().width;
					page.height = page.texture.getImage().height;
					this.pages.push(page);
				}
				else {
					var region = new TextureAtlasRegion();
					region.name = line;
					region.page = page;
					var rotateValue = reader.readValue();
					if (rotateValue.toLocaleLowerCase() == "true") {
						region.degrees = 90;
					}
					else if (rotateValue.toLocaleLowerCase() == "false") {
						region.degrees = 0;
					}
					else {
						region.degrees = parseFloat(rotateValue);
					}
					region.rotate = region.degrees == 90;
					reader.readTuple(tuple);
					var x = parseInt(tuple[0]);
					var y = parseInt(tuple[1]);
					reader.readTuple(tuple);
					var width = parseInt(tuple[0]);
					var height = parseInt(tuple[1]);
					region.u = x / page.width;
					region.v = y / page.height;
					if (region.rotate) {
						region.u2 = (x + height) / page.width;
						region.v2 = (y + width) / page.height;
					}
					else {
						region.u2 = (x + width) / page.width;
						region.v2 = (y + height) / page.height;
					}
					region.x = x;
					region.y = y;
					region.width = Math.abs(width);
					region.height = Math.abs(height);
					if (reader.readTuple(tuple) == 4) {
						if (reader.readTuple(tuple) == 4) {
							reader.readTuple(tuple);
						}
					}
					region.originalWidth = parseInt(tuple[0]);
					region.originalHeight = parseInt(tuple[1]);
					reader.readTuple(tuple);
					region.offsetX = parseInt(tuple[0]);
					region.offsetY = parseInt(tuple[1]);
					region.index = parseInt(reader.readValue());
					region.texture = page.texture;
					this.regions.push(region);
				}
			}
		};
		TextureAtlas.prototype.findRegion = function (name) {
			for (var i = 0; i < this.regions.length; i++) {
				if (this.regions[i].name == name) {
					return this.regions[i];
				}
			}
			return null;
		};
		TextureAtlas.prototype.dispose = function () {
			for (var i = 0; i < this.pages.length; i++) {
				this.pages[i].texture.dispose();
			}
		};
		return TextureAtlas;
	}());
	spine.TextureAtlas = TextureAtlas;
	var TextureAtlasReader = (function () {
		function TextureAtlasReader(text) {
			this.index = 0;
			this.lines = text.split(/\r\n|\r|\n/);
		}
		TextureAtlasReader.prototype.readLine = function () {
			if (this.index >= this.lines.length)
				return null;
			return this.lines[this.index++];
		};
		TextureAtlasReader.prototype.readValue = function () {
			var line = this.readLine();
			var colon = line.indexOf(":");
			if (colon == -1)
				throw new Error("Invalid line: " + line);
			return line.substring(colon + 1).trim();
		};
		TextureAtlasReader.prototype.readTuple = function (tuple) {
			var line = this.readLine();
			var colon = line.indexOf(":");
			if (colon == -1)
				throw new Error("Invalid line: " + line);
			var i = 0, lastMatch = colon + 1;
			for (; i < 3; i++) {
				var comma = line.indexOf(",", lastMatch);
				if (comma == -1)
					break;
				tuple[i] = line.substr(lastMatch, comma - lastMatch).trim();
				lastMatch = comma + 1;
			}
			tuple[i] = line.substring(lastMatch).trim();
			return i + 1;
		};
		return TextureAtlasReader;
	}());
	var TextureAtlasPage = (function () {
		function TextureAtlasPage() {
		}
		return TextureAtlasPage;
	}());
	spine.TextureAtlasPage = TextureAtlasPage;
	var TextureAtlasRegion = (function (_super) {
		__extends(TextureAtlasRegion, _super);
		function TextureAtlasRegion() {
			return _super !== null && _super.apply(this, arguments) || this;
		}
		return TextureAtlasRegion;
	}(spine.TextureRegion));
	spine.TextureAtlasRegion = TextureAtlasRegion;
})(spine || (spine = {}));
var spine;
(function (spine) {
	var TransformConstraint = (function () {
		function TransformConstraint(data, skeleton) {
			this.rotateMix = 0;
			this.translateMix = 0;
			this.scaleMix = 0;
			this.shearMix = 0;
			this.temp = new spine.Vector2();
			this.active = false;
			if (data == null)
				throw new Error("data cannot be null.");
			if (skeleton == null)
				throw new Error("skeleton cannot be null.");
			this.data = data;
			this.rotateMix = data.rotateMix;
			this.translateMix = data.translateMix;
			this.scaleMix = data.scaleMix;
			this.shearMix = data.shearMix;
			this.bones = new Array();
			for (var i = 0; i < data.bones.length; i++)
				this.bones.push(skeleton.findBone(data.bones[i].name));
			this.target = skeleton.findBone(data.target.name);
		}
		TransformConstraint.prototype.isActive = function () {
			return this.active;
		};
		TransformConstraint.prototype.apply = function () {
			this.update();
		};
		TransformConstraint.prototype.update = function () {
			if (this.data.local) {
				if (this.data.relative)
					this.applyRelativeLocal();
				else
					this.applyAbsoluteLocal();
			}
			else {
				if (this.data.relative)
					this.applyRelativeWorld();
				else
					this.applyAbsoluteWorld();
			}
		};
		TransformConstraint.prototype.applyAbsoluteWorld = function () {
			var rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix, shearMix = this.shearMix;
			var target = this.target;
			var ta = target.a, tb = target.b, tc = target.c, td = target.d;
			var degRadReflect = ta * td - tb * tc > 0 ? spine.MathUtils.degRad : -spine.MathUtils.degRad;
			var offsetRotation = this.data.offsetRotation * degRadReflect;
			var offsetShearY = this.data.offsetShearY * degRadReflect;
			var bones = this.bones;
			for (var i = 0, n = bones.length; i < n; i++) {
				var bone = bones[i];
				var modified = false;
				if (rotateMix != 0) {
					var a = bone.a, b = bone.b, c = bone.c, d = bone.d;
					var r = Math.atan2(tc, ta) - Math.atan2(c, a) + offsetRotation;
					if (r > spine.MathUtils.PI)
						r -= spine.MathUtils.PI2;
					else if (r < -spine.MathUtils.PI)
						r += spine.MathUtils.PI2;
					r *= rotateMix;
					var cos = Math.cos(r), sin = Math.sin(r);
					bone.a = cos * a - sin * c;
					bone.b = cos * b - sin * d;
					bone.c = sin * a + cos * c;
					bone.d = sin * b + cos * d;
					modified = true;
				}
				if (translateMix != 0) {
					var temp = this.temp;
					target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));
					bone.worldX += (temp.x - bone.worldX) * translateMix;
					bone.worldY += (temp.y - bone.worldY) * translateMix;
					modified = true;
				}
				if (scaleMix > 0) {
					var s = Math.sqrt(bone.a * bone.a + bone.c * bone.c);
					var ts = Math.sqrt(ta * ta + tc * tc);
					if (s > 0.00001)
						s = (s + (ts - s + this.data.offsetScaleX) * scaleMix) / s;
					bone.a *= s;
					bone.c *= s;
					s = Math.sqrt(bone.b * bone.b + bone.d * bone.d);
					ts = Math.sqrt(tb * tb + td * td);
					if (s > 0.00001)
						s = (s + (ts - s + this.data.offsetScaleY) * scaleMix) / s;
					bone.b *= s;
					bone.d *= s;
					modified = true;
				}
				if (shearMix > 0) {
					var b = bone.b, d = bone.d;
					var by = Math.atan2(d, b);
					var r = Math.atan2(td, tb) - Math.atan2(tc, ta) - (by - Math.atan2(bone.c, bone.a));
					if (r > spine.MathUtils.PI)
						r -= spine.MathUtils.PI2;
					else if (r < -spine.MathUtils.PI)
						r += spine.MathUtils.PI2;
					r = by + (r + offsetShearY) * shearMix;
					var s = Math.sqrt(b * b + d * d);
					bone.b = Math.cos(r) * s;
					bone.d = Math.sin(r) * s;
					modified = true;
				}
				if (modified)
					bone.appliedValid = false;
			}
		};
		TransformConstraint.prototype.applyRelativeWorld = function () {
			var rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix, shearMix = this.shearMix;
			var target = this.target;
			var ta = target.a, tb = target.b, tc = target.c, td = target.d;
			var degRadReflect = ta * td - tb * tc > 0 ? spine.MathUtils.degRad : -spine.MathUtils.degRad;
			var offsetRotation = this.data.offsetRotation * degRadReflect, offsetShearY = this.data.offsetShearY * degRadReflect;
			var bones = this.bones;
			for (var i = 0, n = bones.length; i < n; i++) {
				var bone = bones[i];
				var modified = false;
				if (rotateMix != 0) {
					var a = bone.a, b = bone.b, c = bone.c, d = bone.d;
					var r = Math.atan2(tc, ta) + offsetRotation;
					if (r > spine.MathUtils.PI)
						r -= spine.MathUtils.PI2;
					else if (r < -spine.MathUtils.PI)
						r += spine.MathUtils.PI2;
					r *= rotateMix;
					var cos = Math.cos(r), sin = Math.sin(r);
					bone.a = cos * a - sin * c;
					bone.b = cos * b - sin * d;
					bone.c = sin * a + cos * c;
					bone.d = sin * b + cos * d;
					modified = true;
				}
				if (translateMix != 0) {
					var temp = this.temp;
					target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));
					bone.worldX += temp.x * translateMix;
					bone.worldY += temp.y * translateMix;
					modified = true;
				}
				if (scaleMix > 0) {
					var s = (Math.sqrt(ta * ta + tc * tc) - 1 + this.data.offsetScaleX) * scaleMix + 1;
					bone.a *= s;
					bone.c *= s;
					s = (Math.sqrt(tb * tb + td * td) - 1 + this.data.offsetScaleY) * scaleMix + 1;
					bone.b *= s;
					bone.d *= s;
					modified = true;
				}
				if (shearMix > 0) {
					var r = Math.atan2(td, tb) - Math.atan2(tc, ta);
					if (r > spine.MathUtils.PI)
						r -= spine.MathUtils.PI2;
					else if (r < -spine.MathUtils.PI)
						r += spine.MathUtils.PI2;
					var b = bone.b, d = bone.d;
					r = Math.atan2(d, b) + (r - spine.MathUtils.PI / 2 + offsetShearY) * shearMix;
					var s = Math.sqrt(b * b + d * d);
					bone.b = Math.cos(r) * s;
					bone.d = Math.sin(r) * s;
					modified = true;
				}
				if (modified)
					bone.appliedValid = false;
			}
		};
		TransformConstraint.prototype.applyAbsoluteLocal = function () {
			var rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix, shearMix = this.shearMix;
			var target = this.target;
			if (!target.appliedValid)
				target.updateAppliedTransform();
			var bones = this.bones;
			for (var i = 0, n = bones.length; i < n; i++) {
				var bone = bones[i];
				if (!bone.appliedValid)
					bone.updateAppliedTransform();
				var rotation = bone.arotation;
				if (rotateMix != 0) {
					var r = target.arotation - rotation + this.data.offsetRotation;
					r -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360;
					rotation += r * rotateMix;
				}
				var x = bone.ax, y = bone.ay;
				if (translateMix != 0) {
					x += (target.ax - x + this.data.offsetX) * translateMix;
					y += (target.ay - y + this.data.offsetY) * translateMix;
				}
				var scaleX = bone.ascaleX, scaleY = bone.ascaleY;
				if (scaleMix != 0) {
					if (scaleX > 0.00001)
						scaleX = (scaleX + (target.ascaleX - scaleX + this.data.offsetScaleX) * scaleMix) / scaleX;
					if (scaleY > 0.00001)
						scaleY = (scaleY + (target.ascaleY - scaleY + this.data.offsetScaleY) * scaleMix) / scaleY;
				}
				var shearY = bone.ashearY;
				if (shearMix != 0) {
					var r = target.ashearY - shearY + this.data.offsetShearY;
					r -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360;
					bone.shearY += r * shearMix;
				}
				bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);
			}
		};
		TransformConstraint.prototype.applyRelativeLocal = function () {
			var rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix, shearMix = this.shearMix;
			var target = this.target;
			if (!target.appliedValid)
				target.updateAppliedTransform();
			var bones = this.bones;
			for (var i = 0, n = bones.length; i < n; i++) {
				var bone = bones[i];
				if (!bone.appliedValid)
					bone.updateAppliedTransform();
				var rotation = bone.arotation;
				if (rotateMix != 0)
					rotation += (target.arotation + this.data.offsetRotation) * rotateMix;
				var x = bone.ax, y = bone.ay;
				if (translateMix != 0) {
					x += (target.ax + this.data.offsetX) * translateMix;
					y += (target.ay + this.data.offsetY) * translateMix;
				}
				var scaleX = bone.ascaleX, scaleY = bone.ascaleY;
				if (scaleMix != 0) {
					if (scaleX > 0.00001)
						scaleX *= ((target.ascaleX - 1 + this.data.offsetScaleX) * scaleMix) + 1;
					if (scaleY > 0.00001)
						scaleY *= ((target.ascaleY - 1 + this.data.offsetScaleY) * scaleMix) + 1;
				}
				var shearY = bone.ashearY;
				if (shearMix != 0)
					shearY += (target.ashearY + this.data.offsetShearY) * shearMix;
				bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);
			}
		};
		return TransformConstraint;
	}());
	spine.TransformConstraint = TransformConstraint;
})(spine || (spine = {}));
var spine;
(function (spine) {
	var TransformConstraintData = (function (_super) {
		__extends(TransformConstraintData, _super);
		function TransformConstraintData(name) {
			var _this = _super.call(this, name, 0, false) || this;
			_this.bones = new Array();
			_this.rotateMix = 0;
			_this.translateMix = 0;
			_this.scaleMix = 0;
			_this.shearMix = 0;
			_this.offsetRotation = 0;
			_this.offsetX = 0;
			_this.offsetY = 0;
			_this.offsetScaleX = 0;
			_this.offsetScaleY = 0;
			_this.offsetShearY = 0;
			_this.relative = false;
			_this.local = false;
			return _this;
		}
		return TransformConstraintData;
	}(spine.ConstraintData));
	spine.TransformConstraintData = TransformConstraintData;
})(spine || (spine = {}));
var spine;
(function (spine) {
	var Triangulator = (function () {
		function Triangulator() {
			this.convexPolygons = new Array();
			this.convexPolygonsIndices = new Array();
			this.indicesArray = new Array();
			this.isConcaveArray = new Array();
			this.triangles = new Array();
			this.polygonPool = new spine.Pool(function () {
				return new Array();
			});
			this.polygonIndicesPool = new spine.Pool(function () {
				return new Array();
			});
		}
		Triangulator.prototype.triangulate = function (verticesArray) {
			var vertices = verticesArray;
			var vertexCount = verticesArray.length >> 1;
			var indices = this.indicesArray;
			indices.length = 0;
			for (var i = 0; i < vertexCount; i++)
				indices[i] = i;
			var isConcave = this.isConcaveArray;
			isConcave.length = 0;
			for (var i = 0, n = vertexCount; i < n; ++i)
				isConcave[i] = Triangulator.isConcave(i, vertexCount, vertices, indices);
			var triangles = this.triangles;
			triangles.length = 0;
			while (vertexCount > 3) {
				var previous = vertexCount - 1, i = 0, next = 1;
				while (true) {
					outer: if (!isConcave[i]) {
						var p1 = indices[previous] << 1, p2 = indices[i] << 1, p3 = indices[next] << 1;
						var p1x = vertices[p1], p1y = vertices[p1 + 1];
						var p2x = vertices[p2], p2y = vertices[p2 + 1];
						var p3x = vertices[p3], p3y = vertices[p3 + 1];
						for (var ii = (next + 1) % vertexCount; ii != previous; ii = (ii + 1) % vertexCount) {
							if (!isConcave[ii])
								continue;
							var v = indices[ii] << 1;
							var vx = vertices[v], vy = vertices[v + 1];
							if (Triangulator.positiveArea(p3x, p3y, p1x, p1y, vx, vy)) {
								if (Triangulator.positiveArea(p1x, p1y, p2x, p2y, vx, vy)) {
									if (Triangulator.positiveArea(p2x, p2y, p3x, p3y, vx, vy))
										break outer;
								}
							}
						}
						break;
					}
					if (next == 0) {
						do {
							if (!isConcave[i])
								break;
							i--;
						} while (i > 0);
						break;
					}
					previous = i;
					i = next;
					next = (next + 1) % vertexCount;
				}
				triangles.push(indices[(vertexCount + i - 1) % vertexCount]);
				triangles.push(indices[i]);
				triangles.push(indices[(i + 1) % vertexCount]);
				indices.splice(i, 1);
				isConcave.splice(i, 1);
				vertexCount--;
				var previousIndex = (vertexCount + i - 1) % vertexCount;
				var nextIndex = i == vertexCount ? 0 : i;
				isConcave[previousIndex] = Triangulator.isConcave(previousIndex, vertexCount, vertices, indices);
				isConcave[nextIndex] = Triangulator.isConcave(nextIndex, vertexCount, vertices, indices);
			}
			if (vertexCount == 3) {
				triangles.push(indices[2]);
				triangles.push(indices[0]);
				triangles.push(indices[1]);
			}
			return triangles;
		};
		Triangulator.prototype.decompose = function (verticesArray, triangles) {
			var vertices = verticesArray;
			var convexPolygons = this.convexPolygons;
			this.polygonPool.freeAll(convexPolygons);
			convexPolygons.length = 0;
			var convexPolygonsIndices = this.convexPolygonsIndices;
			this.polygonIndicesPool.freeAll(convexPolygonsIndices);
			convexPolygonsIndices.length = 0;
			var polygonIndices = this.polygonIndicesPool.obtain();
			polygonIndices.length = 0;
			var polygon = this.polygonPool.obtain();
			polygon.length = 0;
			var fanBaseIndex = -1, lastWinding = 0;
			for (var i = 0, n = triangles.length; i < n; i += 3) {
				var t1 = triangles[i] << 1, t2 = triangles[i + 1] << 1, t3 = triangles[i + 2] << 1;
				var x1 = vertices[t1], y1 = vertices[t1 + 1];
				var x2 = vertices[t2], y2 = vertices[t2 + 1];
				var x3 = vertices[t3], y3 = vertices[t3 + 1];
				var merged = false;
				if (fanBaseIndex == t1) {
					var o = polygon.length - 4;
					var winding1 = Triangulator.winding(polygon[o], polygon[o + 1], polygon[o + 2], polygon[o + 3], x3, y3);
					var winding2 = Triangulator.winding(x3, y3, polygon[0], polygon[1], polygon[2], polygon[3]);
					if (winding1 == lastWinding && winding2 == lastWinding) {
						polygon.push(x3);
						polygon.push(y3);
						polygonIndices.push(t3);
						merged = true;
					}
				}
				if (!merged) {
					if (polygon.length > 0) {
						convexPolygons.push(polygon);
						convexPolygonsIndices.push(polygonIndices);
					}
					else {
						this.polygonPool.free(polygon);
						this.polygonIndicesPool.free(polygonIndices);
					}
					polygon = this.polygonPool.obtain();
					polygon.length = 0;
					polygon.push(x1);
					polygon.push(y1);
					polygon.push(x2);
					polygon.push(y2);
					polygon.push(x3);
					polygon.push(y3);
					polygonIndices = this.polygonIndicesPool.obtain();
					polygonIndices.length = 0;
					polygonIndices.push(t1);
					polygonIndices.push(t2);
					polygonIndices.push(t3);
					lastWinding = Triangulator.winding(x1, y1, x2, y2, x3, y3);
					fanBaseIndex = t1;
				}
			}
			if (polygon.length > 0) {
				convexPolygons.push(polygon);
				convexPolygonsIndices.push(polygonIndices);
			}
			for (var i = 0, n = convexPolygons.length; i < n; i++) {
				polygonIndices = convexPolygonsIndices[i];
				if (polygonIndices.length == 0)
					continue;
				var firstIndex = polygonIndices[0];
				var lastIndex = polygonIndices[polygonIndices.length - 1];
				polygon = convexPolygons[i];
				var o = polygon.length - 4;
				var prevPrevX = polygon[o], prevPrevY = polygon[o + 1];
				var prevX = polygon[o + 2], prevY = polygon[o + 3];
				var firstX = polygon[0], firstY = polygon[1];
				var secondX = polygon[2], secondY = polygon[3];
				var winding = Triangulator.winding(prevPrevX, prevPrevY, prevX, prevY, firstX, firstY);
				for (var ii = 0; ii < n; ii++) {
					if (ii == i)
						continue;
					var otherIndices = convexPolygonsIndices[ii];
					if (otherIndices.length != 3)
						continue;
					var otherFirstIndex = otherIndices[0];
					var otherSecondIndex = otherIndices[1];
					var otherLastIndex = otherIndices[2];
					var otherPoly = convexPolygons[ii];
					var x3 = otherPoly[otherPoly.length - 2], y3 = otherPoly[otherPoly.length - 1];
					if (otherFirstIndex != firstIndex || otherSecondIndex != lastIndex)
						continue;
					var winding1 = Triangulator.winding(prevPrevX, prevPrevY, prevX, prevY, x3, y3);
					var winding2 = Triangulator.winding(x3, y3, firstX, firstY, secondX, secondY);
					if (winding1 == winding && winding2 == winding) {
						otherPoly.length = 0;
						otherIndices.length = 0;
						polygon.push(x3);
						polygon.push(y3);
						polygonIndices.push(otherLastIndex);
						prevPrevX = prevX;
						prevPrevY = prevY;
						prevX = x3;
						prevY = y3;
						ii = 0;
					}
				}
			}
			for (var i = convexPolygons.length - 1; i >= 0; i--) {
				polygon = convexPolygons[i];
				if (polygon.length == 0) {
					convexPolygons.splice(i, 1);
					this.polygonPool.free(polygon);
					polygonIndices = convexPolygonsIndices[i];
					convexPolygonsIndices.splice(i, 1);
					this.polygonIndicesPool.free(polygonIndices);
				}
			}
			return convexPolygons;
		};
		Triangulator.isConcave = function (index, vertexCount, vertices, indices) {
			var previous = indices[(vertexCount + index - 1) % vertexCount] << 1;
			var current = indices[index] << 1;
			var next = indices[(index + 1) % vertexCount] << 1;
			return !this.positiveArea(vertices[previous], vertices[previous + 1], vertices[current], vertices[current + 1], vertices[next], vertices[next + 1]);
		};
		Triangulator.positiveArea = function (p1x, p1y, p2x, p2y, p3x, p3y) {
			return p1x * (p3y - p2y) + p2x * (p1y - p3y) + p3x * (p2y - p1y) >= 0;
		};
		Triangulator.winding = function (p1x, p1y, p2x, p2y, p3x, p3y) {
			var px = p2x - p1x, py = p2y - p1y;
			return p3x * py - p3y * px + px * p1y - p1x * py >= 0 ? 1 : -1;
		};
		return Triangulator;
	}());
	spine.Triangulator = Triangulator;
})(spine || (spine = {}));
var spine;
(function (spine) {
	var IntSet = (function () {
		function IntSet() {
			this.array = new Array();
		}
		IntSet.prototype.add = function (value) {
			var contains = this.contains(value);
			this.array[value | 0] = value | 0;
			return !contains;
		};
		IntSet.prototype.contains = function (value) {
			return this.array[value | 0] != undefined;
		};
		IntSet.prototype.remove = function (value) {
			this.array[value | 0] = undefined;
		};
		IntSet.prototype.clear = function () {
			this.array.length = 0;
		};
		return IntSet;
	}());
	spine.IntSet = IntSet;
	var Color = (function () {
		function Color(r, g, b, a) {
			if (r === void 0) { r = 0; }
			if (g === void 0) { g = 0; }
			if (b === void 0) { b = 0; }
			if (a === void 0) { a = 0; }
			this.r = r;
			this.g = g;
			this.b = b;
			this.a = a;
		}
		Color.prototype.set = function (r, g, b, a) {
			this.r = r;
			this.g = g;
			this.b = b;
			this.a = a;
			this.clamp();
			return this;
		};
		Color.prototype.setFromColor = function (c) {
			this.r = c.r;
			this.g = c.g;
			this.b = c.b;
			this.a = c.a;
			return this;
		};
		Color.prototype.setFromString = function (hex) {
			hex = hex.charAt(0) == '#' ? hex.substr(1) : hex;
			this.r = parseInt(hex.substr(0, 2), 16) / 255.0;
			this.g = parseInt(hex.substr(2, 2), 16) / 255.0;
			this.b = parseInt(hex.substr(4, 2), 16) / 255.0;
			this.a = (hex.length != 8 ? 255 : parseInt(hex.substr(6, 2), 16)) / 255.0;
			return this;
		};
		Color.prototype.add = function (r, g, b, a) {
			this.r += r;
			this.g += g;
			this.b += b;
			this.a += a;
			this.clamp();
			return this;
		};
		Color.prototype.clamp = function () {
			if (this.r < 0)
				this.r = 0;
			else if (this.r > 1)
				this.r = 1;
			if (this.g < 0)
				this.g = 0;
			else if (this.g > 1)
				this.g = 1;
			if (this.b < 0)
				this.b = 0;
			else if (this.b > 1)
				this.b = 1;
			if (this.a < 0)
				this.a = 0;
			else if (this.a > 1)
				this.a = 1;
			return this;
		};
		Color.rgba8888ToColor = function (color, value) {
			color.r = ((value & 0xff000000) >>> 24) / 255;
			color.g = ((value & 0x00ff0000) >>> 16) / 255;
			color.b = ((value & 0x0000ff00) >>> 8) / 255;
			color.a = ((value & 0x000000ff)) / 255;
		};
		Color.rgb888ToColor = function (color, value) {
			color.r = ((value & 0x00ff0000) >>> 16) / 255;
			color.g = ((value & 0x0000ff00) >>> 8) / 255;
			color.b = ((value & 0x000000ff)) / 255;
		};
		Color.WHITE = new Color(1, 1, 1, 1);
		Color.RED = new Color(1, 0, 0, 1);
		Color.GREEN = new Color(0, 1, 0, 1);
		Color.BLUE = new Color(0, 0, 1, 1);
		Color.MAGENTA = new Color(1, 0, 1, 1);
		return Color;
	}());
	spine.Color = Color;
	var MathUtils = (function () {
		function MathUtils() {
		}
		MathUtils.clamp = function (value, min, max) {
			if (value < min)
				return min;
			if (value > max)
				return max;
			return value;
		};
		MathUtils.cosDeg = function (degrees) {
			return Math.cos(degrees * MathUtils.degRad);
		};
		MathUtils.sinDeg = function (degrees) {
			return Math.sin(degrees * MathUtils.degRad);
		};
		MathUtils.signum = function (value) {
			return value > 0 ? 1 : value < 0 ? -1 : 0;
		};
		MathUtils.toInt = function (x) {
			return x > 0 ? Math.floor(x) : Math.ceil(x);
		};
		MathUtils.cbrt = function (x) {
			var y = Math.pow(Math.abs(x), 1 / 3);
			return x < 0 ? -y : y;
		};
		MathUtils.randomTriangular = function (min, max) {
			return MathUtils.randomTriangularWith(min, max, (min + max) * 0.5);
		};
		MathUtils.randomTriangularWith = function (min, max, mode) {
			var u = Math.random();
			var d = max - min;
			if (u <= (mode - min) / d)
				return min + Math.sqrt(u * d * (mode - min));
			return max - Math.sqrt((1 - u) * d * (max - mode));
		};
		MathUtils.PI = 3.1415927;
		MathUtils.PI2 = MathUtils.PI * 2;
		MathUtils.radiansToDegrees = 180 / MathUtils.PI;
		MathUtils.radDeg = MathUtils.radiansToDegrees;
		MathUtils.degreesToRadians = MathUtils.PI / 180;
		MathUtils.degRad = MathUtils.degreesToRadians;
		return MathUtils;
	}());
	spine.MathUtils = MathUtils;
	var Interpolation = (function () {
		function Interpolation() {
		}
		Interpolation.prototype.apply = function (start, end, a) {
			return start + (end - start) * this.applyInternal(a);
		};
		return Interpolation;
	}());
	spine.Interpolation = Interpolation;
	var Pow = (function (_super) {
		__extends(Pow, _super);
		function Pow(power) {
			var _this = _super.call(this) || this;
			_this.power = 2;
			_this.power = power;
			return _this;
		}
		Pow.prototype.applyInternal = function (a) {
			if (a <= 0.5)
				return Math.pow(a * 2, this.power) / 2;
			return Math.pow((a - 1) * 2, this.power) / (this.power % 2 == 0 ? -2 : 2) + 1;
		};
		return Pow;
	}(Interpolation));
	spine.Pow = Pow;
	var PowOut = (function (_super) {
		__extends(PowOut, _super);
		function PowOut(power) {
			return _super.call(this, power) || this;
		}
		PowOut.prototype.applyInternal = function (a) {
			return Math.pow(a - 1, this.power) * (this.power % 2 == 0 ? -1 : 1) + 1;
		};
		return PowOut;
	}(Pow));
	spine.PowOut = PowOut;
	var Utils = (function () {
		function Utils() {
		}
		Utils.arrayCopy = function (source, sourceStart, dest, destStart, numElements) {
			for (var i = sourceStart, j = destStart; i < sourceStart + numElements; i++, j++) {
				dest[j] = source[i];
			}
		};
		Utils.setArraySize = function (array, size, value) {
			if (value === void 0) { value = 0; }
			var oldSize = array.length;
			if (oldSize == size)
				return array;
			array.length = size;
			if (oldSize < size) {
				for (var i = oldSize; i < size; i++)
					array[i] = value;
			}
			return array;
		};
		Utils.ensureArrayCapacity = function (array, size, value) {
			if (value === void 0) { value = 0; }
			if (array.length >= size)
				return array;
			return Utils.setArraySize(array, size, value);
		};
		Utils.newArray = function (size, defaultValue) {
			var array = new Array(size);
			for (var i = 0; i < size; i++)
				array[i] = defaultValue;
			return array;
		};
		Utils.newFloatArray = function (size) {
			if (Utils.SUPPORTS_TYPED_ARRAYS) {
				return new Float32Array(size);
			}
			else {
				var array = new Array(size);
				for (var i = 0; i < array.length; i++)
					array[i] = 0;
				return array;
			}
		};
		Utils.newShortArray = function (size) {
			if (Utils.SUPPORTS_TYPED_ARRAYS) {
				return new Int16Array(size);
			}
			else {
				var array = new Array(size);
				for (var i = 0; i < array.length; i++)
					array[i] = 0;
				return array;
			}
		};
		Utils.toFloatArray = function (array) {
			return Utils.SUPPORTS_TYPED_ARRAYS ? new Float32Array(array) : array;
		};
		Utils.toSinglePrecision = function (value) {
			return Utils.SUPPORTS_TYPED_ARRAYS ? Math.fround(value) : value;
		};
		Utils.webkit602BugfixHelper = function (alpha, blend) {
		};
		Utils.contains = function (array, element, identity) {
			if (identity === void 0) { identity = true; }
			for (var i = 0; i < array.length; i++) {
				if (array[i] == element)
					return true;
			}
			return false;
		};
		Utils.SUPPORTS_TYPED_ARRAYS = typeof (Float32Array) !== "undefined";
		return Utils;
	}());
	spine.Utils = Utils;
	var DebugUtils = (function () {
		function DebugUtils() {
		}
		DebugUtils.logBones = function (skeleton) {
			for (var i = 0; i < skeleton.bones.length; i++) {
				var bone = skeleton.bones[i];
				console.log(bone.data.name + ", " + bone.a + ", " + bone.b + ", " + bone.c + ", " + bone.d + ", " + bone.worldX + ", " + bone.worldY);
			}
		};
		return DebugUtils;
	}());
	spine.DebugUtils = DebugUtils;
	var Pool = (function () {
		function Pool(instantiator) {
			this.items = new Array();
			this.instantiator = instantiator;
		}
		Pool.prototype.obtain = function () {
			return this.items.length > 0 ? this.items.pop() : this.instantiator();
		};
		Pool.prototype.free = function (item) {
			if (item.reset)
				item.reset();
			this.items.push(item);
		};
		Pool.prototype.freeAll = function (items) {
			for (var i = 0; i < items.length; i++) {
				if (items[i].reset)
					items[i].reset();
				this.items[i] = items[i];
			}
		};
		Pool.prototype.clear = function () {
			this.items.length = 0;
		};
		return Pool;
	}());
	spine.Pool = Pool;
	var Vector2 = (function () {
		function Vector2(x, y) {
			if (x === void 0) { x = 0; }
			if (y === void 0) { y = 0; }
			this.x = x;
			this.y = y;
		}
		Vector2.prototype.set = function (x, y) {
			this.x = x;
			this.y = y;
			return this;
		};
		Vector2.prototype.length = function () {
			var x = this.x;
			var y = this.y;
			return Math.sqrt(x * x + y * y);
		};
		Vector2.prototype.normalize = function () {
			var len = this.length();
			if (len != 0) {
				this.x /= len;
				this.y /= len;
			}
			return this;
		};
		return Vector2;
	}());
	spine.Vector2 = Vector2;
	var TimeKeeper = (function () {
		function TimeKeeper() {
			this.maxDelta = 0.064;
			this.framesPerSecond = 0;
			this.delta = 0;
			this.totalTime = 0;
			this.lastTime = Date.now() / 1000;
			this.frameCount = 0;
			this.frameTime = 0;
		}
		TimeKeeper.prototype.update = function () {
			var now = Date.now() / 1000;
			this.delta = now - this.lastTime;
			this.frameTime += this.delta;
			this.totalTime += this.delta;
			if (this.delta > this.maxDelta)
				this.delta = this.maxDelta;
			this.lastTime = now;
			this.frameCount++;
			if (this.frameTime > 1) {
				this.framesPerSecond = this.frameCount / this.frameTime;
				this.frameTime = 0;
				this.frameCount = 0;
			}
		};
		return TimeKeeper;
	}());
	spine.TimeKeeper = TimeKeeper;
	var WindowedMean = (function () {
		function WindowedMean(windowSize) {
			if (windowSize === void 0) { windowSize = 32; }
			this.addedValues = 0;
			this.lastValue = 0;
			this.mean = 0;
			this.dirty = true;
			this.values = new Array(windowSize);
		}
		WindowedMean.prototype.hasEnoughData = function () {
			return this.addedValues >= this.values.length;
		};
		WindowedMean.prototype.addValue = function (value) {
			if (this.addedValues < this.values.length)
				this.addedValues++;
			this.values[this.lastValue++] = value;
			if (this.lastValue > this.values.length - 1)
				this.lastValue = 0;
			this.dirty = true;
		};
		WindowedMean.prototype.getMean = function () {
			if (this.hasEnoughData()) {
				if (this.dirty) {
					var mean = 0;
					for (var i = 0; i < this.values.length; i++) {
						mean += this.values[i];
					}
					this.mean = mean / this.values.length;
					this.dirty = false;
				}
				return this.mean;
			}
			else {
				return 0;
			}
		};
		return WindowedMean;
	}());
	spine.WindowedMean = WindowedMean;
})(spine || (spine = {}));
(function () {
	if (!Math.fround) {
		Math.fround = (function (array) {
			return function (x) {
				return array[0] = x, array[0];
			};
		})(new Float32Array(1));
	}
})();
var spine;
(function (spine) {
	var Attachment = (function () {
		function Attachment(name) {
			if (name == null)
				throw new Error("name cannot be null.");
			this.name = name;
		}
		return Attachment;
	}());
	spine.Attachment = Attachment;
	var VertexAttachment = (function (_super) {
		__extends(VertexAttachment, _super);
		function VertexAttachment(name) {
			var _this = _super.call(this, name) || this;
			_this.id = (VertexAttachment.nextID++ & 65535) << 11;
			_this.worldVerticesLength = 0;
			_this.deformAttachment = _this;
			return _this;
		}
		VertexAttachment.prototype.computeWorldVertices = function (slot, start, count, worldVertices, offset, stride) {
			count = offset + (count >> 1) * stride;
			var skeleton = slot.bone.skeleton;
			var deformArray = slot.deform;
			var vertices = this.vertices;
			var bones = this.bones;
			if (bones == null) {
				if (deformArray.length > 0)
					vertices = deformArray;
				var bone = slot.bone;
				var x = bone.worldX;
				var y = bone.worldY;
				var a = bone.a, b = bone.b, c = bone.c, d = bone.d;
				for (var v_1 = start, w = offset; w < count; v_1 += 2, w += stride) {
					var vx = vertices[v_1], vy = vertices[v_1 + 1];
					worldVertices[w] = vx * a + vy * b + x;
					worldVertices[w + 1] = vx * c + vy * d + y;
				}
				return;
			}
			var v = 0, skip = 0;
			for (var i = 0; i < start; i += 2) {
				var n = bones[v];
				v += n + 1;
				skip += n;
			}
			var skeletonBones = skeleton.bones;
			if (deformArray.length == 0) {
				for (var w = offset, b = skip * 3; w < count; w += stride) {
					var wx = 0, wy = 0;
					var n = bones[v++];
					n += v;
					for (; v < n; v++, b += 3) {
						var bone = skeletonBones[bones[v]];
						var vx = vertices[b], vy = vertices[b + 1], weight = vertices[b + 2];
						wx += (vx * bone.a + vy * bone.b + bone.worldX) * weight;
						wy += (vx * bone.c + vy * bone.d + bone.worldY) * weight;
					}
					worldVertices[w] = wx;
					worldVertices[w + 1] = wy;
				}
			}
			else {
				var deform = deformArray;
				for (var w = offset, b = skip * 3, f = skip << 1; w < count; w += stride) {
					var wx = 0, wy = 0;
					var n = bones[v++];
					n += v;
					for (; v < n; v++, b += 3, f += 2) {
						var bone = skeletonBones[bones[v]];
						var vx = vertices[b] + deform[f], vy = vertices[b + 1] + deform[f + 1], weight = vertices[b + 2];
						wx += (vx * bone.a + vy * bone.b + bone.worldX) * weight;
						wy += (vx * bone.c + vy * bone.d + bone.worldY) * weight;
					}
					worldVertices[w] = wx;
					worldVertices[w + 1] = wy;
				}
			}
		};
		VertexAttachment.prototype.copyTo = function (attachment) {
			if (this.bones != null) {
				attachment.bones = new Array(this.bones.length);
				spine.Utils.arrayCopy(this.bones, 0, attachment.bones, 0, this.bones.length);
			}
			else
				attachment.bones = null;
			if (this.vertices != null) {
				attachment.vertices = spine.Utils.newFloatArray(this.vertices.length);
				spine.Utils.arrayCopy(this.vertices, 0, attachment.vertices, 0, this.vertices.length);
			}
			else
				attachment.vertices = null;
			attachment.worldVerticesLength = this.worldVerticesLength;
			attachment.deformAttachment = this.deformAttachment;
		};
		VertexAttachment.nextID = 0;
		return VertexAttachment;
	}(Attachment));
	spine.VertexAttachment = VertexAttachment;
})(spine || (spine = {}));
var spine;
(function (spine) {
	var AttachmentType;
	(function (AttachmentType) {
		AttachmentType[AttachmentType["Region"] = 0] = "Region";
		AttachmentType[AttachmentType["BoundingBox"] = 1] = "BoundingBox";
		AttachmentType[AttachmentType["Mesh"] = 2] = "Mesh";
		AttachmentType[AttachmentType["LinkedMesh"] = 3] = "LinkedMesh";
		AttachmentType[AttachmentType["Path"] = 4] = "Path";
		AttachmentType[AttachmentType["Point"] = 5] = "Point";
		AttachmentType[AttachmentType["Clipping"] = 6] = "Clipping";
	})(AttachmentType = spine.AttachmentType || (spine.AttachmentType = {}));
})(spine || (spine = {}));
var spine;
(function (spine) {
	var BoundingBoxAttachment = (function (_super) {
		__extends(BoundingBoxAttachment, _super);
		function BoundingBoxAttachment(name) {
			var _this = _super.call(this, name) || this;
			_this.color = new spine.Color(1, 1, 1, 1);
			return _this;
		}
		BoundingBoxAttachment.prototype.copy = function () {
			var copy = new BoundingBoxAttachment(name);
			this.copyTo(copy);
			copy.color.setFromColor(this.color);
			return copy;
		};
		return BoundingBoxAttachment;
	}(spine.VertexAttachment));
	spine.BoundingBoxAttachment = BoundingBoxAttachment;
})(spine || (spine = {}));
var spine;
(function (spine) {
	var ClippingAttachment = (function (_super) {
		__extends(ClippingAttachment, _super);
		function ClippingAttachment(name) {
			var _this = _super.call(this, name) || this;
			_this.color = new spine.Color(0.2275, 0.2275, 0.8078, 1);
			return _this;
		}
		ClippingAttachment.prototype.copy = function () {
			var copy = new ClippingAttachment(name);
			this.copyTo(copy);
			copy.endSlot = this.endSlot;
			copy.color.setFromColor(this.color);
			return copy;
		};
		return ClippingAttachment;
	}(spine.VertexAttachment));
	spine.ClippingAttachment = ClippingAttachment;
})(spine || (spine = {}));
var spine;
(function (spine) {
	var MeshAttachment = (function (_super) {
		__extends(MeshAttachment, _super);
		function MeshAttachment(name) {
			var _this = _super.call(this, name) || this;
			_this.color = new spine.Color(1, 1, 1, 1);
			_this.tempColor = new spine.Color(0, 0, 0, 0);
			return _this;
		}
		MeshAttachment.prototype.updateUVs = function () {
			var regionUVs = this.regionUVs;
			if (this.uvs == null || this.uvs.length != regionUVs.length)
				this.uvs = spine.Utils.newFloatArray(regionUVs.length);
			var uvs = this.uvs;
			var n = this.uvs.length;
			var u = this.region.u, v = this.region.v, width = 0, height = 0;
			if (this.region instanceof spine.TextureAtlasRegion) {
				var region = this.region;
				var textureWidth = region.texture.getImage().width, textureHeight = region.texture.getImage().height;
				switch (region.degrees) {
					case 90:
						u -= (region.originalHeight - region.offsetY - region.height) / textureWidth;
						v -= (region.originalWidth - region.offsetX - region.width) / textureHeight;
						width = region.originalHeight / textureWidth;
						height = region.originalWidth / textureHeight;
						for (var i = 0; i < n; i += 2) {
							uvs[i] = u + regionUVs[i + 1] * width;
							uvs[i + 1] = v + (1 - regionUVs[i]) * height;
						}
						return;
					case 180:
						u -= (region.originalWidth - region.offsetX - region.width) / textureWidth;
						v -= region.offsetY / textureHeight;
						width = region.originalWidth / textureWidth;
						height = region.originalHeight / textureHeight;
						for (var i = 0; i < n; i += 2) {
							uvs[i] = u + (1 - regionUVs[i]) * width;
							uvs[i + 1] = v + (1 - regionUVs[i + 1]) * height;
						}
						return;
					case 270:
						u -= region.offsetY / textureWidth;
						v -= region.offsetX / textureHeight;
						width = region.originalHeight / textureWidth;
						height = region.originalWidth / textureHeight;
						for (var i = 0; i < n; i += 2) {
							uvs[i] = u + (1 - regionUVs[i + 1]) * width;
							uvs[i + 1] = v + regionUVs[i] * height;
						}
						return;
				}
				u -= region.offsetX / textureWidth;
				v -= (region.originalHeight - region.offsetY - region.height) / textureHeight;
				width = region.originalWidth / textureWidth;
				height = region.originalHeight / textureHeight;
			}
			else if (this.region == null) {
				u = v = 0;
				width = height = 1;
			}
			else {
				width = this.region.u2 - u;
				height = this.region.v2 - v;
			}
			for (var i = 0; i < n; i += 2) {
				uvs[i] = u + regionUVs[i] * width;
				uvs[i + 1] = v + regionUVs[i + 1] * height;
			}
		};
		MeshAttachment.prototype.getParentMesh = function () {
			return this.parentMesh;
		};
		MeshAttachment.prototype.setParentMesh = function (parentMesh) {
			this.parentMesh = parentMesh;
			if (parentMesh != null) {
				this.bones = parentMesh.bones;
				this.vertices = parentMesh.vertices;
				this.worldVerticesLength = parentMesh.worldVerticesLength;
				this.regionUVs = parentMesh.regionUVs;
				this.triangles = parentMesh.triangles;
				this.hullLength = parentMesh.hullLength;
				this.worldVerticesLength = parentMesh.worldVerticesLength;
			}
		};
		MeshAttachment.prototype.copy = function () {
			if (this.parentMesh != null)
				return this.newLinkedMesh();
			var copy = new MeshAttachment(this.name);
			copy.region = this.region;
			copy.path = this.path;
			copy.color.setFromColor(this.color);
			this.copyTo(copy);
			copy.regionUVs = new Array(this.regionUVs.length);
			spine.Utils.arrayCopy(this.regionUVs, 0, copy.regionUVs, 0, this.regionUVs.length);
			copy.uvs = new Array(this.uvs.length);
			spine.Utils.arrayCopy(this.uvs, 0, copy.uvs, 0, this.uvs.length);
			copy.triangles = new Array(this.triangles.length);
			spine.Utils.arrayCopy(this.triangles, 0, copy.triangles, 0, this.triangles.length);
			copy.hullLength = this.hullLength;
			if (this.edges != null) {
				copy.edges = new Array(this.edges.length);
				spine.Utils.arrayCopy(this.edges, 0, copy.edges, 0, this.edges.length);
			}
			copy.width = this.width;
			copy.height = this.height;
			return copy;
		};
		MeshAttachment.prototype.newLinkedMesh = function () {
			var copy = new MeshAttachment(this.name);
			copy.region = this.region;
			copy.path = this.path;
			copy.color.setFromColor(this.color);
			copy.deformAttachment = this.deformAttachment;
			copy.setParentMesh(this.parentMesh != null ? this.parentMesh : this);
			copy.updateUVs();
			return copy;
		};
		return MeshAttachment;
	}(spine.VertexAttachment));
	spine.MeshAttachment = MeshAttachment;
})(spine || (spine = {}));
var spine;
(function (spine) {
	var PathAttachment = (function (_super) {
		__extends(PathAttachment, _super);
		function PathAttachment(name) {
			var _this = _super.call(this, name) || this;
			_this.closed = false;
			_this.constantSpeed = false;
			_this.color = new spine.Color(1, 1, 1, 1);
			return _this;
		}
		PathAttachment.prototype.copy = function () {
			var copy = new PathAttachment(name);
			this.copyTo(copy);
			copy.lengths = new Array(this.lengths.length);
			spine.Utils.arrayCopy(this.lengths, 0, copy.lengths, 0, this.lengths.length);
			copy.closed = closed;
			copy.constantSpeed = this.constantSpeed;
			copy.color.setFromColor(this.color);
			return copy;
		};
		return PathAttachment;
	}(spine.VertexAttachment));
	spine.PathAttachment = PathAttachment;
})(spine || (spine = {}));
var spine;
(function (spine) {
	var PointAttachment = (function (_super) {
		__extends(PointAttachment, _super);
		function PointAttachment(name) {
			var _this = _super.call(this, name) || this;
			_this.color = new spine.Color(0.38, 0.94, 0, 1);
			return _this;
		}
		PointAttachment.prototype.computeWorldPosition = function (bone, point) {
			point.x = this.x * bone.a + this.y * bone.b + bone.worldX;
			point.y = this.x * bone.c + this.y * bone.d + bone.worldY;
			return point;
		};
		PointAttachment.prototype.computeWorldRotation = function (bone) {
			var cos = spine.MathUtils.cosDeg(this.rotation), sin = spine.MathUtils.sinDeg(this.rotation);
			var x = cos * bone.a + sin * bone.b;
			var y = cos * bone.c + sin * bone.d;
			return Math.atan2(y, x) * spine.MathUtils.radDeg;
		};
		PointAttachment.prototype.copy = function () {
			var copy = new PointAttachment(name);
			copy.x = this.x;
			copy.y = this.y;
			copy.rotation = this.rotation;
			copy.color.setFromColor(this.color);
			return copy;
		};
		return PointAttachment;
	}(spine.VertexAttachment));
	spine.PointAttachment = PointAttachment;
})(spine || (spine = {}));
var spine;
(function (spine) {
	var RegionAttachment = (function (_super) {
		__extends(RegionAttachment, _super);
		function RegionAttachment(name) {
			var _this = _super.call(this, name) || this;
			_this.x = 0;
			_this.y = 0;
			_this.scaleX = 1;
			_this.scaleY = 1;
			_this.rotation = 0;
			_this.width = 0;
			_this.height = 0;
			_this.color = new spine.Color(1, 1, 1, 1);
			_this.offset = spine.Utils.newFloatArray(8);
			_this.uvs = spine.Utils.newFloatArray(8);
			_this.tempColor = new spine.Color(1, 1, 1, 1);
			return _this;
		}
		RegionAttachment.prototype.updateOffset = function () {
			var regionScaleX = this.width / this.region.originalWidth * this.scaleX;
			var regionScaleY = this.height / this.region.originalHeight * this.scaleY;
			var localX = -this.width / 2 * this.scaleX + this.region.offsetX * regionScaleX;
			var localY = -this.height / 2 * this.scaleY + this.region.offsetY * regionScaleY;
			var localX2 = localX + this.region.width * regionScaleX;
			var localY2 = localY + this.region.height * regionScaleY;
			var radians = this.rotation * Math.PI / 180;
			var cos = Math.cos(radians);
			var sin = Math.sin(radians);
			var localXCos = localX * cos + this.x;
			var localXSin = localX * sin;
			var localYCos = localY * cos + this.y;
			var localYSin = localY * sin;
			var localX2Cos = localX2 * cos + this.x;
			var localX2Sin = localX2 * sin;
			var localY2Cos = localY2 * cos + this.y;
			var localY2Sin = localY2 * sin;
			var offset = this.offset;
			offset[RegionAttachment.OX1] = localXCos - localYSin;
			offset[RegionAttachment.OY1] = localYCos + localXSin;
			offset[RegionAttachment.OX2] = localXCos - localY2Sin;
			offset[RegionAttachment.OY2] = localY2Cos + localXSin;
			offset[RegionAttachment.OX3] = localX2Cos - localY2Sin;
			offset[RegionAttachment.OY3] = localY2Cos + localX2Sin;
			offset[RegionAttachment.OX4] = localX2Cos - localYSin;
			offset[RegionAttachment.OY4] = localYCos + localX2Sin;
		};
		RegionAttachment.prototype.setRegion = function (region) {
			this.region = region;
			var uvs = this.uvs;
			if (region.rotate) {
				uvs[2] = region.u;
				uvs[3] = region.v2;
				uvs[4] = region.u;
				uvs[5] = region.v;
				uvs[6] = region.u2;
				uvs[7] = region.v;
				uvs[0] = region.u2;
				uvs[1] = region.v2;
			}
			else {
				uvs[0] = region.u;
				uvs[1] = region.v2;
				uvs[2] = region.u;
				uvs[3] = region.v;
				uvs[4] = region.u2;
				uvs[5] = region.v;
				uvs[6] = region.u2;
				uvs[7] = region.v2;
			}
		};
		RegionAttachment.prototype.computeWorldVertices = function (bone, worldVertices, offset, stride) {
			var vertexOffset = this.offset;
			var x = bone.worldX, y = bone.worldY;
			var a = bone.a, b = bone.b, c = bone.c, d = bone.d;
			var offsetX = 0, offsetY = 0;
			offsetX = vertexOffset[RegionAttachment.OX1];
			offsetY = vertexOffset[RegionAttachment.OY1];
			worldVertices[offset] = offsetX * a + offsetY * b + x;
			worldVertices[offset + 1] = offsetX * c + offsetY * d + y;
			offset += stride;
			offsetX = vertexOffset[RegionAttachment.OX2];
			offsetY = vertexOffset[RegionAttachment.OY2];
			worldVertices[offset] = offsetX * a + offsetY * b + x;
			worldVertices[offset + 1] = offsetX * c + offsetY * d + y;
			offset += stride;
			offsetX = vertexOffset[RegionAttachment.OX3];
			offsetY = vertexOffset[RegionAttachment.OY3];
			worldVertices[offset] = offsetX * a + offsetY * b + x;
			worldVertices[offset + 1] = offsetX * c + offsetY * d + y;
			offset += stride;
			offsetX = vertexOffset[RegionAttachment.OX4];
			offsetY = vertexOffset[RegionAttachment.OY4];
			worldVertices[offset] = offsetX * a + offsetY * b + x;
			worldVertices[offset + 1] = offsetX * c + offsetY * d + y;
		};
		RegionAttachment.prototype.copy = function () {
			var copy = new RegionAttachment(name);
			copy.region = this.region;
			copy.rendererObject = this.rendererObject;
			copy.path = this.path;
			copy.x = this.x;
			copy.y = this.y;
			copy.scaleX = this.scaleX;
			copy.scaleY = this.scaleY;
			copy.rotation = this.rotation;
			copy.width = this.width;
			copy.height = this.height;
			spine.Utils.arrayCopy(this.uvs, 0, copy.uvs, 0, 8);
			spine.Utils.arrayCopy(this.offset, 0, copy.offset, 0, 8);
			copy.color.setFromColor(this.color);
			return copy;
		};
		RegionAttachment.OX1 = 0;
		RegionAttachment.OY1 = 1;
		RegionAttachment.OX2 = 2;
		RegionAttachment.OY2 = 3;
		RegionAttachment.OX3 = 4;
		RegionAttachment.OY3 = 5;
		RegionAttachment.OX4 = 6;
		RegionAttachment.OY4 = 7;
		RegionAttachment.X1 = 0;
		RegionAttachment.Y1 = 1;
		RegionAttachment.C1R = 2;
		RegionAttachment.C1G = 3;
		RegionAttachment.C1B = 4;
		RegionAttachment.C1A = 5;
		RegionAttachment.U1 = 6;
		RegionAttachment.V1 = 7;
		RegionAttachment.X2 = 8;
		RegionAttachment.Y2 = 9;
		RegionAttachment.C2R = 10;
		RegionAttachment.C2G = 11;
		RegionAttachment.C2B = 12;
		RegionAttachment.C2A = 13;
		RegionAttachment.U2 = 14;
		RegionAttachment.V2 = 15;
		RegionAttachment.X3 = 16;
		RegionAttachment.Y3 = 17;
		RegionAttachment.C3R = 18;
		RegionAttachment.C3G = 19;
		RegionAttachment.C3B = 20;
		RegionAttachment.C3A = 21;
		RegionAttachment.U3 = 22;
		RegionAttachment.V3 = 23;
		RegionAttachment.X4 = 24;
		RegionAttachment.Y4 = 25;
		RegionAttachment.C4R = 26;
		RegionAttachment.C4G = 27;
		RegionAttachment.C4B = 28;
		RegionAttachment.C4A = 29;
		RegionAttachment.U4 = 30;
		RegionAttachment.V4 = 31;
		return RegionAttachment;
	}(spine.Attachment));
	spine.RegionAttachment = RegionAttachment;
})(spine || (spine = {}));
var spine;
(function (spine) {
	var JitterEffect = (function () {
		function JitterEffect(jitterX, jitterY) {
			this.jitterX = 0;
			this.jitterY = 0;
			this.jitterX = jitterX;
			this.jitterY = jitterY;
		}
		JitterEffect.prototype.begin = function (skeleton) {
		};
		JitterEffect.prototype.transform = function (position, uv, light, dark) {
			position.x += spine.MathUtils.randomTriangular(-this.jitterX, this.jitterY);
			position.y += spine.MathUtils.randomTriangular(-this.jitterX, this.jitterY);
		};
		JitterEffect.prototype.end = function () {
		};
		return JitterEffect;
	}());
	spine.JitterEffect = JitterEffect;
})(spine || (spine = {}));
var spine;
(function (spine) {
	var SwirlEffect = (function () {
		function SwirlEffect(radius) {
			this.centerX = 0;
			this.centerY = 0;
			this.radius = 0;
			this.angle = 0;
			this.worldX = 0;
			this.worldY = 0;
			this.radius = radius;
		}
		SwirlEffect.prototype.begin = function (skeleton) {
			this.worldX = skeleton.x + this.centerX;
			this.worldY = skeleton.y + this.centerY;
		};
		SwirlEffect.prototype.transform = function (position, uv, light, dark) {
			var radAngle = this.angle * spine.MathUtils.degreesToRadians;
			var x = position.x - this.worldX;
			var y = position.y - this.worldY;
			var dist = Math.sqrt(x * x + y * y);
			if (dist < this.radius) {
				var theta = SwirlEffect.interpolation.apply(0, radAngle, (this.radius - dist) / this.radius);
				var cos = Math.cos(theta);
				var sin = Math.sin(theta);
				position.x = cos * x - sin * y + this.worldX;
				position.y = sin * x + cos * y + this.worldY;
			}
		};
		SwirlEffect.prototype.end = function () {
		};
		SwirlEffect.interpolation = new spine.PowOut(2);
		return SwirlEffect;
	}());
	spine.SwirlEffect = SwirlEffect;
})(spine || (spine = {}));
//# sourceMappingURL=spine-core.js.map
pc.extend(pc, function () {
    // Compare semantic versions
    function versionCompare(v1, v2, options) {
        var lexicographical = options && options.lexicographical,
            zeroExtend = options && options.zeroExtend,
            v1parts = v1.split('.'),
            v2parts = v2.split('.');

        function isValidPart(x) {
            return (lexicographical ? /^\d+[A-Za-z]*$/ : /^\d+$/).test(x);
        }

        if (!v1parts.every(isValidPart) || !v2parts.every(isValidPart)) {
            return NaN;
        }

        if (zeroExtend) {
            while (v1parts.length < v2parts.length) v1parts.push("0");
            while (v2parts.length < v1parts.length) v2parts.push("0");
        }

        if (!lexicographical) {
            v1parts = v1parts.map(Number);
            v2parts = v2parts.map(Number);
        }

        for (var i = 0; i < v1parts.length; ++i) {
            if (v2parts.length == i) {
                return 1;
            }

            if (v1parts[i] == v2parts[i]) {
                continue;
            } else if (v1parts[i] > v2parts[i]) {
                return 1;
            } else {
                return -1;
            }
        }

        if (v1parts.length != v2parts.length) {
            return -1;
        }

        return 0;
    }

    var ATTACHMENT_TYPE = {
        NULL: 0,
        MESH: 1,
        REGION: 2
    };

    var TO_TEXTURE_FILTER = {
        9728: pc.FILTER_NEAREST,
        9729: pc.FILTER_LINEAR,
        9984: pc.FILTER_NEAREST_MIPMAP_NEAREST,
        9985: pc.FILTER_LINEAR_MIPMAP_NEAREST,
        9986: pc.FILTER_NEAREST_MIPMAP_LINEAR,
        9987: pc.FILTER_LINEAR_MIPMAP_LINEAR
    };

    var TO_UV_WRAP_MODE = {
        33648: pc.ADDRESS_MIRRORED_REPEAT,
        33071: pc.ADDRESS_CLAMP_TO_EDGE,
        10487: pc.ADDRESS_REPEAT
    };

    // index data for region (quad) type of attachment
    var QUAD_TRIANGLES = [0, 1, 2, 2, 3, 0];

    /**
     * @class
     * @name SpineTextureWrapper
     * @description Implement Spine's interface for textures
     * @param {pc.Texture} texture - A PlayCanvas Texture
     */
    var SpineTextureWrapper = function (texture) {
        this._image = {
            width: texture.width,
            height: texture.height
        };

        this.pcTexture = texture;
    };

    SpineTextureWrapper.prototype = {
        setFilters: function (minFilter, magFilter) {
            this.pcTexture.minFilter = TO_TEXTURE_FILTER[minFilter];
            this.pcTexture.magFilter = TO_TEXTURE_FILTER[magFilter];
        },

        setWraps: function (uWrap, vWrap) {
            this.pcTexture.addressU = TO_UV_WRAP_MODE[uWrap];
            this.pcTexture.addressV = TO_UV_WRAP_MODE[vWrap];
        },

        getImage: function () {
            return this._image;
        }
    };


    /**
     * @name spine
     * @namespace
     * @description The Spine API.
     */

    /**
     * @class
     * @name pc.Spine
     * @classdesc  A Spine animation object.
     * @description Contains the skeleton and animation states as detailed in the Spine Runtime documentation.
     * @param {pc.Application} app - The application that will manage this Spine object.
     * @param {string} atlasData - Text data loaded from the atlas file.
     * @param {object} skeletonData - JSON data loaded from the skeleton file.
     * @param {object} textureData - Texture initialization data. An object where the key is the texture filename and the value is the pc.Texture resource.
     * @property {spine.Skeleton} skeleton The Skeleton object.
     * @property {spine.AnimationState} state The first AnimationState object. There is always one AnimationState.
     * @property {spine.AnimationState[]} states A list of all AnimationState objects.
     * @property {number} priority An integer value which determines when the spine mesh is rendered relative to other Spine meshes. Lower numbers are rendered first.
     * @property {boolean} autoUpdate Determines whether the Spine object calls skeleton.updateWorldTransform in the update loop. Default is true.
     */
    var Spine = function (app, atlasData, skeletonData, textureData) {
        this._app = app;

        this._position = new pc.Vec3();

        var atlas = new spine.TextureAtlas(atlasData, function (path) {
            return new SpineTextureWrapper(textureData[path]);
        });
        var json = new spine.SkeletonJson(new spine.AtlasAttachmentLoader(atlas));
        json.scale *= 0.01;
        var _skeletonData = json.readSkeletonData(skeletonData);
        this.skeletonVersion = _skeletonData.version;
        this._spine_3_6_0 = versionCompare(this.skeletonVersion, "3.6.0") <= 0;
        this._spine_3_7_99 = versionCompare(this.skeletonVersion, "3.7.99") <= 0;

        this.skeleton = new spine.Skeleton(_skeletonData);
        this.skeleton.updateWorldTransform();

        this.stateData = new spine.AnimationStateData(this.skeleton.data);
        this.states = [new spine.AnimationState(this.stateData)];
        this.clipper = new spine.SkeletonClipping();

        this._node = new pc.GraphNode();
        this._meshes = [];
        this._meshInstances = [];
        this._materials = {};
        this._tint = {};

        this._aabb = new pc.BoundingBox();
        this._aabbTempArray = [];
        this._aabbTempOffset = new pc.Vec2();
        this._aabbTempSize = new pc.Vec2();

        this._renderCounts = { vertexCount: 0, indexCount: 0 };
        this._vertexFormat = null;
        this._vertexBuffer = null;
        this._indexBuffer = null;

        this._priority = 0;
        this._timeScale = 1;
        this._layers = [pc.LAYERID_UI];

        this.init();

        this.autoUpdate = true;
        this._hidden = false;
    };

    Spine.prototype.destroy = function () {
        this.removeFromLayers();

        for (var i = 0; i < this._meshInstances.length; i++) {
            this._meshInstances[i].mesh.vertexBuffer = null;
            this._meshInstances[i].mesh.indexBuffer.length = 0;
            this._meshInstances[i].material = null;
        }

        if (this._vertexBuffer) {
            this._vertexBuffer.destroy();
            this._vertexBuffer = null;
        }

        if (this._indexBuffer) {
            this._indexBuffer.destroy();
            this._indexBuffer = null;
        }

        this._meshInstances = [];
        this.skeleton = null;
        this.stateData = null;
        this.state = null;
        this._materials = {};
        this._node = null;
    };

    Spine.prototype.hide = function () {
        if (this._hidden)
            return;

        for (var i = 0, n = this._meshInstances.length; i < n; i++) {
            this._meshInstances[i].visible = false;
        }

        this._hidden = true;
    };

    Spine.prototype.show = function () {
        if (!this._hidden)
            return;

        for (var i = 0, n = this._meshInstances.length; i < n; i++) {
            this._meshInstances[i].visible = true;
        }

        this._hidden = false;
    };

    Spine.prototype.init = function () {

        // vertex format
        this._vertexFormat = new pc.VertexFormat(this._app.graphicsDevice, [
            { semantic: pc.SEMANTIC_POSITION, components: 2, type: pc.TYPE_FLOAT32 },
            { semantic: pc.SEMANTIC_NORMAL, components: 4, type: pc.TYPE_UINT8, normalize: true },
            { semantic: pc.SEMANTIC_TEXCOORD0, components: 2, type: pc.TYPE_FLOAT32 },
            { semantic: pc.SEMANTIC_COLOR, components: 4, type: pc.TYPE_UINT8, normalize: true }
        ]);

        // init slots
        var drawOrder = this.skeleton.drawOrder;
        for (var i = 0, n = drawOrder.length; i < n; i++) {
            this.initSlot(drawOrder[i]);
        }
    };

    Spine.prototype.initSlot = function (slot) {
        slot.positions = [];    // vec2 world space positions
        slot.uvs = [];          // vec2 uv coordinates
        slot.indices = [];      // triangle indices
        slot.vertexColor = {};  // rgba color of the slot

        // last update name and type, used to detect when attachment changes on a slot
        slot._active = { name: '', type: ATTACHMENT_TYPE.NULL };

        this.initAttachment(slot);
    };

    Spine.prototype.createMaterial = function (texture) {
        var material = new pc.StandardMaterial();
        material.shadingModel = pc.SPECULAR_BLINN;
        material.diffuse = new pc.Color(1, 1, 1); // include diffuse component, this allows lights contribution

        material.emissiveMap = texture;
        material.emissiveMapChannel = "rgb";
        material.emissiveVertexColor = true;
        material.emissiveVertexColorChannel = "rgb";

        material.opacityMap = texture;
        material.opacityMapChannel = "a";
        material.opacityVertexColor = true;
        material.opacityVertexColorChannel = "a";

        material.depthWrite = false;
        material.cull = pc.CULLFACE_NONE;
        material.blendType = pc.BLEND_PREMULTIPLIED;

        if (this._spine_3_6_0) {
            // override premultiplied chunk because images are already premultiplied however the opacity is not premultiplied by slot alpha
            var alphaPremul = [
                'gl_FragColor.rgb *= vVertexColor.a;',
                'gl_FragColor.a = dAlpha;'
            ].join('\n');
            material.chunks.outputAlphaPremulPS = alphaPremul;
        }

        material.update();
        return material;
    };

    Spine.prototype.initAttachment = function (slot) {
        var attachment = slot.attachment;
        if (attachment) {
            slot._active.name = attachment.name;
            if (attachment instanceof spine.RegionAttachment) {
                slot._active.type = ATTACHMENT_TYPE.REGION;
            } else if (attachment instanceof spine.MeshAttachment) {
                slot._active.type = ATTACHMENT_TYPE.MESH;
            }

            // create / assign material
            if (attachment.region && attachment.region.texture) {
                var texture = attachment.region.texture.pcTexture;
                if (texture) {
                    if (texture instanceof pc.StandardMaterial) {
                        this._materials[texture.name] = texture;
                        slot.material = texture.name;
                    } else {
                        // get a unique key for the texture
                        var key = null;
                        if (texture.name) {
                            key = texture.name; // texture name might not be unique - should be resolved with content
                        } else if (texture.getSource() instanceof Image) {
                            key = texture.getSource().getAttribute("src");
                        }
                        if (key) {
                            // create a new material if required
                            if (this._materials[key] === undefined) {
                                var material = this.createMaterial(texture);
                                this._materials[key] = material;
                            }
                            slot.material = key;
                        }
                    }
                }
            }
        }
    };

    Spine.prototype.updateSlot = function (slot, clipper) {
        var attachment = slot.attachment;
        var name = attachment.name;

        // attachment can change on the slot
        var type = (attachment instanceof spine.RegionAttachment) ? ATTACHMENT_TYPE.REGION : ((attachment instanceof spine.MeshAttachment) ? ATTACHMENT_TYPE.MESH : ATTACHMENT_TYPE.NULL);
        if (slot._active.name !== name || slot._active.type != type) {
            this.initAttachment(slot);
        }

        // convert vertices to world space
        slot.positions.length = 0;
        if (attachment instanceof spine.RegionAttachment) {
            attachment.computeWorldVertices(slot.bone, slot.positions, 0, 2);
        } else if (attachment instanceof spine.MeshAttachment) {
            attachment.computeWorldVertices(slot, 0, attachment.worldVerticesLength, slot.positions, 0, 2);
        }

        // mesh vertex color
        var tint = this._tint[name];
        slot.vertexColor = {
            r: Math.round(255 * slot.color.r * (tint ? tint.r : 1)),
            g: Math.round(255 * slot.color.g * (tint ? tint.g : 1)),
            b: Math.round(255 * slot.color.b * (tint ? tint.b : 1)),
            a: Math.round(255 * slot.color.a * (tint ? tint.a : 1))
        };

        // indices
        var srcTriangles = attachment.triangles || QUAD_TRIANGLES;

        var i, count;

        if (clipper.isClipping()) {
            // clip triangles on CPU
            var twoColorTint = false;
            clipper.clipTriangles(slot.positions, 0, srcTriangles, srcTriangles.length, attachment.uvs, spine.Color.WHITE, spine.Color.WHITE, twoColorTint);

            // copy clipped vertex data
            slot.positions.length = 0;
            slot.uvs.length = 0;
            var vertexSize = twoColorTint ? 12 : 8;     // clipper output format
            count = clipper.clippedVertices.length;
            for (i = 0; i < count; i += vertexSize) {
                slot.positions.push(clipper.clippedVertices[i], clipper.clippedVertices[i + 1]);
                slot.uvs.push(clipper.clippedVertices[i + 6], 1 - clipper.clippedVertices[i + 7]);
            }

            // copy clipped index data
            slot.indices = clipper.clippedTriangles.slice();
        } else {
            // copy vertex data (uvs only, position was filled in already)
            slot.uvs.length = 0;
            count = slot.positions.length;
            for (i = 0; i < count; i += 2) {
                slot.uvs.push(attachment.uvs[i], 1 - attachment.uvs[i + 1]);
            }

            // reference index data
            slot.indices = srcTriangles;
        }

        // update overall counts
        this._renderCounts.vertexCount += slot.positions.length / 2;
        this._renderCounts.indexCount += slot.indices.length;
    };

    Spine.prototype.updateSkeleton = function (dt) {

        // count verticies and triangles
        this._renderCounts.vertexCount = 0;
        this._renderCounts.indexCount = 0;

        // handle clipping start / end / range
        var clipper = this.clipper;
        var slotRangeStart = -1, slotRangeEnd = -1;
        var inRange = false;
        if (slotRangeStart == -1)
            inRange = true;

        var drawOrder = this.skeleton.drawOrder;
        var count = drawOrder.length;
        for (var i = 0; i < count; i++) {
            var slot = drawOrder[i];

            if (!this._spine_3_7_99) {
                if (!slot.bone.active) {
                    clipper.clipEndWithSlot(slot);
                    continue;
                }
            }

            if (slotRangeStart >= 0 && slotRangeStart == slot.data.index) {
                inRange = true;
            }

            if (!inRange) {
                clipper.clipEndWithSlot(slot);
                continue;
            }

            if (slotRangeEnd >= 0 && slotRangeEnd == slot.data.index) {
                inRange = false;
            }

            var attachment = slot.getAttachment();
            if (attachment instanceof spine.ClippingAttachment) {
                clipper.clipStart(slot, attachment);
                continue;
            } else if (!(attachment instanceof spine.RegionAttachment) && !(attachment instanceof spine.MeshAttachment)) {
                if (!this._spine_3_7_99)
                    clipper.clipEndWithSlot(slot);
                continue;
            }

            // update slot geometry
            this.updateSlot(slot, clipper);
        }
    };

    Spine.prototype.render = function () {

        // remove materials from meshInstances as they keep references to meshInstances not allowing them to be GC'd
        this._meshInstances.forEach(function (instance) {
            instance.material = null;
        });

        this.removeFromLayers();
        this._meshes = [];
        this._meshInstances.length = 0;

        // any vertices / triangles to render
        if (this._renderCounts.indexCount > 0 && this._renderCounts.vertexCount > 0) {

            // update aabb
            this.skeleton.getBounds(this._aabbTempOffset, this._aabbTempSize, this._aabbTempArray);
            this._aabb.center = new pc.Vec3(this._aabbTempOffset.x, this._aabbTempOffset.y, 0);
            this._aabb.halfExtents = new pc.Vec3(0.5 * this._aabbTempSize.x, 0.5 * this._aabbTempSize.y, 0);

            // make vertex buffer at least required size
            if (!this._vertexBuffer || this._vertexBuffer.getNumVertices() < this._renderCounts.vertexCount) {
                if (this._vertexBuffer)
                    this._vertexBuffer.destroy();

                this._vertexBuffer = new pc.VertexBuffer(this._app.graphicsDevice, this._vertexFormat, this._renderCounts.vertexCount);
            }

            // make index buffer at least required size
            if (!this._indexBuffer || this._indexBuffer.getNumIndices() < this._renderCounts.indexCount) {
                if (this._indexBuffer)
                    this._indexBuffer.destroy();

                this._indexBuffer = new pc.IndexBuffer(this._app.graphicsDevice, pc.INDEXFORMAT_UINT16, this._renderCounts.indexCount);
            }

            // batching start
            var currentMaterialKey = null;
            var batchStartIndex = 0;
            var batchIndexCount = 0;

            // vertex / index buffer access
            var dstVertices = new pc.VertexIterator(this._vertexBuffer);
            var dstIndices = new Uint16Array(this._indexBuffer.lock());
            var dstIndexOffset = 0, dstVertexOffset = 0;

            var drawOrder = this.skeleton.drawOrder;
            var count = drawOrder.length;
            for (var i = 0; i < count; i++) {
                var slot = drawOrder[i];

                if (slot.attachment && slot.material && slot.positions.length > 0 && slot.indices.length > 0) {

                    // material switch
                    if (currentMaterialKey && currentMaterialKey !== slot.material) {
                        this.SubmitBatch(batchStartIndex, batchIndexCount, currentMaterialKey);

                        // prepare next batch
                        currentMaterialKey = slot.material;
                        batchStartIndex = dstIndexOffset;
                        batchIndexCount = 0;

                    }
                    currentMaterialKey = slot.material;

                    // write vertex data
                    var positions = slot.positions;
                    var r = slot.vertexColor.r, g = slot.vertexColor.g, b = slot.vertexColor.b, a = slot.vertexColor.a;
                    var uvs = slot.uvs;
                    var j, posCount = positions.length / 2;

                    for (j = 0; j < posCount; j++) {
                        dstVertices.element[pc.SEMANTIC_POSITION].set(positions[j * 2], positions[j * 2 + 1]);
                        dstVertices.element[pc.SEMANTIC_NORMAL].set(0, 255, 0, 0);      // 0,1,0 normal stored in 8 bit per component
                        dstVertices.element[pc.SEMANTIC_COLOR].set(r, g, b, a);
                        dstVertices.element[pc.SEMANTIC_TEXCOORD0].set(uvs[j * 2], 1.0 - uvs[j * 2 + 1]);
                        dstVertices.next();
                    }

                    // write index data
                    var indices = slot.indices;
                    var indCount = indices.length;
                    for (j = 0; j < indCount; j++)
                        dstIndices[dstIndexOffset + j] = indices[j] + dstVertexOffset;

                    batchIndexCount += indCount;
                    dstIndexOffset += indCount;
                    dstVertexOffset += posCount;
                }
            }

            dstVertices.end();
            this._indexBuffer.unlock();

            // final batch
            this.SubmitBatch(batchStartIndex, batchIndexCount, currentMaterialKey);
        }

        // add all instances to layers
        this.addToLayers();
    };

    Spine.prototype.SubmitBatch = function (indexBase, indexCount, materialKey) {
        if (indexCount > 0) {
            var mesh = new pc.Mesh();
            mesh.vertexBuffer = this._vertexBuffer;
            mesh.indexBuffer[0] = this._indexBuffer;
            mesh.primitive[0].type = pc.PRIMITIVE_TRIANGLES;
            mesh.primitive[0].base = indexBase;
            mesh.primitive[0].count = indexCount;
            mesh.primitive[0].indexed = true;
            mesh.aabb = this._aabb;
            this._meshes.push(mesh);

            var mi = new pc.MeshInstance(this._node, mesh, this._materials[materialKey]);
            mi.drawOrder = this.priority + this._meshInstances.length;
            mi.visible = !this._hidden;
            this._meshInstances.push(mi);
        }
    };

    Spine.prototype.update = function (dt) {
        if (this._hidden)
            return;

        dt *= this._timeScale;

        var i, n = this.states.length;
        for (i = 0; i < n; i++) {
            this.states[i].update(dt);
        }

        for (i = 0; i < n; i++) {
            this.states[i].apply(this.skeleton);
        }

        if (this.autoUpdate) {
            this.skeleton.updateWorldTransform();
        }

        this.updateSkeleton();
        this.render();
    };

    Spine.prototype.setPosition = function (p) {
        this._position.copy(p);
    };

    Spine.prototype.setTint = function (name, color) {
        this._tint[name] = color;
    };

    Spine.prototype.removeFromLayers = function () {
        if (this._meshInstances.length) {
            for (var i = 0; i < this._layers.length; i++) {
                var layer = this._app.scene.layers.getLayerById(this._layers[i]);
                if (layer)
                    layer.removeMeshInstances(this._meshInstances);
            }
        }
    };

    Spine.prototype.addToLayers = function () {
        if (this._meshInstances.length) {
            for (var i = 0; i < this._layers.length; i++) {
                var layer = this._app.scene.layers.getLayerById(this._layers[i]);
                if (layer)
                    layer.addMeshInstances(this._meshInstances);
            }
        }
    };

    Object.defineProperty(Spine.prototype, "state", {
        get: function () {
            return this.states[0];
        }
    });

    Object.defineProperty(Spine.prototype, "priority", {
        get: function () {
            return this._priority;
        },
        set: function (value) {
            this._priority = value;
        }
    });

    Object.defineProperty(Spine.prototype, "timeScale", {
        get: function () {
            return this._timeScale;
        },
        set: function (value) {
            this._timeScale = value;
        }
    });

    Object.defineProperty(Spine.prototype, "layers", {
        get: function () {
            return this._layers;
        },
        set: function (value) {
            this.removeFromLayers();
            this._layers = value || [];
            this.addToLayers();
        }
    });

    return {
        Spine: Spine
    };
}());

pc.extend(pc, function () {
    var SpineComponentSystem = function SpineComponentSystem(app) {
        pc.ComponentSystem.call(this, app);

        this.id = 'spine';

        this.ComponentType = pc.SpineComponent;
        this.DataType = pc.SpineComponentData;

        this.schema = [
            'enabled',
            'atlasAsset',
            'textureAssets',
            'skeletonAsset',
            'atlasData',
            'textures',
            'skeletonData',
            'speed',
            'spine'
        ];

        this.on('beforeremove', this.onBeforeRemove, this);
        this.app.systems.on('update', this.onUpdate, this);
    };
    SpineComponentSystem.prototype = Object.create(pc.ComponentSystem.prototype);
    SpineComponentSystem.prototype.constructor = SpineComponentSystem;

    Object.assign(SpineComponentSystem.prototype, {
        initializeComponentData: function (component, data, properties) {
            properties = ['enabled', 'atlasAsset', 'textureAssets', 'skeletonAsset', 'atlasData', 'textures', 'skeletonData', 'spine'];
            pc.ComponentSystem.prototype.initializeComponentData.call(this.system, component, data, properties);
        },

        onBeforeRemove: function (entity, component) {
            var data = entity.spine.data;
            if (data.spine) {
                data.spine.destroy();
            }

            entity.spine.removeComponent();
        },

        onUpdate: function (dt) {
            var components = this.store;

            for (var id in components) {
                if (components.hasOwnProperty(id)) {
                    var component = components[id];
                    var componentData = component.data;
                    if (componentData.enabled && component.entity.enabled) {
                        if (componentData.spine) {
                            componentData.spine.setPosition(component.entity.getPosition());
                            componentData.spine.update(componentData.speed * dt);
                        }
                    }
                }
            }
        }
    });

    return {
        SpineComponentSystem: SpineComponentSystem
    };
}());

pc.extend(pc, function () {
    var SpineComponent = function SpineComponent(system, entity) {
        pc.Component.call(this, system, entity);

        this.on("set_atlasAsset", this.onSetAsset, this);
        this.on("set_textureAssets", this.onSetAssets, this);
        this.on("set_skeletonAsset", this.onSetAsset, this);

        this.on("set_atlasData", this.onSetResource, this);
        this.on("set_textures", this.onSetResource, this);
        this.on("set_skeletonData", this.onSetResource, this);
    };
    SpineComponent.prototype = Object.create(pc.Component.prototype);
    SpineComponent.prototype.constructor = SpineComponent;

    Object.assign(SpineComponent.prototype, {
        _createSpine: function () {
            if (this.data.spine) {
                this.data.spine.destroy();
                this.data.spine = null;
            }

            var textureData = {};
            for (var i = 0, n = this.textureAssets.length; i < n; i++) {
                var asset = this.system.app.assets.get(this.textureAssets[i]);
                var path = asset.name ? asset.name : (asset.file ? asset.file.filename : null);
                // Fallback if filename doesn't exist
                if (!path) {
                    path = pc.path.getBasename(asset.file.url);
                }

                var query = path.indexOf('?');
                if (query !== -1)
                    path = path.substring(0, query);

                textureData[path] = asset.resource;
            }

            this.data.spine = new pc.Spine(this.system.app, this.atlasData, this.skeletonData, textureData);

            this.state = this.data.spine.state;
            this.states = this.data.spine.states;
            this.skeleton = this.data.spine.skeleton;

            this.entity.addChild(this.data.spine._node);
        },

        _onAssetReady: function (asset) {
            if (asset.type === "texture") {
                this.textures.push(asset.resource);
            }
            if (asset.type === "json") {
                this.skeletonData = asset.resource;
            }
            if (asset.type === "text") {
                this.atlasData = asset.resource;
            }
        },

        _onAssetAdd: function (asset) {
            asset.off('change', this.onAssetChanged, this);
            asset.on('change', this.onAssetChanged, this);

            asset.off('remove', this.onAssetRemoved, this);
            asset.on('remove', this.onAssetRemoved, this);

            asset.ready(this._onAssetReady, this);
            this.system.app.assets.load(asset);
        },

        onSetResource: function () {
            if (this.data.atlasData && this.data.textures.length && this.data.skeletonData) {
                this._createSpine();
            }
        },

        onSetAsset: function (name, oldValue, newValue) {
            var registry = this.system.app.assets;
            var asset = null;
            if (oldValue) {
                asset = registry.get(oldValue);
                if (asset) {
                    asset.off("change", this.onAssetChanged);
                    asset.off("remove", this.onAssetRemoved);
                }
            }

            if (newValue) {
                var id = newValue;
                if (newValue instanceof pc.Asset) {
                    id = newValue.id;
                    this.data[name] = id;
                }
                asset = registry.get(id);
                if (asset) {
                    this._onAssetAdd(asset);
                } else {
                    registry.on("add:" + id);
                }
            }
        },

        onSetAssets: function (name, oldValue, newValue) {
            var registry = this.system.app.assets;
            var asset = null;
            var i, n;
            if (oldValue.length) {
                for (i = 0, n = oldValue.length; i < n; i++) {
                    asset = registry.get(oldValue[i]);
                    if (asset) {
                        asset.off("change", this.onAssetChanged);
                        asset.off("remove", this.onAssetRemoved);
                    }
                }
            }

            if (newValue && newValue.length) {
                var ids = newValue.map(function (v) {
                    if (v instanceof pc.Asset) {
                        return v.id;
                    }
                    return v;
                });

                for (i = 0, n = newValue.length; i < n; i++) {
                    asset = registry.get(ids[i]);
                    if (asset) {
                        this._onAssetAdd(asset);
                    } else {
                        registry.on("add:" + ids[i]);
                    }
                }
            }
        },

        onAssetChanged: function (asset, attribute, newValue, oldValue) {

        },

        onAssetRemoved: function (asset) {

        },

        onEnable: function () {
            pc.Component.prototype.onEnable.call(this);

            var spine = this.data.spine;
            if (spine) {
                spine.addToLayers();
            }
        },

        onDisable: function () {
            pc.Component.prototype.onDisable.call(this);

            var spine = this.data.spine;
            if (spine) {
                spine.removeFromLayers();
            }
        },

        hide: function () {
            if (this.data.spine) {
                this.data.spine.hide();
            }
        },

        show: function () {
            if (this.data.spine) {
                this.data.spine.show();
            }
        },

        removeComponent: function () {
            var asset;

            if (this.atlasAsset) {
                asset = this.system.app.assets.get(this.atlasAsset);
                if (asset) {
                    asset.off("change", this.onAssetChanged);
                    asset.off("remove", this.onAssetRemoved);
                }
            }

            if (this.skeletonAsset) {
                asset = this.system.app.assets.get(this.skeletonAsset);
                if (asset) {
                    asset.off("change", this.onAssetChanged);
                    asset.off("remove", this.onAssetRemoved);
                }
            }

            if (this.textureAssets && this.textureAssets.length) {
                for (var i = 0; i < this.textureAssets.length; i++) {
                    asset = this.system.app.assets.get(this.textureAssets[i]);
                    if (asset) {
                        asset.off("change", this.onAssetChanged);
                        asset.off("remove", this.onAssetRemoved);
                    }
                }
            }
        }
    });

    return {
        SpineComponent: SpineComponent
    };
}());

pc.extend(pc, function () {
    var SpineComponentData = function () {
        // serialized
        this.enabled = true;
        this.atlasAsset = null;
        this.textureAssets = [];
        this.skeletonAsset = null;
        this.speed = 1;

        // non-serialized
        this.spine = null;
        this.atlasData = null;
        this.textures = [];
        this.skeletonData = null;
    };

    return {
        SpineComponentData: SpineComponentData
    };
}());

(function () {
    if (pc.Application.registerPlugin) {
        var register = function (app) {
            new pc.SpineComponentSystem(app);
        };
        pc.Application.registerPlugin("spine", register);
    } else {
        var app = pc.Application.getApplication();
        var system = new pc.SpineComponentSystem(app);
        app.systems.add(system);
    }
}());

// FakeLevelButton.js
class FakeLevelButton extends pc.ScriptType {
    static addAttributes() {
        this.attributes.add('buttonBorderEntity', { type: 'entity' });
        this.attributes.add('objectiveImages', { type: 'entity', array: true });
        this.attributes.add('starImages', { type: 'entity', array: true });
        this.attributes.add('levelNumberText', { type: 'entity' });

        this.attributes.add('backgrounds', { type: 'asset', array: true});
        this.attributes.add('unlockedBorderEntity', { type: 'entity'});
        this.attributes.add('lockedGroupEntity', { type: 'entity'});
        this.attributes.add('currentGroupEntity', { type: 'entity'});

    }

    // NOTE levelInfo is not used yet, but created for the purpose of objectiveData
    setButtonInformation(chapterID, levelID, levelInfo) {
        this.levelNumberText.element.text = levelID;
        this.levelID = levelID;
        this.levelInfo = levelInfo;
        this.chapterID = chapterID;

        this.setImage();

        // stars
        var levelData = LevelDataManager.instance.getLevelData(chapterID, levelID);

        var nStars = levelData === null ? 0 : levelData.stars;

        for (var i = 0; i < this.starImages.length; i += 1) {
            var enabled = nStars > i
            this.starImages[i].enabled = enabled;

            if (enabled) {
                this.starImages[i].children[0].script.coloredStar.setStarBasedOnWorldIndex(chapterID);
            }        
        }

        // objectives
        this.data = LevelManager.instance.getLevelData(this.levelID);

        if (this.data) {
            var keys = Object.keys(this.data);

            if (keys.length > 3) {
                console.error("This level has too many objectives! Level:", this.levelID, this.data)
                return;
            }

            var index = 0;

            for (var j = 0; j < keys.length; j++) {
                var key = keys[j];

                if (key === 'turns') {
                    continue;
                }
                var sprite = TileLibrary.instance.getTileSprite(key);

                if (sprite) {
                    this.objectiveImages[index].enabled = true;
                    this.objectiveImages[index].element.spriteAsset = sprite;
                    index++;
                } else {
                    console.warn("No asset found for key:", key);
                }
            }

            if (index === 1) {
                this.objectiveImages[index].enabled = false;
            }
        } else {
            console.warn("No data found for level", levelID);
        }
    }

    setImage() {
        this.entity.element.sprite = this.backgrounds[this.chapterID - 1].resource;
    }

    setState(state) {
        this.currentState = state;

        this.lockedGroupEntity.enabled = this.currentState === LevelButton.buttonStates.LOCKED;
        this.unlockedBorderEntity.enabled = this.currentState !== LevelButton.buttonStates.LOCKED;
        this.currentGroupEntity.enabled = this.currentState === LevelButton.buttonStates.CURRENT;

        for (var i  = 0; i < this.objectiveImages.length; i ++) {
            this.objectiveImages[i].element.color = this.currentState === LevelButton.buttonStates.LOCKED ? LevelButton.GREY : pc.Color.WHITE;
            this.objectiveImages[i].element.opacity = this.currentState === LevelButton.buttonStates.LOCKED ? 0.7 : 1;
        }
    }
}

pc.registerScript(FakeLevelButton);
FakeLevelButton.addAttributes();


// es6ClassTemplate.js
class Es6ClassTemplate extends pc.ScriptType {
    static addAttributes(){
         this.attributes.add('attribute1', {type: 'entity'});
    }
    initialize(){
        
    }
    postInitialize(){
        
    }
    update(dt){
        
    }
}
pc.registerScript(Es6ClassTemplate, 'es6ClassTemplate');
Es6ClassTemplate.addAttributes();

// BlurShader.js
class BlurShader extends pc.ScriptType {
    static addAttributes() {
        this.attributes.add('fragmentShader', { type: 'asset', assetType: 'shader' });
        this.attributes.add('vertexShader', { type: 'asset', assetType: 'shader' });
        this.attributes.add('uDiffuseMap', { type: 'asset' });
        this.attributes.add('uBlurRadius', { type: 'number', step: 0.001, default: 0.005 });
        this.attributes.add('uBlurStrength', { type: 'number', default: 1 });
    }

    initialize() {
        this.shaders = [];

        this.time = 0;
        if (this.entity.model) {
            this.entity.model.model.meshInstances[0].material = this.createMaterial();
        } else if (this.entity.element) {
            this.entity.element.material = this.createMaterial();
        }

        this.on('attr', (key, value) => {
            switch (key) {
                case 'uDiffuseMap': {
                    this.material.setParameter(key, value.resource.atlas.texture);
                    break;
                }
            }
        });

        this.on('destroy', this._onDestroy, this);
    }

    _onDestroy() {
        if (this.material) {
            this.material.destroy();
            delete this.material;
        }

        this.shader.forEach(s => s.destroy());

        this.shaders.length = 0;
    }

    update(dt) {
        this.time += dt;
    }

    setShaderAttributes() {
        //loop through all attributes of a shader to update them when changed.
        for (const [key, value] of Object.entries(this.__attributes)) {
            switch (typeof value) {
                case 'number': {
                    this.material.setParameter(key, value); //Set shader parameter
                    this.on('attr:' + key, function (value, prev) {
                        this.material.setParameter(key, value); //Set shader parameter
                    });
                    break;
                }
                case 'object': {
                    // loop through different attribute types.

                    if (value === null) {
                        continue;
                    }

                    switch (value.type) {
                        case 'shader': {
                            this.material.shader = this.createShader();// Apply shader to new material 
                            this.on('attr:' + key, function (value, prev) {
                                this.material.shader = this.createShader();// Apply shader to new material 
                            });
                            break;
                        }
                        case 'sprite': {
                            this.material.setParameter(key, this[key].resource.atlas.texture);

                            this.on('attr:' + key, function (value, prev) {
                                this.material.setParameter(key, this[key].resource);
                            });
                            break;
                        }
                        case 'textureatlas': {
                            this.material.setParameter(key, this[key].resource.texture);

                            this.on('attr:' + key, function (value, prev) {
                                this.material.setParameter(key, this[key].resource);
                            });
                            break;
                        }
                        case 'texture': {
                            this.material.setParameter(key, this[key].resource);

                            this.on('attr:' + key, function (value, prev) {
                                this.material.setParameter(key, this[key].resource);
                            });
                            break;
                        }
                        default: {
                            this.material.setParameter(key, value.data);
                            this.on('attr:' + key, function (value, prev) {
                                this.material.setParameter(key, value.data);
                            });
                            break;
                        }
                    }
                    break;
                }
                default: {
                    console.warn("could not update", key, "with current datatype", typeof value);
                }
            }
        }
    }

    createMaterial() {
        var material = new pc.Material();// new material 
        material.name = "blurMaterial";// material name
        this.material = material; // Save a reference to this material
        this.setShaderAttributes();

        return material;
    }

    createShader() {
        //vertex shader
        var vertexShader = this.vertexShader.resource;
        //fragment shader
        // set float precision depending on device.
        var fragmentShader = `precision ${this.app.graphicsDevice.precision} float;\n` + this.fragmentShader.resource;
        // Create shader definition 
        // A shader definition used to create a new shader.
        var shaderDefinition = {
            attributes: {
                aPosition: pc.gfx.SEMANTIC_POSITION,
                aUv0: pc.gfx.SEMANTIC_TEXCOORD0,
            },
            vshader: vertexShader,
            fshader: fragmentShader
        };
        // Create the shader from the definition 
        var shader = new pc.Shader(this.app.graphicsDevice, shaderDefinition);

        this.shaders.push(shader);
        return shader;
    }
}

pc.registerScript(BlurShader, 'blurShader');
BlurShader.addAttributes();

// Timer.js
(function () {
    var _timers = {};
    var _nextFreeId = 0;

    pc.timer = {};
    pc.timer.add = function (durationSecs, callback, scope) {
        if (durationSecs > 100) {
            console.warn("where", durationSecs);
        }

        if (durationSecs >= 0) {
            var handle = {};
            handle.id = _nextFreeId;
            handle.secsLeft = durationSecs;

            _timers[_nextFreeId] = {
                secsLeft: durationSecs,
                callback: callback,
                scope: scope
            };

            _nextFreeId += 1;
            return handle;

        } else {
            callback.call(scope);
        }
        return null;
    };

    pc.timer.remove = function (handle) {
        if (handle) {
            delete _timers[handle.id];
        }
    };

    pc.timer.update = function (dt) {
        for (var property in _timers) {
            var timer = _timers[property];
            timer.secsLeft -= dt;
            if (timer.secsLeft <= 0) {
                timer.callback.call(timer.scope);
                delete _timers[property];
            }
        }
    };

    pc.timer.adjustSecsLeft = function (handle, secs) {
        handle.secsLeft = secs;

        if (_timers[handle.id]) {
            _timers[handle.id].secsLeft = secs;
        }
    };

    var application = pc.Application.getApplication();
    if (application) {
        application.on('update', function (dt) {
            pc.timer.update(dt);
        });
    }
})();

// BackToGardenButton.js
class BackTogardenButton extends pc.ScriptType {
    static addAttributes() {
        this.attributes.add('showIntroComic', { type: 'boolean' });
    }

    initialize() {
        this.entity.script.elementInput.on('click', this._onClick, this);
        if (BackTogardenButton.showIntro === null) {
            BackTogardenButton.showIntro = GardenDataManager.instance.firstTimeGarden();
        }
    }

    postInitialize() {
        this.app.on('StorageManager:changedStorage', this.onUserChange, this);
    }

    onUserChange(user) {
        BackTogardenButton.showIntro = GardenDataManager.instance.firstTimeGarden();
    }

    _hasObjectiveSet() {
        return GardenDataManager.instance.getNextUnlockableObject();
    }

    _onClick() {
        if (BackTogardenButton.showIntro && !this._hasObjectiveSet()) {
            if (LevelDataManager.instance.getCurrentLevel() === 1) {
                if (this.showIntroComic) {
                    this.app.fire('UIManager:showUI', 'LoadingScreen', "garden");
                    LoadingScreen.instance.setType(LoadingScreen.TYPES.ASSETS).once('fadeInComplete', () => {
                        WorldUnlockManager.instance.setWorldUnlocked(0);
                        WorldManager.instance.switchWorld(1)
                        AssetManager.instance.loadIntro(() => {
                            this.app.fire('UIManager:hideUI', 'LoadingScreen');
                            this.app.fire('UIManager:showUI', 'introComic');
                        }, this);

                        BackTogardenButton.showIntro = false;

                        this.app.on('UIManager:hideUI', this.afterIntro, this);
                    });
                    return;

                } else {
                    Wrapper.instance.sendGAEvent(Wrapper.GA_EVENT_TYPE.DESIGN, { eventId: 'tutorialFunnel:photoAnimationStarted' });
                    Wrapper.instance.sendGAEvent(Wrapper.GA_EVENT_TYPE.DESIGN, { eventId: 'tutorialFunnel:photoAnimationEnded' });
                    FirstTimeUserManager.instance.enableFTUE();
                    WorldUnlockManager.instance.setWorldUnlocked(0);
                    BackTogardenButton.showIntro = false;
                    AssetManager.instance.ftue = true;

                    this.afterIntro('introComic');
                }
                return;

            } else {
                WorldUnlockManager.instance.setWorldUnlocked(0);
                BackTogardenButton.showIntro = false;
            }
        }

        if (BackTogardenButton.showIntro && this._hasObjectiveSet()) {
            WorldUnlockManager.instance.setWorldUnlocked(0);
            BackTogardenButton.showIntro = false;
        }

        if (Application.currentScene !== 'Garden') {
            //////
            // AssetManager.instance.setWorld(AssetManager.WORLDS.GARDEN, null, null, true);
            // LoadSceneController.load('Garden', false, 'garden');
            // LoadingScreen.instance.once('fadeInComplete', this.hide, this);


            //////

            this.app.fire('BackToGardenButton:click');
            AssetManager.instance.setGarden();
            LoadSceneController.load('Garden', false, 'garden');
            this.app.once('switchedScene', () => {
                this.app.fire('UIManager:hideUI', 'LoadingScreen');

                this.app.fire('UIManager:hideAll');
                this._changeUI()

                if (WorldUnlockManager.instance.isUnlocked()) {
                    WorldUnlockManager.instance.startGardenSequence();
                } else {
                    this.app.fire('UIManager:showUI', 'Garden', this.tunnelValues);
                }

                this.tunnelValues = null;
            }, this);

        } else {
            this.app.fire('UIManager:showUI', 'LoadingScreen', "garden");

            LoadingScreen.instance.setType(LoadingScreen.TYPES.ASSETS).once('fadeInComplete', () => {
                AssetManager.instance.setGarden(this._changeUI, this, true, true, true);
            });
        }
    }

    afterIntro(name) {
        if (name === 'introComic') {
            this.app.off('UIManager:hideUI', this.afterIntro, this);
            GardenDataManager.instance.firstTimeGarden();
            LevelManager.instance.doFTUEEvent();
            LevelManager.instance.startLevel(1, 1, true)
            // this._onClick();
        }
    }

    _changeUI() {
        LoadingScreen.instance.once('startFadeOut', () => {
            if (WorldUnlockManager.instance.isUnlocked()) {
                WorldUnlockManager.instance.startGardenSequence();
            } else {
                this.app.fire('UIManager:hideAll', "Garden");

                this.app.fire('UIManager:showUI', 'Garden', this.getTunnelValue());
            }

            pc.timer.add(0.3, () => {
                // AssetManager.instance.unloadPreviousAssets();
                this.app.fire('rebatch');
            });
        });

        this.app.fire('UIManager:hideUI', 'LoadingScreen');


        //         for (let i = 0; i < BackTogardenButton.batchGroupIDs.length; i++) {
        //             this.app.batcher.markGroupDirty(BackTogardenButton.batchGroupIDs[i]);
        //         }
    }

    getTunnelValue() {
        try {
            const areaData = GardenDataManager.instance.areaData;
            const areaObjectsSaveValues = areaData['Area 1'].areaObjectsSaveValues

            const flowerBedFixed = areaObjectsSaveValues[0].currentObject !== 3;

            if (flowerBedFixed) {
                return null;
            }

            return { OpenTaskScreen: true }
        } catch (e) {
            return null
        }

    }

    hide() {
        var script = this.entity.findScriptInParents("uiEntity");

        if (script) {
            this.app.fire("UIManager:hideUI", script.name);
        }
    }
}
pc.registerScript(BackTogardenButton, 'backTogardenButton');
BackTogardenButton.addAttributes();
BackTogardenButton.showIntro = null;

// GardenTasksScreen.js
class GardenTasksScreen extends pc.ScriptType {
    static addAttributes() {
        this.attributes.add('templateEntity', { type: 'entity', title: 'Task item template' });
        this.attributes.add('headerTemplateEntity', { type: 'entity', title: 'Header template' });
        this.attributes.add('dividerTemplateEntity', { type: 'entity', title: 'Divider template' });
        this.attributes.add('contentList', { type: 'entity', title: 'Entity to populate with content' });
        this.attributes.add('background', { type: 'entity', title: 'Background entity' });
        this.attributes.add('header', { type: 'entity', title: 'Header entity' });
        this.attributes.add('lucyImageLandscape', { type: 'entity', title: 'LucyImageLandscape' });
        this.attributes.add('lucyImagePortrait', { type: 'entity', title: 'LucyImagePortrait' });
        this.attributes.add('closeButtonReference', { type: 'entity', title: 'Close button' });
        this.attributes.add('contentPadding', { type: 'number', default: 10 });
        this.attributes.add('contentEntity', { type: 'entity' });
        this.attributes.add('scrollview', { type: 'entity' });
        this.attributes.add('scrollbar', { type: 'entity' });
        this.attributes.add('viewport', { type: 'entity' });
    }

    init() {
        GardenTasksScreen.instance = this;
        this.gardenTutorialHand = this.entity.findByTag('tutorial-hand')[0];
        this.gardenTutorialHandImage = this.entity.findByTag('tutorial-hand-image')[0];
        this.buttonPosition = null;
        this.childCounter = 0;

        this.app.on('AreaManager:addTask', this.populate, this);
        // this.app.on('AreaManager:checkedForLast', this.startTweens, this);
        this.app.on('GardenManager:checkStates', this.clear, this);
        this.app.on('GardenTaskScreenTemplate:lastChildDone', this.backgroundOutTween, this);
        this.app.on('GardenTaskScreenTemplate:gotoLevel', this.closeAndGoToLevel, this);
        this.app.on('TutorialHandler:startTutorial', this.handleTutorialState, this);
        this.app.on('GardenTasksScreen:moveToArea', this.moveToArea, this);
        this.canTween = true;
        this.closing = false;
        this.gotoNextLevel = false;
        this.gotoArea = 0;
        this.headerStartPosition = this.header.getLocalPosition().clone();
        this.lucyLandscapeStartPosition = this.lucyImageLandscape.getLocalPosition().clone();

        this.taskHeight = this.contentList.layoutgroup.spacing.y + this.templateEntity.element.height + this.contentEntity.layoutgroup.spacing.y;
        this.areas = [];

        this.setOffset();
    }

    postInitialize() {
        this.app.on('ViewportManager:onResize', this.onResize, this);
        pc.timer.add(0.01, this.onResize, this);
    }

    onResize(orientation = ViewportManager.instance.getOrientation()) {
        this.orientation = orientation;

        if (orientation === orientationEnum.LANDSCAPE) {
            this.contentList.element.height = this.normalHeight;
        } else {
            this.contentList.element.height = this.normalHeight + 98 * 2;
        }

        this.setOffset(orientation);
    }

    setOffset(orientation = ViewportManager.instance.getOrientation()) {
        if (orientation === orientationEnum.LANDSCAPE) {
            this.taskOffset = 30;
            this.scrollviewOffset = 35;
        } else {
            this.taskOffset = 40;
            this.scrollviewOffset = 98 * 2;
        }
    }

    moveToArea(area) {
        this._moveToArea = area;
    }

    startMoveToArea() {
        this.onResize(this.orientation)

        if (typeof this._moveToArea !== 'number') {
            this.scrollview.scrollview._onSetVerticalScrollbarValue(0);
            return;
        }

        const steps = this.areas.length - 1;
        const index = steps - this.areas.indexOf(this._moveToArea);

        var taskHeight = index * (
            this.taskHeight +
            this.dividerTemplateEntity.element.height +
            this.headerTemplateEntity.element.height
        ) - this.taskOffset;

        const ratio = pc.math.clamp(taskHeight / (this.contentList.element.height - this.scrollview.element.height - this.scrollviewOffset), 0, 1);
        this.scrollview.scrollview._onSetVerticalScrollbarValue(ratio);
    }

    handleTutorialState(args) {
        switch (args) {
            case GardenTutorialType.FIRST_TIME_USER_TUTORIAL:
                this.closeButtonReference.element.useInput = false;
                this.app.once('UIManager:showUI', (args) => {
                    this.closeButtonReference.element.useInput = true;
                });
                break;
            case GardenTutorialType.NO_TUTORIAL:
                this.closeButtonReference.element.useInput = true;
                break;
        }
    }
    _onDestroy() {
        this.app.off('AreaManager:addTask', this);
        this.app.off('GardenManager:checkStates', this);
        this.clear();
    }
    _onClick() {
        if (this.closing) return;
        this.childOutTween();
    }

    setScrolling(value) {
        this.scrollview.scrollview.useMouseWheel = value;
        this.scrollbar.enabled = value;
    }

    onUIEntityOpen() {
        this.areas.length = 0;

        this.app.fire('Audio:sfx', 'task_list_open.mp3');
        this.app.fire('GardenInput:setMouseWheel', false);
        this.clear();
        this.childCounter = 0;
        this.app.fire('GardenTaskScreen:populateMe');

        this.startTweens();

        this.startMoveToArea();

        if (TodoCardHandler.instance.notifyElement) {
            TodoCardHandler.instance.notifyElement.enabled = false;
        }
        if (TodoCardHandler.instance.todoCard) {
            TodoCardHandler.instance.todoCard.enabled = false;
        }
        TodoCardHandler.instance._isVisible = false;


        if (GardenTutorialHandler.instance.active) {
            this.scrollview.scrollview._onContentElementLose();
            this.scrollview.scrollview._onSetVerticalScrollbarValue(1);
        } else {
            this.scrollview.scrollview._onContentElementGain();
        }
    }

    onUIEntityClose() {
        this._moveToArea = null;
    }

    closeAndGoToLevel(index) {
        if (this.closing) return;
        this.gotoArea = index;
        this.gotoNextLevel = true;
        this.childOutTween();
    }

    populate(task, areaNumber) {
        // if (Math.random() < 0.8) {
        //     return
        // }
        this.areas.push(areaNumber);
        if (GardenTutorialHandler.instance.active && task.area !== 1) {
            return;
        }

        if (this.childCounter > 0) {
            this.divider = this.dividerTemplateEntity.clone();
            this.divider.enabled = true;
            this.contentList.insertChild(this.divider, 0);
        }

        this.header = this.headerTemplateEntity.clone();
        this.header.enabled = true;
        this.contentList.insertChild(this.header, 0);

        this.header.script.taskScreenHeaderTemplate.populate(task);

        this.template = this.templateEntity.clone();
        this.template.enabled = true;
        this.contentList.insertChild(this.template, 1);

        const gardenTaskScreenTemplate = this.template.script.get('gardenTaskScreenTemplate');
        gardenTaskScreenTemplate.fillTemplate(task);
        gardenTaskScreenTemplate.childIndex = this.childCounter;
        gardenTaskScreenTemplate.setHeader(this.header);

        this.childCounter += 1;
    }

    clear() {
        if (this.contentList.children.length >= 1) {
            for (var i = this.contentList.children.length - 1; i >= 0; i--) {
                if (this.contentList.children[i].script && this.contentList.children[i].script.get("gardenTaskScreenTemplate") && this.contentList.children[i].script.get("gardenTaskScreenTemplate").isclone) {
                    var errorMessageEntity = this.contentList.children[i].script.get("gardenTaskScreenTemplate").errorMessageEntity;
                    if (errorMessageEntity.element.opacity !== 0) {
                        errorMessageEntity.element.opacity = 0;
                        errorMessageEntity.children[0].element.opacity = 0;
                        errorMessageEntity.children[1].element.opacity = 0;
                    }
                    this.contentList.children[i].destroy();
                } else {
                    this.contentList.children[i].destroy();
                }
            }
        }
        this.gotoNextLevel = false;
        this.childCounter = 0;
        this.canTween = true;
        this.closing = false;
    }

    startTweens() {
        this.canTween = false;
        this.childInTween();
        this.closed = false;
    }

    backgroundOutTween() {
        var onTweenComplete = function () {
            this.app.fire('UIManager:hideUI', "Garden Tasks");
            if (this.gotoNextLevel) {
                var areaStars = StorageManager.instance.get("levelData")[1];
                var starsArrayLength = Object.keys(areaStars).length;
                if (starsArrayLength === 0) {
                    LevelManager.instance.startLevel(1, 1);
                } else {
                    this.app.fire('UIManager:showUI', 'Book', { key: 'lowStarLevel', chapterID: this.gotoArea, openLevelPage: true });
                }
                this.clear();

            } else {
                this.app.fire('UIManager:showUI', "Garden");
            }
        };
        var gotoPositions = {
            x: this.headerStartPosition.x,
            y: this.header.getLocalPosition().y + (ViewportManager.instance.height / 2),
            z: this.headerStartPosition.z,
        };
        var bgScrollUp = this.background.tween(this.background.getLocalScale()).to({ x: 1, y: 0, z: 1 }, 0.5, pc.BackIn);
        var headerMoveUp = this.header.tween(this.header.getLocalPosition()).to({ x: gotoPositions.x, y: gotoPositions.y, z: gotoPositions.z }, 0.25, pc.QuadraticIn)
        headerMoveUp.on('complete', onTweenComplete, this);
        bgScrollUp.chain(headerMoveUp);
        bgScrollUp.start();
    }

    getAreaLevel() {
        //calculate total amount of stars for area
        var areaStars = StorageManager.instance.get("levelData")[this.gotoArea];
        var starsArrayLength = Object.keys(areaStars).length;
        var oneStarLevel = null;
        for (var i = 0; i < starsArrayLength; i++) {
            if (areaStars[i + 1].stars < 3) {
                if (areaStars[i + 1].stars === 2) {
                    return i + 1;
                }
                if (areaStars[i + 1].stars === 1 && !oneStarLevel) {
                    oneStarLevel = i + 1;
                }
            }
        }
        return oneStarLevel;
    }

    childInTween() {
        this.contentList.element.height = 0;

        this.normalHeight = 0;

        for (var i = 0; i < this.contentList.children.length; i++) {
            // console.log(this.contentList.children[i].tags._list[0])
            switch (this.contentList.children[i].tags._list[0]) {
                case "task-item":
                    if (this.contentList.children[i].script.get("gardenTaskScreenTemplate")) {
                        var child = this.contentList.children[i].script.get("gardenTaskScreenTemplate");
                        if (child.isclone) {
                            var last = false;
                            if (child.childIndex === 0) {
                                last = true;
                            }

                            // this.contentList.element.height += this.taskHeight
                            child.startupTween(this.childCounter - child.childIndex - 1, last);
                            this.normalHeight += this.taskHeight;
                        }
                    }
                    break;
                case "task-header":
                case "task-divider":
                    this.normalHeight += this.contentList.children[i].element.height;
                    // this.contentList.element.height += this.contentList.children[i].element.height;
                    break;
                default:
                    console.log(this.contentList.children[i])
            }

        }

        this.normalHeight += this.contentPadding;

        this.contentList.element.height += this.normalHeight;
    }

    childOutTween() {
        if (this.contentList.children.length <= 0) {
            this.backgroundOutTween();
            this.closing = true;
        }
        if (this.contentList.children[this.contentList.children.length - 1].script && !this.contentList.children[this.contentList.children.length - 1].script.get("gardenTaskScreenTemplate").started) return;
        this.closing = true;
        for (var i = 0; i < this.contentList.children.length; i++) {
            if (this.contentList.children[i].script && this.contentList.children[i].script.get("gardenTaskScreenTemplate")) {
                var child = this.contentList.children[i].script.get("gardenTaskScreenTemplate");
                if (child.isclone) {
                    var last = false;
                    if (child.childIndex === 0) {
                        last = true;
                    }
                    child.closeTween(this.contentList.children.length - i, last);
                    child.hideErrorMessageTween();
                }
            }
        }
    }
}
pc.registerScript(GardenTasksScreen, 'gardenTasksScreen');
GardenTasksScreen.addAttributes();

// GardenTaskScreenTemplate.js
class GardenTaskScreenTemplate extends pc.ScriptType {
    static addAttributes() {
        //
        this.attributes.add('TweenValues', { type: 'string', default: '-------------------------------------------', title: 'Tween Values' });
        this.attributes.add('speed', { type: 'number', default: 0.2 });
        this.attributes.add('distance', { type: 'number', default: 25 });
        this.attributes.add('repetitions', { type: 'number', default: 3 });

        this.attributes.add('DefaultSettings', { type: 'string', default: '-------------------------------------------', title: 'Default Settings' });
        this.attributes.add('explanationText', { type: 'string', default: 'Fix the tree', title: 'Explanation Text' });
        this.attributes.add('starText', { type: 'string', default: '0/30', title: 'Star Text' });
        this.attributes.add('image', { type: 'asset', assetType: 'sprite', title: 'Task Image' });

        this.attributes.add('EntityReferences', { type: 'string', default: '-------------------------------------------', title: 'Entity References' });
        this.attributes.add('imageReference', { type: 'entity', title: 'Task Image' });
        this.attributes.add('explanationTextReference', { type: 'entity', title: 'Explanation Text' });
        this.attributes.add('starTextReference', { type: 'entity', title: 'Star Text' });
        this.attributes.add('buttonReference', { type: 'entity', title: 'Star button' });
        this.attributes.add('buttonStarImageReference', { type: 'entity', title: 'Button Star Image' });
        this.attributes.add('errorMessageEntity', { type: 'entity', title: 'Error message entity' });
        this.attributes.add('playButtonReference', { type: 'entity', title: 'Play button' });

        this.attributes.add('stepEntity', { type: 'entity', title: 'step' });
        this.attributes.add('starEntity', { type: 'entity', title: 'Star Entity' });
        this.attributes.add('starStartEntity', { type: 'entity', title: 'Star Start Entity' });
        this.attributes.add('starGoalEntity', { type: 'entity', title: 'Star Goal Entity' });
        this.attributes.add('starPaymentDuration', { type: 'number', title: "Star Payment Duration" });
        this.attributes.add('taskScreenScript', { type: 'entity', title: 'Task Screen Script' });
        this.attributes.add('pressedButtonSprite', { type: 'asset', title: 'Pressed button sprite' });
        this.attributes.add('tweenStarContainer', { type: 'entity', title: 'Tween Star Container' });
    }

    initialize() {
        this.entity.setLocalScale(1, 0, 1);
        this.childIndex = 0;
        this.isclone = false;
        this.area = 0;
        this.buttonReference.script.elementInput.on(inputEvents.CLICK, this._onClick, this);
        this.playButtonReference.script.elementInput.on(inputEvents.CLICK, this._onClickPlayButton, this);
        this.objectEntity = null;
        this.task = null;
        this.buttonPosition = this.buttonReference.getLocalPosition().clone();
        this.startupFired = false;
        this.started = false;
        this.jigglePressed = false;
        this.canUpgrade = false;
        this.stepObjects = [];

        this.starObjectPool = TilePrefabManager.instance.getObjectPool('starObjectPool');
    }

    fillTemplate(task) {
        this.worldTask = task.worldTask;

        this.starEntity.parent.enabled = !this.worldTask;

        if (task.starText === "Fix") {
            this.buttonStarImageReference.enabled = false;
        }

        if (task.entity) {
            if (task.currentAreaStars - task.entity.script.objectOptions.objectCostInStars >= 0) {
                this.canUpgrade = true;
            }

        }

        this.taskScreenScript.script.gardenTasksScreen.setScrolling(true);
        this.area = task.area;
        this.isclone = true;
        if (!task.sprite) {
            console.warn("TASKLIST:USING DEFAULT SPRITE||" + "%c broken sprite", "font-weight:bold;", "not defined on object")
        } else {
            var sprite = task.sprite;

            if (sprite.resource.atlas) {
                var imageSize = sprite.resource.atlas.frames[sprite.resource.frameKeys[0]].rect;
                this.imageReference.element.width = imageSize.z;
                this.imageReference.element.height = imageSize.w;
                this.imageReference.element.sprite = sprite.resource;
            } else {
                sprite.ready(() => {
                    var imageSize = sprite.resource.atlas.frames[sprite.resource.frameKeys[0]].rect;
                    this.imageReference.element.width = imageSize.z;
                    this.imageReference.element.height = imageSize.w;
                    this.imageReference.element.sprite = sprite.resource;
                });
            }
        }
        this.explanationTextReference.element.key = task.explanationText;

        this.starTextReference.element.text = task.starText || this.app.i18n.getText('WORLD_TASK_BUTTON');

        this.objectEntity = task.entity;
        this.task = task;
        this.starEntity.script.coloredStar.setStarByWorld(task.area);
        this.addSteps(task);
    }

    addSteps(task) {
        if (task.maxSteps > 1) {
            for (var i = 0; i < task.maxSteps; i++) {
                var bgEntity = this.stepEntity.clone();
                bgEntity.enabled = true;
                this.stepEntity.parent.addChild(bgEntity);
                this.stepObjects.push(bgEntity);
                if (i >= task.step - 1) {
                    bgEntity.children[1].enabled = false;
                }
            }
        }
    }

    _onClick() {
        if (this.clicked) {
            console.warn("alreaady clicked");
            return;
        }

        this.clicked = true;
        if (GardenTutorialHandler.instance.active && this.area !== 1) {
            return;
        }

        GardenFTUTutorialHandler.instance.disable();

        if (this.worldTask) {
            this.app.fire('UIManager:hideAll');
            var worldID = WorldManager.instance.getWorldByLevel(LevelDataManager.instance.getCurrentLevel());

            this.app.fire('UIManager:showUI', 'LoadingScreen');

            LoadingScreen.instance.setType(LoadingScreen.TYPES.ASSETS).once('fadeInComplete', () => {
                AssetManager.instance.loadBookAssets(worldID, () => {
                    this.app.fire('UIManager:hideUI', 'LoadingScreen');

                    this.app.fire('UIManager:showUI', 'Book', { key: 'nextLevel' });
                    this.clicked = false;
                });
            });
        } else if (this.objectEntity.script.get("objectOptions").objectState === ObjectOptions.states.Locked || !this.canUpgrade) {
            // this.errorTweenHandler();
            this.clicked = false;

            this.app.fire('GardenTaskScreenTemplate:click');

            this.openNotEnoughStarsScreen();
            this.app.fire('UIManager:hideUI', "Garden Tasks");
        } else {
            DialogManager.instance.stopDialog('tutorial-garden-tasks');
            GardenTutorialHandler.instance.removeFirstTimeUserTutorialEvents();
            this.app.fire('GardenTaskScreenTemplate:click');

            this.app.fire('UIManager:showUI', 'InputDisabler');

            this.playPaymentAnimation().then(() => {
                this.app.fire('UIManager:hideUI', "Garden Tasks");
                ObjectHandler.instance.selectEntity(this.objectEntity);
                this.clicked = false;
                this.app.fire('UIManager:hideUI', 'InputDisabler');
            });
        }
    }

    playPaymentAnimation() {
        this.app.fire('Audio:sfx', 'task_complete.mp3');
        let amountOfStars = this.objectEntity.script.objectOptions.objectCostInStars;
        let startPosition = this.header.script.taskScreenHeaderTemplate.getStartPosition();
        let goalPosition = this.starGoalEntity.getPosition();
        let count = 0;

        var array = [];

        const cost = this.objectEntity.script.objectOptions.objectCostInStars;

        this.taskScreenScript.script.gardenTasksScreen.setScrolling(false);
        this.buttonReference.element.sprite = this.pressedButtonSprite.resource;

        for (var i = 0; i < cost; i++) {
            const star = this.starObjectPool.use();
            star.enabled = true;
            star.reparent(this.tweenStarContainer);
            const promise = this.starTween(star, startPosition, goalPosition, (cost - i - 1) * (this.starPaymentDuration / cost));
            array.push(promise);
        }

        let steps = this.task.maxSteps;

        return new Promise(resolve => {
            Promise.all(array).then(() => {
                if (steps > 1) this.playStepAnimation().then(resolve);
                else resolve();
            });
        });
    }

    playStepAnimation() {

        let element = this.task.step - 1;

        var imageObject = this.stepObjects[element].findByTag('img')[0];
        imageObject.enabled = true;
        imageObject.setLocalScale(0, 0, 0);

        return new Promise(resolve => {
            var scaleTween = imageObject
                .tween(imageObject.getLocalScale())
                .to(pc.Vec3.ONE,
                    0.4,
                    pc.BackOut,
                    0).start()
                .on('complete', () => {
                    this.taskScreenScript.script.gardenTasksScreen.setScrolling(true);
                    resolve();
                });
        });
    }

    setHeader(header) {
        this.header = header;
    }

    starTween(starObject, startPosition, goalPosition, startDelay) {
        starObject.enabled = true;
        starObject.setLocalScale(0.3, 0.3, 0.3);
        starObject.script.coloredStar.setStarByWorld(this.area);

        var starImg = starObject.findByTag('starImg')[0];
        var starBorder = starObject.findByTag('starBorder')[0];
        starImg.element.opacity = 1;
        starBorder.element.opacity = 1;

        return new Promise(resolve => {
            const position = new pc.Vec3().copy(startPosition);
            starObject.setPosition(position);
            var tween = this.entity
                .tween(position)
                .to(goalPosition, 0.5, pc.ExponentialIn, startDelay)
                .start();

            tween.on('update', () => {
                starObject.setPosition(position);
            }, this);

            tween.on('complete', () => {
                this.jiggleButton();
                this.app.fire('Audio:sfx', 'star_ingame.mp3');
                this.starObjectPool.recycle(starObject);
                resolve();
            });

            if (startDelay > 0) {
                tween.on('delayDone', this.decrementStarCounter, this);
            } else {
                this.decrementStarCounter();
            }

            this.entity
                .tween(starObject.getLocalScale())
                .to(new pc.Vec3(0.1, 0.1, 0.1), 0.5, pc.QuarticIn, startDelay + 0.1)
                .start();
        });
    }

    jiggleButton() {
        let amountOfStars = this.objectEntity.script.objectOptions.objectCostInStars;
        let tweenTime = (this.starPaymentDuration / amountOfStars) / 3;

        if (this.buttonJiggle || this.buttonBounce) {
            this.buttonJiggle.stop();
            this.buttonBounce.stop();
            delete this.buttonJiggle;
            delete this.buttonBounce;
            this.buttonReference.setLocalScale(1, 1, 0);
            this.buttonReference.setLocalPosition(-8, 0, 0);
        }

        this.buttonJiggle = this.buttonReference
            .tween(this.buttonReference.getLocalScale())
            .to(new pc.Vec3(1, 0.85, 0), tweenTime, pc.ExponentialOut, 0)
            .yoyo(true)
            .repeat(2)
            .start();

        this.buttonBounce = this.buttonReference
            .tween(this.buttonReference.getLocalPosition())
            .to(new pc.Vec3(-8, -5, 0), tweenTime / 1.4, pc.ExponentialOut, 0)
            .yoyo(true)
            .repeat(2)
            .start();
    }

    onPaymentFinish() {
        this.app.fire('UIManager:hideUI', "Garden Tasks");
        ObjectHandler.instance.selectEntity(this.objectEntity);
    }

    decrementStarCounter() {
        let textObject = this.header.script.taskScreenHeaderTemplate.getStarText();
        let amount = parseInt(textObject.element.text);

        if (isFinite(amount)) {
            amount = amount - 1;
            textObject.element.text = amount;
        } else return;
    }

    openNotEnoughStarsScreen() {
        var areaStars = Object.values(LevelDataManager.instance._starData)[this.objectEntity.script.objectOptions.world - 1];
        var amountNeeded = this.objectEntity.script.objectOptions.objectCostInStars - (areaStars - GardenManager.instance.getAreaScriptByAreaNumber(this.area).areaSaveValues.starsSpent);
        if (!isFinite(amountNeeded)) {
            amountNeeded = this.objectEntity.script.objectOptions.objectCostInStars;
        }
        LocalizationManager.instance.setText(GardenUIEntity.instance.notEnoughStarsTextEntity, 'NOT_ENOUGH_STARS_DESCRIPTION', [amountNeeded]);

        const data = {
            amount: amountNeeded,
            area: this.objectEntity.script.objectOptions.world,
        }

        this.app.fire('HoldCounter:ObjectLocked', this.objectEntity, data);
    }

    _onClickPlayButton() {
        this.app.fire('GardenTaskScreenTemplate:gotoLevel', this.area);
    }

    startupTween(duration, last) {
        var startUpComplete = function () {
            this.started = true;
            if (last) {
                this.app.fire('GardenTaskScreenTemplate:lastChildStartupDone');
            }
        };
        var tweenEntityScale = this.entity.tween(this.entity.getLocalScale()).to({ x: 1, y: 1, z: 1 }, 0.25, pc.BackOut)
        tweenEntityScale.on('complete', startUpComplete, this);
        var delayTween = this.entity.tween(this.entity.getLocalScale()).to({ x: 1, y: 0, z: 1 }, 0.25 * (duration / 2), pc.BackOut);
        delayTween.chain(tweenEntityScale);
        delayTween.start();
    }

    closeTween(duration, last) {
        var closeComplete = function () {
            if (!last) return;
            this.app.fire('GardenTaskScreenTemplate:lastChildDone');
        };
        var tweenEntityScale = this.entity.tween(this.entity.getLocalScale()).to({ x: 1, y: 0, z: 1 }, 0.2, pc.BackIn)
        tweenEntityScale.on('complete', closeComplete, this);
        var delayTween = this.entity.tween(this.entity.getLocalScale()).to({ x: 1, y: 1, z: 1 }, 0.2 * (duration / 2), pc.BackOut);
        delayTween.chain(tweenEntityScale);
        delayTween.start();
    }

    errorTweenHandler() {
        this.showErrorMessageTween();
        this.jiggleButtonTween();
    }

    showErrorMessageTween() {
        this.errorMessageEntity.enabled = true;
        var opacity = {
            self: this.errorMessageEntity.element.opacity,
            handle: this.errorMessageEntity.children[0].element.opacity,
            text: this.errorMessageEntity.children[1].element.opacity
        };
        var updateOpacity = function () {
            this.errorMessageEntity.element.opacity = opacity.self;
            this.errorMessageEntity.children[0].element.opacity = opacity.handle;
            this.errorMessageEntity.children[1].element.opacity = opacity.text;
        };
        var delayTween = this.entity.tween(opacity).to({ self: 1, handle: 1, text: 1 }, 2.5, pc.BackOut)
        delayTween.on('complete', this.hideErrorMessageTween, this);
        var opacityTweenFadeIn = this.entity.tween(opacity).to({ self: 1, handle: 1, text: 1 }, 1.0, pc.BackOut)
        opacityTweenFadeIn.on('update', updateOpacity, this);
        opacityTweenFadeIn.chain(delayTween);
        if (opacity.self === 0) {
            opacityTweenFadeIn.start();
        }
    }

    hideErrorMessageTween() {
        var opacity = {
            self: this.errorMessageEntity.element.opacity,
            handle: this.errorMessageEntity.children[0].element.opacity,
            text: this.errorMessageEntity.children[1].element.opacity
        };
        var updateOpacity = function () {
            this.errorMessageEntity.element.opacity = opacity.self;
            this.errorMessageEntity.children[0].element.opacity = opacity.handle;
            this.errorMessageEntity.children[1].element.opacity = opacity.text;
        };
        var opacityTweenFadeOut = this.entity.tween(opacity).to({ self: 0, handle: 0, text: 0 }, 1.0, pc.BackOut)
        opacityTweenFadeOut.on('update', updateOpacity, this);
        if (opacity.self > 0) {
            opacityTweenFadeOut.start();
        }
    }

    jiggleButtonTween() {
        if (this.jigglePressed) return;
        this.jigglePressed = true;
        this.buttonIsShaking = true;

        var onMorphComplete = function () {
            this.buttonReference.enabled = false;
            this.playButtonReference.setLocalScale(0, 0, 0);
            this.playButtonReference.enabled = true;
        };
        //Tweens
        var initialGoLeft = this.buttonReference.tween(this.buttonReference.getLocalPosition()).to({ x: this.buttonPosition.x - this.distance, y: 0, z: 0 }, this.speed, pc.BackOut);
        var jiggle = this.buttonReference.tween(this.buttonReference.getLocalPosition()).to({ x: this.buttonPosition.x + this.distance, y: 0, z: 0 }, this.speed * 2, pc.BackOut).yoyo(true).repeat(this.repetitions);
        var returnToInitialPosition = this.buttonReference.tween(this.buttonReference.getLocalPosition()).to({ x: this.buttonPosition.x, y: 0, z: 0 }, this.speed, pc.BackOut);
        var showNewButton = this.playButtonReference.tween(this.playButtonReference.getLocalScale()).to({ x: 1, y: 1, z: 1 }, this.speed * 7.5, pc.BackOut);
        var hideOldButton = this.buttonReference.tween(this.buttonReference.getLocalScale()).to({ x: 0, y: 0, z: 0 }, this.speed * 7.5, pc.BackOut)
        hideOldButton.on('complete', onMorphComplete, this);
        initialGoLeft.chain(jiggle, returnToInitialPosition, hideOldButton, showNewButton);
        initialGoLeft.start();
    }
}
pc.registerScript(GardenTaskScreenTemplate, 'gardenTaskScreenTemplate');
GardenTaskScreenTemplate.addAttributes();


// SpecialFlowerManager.js
class SpecialFlowerManager extends pc.ScriptType {
    static addAttributes() {
        this.attributes.add('flowers', { type: 'entity', array: true });
        this.attributes.add('flowersOffset', { type: 'vec3', array: true });

        this.attributes.add('focusSpeed', { type: 'number', default: 1, title: 'focus speed', description: 'The speed at which a flower gets focussed' });
        this.attributes.add('animationSpeed', { type: 'number', default: 1, title: 'animation speed', description: 'The speed at which a Flower gets animated' });
    }

    initialize() {
        SpecialFlowerManager.instance = this;

        this.amountOfZoomOnFocus = 0;
        this.setFlowers();
        //this.app.on('GardenCamera:CloseToObject', this.animateFlower, this);
        // this.app.on('SceneTransition:done', this.focusCamera, this);
        this.on('destroy', this._onDestroy, this);
    }

    _onDestroy() {
        //this.app.off('GardenCamera:CloseToObject', this.animateFlower);
        // this.app.off('SceneTransition:done', this.focusCamera);
    }

    //check if flower is unlocked
    setFlowers() {
        var args = GardenUIEntity.instance.args;
        var flowerToAnimate = null;
        if (args && args.flowerUnlocked) {
            flowerToAnimate = args.currentChapter;
        }
        var currentLevel = LevelDataManager.instance._levelData.currentLevel;
        var currentWorld = WorldManager.instance.getWorldByLevel(currentLevel);
        if (currentLevel > WorldManager.instance.maxLevel) {
            currentWorld = WorldManager.instance.getWorldByLevel(WorldManager.instance.maxLevel) + 1;
        }
        for (var i = 0; i < this.flowers.length; i++) {
            this.flowers[i].enabled = (currentWorld > i + 1 && i + 1 !== flowerToAnimate);
        }
    }

    focusCamera(chapterID) {
        this.setFlowers();
        this.app.fire('rebatch');

        GardenManager.instance.gardenCamera.focusPosition(this.flowers[chapterID - 1].getPosition().clone().add(this.flowersOffset[chapterID - 1]), this.amountOfZoomOnFocus);
        GardenManager.instance.gardenCamera.waiting = true;
        this.previousFocusSpeed = GardenManager.instance.gardenCamera.focusSpeed;
        GardenManager.instance.gardenCamera.focusSpeed = this.focusSpeed;
    }

    startAnimateFlower(worldID) {
        var specialFlower = this.flowers[worldID - 1];
        specialFlower.setLocalScale(0, 0, 0);
        specialFlower.enabled = true;
    }

    //animate a new flower when unlocked
    animateFlower(worldID) {
        this.app.fire('Audio:sfx', 'add_flower_to_garden.mp3');
        var specialFlower = this.flowers[worldID - 1];

        var up = specialFlower
            .tween(specialFlower.getLocalScale())
            .to({ x: 0.1, y: 2, z: 0.1 }, this.animationSpeed * 0.75, pc.BackOut);
        var spread = specialFlower
            .tween(specialFlower.getLocalScale())
            .to({ x: 1, y: 1, z: 1 }, this.animationSpeed * 0.25, pc.BackOut)
        spread.on('complete', this.onFlowerAnimationComplete, this);
        up.chain(spread);
        up.start();
    }

    onFlowerAnimationComplete() {
        this.fire('complete');
        // GardenManager.instance.gardenCamera.blockCamera = false;
        GardenManager.instance.gardenCamera.focusSpeed = this.previousFocusSpeed;
    }
}
pc.registerScript(SpecialFlowerManager, 'specialFlowerManager');
SpecialFlowerManager.addAttributes();

// todoCardHandler.js
class TodoCardHandler extends pc.ScriptType {
    static addAttributes() {
        // this.attributes.add('attribute1', {type: 'entity'});
        this.attributes.add('todoTarget', { type: 'entity' });
    }
    initialize() {
        TodoCardHandler.instance = this;
        this.notifyElement = GardenUIEntity.instance.taskButton.findByTag("notification")[0];
        this.todoCard = this.entity.findByTag('todocard')[0];
        this.app.on('ObjectHandler:showNewToDo', this.showNewToDo, this);

        this.initialToDoCard = {
            localPosition: this.todoCard.getLocalPosition().clone(),
            scale: this.todoCard.getLocalScale().clone()
        };

        this.todoCardValues = {
            image: this.entity.findByTag(['todo', 'objectSprite'])[0],
            description: this.entity.findByTag(['todo', 'descriptionText'])[0],
            starAmount: this.entity.findByTag(['todo', 'starsText'])[0],
            star: this.entity.findByTag(['todo', 'starEntity'])[0]
        };

        // this.setTodoValues();

        this._isVisible = false;
        this._elementEntities = [];
        this._currentTweens = [];

        this._xySettings = new pc.Vec2(1, 0);

        this._onResize(ViewportManager.instance.getOrientation(), ViewportManager.instance.width, ViewportManager.instance.height, ViewportManager.instance.getDevice());
        this.app.on('ViewportManager:onResize', this._onResize, this);
    }

    setTodoValues(description = "Fix the tree stump", starAmount = "999", image = this.todoCardValues.image.element.spriteAsset, area = 1) {
        this.todoCardValues.description.element.key = description;
        this.todoCardValues.starAmount.element.text = starAmount;
        this.todoCardValues.star.enabled = !!starAmount;
        this.todoCardValues.starAmount.enabled = !!starAmount;

        this.todoCardValues.star.script.coloredStar.setStarBasedOnWorldIndex(area);

        this.todoCardValues.image.element.spriteAsset = image;
        var imageSize = image.resource.atlas.frames[image.resource.frameKeys[0]].rect;
        this.todoCardValues.image.element.width = imageSize.z;
        this.todoCardValues.image.element.height = imageSize.w;
    }

    showNewToDo() {
        if (!this.entity.enabled) {
            this.once('enable', this.showNewToDo, this);
            return;
        }

        this.app.fire('Audio:sfx', 'new_task.mp3');

        this._isVisible = true;

        this.todoCard.enabled = true;
        this.notifyElement.enabled = true;
        this.notifyElement.script.tweenScale.enabled = false;
        // this.todoCard.setLocalPosition(this.initialToDoCard.localPosition);
        this.todoCard.setLocalScale(this.initialToDoCard.scale);

        this.todoCard.children.forEach((element) => {
            this.setChildOpacity(element, 1);
        });

        this.todoOpenAnimation();
    }

    todoOpenAnimation() {
        this._isVisible = true;

        //SLIDE
        this.todoCard.setLocalPosition(this.initialToDoCard.localPosition.x + this.moveDirection.x * this.moveDistance, this.initialToDoCard.localPosition.y + this.moveDirection.y * this.moveDistance, this.initialToDoCard.localPosition.z);
        this.notifyElement.setLocalScale(0, 0, 0);

        var slideInAnimation = this.todoCard
            .tween(this.todoCard.getLocalPosition())
            .to({ x: this.initialToDoCard.localPosition.x, y: this.initialToDoCard.localPosition.y, z: this.initialToDoCard.localPosition.z }, 0.3, pc.SineOut);

        //WAIT
        var waitAnim = this.todoCard
            .tween(this.todoCard.getLocalPosition())
            .to({ x: this.initialToDoCard.localPosition.x, y: this.initialToDoCard.localPosition.y, z: this.initialToDoCard.localPosition.z }, 1, pc.SineOut);

        //SCALE DOWN
        var scaleDown1 = this.todoCard.tween(this.todoCard.getLocalScale()).to({ x: 0.5, y: 0.5, z: 0.5 }, 0.3, pc.BackOut);

        //MOVE TO BUTTON
        var start = this._entityGlobalPosition;
        var dest = this.todoTarget.getPosition();

        var tweenPosition = {
            x: start.x,
            y: start.y
        };

        var moveToTaskButtonAnim = this.todoCard.tween(tweenPosition)
            .to({ x: dest.x, y: dest.y, }, 0.5, pc.BackIn);
        moveToTaskButtonAnim.on('update', () => {
            this.todoCard.setPosition(tweenPosition.x, tweenPosition.y, this.todoCard.getPosition().z);
        });

        //SCALE DOWN
        var scaleDown2 = this.todoCard.tween(this.todoCard.getLocalScale()).to({ x: 0, y: 0, z: 0 }, 0.2, pc.SineOut).delay(0.3);

        //FADE OUT
        var value = { opacity: 1 };

        var opacity = this.entity.tween(value)
            .to({ opacity: 0 }, 0.3, pc.SineOut)
        opacity.on('update', () => {
            this.todoCard.children.forEach((element) => {
                this.setChildOpacity(element, value.opacity);
            });
        });

        //SET ON COMPLETE VALUES
        waitAnim.once('complete', () => {
            // opacity.start();
            this.taskButtonAnimation();
            // this._currentTweens.push(opacity);
        });

        moveToTaskButtonAnim.once('complete', () => {
            this._currentTweens.length = 0;
            this.notificationPopUpAnimation();
        });

        //START ANIMATIONS
        slideInAnimation.chain(waitAnim,/*scaleDown1,*/[moveToTaskButtonAnim, scaleDown2]);
        slideInAnimation.start();

        this._currentTweens.push(slideInAnimation);
        this._currentTweens.push(waitAnim);
        this._currentTweens.push(moveToTaskButtonAnim);
        this._currentTweens.push(scaleDown2);
    }

    setChildOpacity(entity, opacity) {
        if (entity && entity.element) {
            entity.element.opacity = opacity;
            if (entity.tags.has("title")) {
                entity.element.outlineThickness = opacity;
            }
        }
        if (entity.children.length !== 0) {
            entity.children.forEach((element) => {
                this.setChildOpacity(element, opacity);
            });
        } else {
            return;
        }
    }

    notificationPopUpAnimation() {
        var popUp = this.notifyElement.tween(this.notifyElement.getLocalScale()).to({ x: 1, y: 1, z: 1 }, 0.3, pc.BackOut);
        popUp.start();
        this._currentTweens.push(popUp);

        popUp.once('complete', () => {
            this._currentTweens.length = 0;
            this.notifyElement.script.tweenScale.enabled = true;
        });
    }

    taskButtonAnimation() {
        // var squash    = GardenUIEntity.instance.taskButton.tween(GardenUIEntity.instance.taskButton.getLocalScale()).to({x:0.8,y:1.2,z:1},  0.1,pc.SineInOut);
        var initialScale = GardenUIEntity.instance.taskButton.getLocalScale().clone();
        var wait = GardenUIEntity.instance.taskButton.tween(GardenUIEntity.instance.taskButton.getLocalScale()).to({ x: initialScale.x, y: initialScale.y, z: 1 }, 0.5, pc.Linear);
        var stretch = GardenUIEntity.instance.taskButton.tween(GardenUIEntity.instance.taskButton.getLocalScale()).to({ x: initialScale.x * 1.2, y: initialScale.y * 0.8, z: 1 }, 0.1, pc.BackOut);
        var backToOne = GardenUIEntity.instance.taskButton.tween(GardenUIEntity.instance.taskButton.getLocalScale()).to({ x: initialScale.x, y: initialScale.y, z: 1 }, 0.2, pc.BackOut);

        wait.chain(stretch, backToOne);
        wait.start();

        this._currentTweens.push(wait);
        this._currentTweens.push(stretch);
        this._currentTweens.push(backToOne);
    }

    _onResize(orientation, width, height, device) {
        this.todoCard.setLocalPosition(this.initialToDoCard.localPosition)

        this._entityGlobalPosition = this.todoCard.getPosition().clone();
        this.calculateOutOfScreenVector();

        var yScale = UIManager.instance.getReferenceResolution().y / ViewportManager.instance.height;
        this.moveDistance = width * yScale / 2;
        this.stopAllTweens();
    }

    calculateOutOfScreenVector() {
        var screenCenter = pc.Vec2.ZERO;
        var entityPosition = this.todoCard.getPosition();
        var centerToPositionDifference = new pc.Vec2(entityPosition.x, entityPosition.y).sub(screenCenter);
        var direction = centerToPositionDifference.mul(this._xySettings).normalize();

        this.moveDirection = direction;
    }

    stopAllTweens() {
        for (let i = 0; i < this._currentTweens.length; i++) {
            this._currentTweens[i].stop();
        }

        this.todoCard.setLocalPosition(this.initialToDoCard.localPosition.x, this.initialToDoCard.localPosition.y, this.initialToDoCard.localPosition.z);
        this.todoCard.enabled = false;
        this.notifyElement.setLocalScale(1, 1, 1);
        this.notifyElement.enabled = this._isVisible;

        this._currentTweens.length = 0;

        if (this._currentPromiseResolve) this._currentPromiseResolve();
    }
}

pc.registerScript(TodoCardHandler, 'todoCardHandler');
TodoCardHandler.addAttributes();

// TaskScreenHeaderTemplate.js
class TaskScreenHeaderTemplate extends pc.ScriptType {
    static addAttributes() {
        this.attributes.add('titleEntity', { type: 'entity' });
        this.attributes.add('starsGroup', { type: 'entity' });
        this.attributes.add('progressBarBg', { type: 'entity' });
        this.attributes.add('starEntity', { type: 'entity' });
    }
    initialize() {
        this.starImage = this.starsGroup.findByTag("task-header-stars-image")[0];
        this.starAmountText = this.starsGroup.findByTag("task-header-stars-text")[0];

        this.progressBarEntity = this.progressBarBg.findByTag("task-header-progress-bar")[0];
        this.progressBarText = this.progressBarBg.findByTag("task-header-progress-text")[0];
        this.on('destroy', this._onDestroy, this);
    }

    postInitialize() {
        this.app.on('ViewportManager:onResize', this._onResize, this);
    }

    _onDestroy() {
        this.app.off('ViewportManager:onResize', this._onResize, this);
    }
    _onResize() {
        // console.log('resize header')
        this.setProgress();
    }
    setTitle(areaNumber) {
        this.titleEntity.element.key = `GARDEN_TASK_TITLE_AREA_${areaNumber}`;
    }
    setStars(area, amount) {
        this.starImage.script.coloredStar.setStarBasedOnWorldIndex(area);
        this.starAmountText.element.text = `${amount}`;
        this.starAmountText.element.color = this.starImage.script.coloredStar.getBorderColor();
    }
    populate(task) {
        var areaScript = GardenManager.instance.getAreaScriptByAreaNumber(task.area);
        var areaProgress = areaScript.getUnlockProgress();
        var currentStars = task.currentAreaStars;
        if (currentStars === undefined || currentStars === null) {
            currentStars = 0;
        }
        this.setTitle(task.area);
        this.setStars(task.area, currentStars);

        this.currentStep = areaProgress.amountUnlocked;
        this.maxSteps = areaProgress.maxUnlockables;
        this.setProgress();
    }
    setProgress() {
        var singleStepPercent = 100 / this.maxSteps;
        var currentPercent = Math.round(singleStepPercent * this.currentStep);
        this.progressBarText.element.text = `${currentPercent}%`;
        this.progressBarEntity.element.width = (this.progressBarBg.element.width * (currentPercent / 100));
    }

    getStartPosition() {
        return this.starEntity.getPosition();
    }

    getStarText() {
        return this.starAmountText;
    }
}
pc.registerScript(TaskScreenHeaderTemplate, 'taskScreenHeaderTemplate');
TaskScreenHeaderTemplate.addAttributes();

// PageDissolveShader.js
class PageDissolveShader extends pc.ScriptType {
    static addAttributes(){
        this.attributes.add('fragmentShader', {type: 'asset',assetType: 'shader'});
        this.attributes.add('vertexShader', {type: 'asset',assetType: 'shader'});
        this.attributes.add('uDiffuseMap', {type: 'asset' });
        this.attributes.add('uDissolveMap', {type: 'asset', assetType: 'texture'});

        this.attributes.add('uDiffuseRotation', {type: 'number', default: 1,step: 0.01,min:0,max:100});
        this.attributes.add('uAlphaCutoff', {type: 'number', default: 1,min: 0.01,max: 1});
        this.attributes.add('uAlphaThickness', {type: 'number', step: 0.001, default: 0.02,min: 0,max: 0.4});
        this.attributes.add('uSteps', {type: 'number', default: 1,precision: 0,min:1,max:10});
        this.attributes.add('uEdgeColor', { type: 'rgba' });

        this.attributes.add('uWaveSpeed', {type: 'vec2', default: [1.0,1.0]});
        this.attributes.add('uWaveAmount', {type: 'vec2', default: [40,40]});
        this.attributes.add('uWaveStrength', {type: 'vec2', default: [0.01,0.01]});
        
        this.attributes.add('edgeColors', { type: 'rgba', array: true });
    }
    initialize(){
        this.time = 0;
        this.shaders = [];
        
        this.on('destroy', this.onDestroy, this);
    }
    
    onDestroy() {
        if (this.material) {
            this.material.destroy();
            delete this.material;
        }
        
        this.shaders.forEach(s => s.destroy());
        
        this.shaders.length = 0;
    }
    
    setDissolveMap() {
        this.uDissolveMap = this.uDissolveMap;
    }

    setDiffuseMap(asset) {
        this.uDiffuseMap = this.app.assets.get(asset.data.textureAtlasAsset);
        
        this.setDissolveMap();
        
        if (!this.material) {
            if (this.entity.element) {
                this.entity.element.material = this.CreateWaterMaterial();
            } else if (this.entity.model) {
                this.entity.model.meshInstances[0].material = this.CreateWaterMaterial();
            }
        } else {
           if (this.entity.element) {
                this.entity.element.material = this.material;
            } else if (this.entity.model) {
                this.entity.model.meshInstances[0].material = this.material;
            } 
            
        }
    }

    updateAlpha(uAlphaCutoff, dt) {
        this.time += dt;

        this.uAlphaCutoff = uAlphaCutoff;

        this.material.setParameter('uAlphaCutoff',this.uAlphaCutoff);

        this.material.setParameter('uTime',this.time);
    }

    setShaderAttributes(){
        //loop through all attributes of a shader to update them when changed.
        for (const [key, value] of Object.entries(this.__attributes)) {
            switch(typeof value){
                case 'number': {
                    this.material.setParameter(key, value); //Set shader parameter
                    this.on('attr:' + key, function (value, prev) {
                        this.material.setParameter(key, value); //Set shader parameter
                    });
                    break;
                }
                case 'object': {
                    // loop through different attribute types.
                    switch(value.type){
                        case 'shader':{
                            this.material.shader = this.createShader();// Apply shader to new material 
                                                    
                            this.on('attr:' + key, function (value, prev) {
                                this.material.shader = this.createShader();// Apply shader to new material 
                            });
                            break;
                        }
                        case 'textureatlas': {
                            this.material.setParameter(key, this[key].resource.texture);

                            this.on('attr:' + key, function (value, prev) {
                                this.material.setParameter(key, this[key].resource.texture);
                            });
                            break;
                        }
                        case 'texture':{
                            this.material.setParameter(key, this[key].resource);

                            this.on('attr:' + key, function (value, prev) {
                                this.material.setParameter(key, this[key].resource);
                            });
                            break;
                        }
                        default:{
                            this.material.setParameter(key, value.data);
                            this.on('attr:' + key, function (value, prev) {
                                this.material.setParameter(key, value.data);
                            });
                            break;
                        }
                    } 
                    break;
                }
                default:{
                    console.warn("could not update",key,"with current datatype",typeof value);
                }
            }
        }
    }

    CreateWaterMaterial(){
        var material = new pc.Material();// new material 
        material.name = "blurMaterial";// material name
        this.material = material; // Save a reference to this material
        this.material.blendType = pc.BLEND_NORMAL;
        this.setShaderAttributes();

        return material;
    }

    createShader(){
        //vertex shader
        var vertexShader = this.vertexShader.resource;
        //fragment shader
        // set float precision depending on device.
        var fragmentShader = `precision ${this.app.graphicsDevice.precision} float;\n` + this.fragmentShader.resource;
        // Create shader definition 
        // A shader definition used to create a new shader.
        var shaderDefinition = {
            attributes: {           
                aPosition: pc.gfx.SEMANTIC_POSITION,
                aUv0: pc.gfx.SEMANTIC_TEXCOORD0,
            },
            vshader: vertexShader,
            fshader: fragmentShader
        };
        // Create the shader from the definition 
        var shader = new pc.Shader(this.app.graphicsDevice, shaderDefinition);
        
        this.shaders.push(shader);
        
        return shader;
    }

    start() {
        this.time = 0;
    }
    
    setWorldIndex(worldIndex) {
        const color = this.edgeColors[worldIndex - 1];
        
        this.uEdgeColor = color;
    }
}
pc.registerScript(PageDissolveShader, 'pageDissolveShader');


PageDissolveShader.addAttributes();

// GardenUIEntity.js
class GardenUIEntity extends pc.ScriptType {
    static addAttributes() {
        this.attributes.add('bookButton', { type: 'entity' });
        this.attributes.add('shopButton', { type: 'entity' });
        this.attributes.add('taskButton', { type: 'entity' });
        this.attributes.add('notEnoughStarsTextEntity', { type: 'entity' });
        this.attributes.add('notEnoughStarsCloseButtonReference', { type: 'entity' });
        this.attributes.add('holdObject', { type: 'entity' });
        this.attributes.add('todoCardEntity', { type: 'entity' });
        this.attributes.add('holdCounter', { type: 'entity' });
        this.attributes.add('arrowTutorials', { type: 'entity', array: true });
        this.attributes.add('coinInterface', { type: 'entity' });
        this.attributes.add('settingsButton', { type: 'entity' });
        this.attributes.add('floatingUI', { type: 'entity' });
    }

    init() {
        GardenUIEntity.instance = this;

        this.entity.script.objectHandler.init();

        this.app.on('TutorialHandler:startTutorial', this.handleTutorialState, this);
        this.app.on('FinalImageScreen:closed', this.animationBookButton, this);
        this.notifyElement = this.taskButton.findByTag("notification")[0];
        this.objectValuesPerArea = {};

        this.args = null;

        this.loadedFirstTime = false;

        this.holdCounter.script.holdCounter.init();
        // this.entity.script.todoCardHandler.init();
    }

    handleTutorialState(args) {
        switch (args) {
            case GardenTutorialType.FIRST_TIME_USER_TUTORIAL:
                this.notEnoughStarsCloseButtonReference.element.useInput = false;
                this.setHideUIListenerFirstTimeUser();
                break;
            case GardenTutorialType.NO_TUTORIAL:
                this.notEnoughStarsCloseButtonReference.element.useInput = true;
                break;
        }
    }
    setHideUIListenerFirstTimeUser() {
        this.app.once('NotEnoughStarsGetStarsButton:getStars', this.onHideNotEnoughStars, this);
    }

    onHideNotEnoughStars() {

        // DialogManager.instance.hideDialog();
        DialogManager.instance.nextDialog();

        this.notEnoughStarsCloseButtonReference.element.useInput = true;

    }

    onUIEntityOpen(args) {
        this.args = args;
        this.app.fire("Audio:bgm", "main_ost.mp3");
        this.app.fire('GardenInput:setMouseWheel', true);

        const task = this.getNextTask();

        let taskAvailable = false;

        if (task) {
            if (!this.task) {
                taskAvailable = true;
            } else {
                taskAvailable = task.nextUnlockableEntity !== this.task.nextUnlockableEntity;
            }
        }

        this.task = task;

        this.notifyElement.enabled = taskAvailable;
        this.notifyElement.script.tweenScale.enabled = taskAvailable;

        if (!taskAvailable && task) {
            this.animationBookButtonFocus(1.2, 1.5, 0.25, 6);
        }

        this.app.on('UIManager:showUI', this.onShowUI, this);

        this.floatingUI.enabled = !GardenDataManager.instance.firstTimeGarden();
    }

    onShowUI(name) {
        if (name === 'Shop') {
            this.shopEnabled = true;
            this.app.fire('UIManager:hideUI', 'Garden');
            this.app.off('UIManager:showUI', this.onShowUI, this);

            if (!this.noMoreLivesUIEnabled) {
                UIManager.instance.getScreen(Xsolla.instance.active || window.famobi.hasFeature('rewarded') ? 'Shop' : 'Daily Coins').script.uiEntity.once('closing', this.hideCoins, this);
            }
            UIManager.instance.getScreen(Xsolla.instance.active || window.famobi.hasFeature('rewarded') ? 'Shop' : 'Daily Coins').script.uiEntity.once('closed', this.onShopClosed, this);
        }


        if (name === 'NoMoreLivesScreen') {
            this.noMoreLivesUIEnabled = true;
            this.app.fire('UIManager:hideUI', 'Garden');
            this.app.off('UIManager:showUI', this.onShowUI, this);
            UIManager.instance.getScreen('NoMoreLivesScreen').script.uiEntity.once('closing', this.hideCoins, this);
            UIManager.instance.getScreen('NoMoreLivesScreen').script.uiEntity.once('closed', this.onNoMoreLivesClosed, this);
        }
    }

    hideCoins() {
        this.app.fire('UIManager:hideUI', 'FloatingUI');
    }

    onNoMoreLivesClosed() {
        this.app.fire('UIManager:showUI', 'Garden');
        this.noMoreLivesUIEnabled = false;
    }

    onShopClosed() {
        if (!this.noMoreLivesUIEnabled && Application.currentScene === 'Garden') {
            this.app.fire('UIManager:showUI', 'Garden');
        }

        this.shopEnabled = false;
    }

    onUIEntityOpenFinish(args) {
        this.fire('openFinish');
        this.app.fire('GardenManager:light');
    }

    onUIEntityClose() {
        if (this.bookButtonTween) {
            this.bookButtonTween.stop();
            delete this.bookButtonTween;
        }
        this.app.off('UIManager:showUI', this.onShowUI, this);
    }

    postInitialize() {

    }

    update() {

    }
    getLastUnlock(areaScript) {
        if (areaScript.regionState === AreaManager.states.Locked) return { found: false };
        var obj = {
            found: false,
            nextUnlockableEntity: null,
            currentAreaStars: Object.values(LevelDataManager.instance._starData)[areaScript.areaNumber - 1],
            starsToUnlock: 0
        };

        var previousDistanceToUnlock = 0;
        var lowestUnlockable = 0;
        var closestEntity = -1;

        for (var i = 0; i < areaScript.areaEntities.length; i++) {
            const script = areaScript.areaEntities[i].script && areaScript.areaEntities[i].script.has("objectOptions") ? areaScript.areaEntities[i].script.get("objectOptions") : null;
            if (script && script.getCurrentIndex() === 3) {
                obj.found = true;
                obj.nextUnlockableEntity = areaScript.areaEntities[i];
                obj.starsToUnlock = script.objectCostInStars;
                obj.step = script.step;
                obj.group = script.group;

                break;
            }
        }

        if (!obj.found && WorldManager.instance.isInWorld(areaScript.areaNumber)) {
            obj.found = true;
            obj.starsToUnlock = 0;
            obj.step = 1;
            obj.worldTask = true;
            obj.data = areaScript.worldTaskData;
        }

        return obj;
    }

    getNextTask() {
        const areas = GardenManager.instance.areas;

        for (var i = 0; i < areas.length; i++) {
            const area = areas[i].script.areaManager;

            const task = this.getLastUnlock(area);

            if (task && task.found && !task.worldTask) {
                return task;
            }
        }

        return null;
    }

    animationBookButton() {
        const scale = this.bookButton.getLocalScale().clone().mulScalar(0.5);
        this.bookButtonTween = this.bookButton
            .tween(this.bookButton.getLocalScale())
            .to(scale, 0.1, pc.SinusInOut)
            .yoyo(true)
            .repeat(2)
            .start();
    }

    animationBookButtonFocus() {
        const scale = this.bookButton.getLocalScale().clone().mulScalar(1.1);

        this.bookButtonTween = this.bookButton
            .tween(this.bookButton.getLocalScale())
            .to(scale, 0.15, pc.SinusInOut, 2.5)
            .yoyo(true)
            .repeat(4)
            .start();
        this.bookButtonTween.on('complete', this.animationBookButtonFocus, this);
    }
}
pc.registerScript(GardenUIEntity, 'gardenUIEntity');
GardenUIEntity.addAttributes();

// GardenTutorialHandler.js
var GardenTutorialType = Object.freeze({ NO_TUTORIAL: 0, FIRST_TIME_USER_TUTORIAL: 1 });

class GardenTutorialHandler extends pc.ScriptType {
    static addAttributes() {
        // this.attributes.add('attribute1', {type: 'entity'});
    }
    initialize() {
        GardenTutorialHandler.instance = this;
        this.enableHand(false);
        this.tutorialIndex = 0;
        // this.handStartPosition = GardenUIEntity.instance.tutorialHandGarden.getPosition().clone();
        this.targetPosition = new pc.Vec3();
        this.pressTweens = [];
        this.app.on('Placeholder:onStartup', () => {
            this.tutorialIndex = 1;
        });
        this.app.on('GardenFTUTutorialHandler:start', () => {
            this.tutorialSetup();
            this.startTutorialTween();
        });

        this.step = 0;

        this.on('destroy', this.onDestroy, this);
    }

    onDestroy() {
        this.app.off('ViewportManager:onResize', this.onResize, this);
    }

    onResize() {
        pc.timer.add(0.01, () => {
            switch (this.step) {
                case 1:
                    this.setHandTargetPosition(GardenUIEntity.instance.taskButton.getPosition());
                    break;
                case 2:
                    this.setHandTargetPosition(GardenTasksScreen.instance.entity.findByTag('star-button')[1].getPosition());
                    break;
                case 3:
                    this.setHandTargetPosition(this.args.getPosition());
                    break;
            }
            this.stopTween();
            this.setHandPosition(this.targetPosition.x, this.targetPosition.y);
            this.playPressAnimation();
        }, this);
    }

    tutorialSetup() {
        this.active = true;
        switch (this.tutorialIndex) {
            case GardenTutorialType.FIRST_TIME_USER_TUTORIAL:
                this.app.on('ViewportManager:onResize', this.onResize, this);

                this.step = 1;
                // this.setHandTargetPosition(GardenUIEntity.instance.taskButton.getPosition());
                // var startPos = new pc.Vec3(GardenUIEntity.instance.taskButton.getPosition().x + 0.3, GardenUIEntity.instance.taskButton.getPosition().y + 0.3, GardenUIEntity.instance.taskButton.getPosition().z);
                // this.setHandStartPosition(startPos);
                break;
            case GardenTutorialType.NO_TUTORIAL:
                break;
        }
    }

    startTutorialTween() {
        console.log("THE INDEX", this.tutorialIndex)
        switch (this.tutorialIndex) {
            case GardenTutorialType.FIRST_TIME_USER_TUTORIAL:
                DialogManager.instance.showDialog("tutorial-garden-tasks", null, this, dialogTypes.GARDENTUTORIAL, false);
                this.app.fire('TutorialHandler:startTutorial', this.tutorialIndex);
                this.enableHand(true);
                // var FTUtween = this.getHandToTargetPositionTween(1);
                // FTUtween.start();
                GardenTasksScreen.instance.setScrolling(false);

                GardenUIEntity.instance.taskButton.script.switchUibutton.once('click', () => {
                    DialogManager.instance.skipDialog();
                    this.app.once('GardenTaskScreenTemplate:click', DialogManager.instance.skipDialog, DialogManager.instance);
                    pc.timer.add(0.1, () => { DialogManager.instance.showDialog("tutorial-garden-tasks-2", null, this, dialogTypes.GARDENTUTORIAL_TASKSCREEN, false); });
                });

                this.stopPressAnimation();
                this.app.once('GardenTaskScreenTemplate:lastChildStartupDone', () => {
                    this.step = 2;

                    const starButtons = GardenTasksScreen.instance.entity.findByTag('star-button');
                    const lastStarButton = starButtons[starButtons.length - 1];
                    // this.setHandTargetPosition(lastStarButton.getPosition());
                    // var tweenToButton = this.getHandToTargetPositionTween(1);
                    // tweenToButton.start();

                    this.stopPressAnimation();
                    // DialogManager.instance.nextDialog();
                    this.app.once('UIManager:showUI', (args) => {
                        this.app.fire('GardenTutorialHandler:setGetStarsButtonPosition');
                    });
                    this.app.once('NotEnoughStarsGetStarsButton:sendSelf', this.onNotEnoughStars, this);
                });
                this.tutorialIndex = 0;

                break;
            case GardenTutorialType.NO_TUTORIAL:
                break;
        }
    }

    onNotEnoughStars(args) {
        this.args = args;
        pc.timer.add(0.1, () => {
            this.setHandTargetPosition(args.getPosition());
            // var tweenTogetStarButton = this.getHandToTargetPositionTween(1);
            // tweenTogetStarButton.start();
            this.step = 3;
            this.stopPressAnimation();
            DialogManager.instance.nextDialog();
        }, this);
    }

    removeFirstTimeUserTutorialEvents() {
        this.active = false;
        this.tutorialIndex = 0;
        this.enableHand(false);
        this.app.off('NotEnoughStarsGetStarsButton:sendSelf', this.onNotEnoughStars, this);
        this.app.off('ViewportManager:onResize', this.onResize, this);
        GardenTasksScreen.instance.setScrolling(true);
        GardenManager.instance.enableGardenInput(true);
        GardenCamera.instance.disableBlockedCamera();
        WorldUnlockManager.instance.disable();
    }

    setHandTargetPosition(position) {
        this.targetPosition.copy(position);
    }
    setHandStartPosition(position) {
        this.setHandPosition(position.x, position.y);
    }
    getHandToTargetPositionTween(tweenDuration) {
        return;
        this.stopTween();

        var start = GardenUIEntity.instance.tutorialHandGarden.getPosition();
        var dest = this.targetPosition;

        var tweenPosition = {
            x: start.x,
            y: start.y
        };


        var moveToTargetAnim = this.entity.tween(tweenPosition)
            .to({ x: dest.x, y: dest.y }, tweenDuration, pc.Linear);

        moveToTargetAnim.on('update', () => {
            // console.log(tweenPosition)
            this.setHandPosition(tweenPosition.x, tweenPosition.y);
        });

        this.moveToTargetAnim = moveToTargetAnim;

        moveToTargetAnim.on('complete', () => {
            this.playPressAnimation();
        });
        return moveToTargetAnim;
    }

    stopTween() {
        if (this.moveToTargetAnim) {
            this.moveToTargetAnim.stop();
            delete this.moveToTargetAnim;
        }
    }

    enableHand(value) {
        //         GardenUIEntity.instance.tutorialHandGarden.enabled = value;
        //         GardenUIEntity.instance.tutorialHandNotEnoughStars.enabled = value;
        //         GardenUIEntity.instance.tutorialHandTaskscreen.enabled = value;
        GardenUIEntity.instance.arrowTutorials.forEach(entity => entity.enabled = value);
    }
    setHandPosition(positionX, positionY) {
        //         GardenUIEntity.instance.tutorialHandGarden.setPosition(positionX, positionY, 1);
        //         GardenUIEntity.instance.tutorialHandNotEnoughStars.setPosition(positionX, positionY, 1);
        //         GardenUIEntity.instance.tutorialHandTaskscreen.setPosition(positionX, positionY, 1);

        //         // This is somehow required, or else it wont update.
        //         GardenUIEntity.instance.tutorialHandGarden.getPosition();
        //         GardenUIEntity.instance.tutorialHandNotEnoughStars.getPosition();
        //         GardenUIEntity.instance.tutorialHandTaskscreen.getPosition();
    }
    playPressAnimation() {
        this.setChildRotationTweenScript(true);
    }
    stopPressAnimation() {
        this.setChildRotationTweenScript(false);
    }
    setChildRotationTweenScript(value) {
        // GardenUIEntity.instance.tutorialHandGarden.children[0].script.tweenRotation.enabled = value;
        // GardenUIEntity.instance.tutorialHandNotEnoughStars.children[0].script.tweenRotation.enabled = value;
        // GardenUIEntity.instance.tutorialHandTaskscreen.children[0].script.tweenRotation.enabled = value;
    }
    postInitialize() {
    }
    update(dt) {
    }
    postUpdate(dt) {
    }
}
pc.registerScript(GardenTutorialHandler, 'gardenTutorialHandler');
GardenTutorialHandler.addAttributes();

// TweenPositionAdvanced.js
var TweenPositionAdvanced = pc.createScript('tweenPositionAdvanced');

TweenPositionAdvanced.attributes.add('initFrom',        { type: 'vec3', default: [0, 0, 0], title: 'From' });
TweenPositionAdvanced.attributes.add('initTo',          { type: 'vec3', default: [0, 0, 0], title: 'To' });
TweenPositionAdvanced.attributes.add('playStyle', {
    type: 'number',
    enum: [
        { 'Once': 0 },
        { 'Loop': 1 },
        { 'PingPong': 2 }
    ],
    title: 'Play Style'
});

TweenPositionAdvanced.attributes.add('duration',        { type: 'number', default: 1, title: 'duration' });
TweenPositionAdvanced.attributes.add('curve',           { type: 'curve', curves: ['x','y','z'], title: 'Animation Curve' });
TweenPositionAdvanced.attributes.add('ignoreTimeScale', { type: 'boolean', default: true, title: 'Ignore Time Scale' });
TweenPositionAdvanced.attributes.add('startDelay',      { type: 'number', default: 0, title: 'Start Delay' });
TweenPositionAdvanced.attributes.add('debug',           { type: 'boolean', default: false, title: 'Show Debug' });
TweenPositionAdvanced.attributes.add('startAtEnable',   { type: 'boolean', default: true, title: 'Start on Initialize' });
TweenPositionAdvanced.attributes.add('startOnEnable',   { type: 'boolean', default: true, title: 'Start on Enable'});

pc.extend(TweenPositionAdvanced.prototype, {
    initialize: function() {
        this._time = this.startAtEnable ? 0 : this.duration + this.startDelay + 1;
        this._oldTime = this.app._time || 0;

        this._from = this.initFrom.clone();
        this._to = this.initTo.clone();

        this._initPosition = this.entity.getLocalPosition().clone();

        this._newPosition = new pc.Vec3(0, 0, 0);
        this._curveXYZ = new pc.Vec3(0,0,0);
    },

    postInitialize: function() {
        this.on('state', function(enabled) {
            if (enabled && this.startOnEnable) {
                this.startTween();
            }
        }, this);

        if (this.startAtEnable) {
            this.startTween();
        }
    },

    update: function(dt) {
        // Only execute code if this.time is between 0 and this.duration + this.startDelay
        if (this._time >= 0 && this._time <= this.duration + this.startDelay) {
            // Update time
            this.updateTime(dt);

            // Only update opacity after the start delay.
            if (this._time > this.startDelay) {
                var curveValue = this.curve.value((this._time - this.startDelay) / this.duration);
                this._curveXYZ.set(curveValue[0], curveValue[1], curveValue[2]);
                
                // Formula: position = initPosition + (from - (from - to) * curve)
                this._newPosition
                    .set(this._from.x, this._from.y, this._from.z)
                    .sub(this._to)
                    .mul(this._curveXYZ)
                    .sub2(this._from, this._newPosition)
                    .add(this._initPosition);
                this.entity.setLocalPosition(this._newPosition);
            }
            // Set new old time 
            this._oldTime = this.app._time;
        }

        // Execute if this.time is higher than this.duration + this.startDelay
        if (this._time >= this.duration + this.startDelay || this._time <= 0) {
            switch (this.playStyle) {
                case 0: break;
                case 1: this._time = 0;
                    break;
                case 2: this._time = 0; 
                    var temp = this._from;
                    this._from = this._to;
                    this._to = temp;
                    break;
            }
        }
    },

    /*
     * Update the time with the game time or the unscaled time
     */
    updateTime: function(dt) {
        this._time += this.ignoreTimeScale ? (this.app._time - this._oldTime) / 1000 : dt;
    },

    /*
     * Use this method to start a tween where the init position is resetted to the current position of the entity.
     */
    moveTo: function(from, to) {
        this._time = 0;

        this._from.set(0, 0, 0);
        this._to.set(0, 0, 0);
        this._to.sub(from);
        this._initPosition.set(from.x, from.y, from.z);
        this._oldTime = this.app._time;
    },

    /*
     * Set the correct value for starting a tween
     * This method can also be called to start a new tween
     */
    startTween: function() {
        try {
            this._time = 0;
            this._from.set(this.initFrom.x, this.initFrom.y, this.initFrom.z);
            this._to.set(this.initTo.x, this.initTo.y, this.initTo.z);
            
            if (this.debug) console.warn(this._from.toString(), this._to.toString())
            this.entity.setLocalPosition(this._from.x + this._initPosition.x, this._from.y + this._initPosition.y, this._from.z + this._initPosition.z);
            this._oldTime = this.app._time;
        } catch(error) {
            console.log(error);
            setTimeout(this.startTween);
        }

    }, 
});


// GardenDataManager.js
var GardenDataManager = pc.createScript('gardenDataManager');

pc.extend(GardenDataManager.prototype, {
    initialize: function () {
        GardenDataManager.instance = this;

        this.areaData = {};

        if (firebaseClass.loaded) {
            this.onUserChange();
        }

        this.objectValuesPerArea = {};

        this.firstTime = true;

        this.app.on('StorageManager:changedStorage', this.onUserChange, this);
    },

    onUserChange: function () {
        if (!StorageManager.instance.get("hasUpdatedAreaData")) {
            StorageManager.instance.set("hasUpdatedAreaData", true);

            this.areaData = {};

            StorageManager.instance.set('areaData', this.areaData);
        } else {
            this.areaData = StorageManager.instance.get('areaData');
        }

        this.firstTime = true;
    },

    getNextUnlockableObject: function () {
        var unlockableObject = null;
        //get area number
        var currentArea = parseInt(LevelManager.instance.currentChapter) || 1;

        //get area save values 
        const areaData = this.areaData;
        const keys = Object.keys(areaData);
        var areaSaveData = null;

        for (let i = 0; i < keys.length; i++) {
            const key = keys[i];
            if (areaData[key].area === currentArea) {
                areaSaveData = areaData[key];
                break;
            }
        }

        if (!areaSaveData) {
            return null;
        }

        //get stars earned
        var earnedStars = 0;
        //add to total stars if not already added
        var totalStars = earnedStars;
        //calculate total amount of stars for area
        var areaStars = StorageManager.instance.get("levelData")[currentArea] || {};
        var starsArrayLength = Object.keys(areaStars).length;

        for (var i = 0; i < starsArrayLength; i++) {
            if (parseInt(Object.keys(areaStars)[i]) === LevelManager.instance.currentLevel) {

                if (earnedStars < areaStars[Object.keys(areaStars)[i]].stars) {
                    totalStars -= earnedStars;
                    totalStars += areaStars[Object.keys(areaStars)[i]].stars;
                }
            } else {
                totalStars += areaStars[Object.keys(areaStars)[i]].stars;
            }
        }

        var areaObjectsArrayLength = Object.keys(areaSaveData.areaObjectsSaveValues).length;

        let previousSaveValue = null;

        for (var j = 0; j < areaObjectsArrayLength; j++) {
            //all objects that are locked
            const obj = Object.values(areaSaveData.areaObjectsSaveValues)[j];
            if (obj.currentObject === 3) {
                unlockableObject = obj;
                unlockableObject.totalStars = totalStars;
                unlockableObject.starsSpent = areaSaveData.starsSpent;
                unlockableObject.stars = totalStars - areaSaveData.starsSpent; // The real amount of stars the user has.
                unlockableObject.costSingle = previousSaveValue ? obj.cost - previousSaveValue.cost : obj.cost; // Cost of this upgrade only.
                unlockableObject.complete = unlockableObject.stars >= unlockableObject.costSingle; // Check if you could already buy it.

                break;
            } else {
                previousSaveValue = obj;
            }
        }

        return unlockableObject;
    },

    pushArea: function (area) {
        this.objectValuesPerArea[area.index] = area.objects;
    },

    getObjectValues: function (areaNumber, objectName) {
        return this.objectValuesPerArea[areaNumber][objectName];
    },

    getAreaStars: function (chapter = LevelManager.instance.currentChapter) {
        return Object.values(this.areaData)[chapter - 1];
    },

    setAreaData: function (areaData) {
        this.areaData = areaData;

        this.saveAreaData();
    },

    save: function () {
        this.saveAreaData();
        this.saveObjectData();
    },

    saveAreaData: function () {
        StorageManager.instance.set("areaData", this.areaData);
    },

    saveObjectData: function () {
        StorageManager.instance.set("objectData", this.objectData);
    },

    firstTimeGarden: function () {
        if (!this.firstTime) {
            return false;
        }

        var firstTime = true;

        try {
            firstTime = !(this.areaData['Area 1'].areaObjectsSaveValues[0].currentObject !== ObjectHandler.BROKEN_STATE);
        } catch (e) {
        }

        var ftue = StorageManager.instance.get('gardenFTUE');

        if (!firstTime && ftue) {
            this.disableFirstTimeGarden();
        }

        this.firstTime = StorageManager.instance.get('gardenFTUE');

        return this.firstTime;
    },

    disableFirstTimeGarden() {
        StorageManager.instance.set('gardenFTUE', false);
    },

    changeStarSpent(index, amount) {
        // Already changed in AreaManager
        // this.areaData[`Area ${index + 1}`].starsSpent += amount;

        this.saveAreaData();
    },

    unlockNextArea() {
        const keys = Object.keys(this.areaData);

        let areaNumber = null;

        keys.forEach(key => {
            if (typeof areaNumber === 'number') {
                return;
            }
            const area = this.areaData[key];

            if (area.state === AreaManager.states.Locked) {
                area.state = AreaManager.states.Unlocked;
                areaNumber = area.area;
            }
        });

        return areaNumber;
    },

    isAreaUnlocked(areaNumber) {
        return this.areaData[`Area ${areaNumber}`].state === AreaManager.states.Unlocked;
    }
});


// GardenTutorialArrowHandler.js
class GardenFTUTutorialHandler extends pc.ScriptType {
    static addAttributes() {
        this.attributes.add('arrowEntity', { type: 'entity' });
        this.attributes.add('arrowImageEntity', { type: 'entity' });
        this.attributes.add('arrowImage2Entity', { type: 'entity' });
        this.attributes.add('elemScreen', { type: 'entity' });
    }
    initialize() {
        GardenFTUTutorialHandler.instance = this;
        this.on('destroy', this._onDestroy, this);
        this.areaStars = StorageManager.instance.get("levelData")[1] || {};
        this.starsArrayLength = Object.keys(this.areaStars).length;

        this.firstTimeGarden = GardenDataManager.instance.firstTimeGarden();

        if (!this.firstTimeGarden) {
            this.disable();
        }

        //this.setArrowOneAnimation();
        this.app.on('UIManager:hideUI', this.hide, this);
        this.app.on('UIManager:showUI', this.show, this);
        this.app.on('GardenCamera:startHold', this.pauze, this);
        this.app.on('GardenCamera:stopHold', this.resume, this);
        this.app.on('HoldCounter:finish', this.stop, this);
        this.app.on('ObjectOptions:sendSelf', this.setFirstObject, this);
        this.app.fire('ObjectHandler:getFirstUnlock');
        this.firstObject = null;
        this.tutorialPlayed = false;
        this.app.on('ObjectOptions:sendSelf', this.setFirstObject, this);
        this.app.on('GardenUIEntity:cheatFired', this.cheatFunction, this);
    }

    enableEntity() {
        this.arrowImageEntity.enabled = true;
    }
    cheatFunction() {
        this.tutorialPlayed = false;
        this.areaStars = StorageManager.instance.get("levelData")[1];
        this.starsArrayLength = Object.keys(this.areaStars).length;
        if (this.starsArrayLength > 0) {
            this.disable();
        } else {
            GardenCamera.instance.focusPosition(this.entity.getPosition());
        }
    }
    _onDestroy() {
        this.app.off('UIManager:hideUI', this.hide, this);
        this.app.off('UIManager:showUI', this.show, this);
        this.app.off('GardenCamera:startHold', this.pauze, this);
        this.app.off('GardenCamera:stopHold', this.resume, this);
        this.app.off('HoldCounter:finish', this.stop, this);
        this.app.off('ObjectOptions:sendSelf', this.setFirstObject);
        this.app.off('GardenUIEntity:cheatFired', this.cheatFunction);
    }

    setStates() {
        const firstTimeGarden = GardenDataManager.instance.firstTimeGarden();

        if (firstTimeGarden) {
            if (!this.tutorialPlayed) {
                this.app.fire('Placeholder:onStartup');
                this.tutorialPlayed = true;
                this.enable();
                TodoCardHandler.instance.showNewToDo();
                this.app.fire('GardenFTUTutorialHandler:start');
            }

            //StorageManager.instance.set("firstTimeGarden", false);

            //GardenCamera.instance.focusPosition(this.entity.getPosition());
        }
    }

    disable() {
        this.disabled = true;
        this.arrowEntity.enabled = false;
        GardenCamera.instance.FTUTutorial = false;
        GardenUIEntity.instance.bookButton.enabled = true;
        GardenUIEntity.instance.shopButton.enabled = true;
    }

    enable() {
        this.disabled = false;
        this.arrowEntity.enabled = true;
        GardenUIEntity.instance.bookButton.enabled = false;
        GardenUIEntity.instance.shopButton.enabled = false;
    }

    setFirstObject(arg) {
        this.firstObject = arg;
        if (this.firstObject.selectedModel !== 0) {
            this.disabled = true;
        }
    }

    pauze() {
        if (this.disabled) return;
        this.arrowEntity.enabled = false;
    }

    resume() {
        if (this.disabled) return;
        this.arrowEntity.enabled = true;
    }

    stop() {
        this.disable();
    }

    hide(args) {
        if (this.disabled) return;
        if (args === 'Garden') {
            this.arrowEntity.enabled = false;
        }
    }
    show(args) {
        if (args === 'introComic') {
            this.enable();
        }

        if (this.disabled) return;
        if (args === 'Garden') {
            this.areaStars = StorageManager.instance.get("levelData")[1] || {};
            this.starsArrayLength = Object.keys(this.areaStars).length;
            this.setStates();
        }
    }
    setArrowOneAnimation() {
        var initialPosition = this.arrowImageEntity.getLocalPosition();
        //stay rest
        var anim3 = this.arrowImageEntity.tween(this.arrowImageEntity.getLocalPosition())
            .to({ x: initialPosition.x, y: initialPosition.y, z: initialPosition.z }, 2, pc.BackIn);
        //press
        var anim4 = this.arrowImageEntity.tween(this.arrowImageEntity.getLocalPosition())
            .to({ x: initialPosition.x - 10, y: initialPosition.y - 10, z: initialPosition.z }, 0.5, pc.BackIn);
        //stay press
        var anim5 = this.arrowImageEntity.tween(this.arrowImageEntity.getLocalPosition())
            .to({ x: initialPosition.x - 10, y: initialPosition.y - 10, z: initialPosition.z }, 2, pc.BackOut);
        //back to rest
        var anim6 = this.arrowImageEntity.tween(this.arrowImageEntity.getLocalPosition())
            .to({ x: initialPosition.x, y: initialPosition.y, z: initialPosition.z }, 0.5, pc.BackOut);
        anim3.chain(anim4, anim5, anim6, anim3).start();
    }
    updatePosition() {
        if (this.disabled) return;

        var screenPosition = new pc.Vec3();
        GardenCamera.instance.entity.camera.worldToScreen(this.entity.getPosition(), screenPosition);
        var screenEntity = this.elemScreen;
        var scale = screenEntity.screen.scale;
        var device = this.app.graphicsDevice;
        var pixelratio = pc.Application.getApplication().graphicsDevice.maxPixelRatio;

        if (pixelratio > 1) {
            this.arrowEntity.setLocalPosition(
                screenPosition.x / scale * pixelratio,
                (device.height - screenPosition.y * pixelratio) / scale,
                0);
        }
        else {
            //If the zoom is above 100%, we don't want to use that factor
            this.arrowEntity.setLocalPosition(
                screenPosition.x / scale,
                (device.height - screenPosition.y) / scale,
                0);
        }
    }
    update() {
        if (!this.arrowEntity.enabled) return;
        this.updatePosition();
    }
}
pc.registerScript(GardenFTUTutorialHandler, 'gardenFTUTutorialHandler');
GardenFTUTutorialHandler.addAttributes();

// NotEnoughStarsGetStarsButton.js
class NotEnoughStarsGetStarsButton extends pc.ScriptType {
    static addAttributes() {
        // this.attributes.add('attribute1', {type: 'entity'});
    }
    initialize() {
        this.app.on('GardenManager:lockedObject', this.sendStars, this);
        this.app.on('GardenTutorialHandler:setGetStarsButtonPosition', this.sendSelf, this);
        this.entity.script.elementInput.on('click', this._onClick, this);
    }
    sendSelf() {
        this.app.fire('NotEnoughStarsGetStarsButton:sendSelf', this.entity)
    }
    sendStars(entity) {
        this.gotoArea = entity.script.objectOptions.world;
    }
    _onClick() {
        var areaStars = StorageManager.instance.get("levelData")[1];
        var starsArrayLength = Object.keys(areaStars).length;
        if (starsArrayLength === 0) {
            this.app.fire('NotEnoughStarsGetStarsButton:getStars');
            Wrapper.instance.sendGAEvent(Wrapper.GA_EVENT_TYPE.DESIGN, { eventId: 'tutorialFunnel:nextLevelPressed' });
            LevelManager.instance.startLevel(1, 1);
        } else {
            this.app.fire('UIManager:showUI', 'LoadingScreen');

            LoadingScreen.instance.setType(LoadingScreen.TYPES.ASSETS).once('fadeInComplete', () => {
                this.app.fire('UIManager:hideUI', 'NotEnoughStars');

                AssetManager.instance.setBook(WorldManager.instance.getWorldIndex(), () => {
                    this.app.fire('UIManager:hideUI', 'LoadingScreen');

                    this.app.fire('UIManager:showUI', 'Book', { key: 'lowStarLevel', chapterID: this.gotoArea, openLevelPage: true });
                });
            });


        }
    }
    postInitialize() {

    }
    update() {

    }
}
pc.registerScript(NotEnoughStarsGetStarsButton, 'notEnoughStarsGetStarsButton');
NotEnoughStarsGetStarsButton.addAttributes();

// GardenLockedAreaFeedbackUI.js
class GardenLockedAreaFeedbackUi extends pc.ScriptType {
    static addAttributes() {
        this.attributes.add('textEntity', { type: 'entity' });
        this.attributes.add('inaccessibleTextEntity', { type: 'entity' });
        this.attributes.add('imageEntity', { type: 'entity' });
        this.attributes.add('elemScreen', { type: 'entity' });
    }
    initialize() {
        this.initialTextPosition = this.textEntity.getLocalPosition().clone();
        this.initialTextPosition2 = this.inaccessibleTextEntity.getLocalPosition().clone();

        this.playing = false;
        this.disabled = false;
        this.app.on('HoldCounter:AreaLocked', this.setText, this);
        this.app.on('HoldCounter:inaccessible', this.setInaccessibleText, this);
        this.on('destroy', this._destroy, this);
        this.referencePosition = BoundingBoxRaycast.instance.hitMarkerEntity.getPosition().clone();
    }
    _destroy() {
        this.app.off('HoldCounter:AreaLocked', this.setText);
        this.app.off('HoldCounter:inaccessible', this.setInaccessibleText);
    }
    setText(entity) {
        var area = entity.script.objectOptions.world;
        LocalizationManager.instance.setText(this.textEntity, 'GARDEN_AREA_LOCKED_DESCRIPTION', [area]);
        this.playTween(BoundingBoxRaycast.instance.hitMarkerEntity.getPosition().clone());
    }
    setInaccessibleText(worldPos) {
        this.playInaccessibleTween(worldPos);
    }
    update() {
        if (!this.active) {
            return;
        }

        this.updatePosition();
    }
    updatePosition() {
        var screenPosition = new pc.Vec3();
        if (this.playing) {
            GardenCamera.instance.entity.camera.worldToScreen(this.referencePosition, screenPosition);
        } else {
            GardenCamera.instance.entity.camera.worldToScreen(BoundingBoxRaycast.instance.hitMarkerEntity.getPosition(), screenPosition);
        }
        var screenEntity = this.elemScreen;
        var scale = screenEntity.screen.scale;
        var device = this.app.graphicsDevice;
        var pixelratio = pc.Application.getApplication().graphicsDevice.maxPixelRatio;

        if (pixelratio > 1) {
            this.entity.setLocalPosition(
                screenPosition.x / scale * pixelratio,
                (device.height - screenPosition.y * pixelratio) / scale,
                0);
        }
        else {
            //If the zoom is above 100%, we don't want to use that factor
            this.entity.setLocalPosition(
                screenPosition.x / scale,
                (device.height - screenPosition.y) / scale,
                0);
        }
    }
    playInaccessibleTween(refPos) {
        // this.referencePosition = BoundingBoxRaycast.instance.hitMarkerEntity.getPosition().clone();
        this.active = true;

        this.referencePosition = refPos;
        this.playing = true;
        this.inaccessibleTextEntity.setLocalPosition(this.initialTextPosition2);
        var duration = 1;
        var opacity = { value: 1 };
        var textUpdate = function () {
            this.inaccessibleTextEntity.element.opacity = opacity.value;
            this.inaccessibleTextEntity.element.outlineColor = new pc.Color(0, 0, 0, opacity.value);
        };
        var anim2 = this.inaccessibleTextEntity.tween(opacity).to({ value: 0 }, duration, pc.Linear)
        anim2.on('update', textUpdate, this);
        var anim3 = this.inaccessibleTextEntity.tween(this.inaccessibleTextEntity.getLocalPosition())
            .to({ x: this.initialTextPosition2.x, y: this.initialTextPosition2.y + 50, z: this.initialTextPosition2.z }, duration, pc.Linear);
        anim2.start();
        anim3.start();
        pc.timer.add(duration, () => {
            this.active = false;

        }, this);

    }
    playTween(refPos) {
        // this.referencePosition = BoundingBoxRaycast.instance.hitMarkerEntity.getPosition().clone();
        this.active = true;

        this.referencePosition = refPos;
        this.playing = true;
        this.textEntity.setLocalPosition(this.initialTextPosition);
        var duration = 1;
        var opacity = { value: 1 };
        var textUpdate = function () {
            this.textEntity.element.opacity = opacity.value;
            this.textEntity.element.outlineColor = new pc.Color(0, 0, 0, opacity.value);
        };
        var anim2 = this.textEntity.tween(opacity).to({ value: 0 }, duration, pc.Linear)
        anim2.on('update', textUpdate, this);
        var anim3 = this.textEntity.tween(this.textEntity.getLocalPosition())
            .to({ x: this.initialTextPosition.x, y: this.initialTextPosition.y + 50, z: this.initialTextPosition.z }, duration, pc.Linear);
        anim2.start();
        anim3.start();
        pc.timer.add(duration, () => {
            this.active = false;

        }, this);
    }
}
pc.registerScript(GardenLockedAreaFeedbackUi, 'gardenLockedAreaFeedbackUi');
GardenLockedAreaFeedbackUi.addAttributes();

// GardenInputElement.js
class GardenInputElement extends pc.ScriptType {
    static addAttributes(){
        this.attributes.add('attribute1', {type: 'entity'});
    }
    initialize(){
        this._touch = InputManager.instance.getSupportTouch();
        this._mouse = InputManager.instance.getSupportMouse();
        this._element = this.entity.element;

        this._active = false;
        // Remove the listeners so if this entity is destroyed
        this.on('destroy', this._destroy, this);

        this.onEnable();
        this.app.on('GardenManager:gardenInput', this.onEnable, this);
        this.on('enable', this.onEnable, this);
    }

    subscribeEvents() {
        if (this._touch) {
            this._element.on(pc.EVENT_TOUCHSTART, this._onTouchStart, this);
            this._element.on(pc.EVENT_TOUCHMOVE, this._onTouchMove, this);
            this._element.on(pc.EVENT_TOUCHCANCEL, this._onTouchLeave, this);
            this._element.on(pc.EVENT_TOUCHEND, this._onTouchEnd, this);
        } 

        if (this._mouse) {
            this._element.on(pc.EVENT_MOUSEDOWN, this._onMouseDown, this);
            this._element.on(pc.EVENT_MOUSEMOVE, this._onMouseMove, this);
            this._element.on(pc.EVENT_MOUSEUP, this._onMouseUp, this);
            this._element.on('mouseleave', this._onMouseLeaveElement, this);
        }
    }

    unsubscribeEvents() {
        if (this._touch) {
            this._element.off(pc.EVENT_TOUCHSTART, this._onTouchStart, this);
            this._element.off(pc.EVENT_TOUCHMOVE, this._onTouchMove, this);
            this._element.off(pc.EVENT_TOUCHCANCEL, this._onTouchLeave, this);
            this._element.off(pc.EVENT_TOUCHEND, this._onTouchEnd, this);
        } 

        if (this._mouse) {
            this._element.off(pc.EVENT_MOUSEDOWN, this._onMouseDown, this);
            this._element.off(pc.EVENT_MOUSEMOVE, this._onMouseMove, this);
            this._element.off(pc.EVENT_MOUSEUP, this._onMouseUp, this);
            this._element.off('mouseleave', this._onMouseLeaveElement, this);
        }
    }

    onEnable(enabled = GardenManager.instance.gardenInput) {
        if (enabled && !this._active) {
            this.subscribeEvents();
            this._active = true;
        } else if (!enabled && this._active) {
            this.unsubscribeEvents();
            this._active = false;
        }
    }

    _destroy(){
        if (this._touch) {
            this._element.off(pc.EVENT_TOUCHSTART, this._onTouchStart, this);
            this._element.off(pc.EVENT_TOUCHMOVE, this._onTouchMove, this);
            this._element.off(pc.EVENT_TOUCHCANCEL, this._onTouchLeave, this);
            this._element.off(pc.EVENT_TOUCHEND, this._onTouchEnd, this);
        } 

        if (this._mouse) {
            this._element.off(pc.EVENT_MOUSEDOWN, this._onMouseDown, this);
            this._element.off(pc.EVENT_MOUSEMOVE, this._onMouseMove, this);
            this._element.off(pc.EVENT_MOUSEUP, this._onMouseUp, this);
            this._element.off('mouseleave', this._onMouseLeaveElement, this);
        }
        
        this.app.off('GardenManager:gardenInput', this.onEnable, this);
    }
    _onMouseDown(event){
        // console.log('GardenInput:onMouseDown',event.event)
        this.app.fire('GardenInput:onMouseDown',event.event);
    }
    _onMouseMove(event){
        // console.log('GardenInput:onMouseMove',event)
        this.app.fire('GardenInput:onMouseMove',event.event);
    }
    _onMouseLeaveElement(event){
        this.app.fire('GardenInput:onMouseLeaveElement', event.event);
    }
    _onMouseLeaveWindow(event){
        // console.log('GardenInput:onMouseLeaveWindow', event)
    }
    _onMouseEnter(event){
        // console.log('GardenInput:onMouseEnter', event)
    }
    _onMouseUp(event){
        // console.log('GardenInput:onMouseUp',event)
        this.app.fire('GardenInput:onMouseUp',event.event);
    }

    _onTouchStart(event){
        for(var i = 0; i < event.touches.length; i++){
            event.touches[i].x = event.touches[i].pageX;
            event.touches[i].y = event.touches[i].pageY;
        }

        this.app.fire('GardenInputElement:touchStart', event);
    }
    _onTouchMove(event){
        //event.event.preventDefault();
        for(var i = 0; i < event.touches.length; i++){
            event.touches[i].x = event.touches[i].pageX;
            event.touches[i].y = event.touches[i].pageY;
        }
        // console.log(event);
        this.app.fire('GardenInputElement:touchMove', event);
    }
    _onTouchLeave(event){
        //event.event.preventDefault();
        for(var i = 0; i < event.touches.length; i++){
            event.touches[i].x = event.touches[i].pageX;
            event.touches[i].y = event.touches[i].pageY;
        }
        this.app.fire('GardenInputElement:touchLeave', event);
    }
    _onTouchEnd(event){
        //event.event.preventDefault();
        for(var i = 0; i < event.touches.length; i++){
            event.touches[i].x = event.touches[i].pageX;
            event.touches[i].y = event.touches[i].pageY;
        }
        this.app.fire('GardenInputElement:touchEnd', event);
    }
}
pc.registerScript(GardenInputElement, 'gardenInputElement');
GardenInputElement.addAttributes();

// SceneSettings.js
var SceneSettings = pc.createScript('sceneSettings');

SceneSettings.attributes.add('ambientColor', { type: 'rgb' });

pc.extend(SceneSettings.prototype, {
    initialize: function() {
        this.setAmbientColor();
        
        this.on('attr:ambientColor', this.setAmbientColor, this);
    },
    
    setAmbientColor: function() {
        this.app.scene.ambientLight = this.ambientColor;
    },
});


// Polaroid.js
var Polaroid = pc.createScript('polaroid');

Polaroid.attributes.add('imageEntity', { type: 'entity' });

pc.extend(Polaroid.prototype, {
    initialize: function() {

    },

    setImage: function(image) {
        this.imageEntity.element.spriteAsset = image;

        this.randomizeTransform();
    },

    randomizeTransform: function() {
        var randomAngle = pc.math.random(-Polaroid.ANGLE_OFFSET, Polaroid.ANGLE_OFFSET);
        let tries = 0;
        
        while (Math.abs(randomAngle - Polaroid.LAST_ROTATION) < Polaroid.MINIMAL_DIFFERENCE && tries < 30) {
            randomAngle = pc.math.random(-Polaroid.ANGLE_OFFSET, Polaroid.ANGLE_OFFSET);            
            tries++;
        }

        this.entity.setLocalEulerAngles(0, 0, randomAngle);
        Polaroid.LAST_ROTATION = randomAngle;
    },
});

Polaroid.ANGLE_OFFSET = 20;
Polaroid.POSITION_OFFSET = new pc.Vec2(50, 50);

Polaroid.LAST_ROTATION = -100;
Polaroid.MINIMAL_DIFFERENCE = 15;


// Copyright.js
var Copyright = pc.createScript('copyright');

pc.extend(Copyright.prototype, {
    postInitialize: function () {
        let hasFeature = Wrapper.instance.hasFeature("copyright");

        if (hasFeature) {
            this.entity.element.text = '(C) Famobi';
        } else {
            this.entity.enabled = false;
        }
    },
});


// SpriteHandler.js
var SpriteHandler = pc.createScript('spriteHandler');

SpriteHandler.attributes.add('sprite', { type: 'asset', assetType: 'sprite' });

pc.extend(SpriteHandler.prototype, {
    initialize: function() {
        this.entity.sprite.spriteAsset = this.sprite.id;
    },
});

// IntroComicScreen.js
var IntroComicScreen = pc.createScript('introComicScreen');

IntroComicScreen.attributes.add('template', { type: 'asset', assetType: 'template' });
IntroComicScreen.attributes.add('polaroids', { type: 'asset', assetType: 'sprite', array: true });
IntroComicScreen.attributes.add('delay', { type: 'number', default: 1 });
IntroComicScreen.attributes.add('timeBetweenPolaroids', { type: 'number', default: 1 });
IntroComicScreen.attributes.add('timeToSkip', { type: 'number', default: 1 });
IntroComicScreen.attributes.add('distanceBetweenPolaroids', { type: 'number', default: 600 });
IntroComicScreen.attributes.add('polaroidGroup', { type: 'entity' });
IntroComicScreen.attributes.add('movingGroup', { type: 'entity' });
IntroComicScreen.attributes.add('skipButton', { type: 'entity' });

pc.extend(IntroComicScreen.prototype, {
    initialize: function () {
        this.delayDone = false;
        this.time = 0;
        this.active = false;
        this.index = 0;

        this.canSkip = false;
        this.hiding = false;

        this._polaroids = [];

        if (this.app.mouse) {
            this.app.mouse.on(pc.EVENT_MOUSEUP, this._skip, this);
        }

        if (this.app.touch) {
            this.app.touch.on(pc.EVENT_TOUCHCANCEL, this._skip, this);
        }

        this.skipButton.script.elementInput.on('click', this.skipAll, this);
    },

    onUIEntityOpen: function () {
        Wrapper.instance.sendGAEvent(Wrapper.GA_EVENT_TYPE.DESIGN, { eventId: 'tutorialFunnel:photoAnimationStarted' });

        this.hiding = false;
        this.delayDone = false;
        this.time = 0;
        this.active = true;
        this.index = 0;
        this.canSkip = false;

        this.app.fire('Audio:bgm', 'part-1-joy.mp3');
    },

    update: function (dt) {
        if (!this.active) {
            return;
        }

        if (!this.delayDone) {
            this.time += dt;

            if (this.time >= this.delay) {
                this.time -= this.delay;
                this.createPolaroid();

                this.delayDone = true;
            }
        } else {
            this.time += dt;

            if (!this.canSkip) {
                if (this.time >= this.timeToSkip) {
                    this.canSkip = true;
                }
            }

            if (this.time >= this.timeBetweenPolaroids) {
                this.time -= this.timeBetweenPolaroids;

                this.createPolaroid();

            }
        }
    },

    _skip: function () {
        if (this.canSkip) {
            this.createPolaroid();
            this.time = 0;
        }
    },

    skipAll: function () {
        this.canSkip = false;
        this.active = false;

        this.end();
    },

    createPolaroid: function () {
        const polaroid = this.template.resource.instantiate();

        polaroid.reparent(this.polaroidGroup);
        polaroid.enabled = true;

        this.playBGM();

        const image = this.polaroids[this.index];

        polaroid.script.polaroid.setImage(image);

        this.index++;
        polaroid.setLocalPosition(this.index * this.distanceBetweenPolaroids, 0, 0);

        this.tweenPolaroidGroup();

        this.active = this.index < this.polaroids.length;

        this._polaroids.push(polaroid);

        if (!this.active) {
            this.startEnd();
        }

        this.canSkip = false;
    },

    tweenPolaroidGroup: function () {
        this.movingGroup.tween(this.movingGroup.getLocalPosition()).to({ x: -this.index * this.distanceBetweenPolaroids, y: 0, z: 0 }, 3, pc.SineInOut).start();
    },

    startEnd: function () {
        pc.timer.add(this.timeBetweenPolaroids, this.end, this);
    },

    playBGM: function () {
        if (this.hiding) {
            return;
        }

        let next = null;

        if (this.index === 5) {
            next = 'part-2-sorrow.mp3';

        } else if (this.index === 8) {
            next = 'part-3-hope.mp3';
        }

        if (next) {
            const fadeOutPrevious = AudioManager.instance.fadeOutMusicSlot(0.2, 0);

            if (!fadeOutPrevious) {
                this.app.fire('Audio:bgm', next);
            } else {
                fadeOutPrevious.on('complete', () => {
                    this.app.fire('Audio:bgm', next);
                }, this);
            }
        }
    },

    end: function () {
        if (this.hiding) {
            return;
        }

        this.hiding = true;

        this.app.fire('UIManager:showUI', 'whiteFadeOut');

        if (this.index < 8) {
            const fadeOutPrevious = AudioManager.instance.fadeOutMusicSlot(3, 0);

            if (!fadeOutPrevious) {
                this.app.fire('Audio:bgm', "main_ost.mp3");
            } else {
                fadeOutPrevious.on('complete', () => {
                    this.app.fire('Audio:bgm', "main_ost.mp3");
                }, this);
            }

        } else {
            AudioManager.instance.setNextBGM("main_ost.mp3");
        }

        pc.timer.add(3, this.hide, this);
    },

    hide: function () {
        for (var i = 0; i < this._polaroids.length; i++) {
            const polaroid = this._polaroids[i];

            polaroid.destroy();
        }

        this._polaroids.length = 0;

        Wrapper.instance.sendGAEvent(Wrapper.GA_EVENT_TYPE.DESIGN, { eventId: 'tutorialFunnel:photoAnimationEnded' });

        this.app.fire('UIManager:hideUI', 'introComic');
    }
});


// StaticObjectHandler.js
class StaticObjectHandler extends pc.ScriptType {
    static addAttributes(){
         // this.attributes.add('attribute1', {type: 'entity', array:true});
    }
    initialize(){
        this.app.on('rebatch', this.rebatch, this);
        this.on('destroy',this._onDestroy, this);
    }
    _onDestroy(){
        this.app.off('rebatch', this.rebatch);
    }
    rebatch(){
        if(this.entity.model){
            this.batchGroupID = this.entity.model.batchGroupId;
            if(this.batchGroupID !== -1){
                this.app.batcher.markGroupDirty(this.batchGroupID);
            }
        }
    }
    postInitialize(){
        
    }
    update(dt){
        
    }
}
pc.registerScript(StaticObjectHandler, 'staticObjectHandler');
StaticObjectHandler.addAttributes();

// DevicePixelRatioHandler.js
var DevicePixelRatioHandler = pc.createScript('devicePixelRatioHandler');


var isLowQualityGPU = function () {
    try {
        var renderer1 = pc.Application.getApplication().graphicsDevice.unmaskedRenderer;

        // console.error(pc.Application.getApplication().graphicsDevice.unmaskedRenderer)
        // console.error(pc.Application.getApplication().graphicsDevice.unmaskedVendor)
        // console.error(pc.Application.getApplication().graphicsDevice._shaderStats.compileTime);
        // console.log(pc.Application.getApplication().graphicsDevice)
        var canvas = document.createElement("canvas");
        var context = canvas.getContext("webgl") || canvas.getContext("webgl2") || canvas.getContext("experimental-webgl");
        var info = context.getExtension("WEBGL_debug_renderer_info");

        var renderer2 = context.getParameter(info.UNMASKED_RENDERER_WEBGL);
        // console.error(this.isiPhoneLowEnd())
        // Only check the GPU if we are on mobile
        if (renderer1 && pc.platform.mobile) {
            // low level GPU's
            if (renderer1.search(/Adreno\D*3/) !== -1 ||
                renderer1.search(/Adreno\D*4/) !== -1 ||
                renderer1.search(/Adreno\D*505/) !== -1 ||
                renderer1.search(/Adreno\D*506/) !== -1 ||
                renderer1.search(/Mali\D*4/) !== -1 ||
                renderer1.search(/Mali\D*5/) !== -1 ||
                renderer1.search(/Mali\D*6/) !== -1 ||
                renderer1.search(/Mali\D*T7/) !== -1 ||
                renderer1.search(/Mali\D*T82/) !== -1 ||
                renderer1.search(/Mali\D*T83/) !== -1 ||
                (renderer1.search(/Apple/) !== -1 && this.isiPhoneLowEnd())
            ) {
                return true;
            }
        }

        return false;
    } catch (e) {
        Sentry.captureException(e);
        return true;
    }
};
// iPhone model checks.
var isiPhoneLowEnd = function () {
    var renderer = null;
    // Create a canvas element which can be used to retrieve information about the GPU.
    var canvas = document.createElement("canvas");
    if (canvas) {
        var context = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
        if (context) {
            var info = context.getExtension("WEBGL_debug_renderer_info");
            if (info) {
                renderer = context.getParameter(info.UNMASKED_RENDERER_WEBGL);
            }
        }
    }
    // 844 390 3  12 , pro 
    // 926 428 3 12 pro max, 
    // 812 375 3 iphone 12 mini
    // console.log(window.screen.height, window.screen.width, window.devicePixelRatio)
    // // iPhone X
    // if ((window.screen.height / window.screen.width == 812 / 375) && (window.devicePixelRatio == 3)) {
    //     return "iPhone X";
    // // iPhone 6+/6s+/7+ and 8+
    // } else 
    if ((window.screen.height / window.screen.width == 736 / 414) && (window.devicePixelRatio == 3)) {
        switch (renderer) {
            default:
            // return "iPhone 6 Plus, 6s Plus, 7 Plus or 8 Plus";
            case "Apple A8 GPU":
            // return "iPhone 6 Plus";
            case "Apple A9 GPU":
            // return "iPhone 6s Plus";
            case "Apple A10 GPU":
                // return "iPhone 7 Plus";
                return true;
            case "Apple A11 GPU":
                // return "iPhone 8 Plus";
                return false;
        }
        // iPhone 6+/6s+/7+ and 8+ in zoom mode
    } else if ((window.screen.height / window.screen.width == 667 / 375) && (window.devicePixelRatio == 3)) {
        switch (renderer) {
            default:
            // return "iPhone 6 Plus, 6s Plus, 7 Plus or 8 Plus (display zoom)";
            case "Apple A8 GPU":
            // return "iPhone 6 Plus (display zoom)";
            case "Apple A9 GPU":
            // return "iPhone 6s Plus (display zoom)";
            case "Apple A10 GPU":
                // return "iPhone 7 Plus (display zoom)";
                return true;
            case "Apple A11 GPU":
                // return "iPhone 8 Plus (display zoom)";
                return false;
        }
        // iPhone 6/6s/7 and 8
    } else if ((window.screen.height / window.screen.width == 667 / 375) && (window.devicePixelRatio == 2)) {
        switch (renderer) {
            default:
            // return "iPhone 6, 6s, 7 or 8";
            case "Apple A8 GPU":
            // return "iPhone 6";
            case "Apple A9 GPU":
            // return "iPhone 6s";
            case "Apple A10 GPU":
                // return "iPhone 7";
                return true;
            case "Apple A11 GPU":
                // return "iPhone 8";
                return false;
        }
        // iPhone 5/5C/5s/SE or 6/6s/7 and 8 in zoom mode
    } else if ((window.screen.height / window.screen.width == 1.775) && (window.devicePixelRatio == 2)) {
        switch (renderer) {
            default:
            // return "iPhone 5, 5C, 5S, SE or 6, 6s, 7 and 8 (display zoom)";
            case "PowerVR SGX 543":
            // return "iPhone 5 or 5c";
            case "Apple A7 GPU":
            // return "iPhone 5s";
            case "Apple A8 GPU":
            // return "iPhone 6 (display zoom)";
            case "Apple A9 GPU":
            // return "iPhone SE or 6s (display zoom)";
            case "Apple A10 GPU":
                // return "iPhone 7 (display zoom)";
                return true;
            case "Apple A11 GPU":
                // return "iPhone 8 (display zoom)";
                return false;
        }
        // iPhone 4/4s
    } else if ((window.screen.height / window.screen.width == 1.5) && (window.devicePixelRatio == 2)) {
        switch (renderer) {
            default:
            // return "iPhone 4 or 4s";
            case "PowerVR SGX 535":
            // return "iPhone 4";
            case "PowerVR SGX 543":
                // return "iPhone 4s";
                return true;
        }
        // iPhone 1/3G/3GS
    } else if ((window.screen.height / window.screen.width == 1.5) && (window.devicePixelRatio == 1)) {
        switch (renderer) {
            default:
            // return "iPhone 1, 3G or 3GS";
            case "ALP0298C05":
            // return "iPhone 3GS";
            case "S5L8900":
                // return "iPhone 1, 3G";
                return true;
        }
    } else {
        // return "Not an low end iPhone";
        return false;
    }
};

// initialize code called once per entity
DevicePixelRatioHandler.prototype.initialize = function () {
    var device = pc.Application.getApplication().graphicsDevice;
    if (!isLowQualityGPU()) {
        device.maxPixelRatio = window.devicePixelRatio;
        // Use the CSS resolution device pixel ratio
    } else {
        // Use the default device pixel ratio of the device

        device.maxPixelRatio = pc.math.clamp(window.devicePixelRatio, 1, 2);
    }
};


// HandleWorldCameraState.js
class HandleWorldCameraState extends pc.ScriptType {
    static addAttributes(){
        this.attributes.add('attribute1', {type: 'entity'});
    }
    initialize(){
        this.app.on('UIManager:showUI', this.handleEnabledState, this);
        this.on('destroy', this._onDestroy, this);
    }
    _onDestroy() {
        this.app.off('UIManager:showUI', this.handleEnabledState, this);
    }
    handleEnabledState(args){
        // console.log('args:', args)
        switch(args){
            case 'Shop':
            case 'FloatingUI':
            case 'IAPSuccess':
            case 'IAPFail':
            case 'IAPWarning':
            case 'IAPClosedWhileProcessing':
                break;
            case 'World':
            case 'Intro':
            case 'Game':
            case 'Coins':
            case 'BoosterShop':
            case 'Pause':
            case 'Unlock':
            case 'Win':
            case 'Lose':
            case 'AddMoves':
            case 'addExploderTimer':
                if(!this.entity.camera.enabled){
                    this.entity.camera.enabled = true;
                }
                break;
            default:
                if(this.entity.camera.enabled){
                    // console.log('Disable camera')
                    this.entity.camera.enabled = false;
                }
                break;
        }
    }

}
pc.registerScript(HandleWorldCameraState, 'handleWorldCameraState');
HandleWorldCameraState.addAttributes();

// Vec3.js
pc.extend(pc.Vec3.prototype, {
    distanceSq(rhs) {
        const x = this.x - rhs.x;
        const y = this.y - rhs.y;
        const z = this.z - rhs.z;
        return x * x + y * y + z * z;
    } 
});

// WorldUnlockManager.js
var WorldUnlockManager = pc.createScript('worldUnlockManager');

var defaultKey = "garden-area-1-object-1-part-2";


WorldUnlockManager.attributes.add('conversation', {
    type: 'json', array: true, schema: [
        {
            name: 'flowerUnlockKey',
            type: 'string',
            default: defaultKey,
        },
        {
            name: 'newBookKey',
            type: 'string',
            default: defaultKey,
        },
        {
            name: 'newAreaKey',
            type: 'string',
            default: defaultKey,
        },
    ]
});

pc.extend(WorldUnlockManager.prototype, {
    initialize: function () {
        WorldUnlockManager.instance = this;

        this.unlocked = false;

        this.worldID = 10;
        this.nextWorldID = 11;
    },

    setWorldUnlocked: function (worldID) {
        this.unlocked = true;
        this.worldID = worldID;
        this.nextWorldID = this.worldID + 1;
    },

    isUnlocked: function () {
        return this.unlocked;
    },

    disable: function () {
        this.unlocked = false;
    },

    startGardenSequence: function () {
        Wrapper.instance.sendGAEvent(Wrapper.GA_EVENT_TYPE.DESIGN, { eventId: 'tutorialFunnel:startGardenSequence' })

        GardenManager.instance.enableGardenInput(false);
        this.app.fire('UIManager:hideAll');

        const areaScript = GardenManager.instance.getAreaScriptByAreaNumber(this.nextWorldID);

        if (areaScript && this.nextWorldID !== 1) {
            areaScript.lock();
        }

        if (this.worldID >= 1) {
            SpecialFlowerManager.instance.startAnimateFlower(this.worldID);
            LoadingScreen.instance.once('done', () => {

                SpecialFlowerManager.instance.focusCamera(this.worldID);
                this.app.once('GardenCamera:CloseToObject', () => {
                    SpecialFlowerManager.instance.animateFlower(this.worldID);
                }, this);
                SpecialFlowerManager.instance.once('complete', this.showDialog1, this);
            }, this);
        } else {
            this.showDialog1(() => {
                this.showNewBook();
                Wrapper.instance.sendGAEvent(Wrapper.GA_EVENT_TYPE.DESIGN, { eventId: 'tutorialFunnel:showedDialog1' })
            });

        }
    },

    getKey(type) {
        var key = this.conversation[this.worldID][type];

        if (key === defaultKey) {
            console.warn("Replace the default key!");
        }

        return key;
    },


    showDialog1: function (functionAfter = this.showNewBook) {
        this.app.fire('UIManager:hideAll');
        DialogManager.instance.showDialog(this.getKey(WorldUnlockManager.KEYS.flowerUnlockKey), functionAfter, this, dialogTypes.CONVERSATION, true);
    },

    showNewBook: function () {
        if (this.nextWorldID === 11) {
            this.app.fire('UIManager:showUI', 'finalImage');

            GardenManager.instance.enableGardenInput(true);
            GardenCamera.instance.disableBlockedCamera();
            this.disable();
            return;
        }

        if (this.nextWorldID === 1) { this.showDialog2(); return }

        var asset = WorldManager.instance.getWorldBackgroundImage(this.nextWorldID);

        if (!asset) { this.showDialog2(); }

        var assetArray = [asset];

        assetArray.push(this.app.assets.get(asset.data.textureAtlasAsset));

        AssetManager.instance.loadExtra(assetArray, () => {
            this.app.fire('UIManager:hideUI', 'loading');
            this.app.fire('UIManager:showUI', 'Book Unlock', { asset: asset, worldID: this.nextWorldID });
            this.app.on('bookUnlockScreen:close', this.showDialog2, this);
        }, this, true);
    },


    showDialog2: function () {
        if (this.nextWorldID === 1) {
            pc.timer.add(0.5, this.showNewArea, this);
            return
        }


        this.app.fire('UIManager:hideAll');

        DialogManager.instance.showDialog(this.getKey(WorldUnlockManager.KEYS.newBookKey), this.showNewArea, this, dialogTypes.CONVERSATION, true);
    },

    showNewArea: function () {


        GardenManager.instance.gardenCamera.waiting = true;

        const areaScript = GardenManager.instance.getAreaScriptByAreaNumber(this.nextWorldID);

        if (!areaScript) {
            this.showDialog3();
            return;
        }

        GardenCamera.instance.focusPosition(areaScript.areaFocusPoint.getPosition(), areaScript.areaFocusZoomAmount);



        this.app.once('GardenCamera:CloseToObject', () => {
            if (GardenDataManager.instance.firstTime) Wrapper.instance.sendGAEvent(Wrapper.GA_EVENT_TYPE.DESIGN, { eventId: 'tutorialFunnel:enteredArea' });
            // TODO animate new area.

            if (this.nextWorldID === 1) {
                this.showDialog3();
                return;
            }

            areaScript.unlockAnimation().then(() => {
                this.showDialog3();
            });
        });

    },

    showDialog3: function () {
        this.app.fire('UIManager:hideAll');

        DialogManager.instance.showDialog(this.getKey(WorldUnlockManager.KEYS.newAreaKey), this.showGardenUI, this, dialogTypes.CONVERSATION, true);
    },

    showGardenUI: function () {
        // UIManager.instance.getScreen('Garden').script.gardenUIEntity.once('openFinish', this.showTodo, this);

        this.app.fire('UIManager:showUI', 'Garden');
        this.showTodo();
        this.disable();
    },

    showTodo: function () {
        const areaScript = GardenManager.instance.getAreaScriptByAreaNumber(this.nextWorldID);

        if (!areaScript) {
            return;
        }

        var obj = GardenUIEntity.instance.getLastUnlock(areaScript);

        if (obj.found) {
            TodoCardHandler.instance.setTodoValues(obj.nextUnlockableEntity.script.objectOptions.descriptionText,
                "" + obj.starsToUnlock,
                obj.nextUnlockableEntity.script.objectOptions.brokenObjectImage,
                obj.nextUnlockableEntity.script.objectOptions.world
            );

            Wrapper.instance.sendGAEvent(Wrapper.GA_EVENT_TYPE.PROGRESSION, {
                progressionStatus: 'Start',
                progression01: `task_area_${this.nextWorldID}`,
                progression02: `task_${obj.group + 1}`,
                progression03: `step_${obj.step}`
            });
        }

        if (!GardenDataManager.instance.firstTimeGarden()) {
            TodoCardHandler.instance.showNewToDo();
            GardenManager.instance.enableGardenInput(true);
            GardenCamera.instance.disableBlockedCamera();
        } else {
            this.disable();
        }
        GardenDataManager.instance.disableFirstTimeGarden();
        this.fire('finish');
    },
});

WorldUnlockManager.KEYS = Object.freeze({
    flowerUnlockKey: 'flowerUnlockKey',
    newBookKey: 'newBookKey',
    newAreaKey: 'newAreaKey',
});

// BookUnlockScreen.js
var BookUnlockScreen = pc.createScript('bookUnlockScreen');

BookUnlockScreen.attributes.add('shaderSize', { type: 'entity' });
BookUnlockScreen.attributes.add('worldPreview', { type: 'entity' });
BookUnlockScreen.attributes.add('alphaCurve', { type: 'curve' });
BookUnlockScreen.attributes.add('duration', { type: 'number', default: 2 });
BookUnlockScreen.attributes.add('camera', { type: 'entity', });
BookUnlockScreen.attributes.add('bookScaleEntity', { type: 'entity', });
BookUnlockScreen.attributes.add('closeAlphaCurve', { type: 'curve' });
BookUnlockScreen.attributes.add('closeDuration', { type: 'number', default: 0.5 });
BookUnlockScreen.attributes.add('textEntity', { type: 'entity', });


// initialize code called once per entity
pc.extend(BookUnlockScreen.prototype, {
    initialize: function () {
        this.time = 0;

        this.on('enable', this.onEnable, this);
        this.on('disable', this.onDisable, this);
    },

    postInitialize: function () {
        this.app.on('ViewportManager:onResize', this.onResize, this);
    },

    onEnable: function () {
        this.time = 0;
        this.worldPreview.enabled = true;
    },

    onDisable: function () {
        this.worldPreview.enabled = false;
    },

    onUIEntityOpen: function (data) {
        const asset = data.asset;
        const worldID = data.worldID;

        this.worldID = worldID;

        if (worldID === 1) {
            Wrapper.instance.sendGAEvent(Wrapper.GA_EVENT_TYPE.DESIGN, { eventId: 'tutorialFunnel:bookOpened' })
        }

        this.worldPreview.enabled = true;

        LocalizationManager.instance.setText(this.textEntity, WorldManager.instance.getWorldList()[worldID].name);

        this.worldPreview.script.pageDissolveShader.start();
        this.time = 0;

        if (!asset) {
            console.warn("no asset");
            return;
        }

        this.opening = false;
        this.closing = false;

        // this.imageEntity.element.sprite = asset.resource;
        this.worldPreview.script.pageDissolveShader.setDiffuseMap(asset);
        this.worldPreview.script.pageDissolveShader.setWorldIndex(worldID);

        const value = this.alphaCurve.value(this.time / this.duration);
        this.worldPreview.script.pageDissolveShader.updateAlpha(value, 0);
    },

    onUIEntityOpenFinish: function () {
        const soundInstance = AudioManager.instance._playSFX('unlock_new_chapter.mp3');

        if (soundInstance) {
            GardenMusicManager.instance.fadeOutMusic(true);
            soundInstance.on('end', () => {
                GardenMusicManager.instance.fadeInMusic(true);
                GardenMusicManager.instance.fadeOutAmbient();
            });
        }

        this.onResize(ViewportManager.instance.getOrientation(), ViewportManager.instance.width, ViewportManager.instance.height);

        this.opening = true;
        this.closing = false;
    },

    update: function (dt) {
        if (this.opening) {
            this.time += dt;
            const value = this.alphaCurve.value(this.time / this.duration);
            this.worldPreview.script.pageDissolveShader.updateAlpha(value, dt);
        } else if (this.closing) {
            this.time += dt;
            const value = this.closeAlphaCurve.value(this.time / this.closeDuration);
            this.worldPreview.script.pageDissolveShader.updateAlpha(value, dt);
        }
    },

    onResize: function (orientation, width, height, device) {
        const scale = this.bookScaleEntity.getLocalScale();
        const reference = UIManager.instance.getReferenceResolution();
        const element = this.shaderSize.element;

        const imageWidth = element.width;
        const imageHeight = element.height;

        const minSize = Math.min(imageWidth, imageHeight);

        const fov = this.camera.camera.fov;

        const distance = ((reference.y / (minSize * scale.x)) / 2) / Math.tan(fov / 2 * (Math.PI / 180));

        this.worldPreview.setLocalPosition(0, 0, -distance);

        switch (orientation) {
            case 'landscape':
                this.worldPreview.script.pageDissolveShader.uDiffuseRotation = 0;
                this.worldPreview.setLocalEulerAngles(90, 0, 0);
                break;
            case 'portrait':
                this.worldPreview.script.pageDissolveShader.uDiffuseRotation = Math.PI / 2;
                this.worldPreview.setLocalEulerAngles(90, 0, 90);
                break;
            default:
                this.worldPreview.script.pageDissolveShader.uDiffuseRotation = 0;
                this.worldPreview.setLocalEulerAngles(90, 0, 0);
                break;
        }
    },

    onUIEntityClose: function () {
        this.opening = false;
        this.closing = true;

        if (this.worldID === 1) {
            Wrapper.instance.sendGAEvent(Wrapper.GA_EVENT_TYPE.DESIGN, { eventId: 'tutorialFunnel:startChapterPressed' });
        }

        this.time = 0;
    },

    onUIEntityCloseFinish: function () {
        this.app.fire('bookUnlockScreen:close');
        this.worldPreview.enabled = false;
    }
});


// BatchManager.js
pc.extend(pc.BatchManager.prototype, {
    getGroupById: function(id) {
        const groups = this._batchGroups;
        
        for (const group in groups) {
            if (!groups.hasOwnProperty(group)) continue;
            if (groups[group].id === id) {
                return groups[group];
            }
        }
        return null;
    }
});

// GardenCheatScreen.js
var GardenCheatScreen = pc.createScript('gardenCheatScreen');

GardenCheatScreen.attributes.add('worldButtons', { type: 'entity', array: true });
GardenCheatScreen.attributes.add('minus100StarButton', { type: 'entity' });
GardenCheatScreen.attributes.add('minus10StarButton', { type: 'entity' });
GardenCheatScreen.attributes.add('plus10StarButton', { type: 'entity' });
GardenCheatScreen.attributes.add('plus100StarButton', { type: 'entity' });

GardenCheatScreen.attributes.add('unlockButtons', { type: 'entity', array: true });
GardenCheatScreen.attributes.add('unlockNextAreaButton', { type: 'entity' });

GardenCheatScreen.attributes.add('resetButtons', { type: 'entity', array: true });
GardenCheatScreen.attributes.add('resetAllButton', { type: 'entity' });
GardenCheatScreen.attributes.add('addCoinButton', { type: 'entity' });

pc.extend(GardenCheatScreen.prototype, {
    initialize: function() {
        this.selectedWorld = -1;

        this.worldButtons.forEach((button, index) => { 
            button.findByTag('arrow')[0].enabled = false;
            this.setWorldButtonInput(button, index);
        }, this);

        this.unlockButtons.forEach((button, index) => { 
            this.setUnlockButtonInput(button, index);
        }, this);

        this.resetButtons.forEach((button, index) => { 
            this.setResetButtonInput(button, index);
        }, this);

        this.selectWorld(0);

        this.minus100StarButton.script.elementInput.on('click', () => this.changeStar(-100));
        this.minus10StarButton.script.elementInput.on('click', () => this.changeStar(-10));
        this.plus10StarButton.script.elementInput.on('click', () => this.changeStar(10));
        this.plus100StarButton.script.elementInput.on('click', () => this.changeStar(100));

        this.unlockNextAreaButton.script.elementInput.on('click', this.unlockNextArea, this);
        this.resetAllButton.script.elementInput.on('click', this.resetAll, this);
                
        this.addCoinButton.script.elementInput.on('click', this.addCoins, this);
    },

    onUIEntityOpen: function() {
        this.setUnlockButtonsState();
        this.setResetButtonsState();
    },

    setWorldButtonInput: function(button, index) {
        button.script.elementInput.on('click', () => this.selectWorld(index), this);
    },

    setUnlockButtonInput: function(button, index) {
        button.script.elementInput.on('click', () => this.unlockSelectedArea(index + 1), this);
    },

    setResetButtonInput: function(button, index) {
        button.script.elementInput.on('click', () => this.resetArea(index + 1), this);
    },

    selectWorld: function(index) {
        var oldButton = this.worldButtons[this.selectedWorld];

        if (oldButton) {
            oldButton.findByTag('arrow')[0].enabled = false;
        }

        this.selectedWorld = index;

        var newButton = this.worldButtons[this.selectedWorld];

        if (newButton) {
            newButton.findByTag('arrow')[0].enabled = true;
        }
    },

    changeStar: function(amount) {
        GardenManager.instance.getAreaScriptByAreaNumber(this.selectedWorld + 1).starsSpent -= amount;
        GardenManager.instance.getAreaScriptByAreaNumber(this.selectedWorld + 1).areaSaveValues.starsSpent -= amount;

        GardenDataManager.instance.changeStarSpent(this.selectedWorld, -amount);
    },

    unlockNextArea: function() {
        const areaNumber = GardenDataManager.instance.unlockNextArea();

        if (typeof areaNumber !== 'number') {
            console.log(areaNumber);
            return;
        }

        this.unlockArea(areaNumber);
    },

    unlockSelectedArea: function(areaNumber) {
        var unlocked = GardenDataManager.instance.isAreaUnlocked(areaNumber);

        if (!unlocked) {
            this.unlockArea(areaNumber);
        }
    },

    setUnlockButtonsState: function() {
        for (var  i = 0; i < this.unlockButtons.length; i++) {
            const button = this.unlockButtons[i];
            button.button.active = !GardenDataManager.instance.isAreaUnlocked(i + 1);
        }  

        this.unlockNextAreaButton.button.active = !GardenDataManager.instance.isAreaUnlocked(10);
    },

    setResetButtonsState: function() {
        for (var  i = 0; i < this.resetButtons.length; i++) {
            const button = this.resetButtons[i];
            button.button.active = GardenDataManager.instance.isAreaUnlocked(i + 1);
        }  

        // this.unlockNextAreaButton.button.active = GardenDataManager.instance.isAreaUnlocked(10);
    },

    unlockArea: function(areaNumber) {
        LevelDataManager.instance.cheatGarden(areaNumber);

        const areas = this.app.root.findByTag('area');

        for (let i = 0; i < areas.length; i++) {
            const area = areas[i];

            if (area.script.areaManager.areaNumber > areaNumber) {
                break;
            }

            const areaManager = area.script.areaManager;

            areaManager.cheatFunction();
        }

        WorldUnlockManager.instance.setWorldUnlocked(areaNumber - 1);
        WorldUnlockManager.instance.startGardenSequence();
        LoadingScreen.instance.fire('done');
    },

    resetArea: function(area) {
        LevelDataManager.instance.cheatGardenReset(area);

        for (var i = 10; i >= area; i--) {
            GardenManager.instance.resetAreaData(i);
            GardenManager.instance.getAreaScriptByAreaNumber(i).postInitialize();
        }

        GardenManager.instance._updateAreaData();

        this.setUnlockButtonsState();
        this.setResetButtonsState();
    },

    resetAll: function() {
        this.resetArea(1);

        StorageManager.instance.set('gardenFTUE', true);
        GardenDataManager.instance.firstTime = true;        
        BackTogardenButton.showIntro = true;
        
        AssetManager.instance.setWorld(AssetManager.WORLDS.MENU, () => {
            this.app.fire('UIManager:hideAll');
            this.app.fire('UIManager:showUI', 'Menu');
        }, this, true, true);

        //         WorldUnlockManager.instance.setWorldUnlocked(0);
        //         WorldUnlockManager.instance.startGardenSequence();

        //         WorldUnlockManager.instance.once('finish', GardenFTUTutorialHandler.instance.setStates, GardenFTUTutorialHandler.instance);
    },
    
    setWorldStars: function(worldID, stars) {
        GardenManager.instance.getAreaScriptByAreaNumber(this.selectedWorld + 1).starsSpent -= amount;
    },
    
    addCoins: function() {
        Inventory.instance.addItem('COINS', 1000000);
    },
});


// NotEnoughStarsScreen.js
var NotEnoughStarsScreen = pc.createScript('notEnoughStarsScreen');

NotEnoughStarsScreen.attributes.add('textEntity', { type: 'entity' });

pc.extend(NotEnoughStarsScreen.prototype, {
    initialize: function() {
        this.coloredStars = this.entity.findScripts('coloredStar');
    },

    onUIEntityOpen: function(data) {
        this.textEntity.element.text = LocalizationManager.instance.get('NOT_ENOUGH_STARS_DESCRIPTION', data.amount);
        this.coloredStars.forEach(coloredStar => coloredStar.setStarImage(data.area));
    },
});

// LoadingScreen.js
var LoadingScreen = pc.createScript('loadingScreen');

LoadingScreen.attributes.add('backgroundGardenEntity', { type: 'entity' });
LoadingScreen.attributes.add('backgroundBookEntity', { type: 'entity' });

LoadingScreen.attributes.add('tweenAlphaEntity', { type: 'entity' });
LoadingScreen.attributes.add('loadingTextEntity', { type: 'entity' });
LoadingScreen.attributes.add('barFillEntity', { type: 'entity' });
LoadingScreen.attributes.add('textKeys', { type: 'string', array: true });
LoadingScreen.attributes.add('switchTextDuration', { type: 'number', default: 3 });

pc.extend(LoadingScreen.prototype, {
    init: function () {
        LoadingScreen.instance = this;
        this.tweenAlphaScript = this.tweenAlphaEntity.script.tweenAlpha;
        this.maxWidth = this.barFillEntity.element.width;
        this.previousKey = '';
        this.currentProgressRatio = 0;

        this.timer = 0;
        this.currentIndex = 0;

        this.app.on('loadSceneController:progress', this.setCurrentProgress, this);
        this.app.on('switchedScene', this.finished, this);

        this.on('disable', this.onDisable, this);
    },

    onDisable: function () {

    },

    setType: function (type) {
        switch (type) {
            case LoadingScreen.TYPES.ASSETS:
                LazyLoader.instance.on('onLoaded', this.setCurrentProgress, this);
                break;
            case LoadingScreen.TYPES.SCENE:
                break;
            default:
                console.warn(type);
        }

        return this;
    },

    onUIEntityOpen: function (args) {
        this.fadeInCompleted = false;

        this.currentIndex = 0;
        this.currentProgressRatio = 0;
        this.timer = 0;
        this.noMoreText = false;

        this.setFillWidth(this.currentProgressRatio);

        if (args === LoadingScreen.BACKGROUND.WORLD) {
            this.backgroundGardenEntity.enabled = false;
            this.backgroundBookEntity.enabled = true;
            this.loadingTextEntity.enabled = false;
        } else if (args === LoadingScreen.BACKGROUND.GARDEN) {
            this.backgroundGardenEntity.enabled = true;
            this.backgroundBookEntity.enabled = false;
            this.loadingTextEntity.enabled = true;
        } else {
            this.backgroundGardenEntity.enabled = true;
            this.backgroundBookEntity.enabled = false;
            this.loadingTextEntity.enabled = false;
        }

        if (!this.tweenAlphaScript) {
            return;
        }

        this.tweenAlphaScript.startDelay = 0;

        this.tweenAlphaScript.startTween(0, 1);
        this.barFillEntity.element.width = 0;

        this.setRandomText();

        return new Promise(resolve => {
            this.tweenAlphaScript.once('finish', resolve);
        });
    },

    update: function (dt) {
        if (!this.loadingTextEntity.enabled) {
            return;
        }

        if (this.noMoreText) {
            return;
        }

        if (this.readyToShowNewText) {
            return;
        }

        this.timer += dt;

        if (this.timer > this.switchTextDuration) {
            this.timer -= this.switchTextDuration;

            this.readyToShowNewText = true;
        }
    },

    onUIEntityOpenFinish: function () {
        this.fire('fadeInComplete');
        this.fadeInCompleted = true;
    },

    onUIEntityClose: function () {
        LazyLoader.instance.off('onLoaded', this.setCurrentProgress, this);

        this.fire("startFadeOut");

        this.tweenAlphaScript.startDelay = 0.5;

        return new Promise(resolve => {
            this.tweenAlphaScript.startTween(1, 0).once('finish', resolve);
        });
    },


    onUIEntityCloseFinish: function () {
        this.fire("done");
    },

    setCurrentProgress: function (totalLoaded, totalAssetsToLoad) {
        const currentProgressRatio = totalLoaded / totalAssetsToLoad;

        this._totalLoaded = totalLoaded;
        this._totalAssetsToLoad = totalAssetsToLoad;

        this.setFillWidth(currentProgressRatio);
    },

    setFillWidth: function (ratio) {
        if (this.currentProgressRatio > ratio) {
            return;
        }

        if (this.readyToShowNewText) {
            this.setRandomText();
        }

        this.currentProgressRatio = ratio;

        this.barFillEntity.element.width = ratio * this.maxWidth;
    },

    setRandomText: function () {
        this.showNextText();
        return;

        let newKey = '';
        let maxTries = 20;

        do {
            newKey = this.textKeys[Math.floor(Math.random() * this.textKeys.length)];
            maxTries--;

            if (maxTries < 0) {
                break;
            }
        } while (newKey === this.previousKey);

        this.loadingTextEntity.element.key = newKey;
        this.readyToShowNewText = false;
        this.timer = 0;
        this.previousKey = newKey;
    },

    showNextText: function () {
        const newKey = this.textKeys[this.currentIndex];

        this.readyToShowNewText = false;
        this.timer = 0;
        this.loadingTextEntity.element.key = newKey;

        this.currentIndex++;

        if (this.currentIndex === this.textKeys.length) {
            this.noMoreText = true;
        }
    },

    finish: function () {
        this.app.fire("UIManager:hideUI", "loadingScreen");
    },

});

LoadingScreen.TYPES = Object.freeze({
    ASSETS: 'assets',
    SCENE: 'scene',
});

LoadingScreen.BACKGROUND = Object.freeze({
    BOOK: 'book',
    GARDEN: 'garden',
    WORLD: 'world',
});


// WinScreenButtons.js
var WinScreenButtons = pc.createScript('winScreenButtons');

WinScreenButtons.attributes.add('homeButton', { type: 'entity' });
WinScreenButtons.attributes.add('nextButton', { type: 'entity' });
WinScreenButtons.attributes.add('restartButton', { type: 'entity' });
WinScreenButtons.attributes.add('restartButtonShadow', { type: 'entity' });
WinScreenButtons.attributes.add('nextButtonTextEntity', { type: 'entity' });

WinScreenButtons.attributes.add('pulse', { type: 'entity', array: true });

pc.extend(WinScreenButtons.prototype, {

    setNextButton: function (replayingLevel) {
        const bookButton = this.nextButton.script.bookButton;
        bookButton.setType(replayingLevel ? bookButton.bookOptions.NEXTREPLAY : bookButton.bookOptions.NEXTCURRENT);
    },

    resetButtons: function () {
        this.activateButton(this.nextButton, true);
        this.activateButton(this.restartButton, true);
        this.homeButton.script.bookButton.setType(bookOptions.GARDEN);
        this.enableButtonShadows(true);

        this.disableButtonPulse();
    },

    setButtonsToGarden: function () {
        // this.activateButton(this.nextButton, false);
        // this.activateButton(this.restartButton, false);
        var bookButton = this.homeButton.script.bookButton;
        this.homeButton.script.bookButton.setType(bookOptions.GARDEN);
        var argument = { OpenTaskScreen: true };
        bookButton.setTunnelValues(argument);
        this.enableButtonShadows(false);

        // this.disableButtonPulse();
    },

    setButtonPulse: function () {
        this.homeButton.script.tweenScale.startTween();

        this.pulse.forEach(p => {
            p.enabled = true;
            p.script.tweenScale.startTween();
            p.script.tweenAlpha.startTween();
        });
    },

    setNextButtonPulse() {
        this.nextButton.script.tweenScale.startTween();

    },

    disableButtonPulse: function () {
        this.homeButton.script.tweenScale.stopTween();
        this.homeButton.setLocalScale(pc.Vec3.ONE);

        this.nextButton.script.tweenScale.stopTween();
        this.nextButton.setLocalScale(pc.Vec3.ONE);

        this.pulse.forEach(p => {
            p.enabled = false;
        });
    },

    activateButton: function (buttonEntity, enableBool) {
        buttonEntity.element.useInput = enableBool;

        if (enableBool) {
            var elements = buttonEntity.findComponents("element");
            for (var i = 0; i < elements.length; i++) {
                if (elements[i].entity.tags.has('restartShadow')) continue;
                elements[i].opacity = 1;
                elements[i].color = pc.Color.WHITE;
            }
        } else {
            var elements = buttonEntity.findComponents("element");
            for (var j = 0; j < elements.length; j++) {
                if (elements[j].entity.tags.has('restartShadow')) continue;
                elements[j].opacity = WinScreenButtons.LOCKED_BUTTON_OPACITY;
                elements[j].color = WinScreenButtons.GREY;
            }
        }
    },

    enableButtonShadows: function (enableBool) {
        this.restartButtonShadow.element.enabled = enableBool;
        this.nextButtonTextEntity.element.outlineThickness = enableBool ? WinScreenButtons.DEFAULT_OUTLINE_THICKNESS : 0;
    },
});

WinScreenButtons.DEFAULT_OUTLINE_THICKNESS = 0.7;
WinScreenButtons.LOCKED_BUTTON_OPACITY = 0.5;
WinScreenButtons.GREY = new pc.Color().fromString("#3E3E3E");

// StateChecker.js
var StateChecker = pc.createScript('stateChecker');

pc.extend(StateChecker.prototype, {
    initialize: function() {
        
    }
});


// WaterShaderDiffuseChunk.js
class WaterShaderDiffuseChunk extends pc.ScriptType {
    static addAttributes() {
        this.attributes.add('diffusePS', { type: 'asset', assetType: 'shader' });
        this.attributes.add('uDiffuseMap', { type: 'asset', assetType: 'texture' });
        this.attributes.add('uDiffuseSpeed', { type: 'vec2', default: [0.1, 0.1] });
        this.attributes.add('uDisplacementMap', { type: 'asset', assetType: 'texture' });
        this.attributes.add('uDisplacementAmount', { type: 'number', default: 0.1 });
        this.attributes.add('uDisplacementSpeed', { type: 'vec2', default: [0.2, 0.2] });
        this.attributes.add('uDarkColor', { type: 'rgba' });
        this.attributes.add('uLightColor', { type: 'rgba' });

    }
    initialize() {
        this.time = 0;
        var meshes = this.entity.model.model.meshInstances;
        this.materials = [];

        LoadingScreen.instance.on('startFadeOut', this.reload, this);

        for (var i = 0; i < meshes.length; i++) {
            var mesh = meshes[i];
            var mat = mesh.material;
            this.setShaderChunkAttributes(mat);
            mat.update();

            /* mat.setParameter("uDiffuseMap", this.uDiffuseMap.resource);
             mat.setParameter("uDiffuseSpeed", this.uDiffuseSpeed.data);
             mat.setParameter("uDisplacementMap", this.uDisplacementMap.resource);
             mat.setParameter("uDisplacementSpeed", this.uDisplacementSpeed.data);
             mat.setParameter("uDisplacementAmount", this.uDisplacementAmount);
             mat.setParameter("uDarkColor", this.uDarkColor.data);
             mat.setParameter("uLightColor", this.uLightColor.data);
             mat.setParameter("uTime", this.time);
             this.on('attr:uLightColor', function (value, prev) {
                 mat.setParameter("uLightColor", value.data);
             });*/

            this.materials.push(mat);
        }
        this.on('destroy', this.onDestroy, this);
    }

    onDestroy() {
        this.materials.length = 0;

        LoadingScreen.instance.off('startFadeOut', this.reload, this);
    }

    reload() {
        if (AssetManager.instance.currentWorld !== AssetManager.WORLDS.GARDEN) {
            return;
        }

        this.uDiffuseMap = this.uDiffuseMap;
        this.uDisplacementMap = this.uDisplacementMap;
    }
    update(dt) {
        if (!this.materials) {
            return;
        }

        this.time += dt;

        for (var i = 0; i < this.materials.length; i++) {
            this.materials[i].setParameter('uTime', this.time);

        }
    }

    setShaderChunkAttributes(mat) {
        //loop through all attributes of a shader to update them when changed.
        for (const [key, value] of Object.entries(this.__attributes)) {
            if (value != null) {
                switch (typeof value) {
                    case 'number': {
                        mat.setParameter(key, value); //Set shader parameter
                        this.on('attr:' + key, function (value, prev) {
                            mat.setParameter(key, value); //Set shader parameter
                        });
                        break;
                    }
                    case 'object': {
                        // loop through different attribute types.
                        switch (value.type) {
                            case 'material': {

                                break;
                            }
                            case 'shader': {

                                mat.chunks[key] = this[key].resource;// Apply shaderchunk to new material 
                                this.on('attr:' + key, function (value, prev) {
                                    mat.chunks[key] = this[key].resource;// Apply shaderchunk to new material 
                                    mat.update();
                                });
                                break;
                            }
                            case 'texture': {
                                mat.setParameter(key, this[key].resource);

                                this.on('attr:' + key, function (value, prev) {
                                    mat.setParameter(key, this[key].resource);
                                });
                                break;
                            }
                            default: {
                                mat.setParameter(key, value.data);
                                this.on('attr:' + key, function (value, prev) {
                                    mat.setParameter(key, value.data);
                                });
                                break;
                            }
                        }
                        break;
                    }
                    default: {
                        console.warn("could not update", key, "with current datatype", typeof value);
                    }
                }
            }
        }
    }
}
pc.registerScript(WaterShaderDiffuseChunk, 'waterShaderDiffuseChunk');
WaterShaderDiffuseChunk.addAttributes();

// WaterShaderPositionChunk.js
class WaterShaderPositionChunk extends pc.ScriptType {
    static addAttributes() {
        this.attributes.add('transformVS', { type: 'asset', assetType: 'shader' });
        this.attributes.add('uWaveSpeed', { type: 'number', default: 1.0 });
        this.attributes.add('uAmount', { type: 'number', default: 1.0 });
        this.attributes.add('uHeight', { type: 'number', default: 1.0 });
        this.attributes.add('uTiling', { type: 'vec2', default: [1.0, 1.0] });
        this.attributes.add('uOffset', { type: 'vec2', default: [1.0, 1.0] });
    }
    initialize() {
        this.time = 0;
        var meshes = this.entity.model.model.meshInstances;
        this.materials = [];
        for (var i = 0; i < meshes.length; i++) {
            var mesh = meshes[i];
            var mat = mesh.material;
            this.setShaderChunkAttributes(mat);
            mat.update();
            this.materials.push(mat);
        }

        this.on('destroy', this.onDestroy, this);
    }

    onDestroy() {
        this.materials.length = 0;
    }

    update(dt) {
        this.time += dt;
        for (var i = 0; i < this.materials.length; i++) {
            this.materials[i].setParameter('uTime', this.time);
        }
    }

    setShaderChunkAttributes(mat) {
        //loop through all attributes of a shader to update them when changed.
        for (const [key, value] of Object.entries(this.__attributes)) {
            if (value != null) {
                switch (typeof value) {
                    case 'number': {
                        mat.setParameter(key, value); //Set shader parameter
                        this.on('attr:' + key, function (value, prev) {
                            mat.setParameter(key, value); //Set shader parameter
                        });
                        break;
                    }
                    case 'object': {
                        // loop through different attribute types.
                        switch (value.type) {
                            case 'material': {

                                break;
                            }
                            case 'shader': {

                                mat.chunks[key] = this[key].resource;// Apply shaderchunk to new material 
                                this.on('attr:' + key, function (value, prev) {
                                    mat.chunks[key] = this[key].resource;// Apply shaderchunk to new material 
                                    mat.update();
                                });
                                break;
                            }
                            case 'texture': {
                                mat.setParameter(key, this[key].resource);

                                this.on('attr:' + key, function (value, prev) {
                                    mat.setParameter(key, this[key].resource);
                                });
                                break;
                            }
                            default: {
                                mat.setParameter(key, value.data);

                                this.on('attr:' + key, function (value, prev) {
                                    mat.setParameter(key, value.data);
                                });
                                break;
                            }
                        }
                        break;
                    }
                    default: {
                        console.warn("could not update", key, "with current datatype", typeof value);
                    }
                }
            }
        }
    }
}
pc.registerScript(WaterShaderPositionChunk, 'waterShaderPositionChunk');
WaterShaderPositionChunk.addAttributes();

// GardenMusicManager.js
var GardenMusicManager = pc.createScript('gardenMusicManager');

GardenMusicManager.attributes.add('ambientSFX', { type: 'asset' });
GardenMusicManager.attributes.add('bgm', { type: 'asset' });

GardenMusicManager.attributes.add('gardenMusicVolumeMultiplier', { type: 'number', default: 0.3 });

GardenMusicManager.attributes.add('fadeOutDuration', { type: 'number', default: 2 });
GardenMusicManager.attributes.add('fadeInDuration', { type: 'number', default: 2 });

GardenMusicManager.attributes.add('timeFadingOutBeforeLoop', { type: 'number', default: 2 });

GardenMusicManager.attributes.add('ambientVolumeHard', { type: 'number', default: 0.4 });
GardenMusicManager.attributes.add('ambientVolumeSoft', { type: 'number', default: 0.05 });

GardenMusicManager.STATES = Object.freeze({
    SILENCED: 'silenced',
    SOFT: 'soft',
    NORMAL: ' normal',
});

pc.extend(GardenMusicManager.prototype, {
    initialize: function () {
        GardenMusicManager.instance = this;

        this.state = GardenMusicManager.STATES.NORMAL;
    },

    postInitialize: function () {
        AudioManager.instance.on('bgmVolume', this.onBGMVolumeChange, this);

        pc.timer.add(0.01, () => {
            LoadingScreen.instance.on('startFadeOut', this.checkMusicState, this);
        }, this);
    },

    onBGMVolumeChange: function (volume) {
        if (this.currentWorld !== AssetManager.WORLDS.GARDEN) {
            return;
        }

        this.stopTween();

        switch (this.state) {
            case GardenMusicManager.STATES.SILENCED:
                this.setBGMVolume(volume, 0);
                this.setAmbientVolume(volume, this.ambientVolumeHard);
                break;

            case GardenMusicManager.STATES.SOFT:
                this.setBGMVolume(volume, this.gardenMusicVolumeMultiplier);
                this.setAmbientVolume(volume, this.ambientVolumeSoft);
                break;

            case GardenMusicManager.STATES.NORMAL:
                this.setBGMVolume(volume, 1);
                break;

            default:
                console.log(this.state);
                break;
        }
    },

    setAmbientVolume: function (volume, volumeMultiplier) {
        if (this.slot) {
            this.slot.volume = volume * volumeMultiplier;
        }
    },

    setBGMVolume: function (volume, volumeMultiplier) {
        if (this.activeMusicInstance) {
            this.activeMusicInstance.volume = volume * volumeMultiplier;
        }
    },

    checkMusicState: function () {
        this.currentWorld = AssetManager.instance.currentWorld;
        this.previousWorld = AssetManager.instance.previousWorld;

        if (this.currentWorld == AssetManager.WORLDS.GARDEN) {
            if (this.ambientSFX.resource) {
                this.playAmbientSFX();
            } else {
                this.ambientSFX.ready(() => {
                    pc.timer.add(0.01, this.playAmbientSFX, this);
                });
            }
        } else {
            this.stopTimer();
            delete this.handle;

            if (this.slot) {
                this.slot.stop();
            }
        }

        if (this.currentWorld !== AssetManager.WORLDS.GARDEN && this.previousWorld === AssetManager.WORLDS.GARDEN) {
            this.changeBGMVolume(1);

            this.setState(GardenMusicManager.STATES.NORMAL);
        }
    },

    playAmbientSFX: function () {
        if (AssetManager.instance.currentWorld === AssetManager.WORLDS.GARDEN) {
            this.slot = AudioManager.instance._playSFX('garden_ambience_1.mp3');

            if (this.slot) {
                this.slot.loop = true;
                this.slot.volume = AudioManager.instance._calculateBGMVolume() * this.ambientVolumeSoft;
            }

            this.activeMusicInstance = AudioManager.instance.activeMusicInstance;

            this.startFadeOut();

            this.changeBGMVolume();

            this.setState(GardenMusicManager.STATES.SOFT);
        } else if (AssetManager.instance.currentWorld !== AssetManager.WORLDS.GARDEN && AssetManager.instance.previousWorld === AssetManager.WORLDS.GARDEN) {
            this.changeBGMVolume(1);

            this.setState(GardenMusicManager.STATES.NORMAL);
        }
    },

    startFadeOut: function () {
        if (!this.isInGarden()) {
            return;
        }

        if (!this.activeMusicInstance) {
            return;
        }

        this.handle = pc.timer.add(pc.math.clamp(this.activeMusicInstance.duration - this.activeMusicInstance.currentTime - this.timeFadingOutBeforeLoop, this.fadeOutDuration, Number.POSITIVE_INFINITY), () => {
            if (!this.isInGarden()) {
                return;
            }

            const tween = this.fadeOutMusic();
            if (tween) {
                tween.on('complete', this.startFadeIn, this);
            }
            this.fadeInAmbient();
        });
    },

    startFadeIn: function () {
        if (!this.isInGarden()) {
            return;
        }

        if (!this.activeMusicInstance) {
            return;
        }

        this.handle = pc.timer.add(pc.math.clamp(this.activeMusicInstance.duration - this.activeMusicInstance.currentTime, 0.01, Number.POSITIVE_INFINITY), () => {

            const music = this.fadeInMusic();

            if (music) {
                music.on('complete', this.startFadeOut, this);
            } else {
                this.startFadeOut();
            }
            this.fadeOutAmbient();
        });
    },

    changeBGMVolume: function (volumeMultiplier = this.gardenMusicVolumeMultiplier) {
        if (!this.activeMusicInstance) {
            return;
        }

        this.volumeTween = this.entity.tween(this.activeMusicInstance).to({ volume: AudioManager.instance._calculateBGMVolume() * volumeMultiplier }, this.fadeInDuration, pc.Linear).start();
    },

    fadeOutMusic: function (unlock) {
        if (!this.isInGarden()) {
            return;
        }
        this.stopTween();
        this.stopTimer();

        this.setState(GardenMusicManager.STATES.SILENCED);

        if (!this.activeMusicInstance) {
            return;
        }

        this.unlock = true;

        this.volumeTween = this.entity
            .tween(this.activeMusicInstance)
            .to({ volume: 0 }, this.fadeOutDuration, pc.Linear)
            .start();

        return this.volumeTween;
    },

    fadeInMusic: function (unlock) {
        if (this.unlock) {
            if (unlock) {
                this.unlock = false;
            } else {
                return;
            }
        }

        if (!this.isInGarden()) {
            return;
        }

        this.stopTween();
        this.stopTimer();

        this.setState(GardenMusicManager.STATES.SOFT);

        if (!this.activeMusicInstance) {
            return;
        }

        this.volumeTween = this.entity
            .tween(this.activeMusicInstance)
            .to({ volume: AudioManager.instance._calculateBGMVolume() * this.gardenMusicVolumeMultiplier }, this.fadeInDuration, pc.Linear)
            .start()

        this.volumeTween.on('complete', () => {
            if (!this.handle) {
                this.startFadeOut();
            }
        });

        return this.volumeTween;
    },

    fadeOutAmbient: function () {
        if (!this.isInGarden()) {
            return;
        }

        if (!this.slot) {
            return;
        }

        this.ambientVolumeTween = this.entity
            .tween(this.slot)
            .to({ volume: this.ambientVolumeSoft }, this.fadeInDuration, pc.Linear)
            .start();
    },

    fadeInAmbient: function () {
        if (!this.isInGarden()) {
            return;
        }

        if (!this.slot) {
            return;
        }

        this.ambientVolumeTween = this.entity
            .tween(this.slot)
            .to({ volume: this.ambientVolumeHard }, this.fadeOutDuration, pc.Linear)
            .start();
    },

    setState: function (state) {
        this.state = state;
    },

    isInGarden: function () {
        return AssetManager.instance.currentWorld === AssetManager.WORLDS.GARDEN;
    },

    stopTween: function () {
        if (this.volumeTween) {
            this.volumeTween.stop();
        }

        if (this.ambientVolumeTween) {
            this.ambientVolumeTween.stop();
        }
    },

    stopTimer: function () {
        if (this.handle) {
            pc.timer.remove(this.handle);
            delete this.handle;
        }
    }
});

// ChangeObjectTutorial.js
var ChangeObjectTutorial = pc.createScript('changeObjectTutorial');

ChangeObjectTutorial.attributes.add('target', { type: 'entity' });

pc.extend(ChangeObjectTutorial.prototype,{
    initialize: function () {
        this.app.on('ObjectHandler:changeObjectTutorial', this.startChangeObjectTutorial, this);
        this.on('destroy', this.onDestroy, this);
        GardenManager.instance.changeObjectTutorialHand.enabled = false;
    },

    onDestroy: function() {
        this.app.off('ObjectHandler:changeObjectTutorial', this.startChangeObjectTutorial, this);
        this.app.off('HoldCounter:stopHolding', this.onStopHolding, this);
        this.app.off('HoldCounter:holding', this.holding, this);
    },

    startChangeObjectTutorial: function() {
        this.app.on('HoldCounter:stopHolding', this.onStopHolding, this);
        this.app.on('HoldCounter:holding', this.holding, this);

        DialogManager.instance.showDialog('garden-change-object-tutorial', this.endChangeObjectTutorial, this, dialogTypes.GARDENTUTORIAL, false);
        GardenCamera.instance.focusObject(this.target);
        this.app.fire('UIManager:showUI', 'gardenInput');
        this.app.fire('changeObjectTutorial:setTarget', this.target);
    },

    endChangeObjectTutorial: function() {
        DialogManager.instance.skipDialog();
        this.app.fire('changeObjectTutorial:setTarget', null);
        this.app.fire('UIManager:hideUI', 'gardenInput');

        this.app.off('HoldCounter:stopHolding', this.onStopHolding, this);
        this.app.off('HoldCounter:holding', this.holding, this);
    },

    onStopHolding: function() {
        GardenManager.instance.changeObjectTutorialHand.enabled = true;
    },

    holding: function() {
        GardenManager.instance.changeObjectTutorialHand.enabled = false;
    },
});


// GameVibrationManager.js
var GameVibrationManager = pc.createScript('gameVibrationManager');

pc.extend(GameVibrationManager.prototype, { // handles vibration during gameplay to avoid sending a crazy amount of continuous calls by ignoring any weaker than the current strongest for its duration
    initialize: function() {
        if (Singleton.instance.canCreateInstance(this)) {
            GameVibrationManager.instance = this;
        }

        this.currentHighest = 0;
        this.timeRemaining = 0;
        this.vibrating = false;
    },

    update: function(dt) {
        this.timeRemaining -= dt;
        if (this.timeRemaining <= 0 && this.vibrating) {
            this.vibrating = false;
            this.currentHighest = 0;
        }
    },

    addVibration: function(vibration) {
        let totalPower = GameVibrationManager.DEFAULT_POWER_VALUE;
        let totalTime = GameVibrationManager.DEFAULT_POWER_VALUE;
        
        if (Array.isArray(vibration)) {
            for (let i = 0; i < vibration.length; i++) {
                totalTime += vibration[i];
                if (i % 2 === 1) continue; // omit pauses from power value
                totalPower += vibration[i];
            }
        }
        else if (typeof vibration === 'number' ) {
            totalPower = vibration;
            totalTime = vibration;
        }

        if (totalPower > this.currentHighest) {
            this._overtakeCurrentVibration(vibration);
            this.currentHighest = totalPower;
            this.timeRemaining = totalTime / 1000;
            this.vibrating = true;
            return;
        } else return;
    },

    _overtakeCurrentVibration: function(newValue) {
        this.app.fire('vibrate', 0);
        this.app.fire('vibrate', newValue);
    },
});

GameVibrationManager.DEFAULT_POWER_VALUE = -1;
GameVibrationManager.SINGLE_TILE = 20;
GameVibrationManager.MATCH_PATTERN = 50;
GameVibrationManager.BOMB_PATTERN = 200;
GameVibrationManager.LINE_POWER_PATTERN = 100;
GameVibrationManager.LINE_BOMB_PATTERN = 100;
GameVibrationManager.COLOR_BOMB_PATTERN = 150;
GameVibrationManager.COLOR_LINE_BOMB_PATTERN = 200;
GameVibrationManager.COLOR_CARPET_BOMB_PATTERN = 250;
GameVibrationManager.ULTIMATE_COLOR_BOMB_PATTERN = 250;
GameVibrationManager.POPPER_PATTERN = 100;


// GardenInput.js
var GardenInput = pc.createScript('gardenInput');

GardenInput.attributes.add('holdCounter', { type: 'entity' });

// initialize code called once per entity
pc.extend(GardenInput.prototype, {
    init: function() {
        this.holdCounter.script.holdCounter.init();
    }
});


// Xsolla.js
var Xsolla = pc.createScript('xsolla');

Xsolla.attributes.add('sandbox', { type: 'boolean', default: true });

pc.extend(Xsolla.prototype, {
    initialize: function () {
        Xsolla.instance = this;

        this.active = Wrapper.instance.hasFeature('payment') && !Wrapper.instance.hasFeature('standalone');

        this.rewards = [];
        this.revokes = [];

        this.extraItems = {
            [Xsolla.SKU.COINS]: 0,
            [Xsolla.SKU.GLOVES]: 0,
            [Xsolla.SKU.SHOVEL]: 0,
            [Xsolla.SKU.BEEHIVE]: 0,
            [Xsolla.SKU.BEES]: 0,
            [Xsolla.SKU.LADYBUGS]: 0,
            [Xsolla.SKU.BUTTERFLY]: 0,
        };

        this.coinsDifference = 0;

        this.currency = [];
        this.items = [];
        this.bundles = [];
        this.virtualCurrencyPackages = [];

        if (!this.active) {
            return;
        }

        XPayStationWidget.on('init', this.onInit.bind(this));
        XPayStationWidget.on('open', this.onLoad.bind(this));
        XPayStationWidget.on('load', this.onOpen.bind(this));
        XPayStationWidget.on('status', this.onStatus.bind(this));
        XPayStationWidget.on('status-done', this.onBuy.bind(this));
        XPayStationWidget.on('status-troubled', this.onBuy.bind(this));
        XPayStationWidget.on('close', this.onClose.bind(this));

        // this.app.on('Firebase:done', this.onUserChange, this);
        this.app.on('StorageManager:changedStorage', this.onUserChange, this);



        this.path = 'https://store.xsolla.com/api/v2/project/175509/';

        this.getVirtualCurrencyPackages();
        this.getBundles();
    },

    postInitialize: function () {
        if (!this.active) {
            if (!window.famobi.hasFeature('rewarded')) {
                UIManager.instance.setRedirect('Shop', 'Daily Coins');

            }
        }
    },

    onStatus: function (a, b) {
        this.status = true;
        GameManager.instance.trackCustomEvent('shop', 'widget_status', { sku: this.sku });
    },

    onInit: function (a, b) {
        GameManager.instance.trackCustomEvent('shop', 'widget_init', { sku: this.sku });
    },

    onLoad: function (a, b) {
        GameManager.instance.trackCustomEvent('shop', 'widget_load', { sku: this.sku });
    },

    onOpen: function (a, b) {
        GameManager.instance.trackCustomEvent('shop', 'widget_open', { sku: this.sku });
    },

    onTroubled: function () {
        GameManager.instance.trackCustomEvent('shop', 'widget_troubled', { sku: this.sku });
    },

    onBuy: function (event, paymentInfo) {
        console.log(event, paymentInfo)
        this.bought = true;

        GameManager.instance.trackCustomEvent('shop', 'package_bought', { sku: this.sku });

        Wrapper.instance.sendGAEvent(Wrapper.GA_EVENT_TYPE.DESIGN, {
            eventId: `packageSold:${this.sku}:XSolla`
        });

        this.fire('bought', paymentInfo);
    },

    onClose: function (event) {
        this.fire('closed', this.bought);

        if (!this.bought) {
            GameManager.instance.trackCustomEvent('shop', 'widget_closed', { sku: this.sku });
        }

        if (this.loggedIn && this.status && !this.bought) {
            this.app.fire('UIManager:showUI', 'IAPClosedWhileProcessing');
            GameManager.instance.trackCustomEvent('shop', 'widget_closed_while_processing', { sku: this.sku });
        }
    },

    onUserChange: function (loggedIn = firebaseClass.loggedIn()) {
        if (StorageManager.instance._hold) {
            return;
        }

        if (loggedIn) {
            this.logging = true;

            firebaseClass.getXsollaAccessToken().then((result) => {
                if (StorageManager.instance._hold) {
                    return;
                }
                // Read result of the Cloud Function.
                if (!this.logging) {
                    return;
                }
                this.accessToken = result.data.token;

                // Xsolla.instance.items(result.data.token);
                this.getInventory();
            })
                .catch((error) => {
                    // Getting the Error details.
                    var code = error.code;
                    var message = error.message;
                    var details = error.details;
                    // ...
                    console.log(error, code, message, details);
                });
        } else {
            this.logging = false;
            this.loggedIn = false;
            delete this.accessToken;
            this.items.length = 0;
            this.currency.length = 0;
            this.coinsDifference = 0;
        }
    },

    getInventory: function () {
        if (!this.logging) {
            return;
        }

        var promiseItems = this.getItems();
        var promiseCurrency = this.getCurrency();

        Promise.all([promiseItems, promiseCurrency]).then(() => {
            if (!this.logging) {
                return;
            }

            if (StorageManager.instance._hold) {
                return;
            }

            this.compareData();
            this.loggedIn = true;
            this.fire('loggedIn');
            this.logging = false;
        });
    },

    updateInventory() {
        var promiseItems = this.getItems();
        var promiseCurrency = this.getCurrency();

        return Promise.all([promiseItems, promiseCurrency]);
    },

    setInventory(inventory) {
        if (!this.loggedIn) {
            this.once('loggedIn', this.setInventory.bind(this, inventory), this);
            return;
        }
        const keys = Object.keys(inventory);

        for (let i = 0; i < keys.length; i++) {
            const key = keys[i];

            const sku = Inventory.instance.getXsollaSKU(key);

            const item = this.findItem(sku);

            if (!item) {
                console.warn("nothing found", sku);
                continue;
            }

            const difference = inventory[key] - item.quantity;

            if (difference > 0) {
                this.setReward(sku, difference);
                this.giveReward = true;
            } else if (difference < 0) {
                this.setRevoke(sku, -difference);
                this.revokeReward = true;
            }
        }

        if (this.giveReward) {
            this.rewardUser();
        }

        if (this.revokeReward) {
            this.revokeUser(this.revokes);
        }
    },

    compareData: function () {
        this.compareCurrency(Xsolla.SKU.COINS, Inventory.ITEMS.COINS);

        // this.compareItem(Xsolla.SKU.COINS, Inventory.ITEMS.COINS);

        this.compareItem(Xsolla.SKU.GLOVES, Inventory.ITEMS.GLOVES);
        this.compareItem(Xsolla.SKU.SHOVEL, Inventory.ITEMS.SHOVEL);
        this.compareItem(Xsolla.SKU.BEEHIVE, Inventory.ITEMS.BEEHIVE);

        this.compareItem(Xsolla.SKU.BEES, Inventory.ITEMS.BEES);
        this.compareItem(Xsolla.SKU.LADYBUGS, Inventory.ITEMS.LADYBUGS);
        this.compareItem(Xsolla.SKU.BUTTERFLY, Inventory.ITEMS.BUTTERFLY);

        if (this.giveReward) {
            this.rewardUser();
        }
    },

    findItem: function (sku) {
        const item = this.items.find(item => item.sku === sku);

        return item;
    },

    findCurrency: function (sku) {
        const currency = this.currency.find(item => item.sku === sku);

        return currency;
    },

    setReward: function (sku, quantity) {
        let item = this.rewards.find(reward => reward.sku === sku);

        if (!item) {
            item = {
                sku: sku,
                quantity: quantity,
            };
            this.rewards.push(item);
        } else {
            item.quantity += quantity;
        }

        return this;
    },

    setRevoke: function (sku, quantity) {
        let item = this.revokes.find(revoke => revoke.sku === sku);

        if (!item) {
            item = {
                sku: sku,
                quantity: quantity,
            };
            this.revokes.push(item);
        } else {
            item.quantity += quantity;
        }

        return this;
    },

    compareCurrency: function (sku, inventoryKey) {
        const currency = this.findCurrency(sku) || { amount: 0 };

        const inventoryCurrency = Inventory.instance.getItem(inventoryKey);

        if (currency.amount === inventoryCurrency) {
            // Do nothing
        } else if (currency.amount > inventoryCurrency) {
            Inventory.instance.addItem(inventoryKey, currency.amount - inventoryCurrency);
        } else {
            this.setReward(sku, inventoryCurrency - currency.amount);
            this.giveReward = true;
        }
    },

    compareItem: function (sku, inventoryKey) {
        const item = this.findItem(sku) || { quantity: 0 };

        const quantity = Inventory.instance.getItem(inventoryKey);

        if (item.quantity === quantity) {
            // console.log("Do nothing");
        } else if (item.quantity > quantity) {
            Inventory.instance.addItem(inventoryKey, item.quantity - quantity);
        } else {
            this.setReward(sku, quantity - item.quantity);
            this.giveReward = true;
        }
    },

    getItems: function () {
        return fetch(this.path + 'user/inventory/items?platform=playstation_network', {
            method: 'GET', // *GET, POST, PUT, DELETE, etc.
            mode: 'cors', // no-cors, *cors, same-origin
            cache: 'no-cache', // *default, no-cache, reload, force-cache, only-if-cached
            credentials: 'same-origin', // include, *same-origin, omit
            headers: {
                'Content-Type': 'application/json',
                "authorization": "Bearer " + this.accessToken,
                // 'Content-Type': 'application/x-www-form-urlencoded',
            },
        }).then(response => {
            if (!response.ok) {
                throw new Error('Network response was not OK', response);
            }
            return response.json();
        })
            .then(responseJSON => {
                this.items = responseJSON.items;
            });
    },

    getCurrency: function () {
        return fetch(this.path + 'user/virtual_currency_balance?platform=playstation_network', {
            method: 'GET', // *GET, POST, PUT, DELETE, etc.
            mode: 'cors', // no-cors, *cors, same-origin
            cache: 'no-cache', // *default, no-cache, reload, force-cache, only-if-cached
            credentials: 'same-origin', // include, *same-origin, omit
            headers: {
                'Content-Type': 'application/json',
                "authorization": "Bearer " + this.accessToken,
                // 'Content-Type': 'application/x-www-form-urlencoded',
            },
        }).then(response => {
            if (!response.ok) {
                throw new Error('Network response was not OK', response);
            }
            return response.json();
        })
            .then(responseJSON => {
                if (responseJSON) {
                    this.currency = responseJSON.items;
                } else {
                    this.currency = [];
                }
            });
    },

    getVirtualCurrencyPackages: function () {
        fetch(this.path + 'items/virtual_currency/package', {
            method: 'GET', // *GET, POST, PUT, DELETE, etc.
            mode: 'cors', // no-cors, *cors, same-origin
            cache: 'no-cache', // *default, no-cache, reload, force-cache, only-if-cached
            credentials: 'same-origin', // include, *same-origin, omit
            // headers: {
            //     'Content-Type': 'application/json',
            //     // "authorization": "Bearer " + this.accessToken,
            //     // 'Content-Type': 'application/x-www-form-urlencoded',
            // },
        }).then(response => {
            if (!response.ok) {
                throw new Error('Network response was not OK', response);
            }

            return response.json();
        })
            .then(responseJSON => {
                this.virtualCurrencyPackages = responseJSON.items;
            });
    },

    getBundles: function () {
        fetch(this.path + 'items/bundle', {
            method: 'GET', // *GET, POST, PUT, DELETE, etc.
            mode: 'cors', // no-cors, *cors, same-origin
            cache: 'no-cache', // *default, no-cache, reload, force-cache, only-if-cached
            credentials: 'same-origin', // include, *same-origin, omit
            // headers: {
            //     'Content-Type': 'application/json',
            //     // "authorization": "Bearer " + this.accessToken,
            //     // 'Content-Type': 'application/x-www-form-urlencoded',
            // },
        }).then(response => {
            if (!response.ok) {
                throw new Error('Network response was not OK', response);
            }

            return response.json();
        })
            .then(responseJSON => {
                this.bundles = responseJSON.items;
            });
    },

    rewardUser: function () {
        if (this.rewards.length === 0) {
            return;
        }

        return firebaseClass.rewardUser(this.rewards).then((result) => {
            this.rewards.length = 0;
            this.updateInventory();
            // Read result of the Cloud Function.
            // if (!this.logging) {
            //     return;
            // }
            // this.accessToken = result.data.token;

            // Xsolla.instance.items(result.data.token);
            // this.getInventory();
        })
            .catch((error) => {
                // Getting the Error details.
                var code = error.code;
                var message = error.message;
                var details = error.details;
                // ...
                console.log(code, message);
            });
    },

    revokeUser: function (sku, quantity) {
        let item = null;

        if (Array.isArray(sku)) {
            item = sku;
        } else {
            item = [
                { sku: sku, quantity: quantity }
            ];
        }

        return firebaseClass.revokeUser(item).then((result) => {
            this.updateInventory();
        })
            .catch((error) => {
                // Getting the Error details.
                var code = error.code;
                var message = error.message;
                var details = error.details;
                // ...
                console.log(code, message);
            });
    },

    buyBundleWithVirtualCurrency: function (itemSKU = Xsolla.SKU_COINS.BEEHIVE) {
        if (!this.loggedIn) {
            return new Promise(resolve => resolve());
        }

        return fetch(this.path + 'payment/item/' + itemSKU + '/virtual/coins', {
            method: 'POST', // *GET, POST, PUT, DELETE, etc.
            mode: 'cors', // no-cors, *cors, same-origin
            cache: 'no-cache', // *default, no-cache, reload, force-cache, only-if-cached
            credentials: 'same-origin', // include, *same-origin, omit
            headers: {
                'Content-Type': 'application/json',
                "authorization": "Bearer " + this.accessToken,
                // 'Content-Type': 'application/x-www-form-urlencoded',
            },
        }).then(response => {
            if (!response.ok) {
                throw new Error('Network response was not OK', response);
            }
            return response.json();
        })
            .then(responseJSON => {
            }).catch(e => {
                console.log(e);
            });
    },

    getItemValue: function (sku, type) {
        switch (type) {
            case BuyItem.TYPES.BUNDLE:
                return this.bundles.find(bundle => bundle.sku === sku);
            case BuyItem.TYPES.VIRTUAL_CURRENCY_PACKAGE:
                return this.virtualCurrencyPackages.find(_package => _package.sku === sku);
            default:
                console.warn(type);
                break;
        }
    },

    consumeItem: function (sku, quantity = 1) {
        if (!this.loggedIn) {
            return new Promise(resolve => resolve());
        }

        console.warn(sku, quantity)

        if (this.extraItems[sku]) {
            const removeExtraItems = Math.min(quantity, this.extraItems[sku]);

            this.extraItems[sku] -= removeExtraItems;
            quantity -= removeExtraItems;
        }

        if (quantity <= 0) {
            return new Promise(resolve => resolve());
        }

        const body = {
            sku: sku,
            quantity: quantity,
            instance_id: null,
        };

        return fetch(this.path + 'user/inventory/item/consume', {
            method: 'POST', // *GET, POST, PUT, DELETE, etc.
            mode: 'cors', // no-cors, *cors, same-origin
            cache: 'no-cache', // *default, no-cache, reload, force-cache, only-if-cached
            credentials: 'same-origin', // include, *same-origin, omit
            headers: {
                'Content-Type': 'application/json',
                "authorization": "Bearer " + this.accessToken,
                // 'Content-Type': 'application/x-www-form-urlencoded',
            },
            body: JSON.stringify(body)
        })
            .then(response => {
                if (!response.ok) {
                    throw new Error('Network response was not OK', response);
                }
            })
            .catch(e => {
                console.log(e);
            });
    },

    buyItem: function (sku = Xsolla.SKU_CASH.BEEHIVE) {
        if (this.busy) {
            return;
        }

        this.busy = true;
        this.bought = false;
        this.status = false;
        this.sku = sku;

        var body = {
            "sandbox": this.sandbox,
            "quantity": 1,
            "settings": {
                "ui": {
                    "size": "large",
                    "theme": this.getTheme(),
                    // "version": "mobile",
                    "desktop": {
                        "header": {
                            "is_visible": true,
                            "visible_logo": true,
                            "visible_name": true,
                            "visible_purchase": true,
                            "type": "normal",
                            "close_button": false
                        }
                    },
                    "mobile": {
                        "footer": {
                            "is_visible": true
                        },
                        "header": {
                            "close_button": true
                        }
                    }
                },
                "redirect_policy": {
                    "redirect_conditions": 'none',
                    "status_for_manual_redirection": 'successful_or_canceled',
                    "autoredirect_from_status_page": true,
                    "manual_redirection_action": "postmessage",
                }
            },
        };

        const data = {
            method: 'POST', // *GET, POST, PUT, DELETE, etc.
            mode: 'cors', // no-cors, *cors, same-origin
            cache: 'no-cache', // *default, no-cache, reload, force-cache, only-if-cached
            credentials: 'same-origin', // include, *same-origin, omit
            headers: {
                'Content-Type': 'application/json',
                // 'Content-Type': 'application/x-www-form-urlencoded',
            },
            body: JSON.stringify(body)
        };

        if (this.accessToken) {
            data.headers.authorization = "Bearer " + this.accessToken;
        }

        return new Promise((resolve, reject) => {
            var onResolve = function () {
                resolve(this.bought);

                this.off('bought', onResolve, this);
            };

            fetch('https://store.xsolla.com/api/v2/project/175509/payment/item/' + sku, data)
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Network response was not OK', response);
                    }
                    return response.json();
                })
                .then(responseJSON => {
                    var options = {
                        access_token: responseJSON.token,
                        iframeOnly: true,
                        sandbox: this.sandbox, //TODO please do not forget to remove this setting when going live
                        lightbox: {
                            contentMargin: "10px",
                            contentBackground: "#00ff00",
                            closeByClick: true,
                            closeByKeyboard: true,
                        },
                    };

                    XPayStationWidget.init(options);
                    XPayStationWidget.open();

                    this.on('closed', onResolve, this);
                }).catch(e => {
                    reject(e);
                })
                .finally(() => {
                    this.off('bought', onResolve, this);
                    this.busy = false;
                });
        });
    },

    getTheme: function () {
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            return "default_dark";
        }

        return 'default';
    }
});

Xsolla.SKU_CASH = Object.freeze({
    STARTER_PACK: 'starter_pack',
    APPRENTICE_PACK: 'apprentice_pack',
    PRO_PACK: 'pro_pack',
    VETERAN_PACK: 'veteran_pack',
    MASTER_PACK: 'master_pack',
    CHAMPION_PACK: 'champion_pack',
    COINS_1000: 'coins_1000',
    COINS_5500: 'coins_5500',
    COINS_12000: 'coins_12000',
    COINS_25000: 'coins_25000',
    COINS_53000: 'coins_53000',
    COINS_110000: 'coins_110000',
});

Xsolla.SKU_COINS = Object.freeze({
    BEES: 'bundle_bees',
    LADYBUGS: 'bundle_ladybugs',
    BUTTERFLY: 'bundle_butterfly',
    GLOVES: 'bundle_gloves',
    SHOVEL: 'bundle_shovel',
    BEEHIVE: 'bundle_beehive',
});

Xsolla.SKU = Object.freeze({
    BEES: 'prebooster_bees',
    LADYBUGS: 'prebooster_ladybugs',
    BUTTERFLY: 'prebooster_butterflies',
    GLOVES: 'booster_gloves',
    SHOVEL: 'booster_shovel',
    BEEHIVE: 'booster_beehive',
    COINS: 'coins',
});



// LivesManager.js
var LivesManager = pc.createScript('livesManager');

LivesManager.attributes.add('maxLives', { type: 'number', default: 3 });
LivesManager.attributes.add('hoursToRegenerate', { type: 'number', default: 3 });

pc.extend(LivesManager.prototype, {
    postInitialize: function () {
        LivesManager.instance = this;

        this.getData();

        this.secondsToRegenerate = this.hoursToRegenerate * 60 * 60;

        this.checkRegeneration();
    },

    getData: function () {
        this.data = StorageManager.instance.get('lives');

        // Data validation
        if (typeof this.data !== 'object') {
            this.data = { lives: 3, time: 0 };
        } else {
            if (typeof this.data.lives !== 'number') {
                this.data.lives = 3;
            }

            if (typeof this.data.time !== 'number') {
                this.data.time = 0;
            }
        }
    },

    checkRegeneration: function () {
        if (this.hasMaxLives()) {
            return;
        }

        const loggedInTime = this.getBrowserTime();

        if (loggedInTime < (this.data.time - this.secondsToRegenerate)) {
            console.log("cheated?", loggedInTime, this.data.time, this.secondsToRegenerate);
        }

        let currentLives = this.data.lives;
        let livesIncrease = 0;
        let currentTime = this.data.time;

        while (loggedInTime >= currentTime) {
            // this.regenerateLife();

            // if (this.hasMaxLives()) {
            //     break;
            // }
            livesIncrease++

            if (this.data.lives + livesIncrease >= this.maxLives) {
                break
            } else {
                currentTime += this.secondsToRegenerate;
            }
        }

        if (livesIncrease > 0) {
            this.regenerateLife(livesIncrease)

            this.save();
        }
    },

    update: function () {
        if (this.hasMaxLives()) {
            return;
        }

        this.timeTillRegeneration = this.data.time - this.getBrowserTime();

        if (this.timeTillRegeneration <= 0) {
            this.regenerateLife();
            this.save();
            this.fire('regenerated', this.data.lives, this.data.time);
        }
    },

    getTimeTillRegeneration: function () {
        return this.timeTillRegeneration;
    },

    regenerateLife: function (amount = 1) {
        this.data.lives = pc.math.clamp(this.data.lives + amount, 0, this.maxLives);

        Wrapper.instance.sendGAEvent(Wrapper.GA_EVENT_TYPE.RESOURCE, {
            flowType: 'source',
            itemType: 'continuity',
            itemId: 'overTime',
            amount: amount,
            resourceCurrency: 'life'
        });

        if (this.hasMaxLives()) {
            this.data.time = 0;
        } else {
            this.data.time += this.secondsToRegenerate * amount;
        }
    },

    hasLives: function () {
        return this.data.lives > 0;
    },

    hasMaxLives: function (lives = this.data.lives) {
        return lives === this.maxLives;
    },

    getLives: function () {
        return this.data.lives;
    },

    reduceLife: function (amount = 1, itemId) {
        if (!this.hasLives()) {
            return;
        }

        if (this.hasMaxLives()) {
            this.startTimer();
        }

        this.data.lives = pc.math.clamp(this.data.lives - amount, 0, this.maxLives);

        Wrapper.instance.sendGAEvent(Wrapper.GA_EVENT_TYPE.RESOURCE, {
            flowType: 'sink',
            itemType: 'continuity',
            itemId,
            amount,
            resourceCurrency: 'life'
        });

        this.save();
    },

    /**
     * Use this to increase life with items or other way.
     */
    increaseLife: function (amount = 1, itemType, itemId) {
        if (typeof amount !== 'number') {
            amount = 1;
        }
        const livesIncrease = pc.math.clamp(amount, 0, this.maxLives - this.data.lives);

        this.data.lives = pc.math.clamp(this.data.lives + amount, 0, this.maxLives);

        if (this.hasMaxLives()) {
            this.data.time = 0;
        }

        Wrapper.instance.sendGAEvent(Wrapper.GA_EVENT_TYPE.RESOURCE, {
            flowType: 'source',
            itemType,
            itemId,
            amount: livesIncrease,
            resourceCurrency: 'life'
        })

        this.save();

        this.fire('regenerated', this.data.lives, this.data.time);
    },

    startTimer: function () {
        this.data.time = this.getBrowserTime() + this.secondsToRegenerate;
    },

    getBrowserTime: function () {
        return Date.now() / 1000;
    },

    save: function () {
        StorageManager.instance.set('lives', this.data);
    },
});


// ToggleElementPerScreen.js
var ToggleElementPerScreen = pc.createScript('toggleElementPerScreen');

ToggleElementPerScreen.attributes.add('screensToDisableOn', { type: 'string', array: true });
ToggleElementPerScreen.attributes.add('screensToIgnore', { type: 'string', array: true, default: ['loading'] });

ToggleElementPerScreen.attributes.add('debug', { type: 'boolean' });

pc.extend(ToggleElementPerScreen.prototype, {
    initialize: function () {
        UIManager.instance.on('showUI', this.onScreenOpen, this);
        UIManager.instance.on('hideUI', this.onScreenClose, this);


        this.onState(this.entity.enabled);

        this.on('state', this.onState, this);
    },

    onState: function (enabled) {
        if (enabled) {
            this.app.on('ToggleElementPerScreen:update', this.updateState, this);
        } else {
            this.app.off('ToggleElementPerScreen:update', this.updateState, this);
        }
    },

    onScreenOpen: function (screen) {

        if (this.screensToIgnore.includes(screen)) {
            return;
        }

        if (this.debug) {
            console.log(screen)
        }

        this.entity.enabled = !this.screensToDisableOn.includes(screen);
    },

    onScreenClose: function () {
        this.updateState();
    },

    updateState: function () {
        const screen = UIManager.instance.getTopStack('Screen');

        if (this.screensToIgnore.includes(screen)) {
            return;
        }

        if (this.debug) {
            console.log(screen);
        }

        if (screen instanceof pc.Entity) {
            const uiEntity = screen.script.get('uiEntity');

            if (uiEntity) {
                this.onScreenOpen(uiEntity.name);
            }
        }
    }
});

// SkipCameraIntroButton.js
var SkipCameraIntroButton = pc.createScript('skipCameraIntroButton');

pc.extend(SkipCameraIntroButton.prototype, {
    initialize: function() {
        this.entity.script.elementInput.on('click', this.fireEvent, this);
    },

    fireEvent: function() {
        this.app.fire('CameraAnimation:skip');
    }
});


// NoMoreLivesScreen.js
var NoMoreLivesScreen = pc.createScript('noMoreLivesScreen');

NoMoreLivesScreen.attributes.add('emptyEntities', { type: 'entity', array: true });
NoMoreLivesScreen.attributes.add('normalEntities', { type: 'entity', array: true });

NoMoreLivesScreen.attributes.add('lucyEntities', { type: 'entity', array: true });

NoMoreLivesScreen.attributes.add('emptyLucySprite', { type: 'asset', assetType: 'sprite' });
NoMoreLivesScreen.attributes.add('normalLucySprite', { type: 'asset', assetType: 'sprite' });

NoMoreLivesScreen.attributes.add('heartAmountText', { type: 'entity' });
NoMoreLivesScreen.attributes.add('refillText', { type: 'entity' });

NoMoreLivesScreen.attributes.add('title', { type: 'entity' });
NoMoreLivesScreen.attributes.add('timer', { type: 'entity' });
NoMoreLivesScreen.attributes.add('refillButton', { type: 'entity' });
NoMoreLivesScreen.attributes.add('nextLifeGroup', { type: 'entity' });

pc.extend(NoMoreLivesScreen.prototype, {
    initialize: function () {
        this.timerText = '';

        this.refillButton.script.elementInput.on('click', this.onRefillButtonClicked, this);
    },

    update: function () {
        if (this.maxLives) {
            return;
        }

        const timerText = pc.utils.millisecondsToTimeFormat(LivesManager.instance.timeTillRegeneration * 1000);

        if (timerText === this.timerText) {
            return;
        }

        this.timer.element.text = timerText;

        this.timerText = timerText;
    },

    onUIEntityOpen: function () {
        LivesManager.instance.on('regenerated', this.checkState, this);

        this.checkState();
    },

    onUIEntityClose: function () {
        LivesManager.instance.off('regenerated', this.checkState, this);
    },

    checkState: function () {
        const lives = LivesManager.instance.getLives();
        this.maxLives = LivesManager.instance.hasMaxLives();
        const isEmpty = !LivesManager.instance.hasLives();

        this.heartAmountText.element.text = lives;

        this.setState(isEmpty);
    },

    setState: function (isEmpty) {
        this.emptyEntities.forEach(entity => entity.enabled = isEmpty);
        this.normalEntities.forEach(entity => entity.enabled = !isEmpty);

        this.lucyEntities.forEach((entity) => {
            this.changeSprite(entity, isEmpty);
        });

        this.nextLifeGroup.enabled = !this.maxLives;

        this.title.element.key = isEmpty ? 'NO_MORE_LIVES_TITLE' : 'REFILL_LIVES_TITLE';

        this.refillText.element.color = isEmpty ? NoMoreLivesScreen.WHITE_COLOR : NoMoreLivesScreen.GREY_COLOR;

        this.refillButton.button.active = !this.maxLives;
    },

    changeSprite: function (entity, isEmpty) {
        const asset = isEmpty ? this.emptyLucySprite : this.normalLucySprite;
        entity.element.spriteAsset = asset;

        var imageSize = asset.resource.atlas.frames[asset.resource.frameKeys[0]].rect;
        entity.element.width = imageSize.z;
        entity.element.height = imageSize.w;
    },

    onRefillButtonClicked: function () {
        const success = Inventory.instance.tryPayItem('COINS', NoMoreLivesScreen.PRICE, 'purchase', 'lives');

        if (success) {
            this.app.fire('Audio:sfx', 'coin_pay.mp3');
            if (Xsolla.instance.loggedIn) {
                Xsolla.instance.revokeUser(Inventory.instance.getXsollaSKU('COINS'), NoMoreLivesScreen.PRICE);
            }

            // Inventory.instance.tryPayItem('COINS', NoMoreLivesScreen.PRICE);
            LivesManager.instance.increaseLife(LivesManager.instance.maxLives, 'purchase', 'refillLives');
            this.app.fire('CoinInterface:updateCoins');
        } else {
            this.app.fire('UIManager:showUI', 'Shop');
        }
    },
});
NoMoreLivesScreen.PRICE = 900;
NoMoreLivesScreen.WHITE_COLOR = new pc.Color(1, 1, 1);
NoMoreLivesScreen.GREY_COLOR = new pc.Color(116 / 255, 98 / 255, 76 / 255);


// widget.min.js
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.XPayStationWidget = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
module.exports = function (css, customDocument) {
  var doc = customDocument || document;
  if (doc.createStyleSheet) {
    var sheet = doc.createStyleSheet()
    sheet.cssText = css;
    return sheet.ownerNode;
  } else {
    var head = doc.getElementsByTagName('head')[0],
        style = doc.createElement('style');

    style.type = 'text/css';

    if (style.styleSheet) {
      style.styleSheet.cssText = css;
    } else {
      style.appendChild(doc.createTextNode(css));
    }

    head.appendChild(style);
    return style;
  }
};

module.exports.byUrl = function(url) {
  if (document.createStyleSheet) {
    return document.createStyleSheet(url).ownerNode;
  } else {
    var head = document.getElementsByTagName('head')[0],
        link = document.createElement('link');

    link.rel = 'stylesheet';
    link.href = url;

    head.appendChild(link);
    return link;
  }
};

},{}],2:[function(require,module,exports){
module.exports = require('cssify');
},{"cssify":1}],3:[function(require,module,exports){
(function (global){
var Helpers = require('./helpers');
var Exception = require('./exception');
var LightBox = require('./lightbox');
var ChildWindow = require('./childwindow');
var Device = require('./device');

module.exports = (function () {
    function ready(fn) {
        if (document.readyState !== 'loading'){
          fn();
        } else {
          document.addEventListener('DOMContentLoaded', fn);
        }
    }

    function App() {
        this.config = Object.assign({}, DEFAULT_CONFIG);
        this.eventObject = Helpers.addEventObject(this);
        this.isInitiated = false;
        this.postMessage = null;
    }

    App.eventTypes = {
        INIT: 'init',
        OPEN: 'open',
        OPEN_WINDOW: 'open-window',
        OPEN_LIGHTBOX: 'open-lightbox',
        LOAD: 'load',
        CLOSE: 'close',
        CLOSE_WINDOW: 'close-window',
        CLOSE_LIGHTBOX: 'close-lightbox',
        STATUS: 'status',
        STATUS_INVOICE: 'status-invoice',
        STATUS_DELIVERING: 'status-delivering',
        STATUS_TROUBLED: 'status-troubled',
        STATUS_DONE: 'status-done',
        USER_COUNTRY: 'user-country'
    };

    var DEFAULT_CONFIG = {
        access_token: null,
        access_data: null,
        sandbox: false,
        lightbox: {},
        childWindow: {},
        host: 'secure.xsolla.com',
        iframeOnly: false
    };
    var SANDBOX_PAYSTATION_URL = 'https://sandbox-secure.xsolla.com/paystation2/?';
    var EVENT_NAMESPACE = '.xpaystation-widget';
    var ATTR_PREFIX = 'data-xpaystation-widget-open';

    /** Private Members **/
    App.prototype.config = {};
    App.prototype.isInitiated = false;
    App.prototype.eventObject = Helpers.addEventObject(this);

    App.prototype.getPaymentUrl = function () {
        if (this.config.payment_url) {
            return this.config.payment_url;
        }

        const query = {};
        if (this.config.access_token) {
            query.access_token = this.config.access_token;
        } else {
            query.access_data = JSON.stringify(this.config.access_data);
        }

        const urlWithoutQueryParams = this.config.sandbox ?
            SANDBOX_PAYSTATION_URL :
            'https://' + this.config.host + '/paystation2/?';
        return urlWithoutQueryParams + Helpers.param(query);
    };

    App.prototype.checkConfig = function () {
        if (Helpers.isEmpty(this.config.access_token) && Helpers.isEmpty(this.config.access_data) && Helpers.isEmpty(this.config.payment_url)) {
            this.throwError('No access token or access data or payment URL given');
        }

        if (!Helpers.isEmpty(this.config.access_data) && typeof this.config.access_data !== 'object') {
            this.throwError('Invalid access data format');
        }

        if (Helpers.isEmpty(this.config.host)) {
            this.throwError('Invalid host');
        }
    };

    App.prototype.checkApp = function () {
        if (this.isInitiated === undefined) {
            this.throwError('Initialize widget before opening');
        }
    };

    App.prototype.throwError = function (message) {
        throw new Exception(message);
    };

    App.prototype.triggerEvent = function (eventName, data) {
        if (arguments.length === 1) {
            [].forEach.call(arguments, (function (eventName) {
                var event = document.createEvent('HTMLEvents');
                event.initEvent(eventName, true, false);
                document.dispatchEvent(event);
            }).bind(this));
        } else {
            this.eventObject.trigger(eventName, data);
        }
    };

    App.prototype.triggerCustomEvent = function (eventName, data) {
        try {
            var event = new CustomEvent(eventName, {detail: data}); // Not working in IE
        } catch(e) {
            var event = document.createEvent('CustomEvent');
            event.initCustomEvent(eventName, true, true, data);
        }
        document.dispatchEvent(event);
    };

    /**
     * Initialize widget with options
     * @param options
     */
    App.prototype.init = function(options) {
        function initialize(options) {
            this.isInitiated = true;
            this.config = Object.assign({}, DEFAULT_CONFIG, options);

            var bodyElement = global.document.body;
            var clickEventName = 'click' + EVENT_NAMESPACE;

            var handleClickEvent = (function(event) {
                var targetElement = document.querySelector('[' + ATTR_PREFIX + ']');
                if (event.sourceEvent.target === targetElement) {
                    this.open.call(this, targetElement);
                }
            }).bind(this);

            bodyElement.removeEventListener(clickEventName, handleClickEvent);

            var clickEvent = document.createEvent('Event');
            clickEvent.initEvent(clickEventName, false, true);

            bodyElement.addEventListener('click', (function(event) {
                clickEvent.sourceEvent = event;
                bodyElement.dispatchEvent(clickEvent);
            }).bind(this), false);

            bodyElement.addEventListener(clickEventName, handleClickEvent);
            this.triggerEvent(App.eventTypes.INIT);
        }
        ready(initialize.bind(this, options));
    }

    /**
     * Open payment interface (PayStation)
     */
    App.prototype.open = function () {
        this.checkConfig();
        this.checkApp();

        var triggerSplitStatus = (function (data) {
            switch (((data || {}).paymentInfo || {}).status) {
                case 'invoice':
                    this.triggerEvent(App.eventTypes.STATUS_INVOICE, data);
                    break;
                case 'delivering':
                    this.triggerEvent(App.eventTypes.STATUS_DELIVERING, data);
                    break;
                case 'troubled':
                    this.triggerEvent(App.eventTypes.STATUS_TROUBLED, data);
                    break;
                case 'done':
                    this.triggerEvent(App.eventTypes.STATUS_DONE, data);
                    break;
            }
        }).bind(this);

        var url = this.getPaymentUrl();
        var that = this;

        function handleStatus(event) {
            var statusData = event.detail;
            that.triggerEvent(App.eventTypes.STATUS, statusData);
            triggerSplitStatus(statusData);
        }

        function handleUserLocale(event) {
            var userCountry = {
                user_country: event.detail.user_country
            };
            that.triggerCustomEvent(App.eventTypes.USER_COUNTRY, userCountry);
        }

        this.postMessage = null;
        if ((new Device).isMobile() && !this.config.iframeOnly) {
            var childWindow = new ChildWindow;
            childWindow.on('open', function handleOpen() {
                that.postMessage = childWindow.getPostMessage();
                that.triggerEvent(App.eventTypes.OPEN);
                that.triggerEvent(App.eventTypes.OPEN_WINDOW);
                childWindow.off('open', handleOpen);
            });
            childWindow.on('load', function handleLoad() {
                that.triggerEvent(App.eventTypes.LOAD);
                childWindow.off('load', handleLoad);
            });
            childWindow.on('close', function handleClose() {
                that.triggerEvent(App.eventTypes.CLOSE);
                that.triggerEvent(App.eventTypes.CLOSE_WINDOW);
                childWindow.off('status', handleStatus);
                childWindow.off(App.eventTypes.USER_COUNTRY, handleUserLocale);
                childWindow.off('close', handleClose);
            });
            childWindow.on('status', handleStatus);
            childWindow.on(App.eventTypes.USER_COUNTRY, handleUserLocale);
            childWindow.open(url, this.config.childWindow);

            this.widget = childWindow;
        } else {
            var lightBox = new LightBox((new Device).isMobile() && this.config.iframeOnly);
            lightBox.on('open', function handleOpen() {
                that.postMessage = lightBox.getPostMessage();
                that.triggerEvent(App.eventTypes.OPEN);
                that.triggerEvent(App.eventTypes.OPEN_LIGHTBOX);
                lightBox.off('open', handleOpen);
            });
            lightBox.on('load', function handleLoad() {
                that.triggerEvent(App.eventTypes.LOAD);
                lightBox.off('load', handleLoad);
            });
            lightBox.on('close', function handleClose() {
                that.triggerEvent(App.eventTypes.CLOSE);
                that.triggerEvent(App.eventTypes.CLOSE_LIGHTBOX);
                lightBox.off('status', handleStatus);
                lightBox.off(App.eventTypes.USER_COUNTRY, handleUserLocale);
                lightBox.off('close', handleClose);
            });
            lightBox.on('status', handleStatus);
            lightBox.on(App.eventTypes.USER_COUNTRY, handleUserLocale);
            lightBox.openFrame(url, this.config.lightbox);

            this.widget = lightBox;
        }
    };

    App.prototype.close = function() {
      try {
        if (this.widget) {
          if (this.widget instanceof ChildWindow) {
            this.widget.close();
          } else if (this.widget instanceof LightBox) {
            this.widget.closeFrame();
          }
          delete this.widget;
        }
      } catch(e) {
        console.log(e);
      }
    };

    /**
     * Attach an event handler function for one or more events to the widget
     * @param event One or more space-separated event types (init, open, load, close, status, status-invoice, status-delivering, status-troubled, status-done)
     * @param handler A function to execute when the event is triggered
     */
    App.prototype.on = function (event, handler, options) {
        if (typeof handler !== 'function') {
            return;
        }

        const handlerDecorator = function(event) {
            handler(event, event.detail);
        }

        this.eventObject.on(event, handlerDecorator, options);
    };

    /**
     * Remove an event handler
     * @param event One or more space-separated event types
     * @param handler A handler function previously attached for the event(s)
     */
    App.prototype.off = function (event, handler, options) {
        this.eventObject.off(event, handler, options);
    };

    /**
     * Send a message directly to PayStation
     * @param command
     * @param data
     */
    App.prototype.sendMessage = function (command, data) {
        if (this.postMessage) {
            this.postMessage.send.apply(this.postMessage, arguments);
        }
    };

    /**
     * Attach an event handler function for message event from PayStation
     * @param command
     * @param handler
     */
    App.prototype.onMessage = function (command, handler) {
        if (this.postMessage) {
            this.postMessage.on.apply(this.postMessage, arguments);
        }
    };

    return App;
})();

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./childwindow":4,"./device":5,"./exception":6,"./helpers":7,"./lightbox":8}],4:[function(require,module,exports){
(function (global){
var version = require('./version');
var Helpers = require('./helpers');
var PostMessage = require('./postmessage');

module.exports = (function () {
    function ChildWindow() {
        this.eventObject = Helpers.addEventObject(this, wrapEventInNamespace);
        this.message = null;
    }

    function wrapEventInNamespace(eventName) {
        return ChildWindow._NAMESPACE + '_' + eventName;
    }

    var DEFAULT_OPTIONS = {
        target: '_blank'
    };

    /** Private Members **/
    ChildWindow.prototype.eventObject = null;
    ChildWindow.prototype.childWindow = null;

    ChildWindow.prototype.triggerEvent = function (event, data) {
        this.eventObject.trigger(event, data);
    };

    /** Public Members **/
    ChildWindow.prototype.open = function (url, options) {
        options = Object.assign({}, DEFAULT_OPTIONS, options);

        if (this.childWindow && !this.childWindow.closed) {
            this.childWindow.location.href = url;
        }

        var that = this;
        var addHandlers = function () {
            that.on('close', function handleClose() {
                if (timer) {
                    global.clearTimeout(timer);
                }
                if (that.childWindow) {
                    that.childWindow.close();
                }

                that.off('close', handleClose)
            });

            // Cross-window communication
            that.message = new PostMessage(that.childWindow);
            that.message.on('dimensions widget-detection', function handleWidgetDetection() {
                that.triggerEvent('load');
                that.message.off('dimensions widget-detection', handleWidgetDetection);
            });
            that.message.on('widget-detection', function handleWidgetDetection() {
                that.message.send('widget-detected', {version: version, childWindowOptions: options});
                that.message.off('widget-detection', handleWidgetDetection);
            });
            that.message.on('status', function (event) {
                that.triggerEvent('status', event.detail);
            });
            that.on('close', function handleClose() {
                that.message.off();
                that.off('close', handleClose);
            });
            that.message.on('user-country', function (event) {
                that.triggerEvent('user-country', event.detail);
            });
        };

        switch (options.target) {
            case '_self':
                this.childWindow = global.window;
                addHandlers();
                this.childWindow.location.href = url;
                break;
            case '_parent':
                this.childWindow = global.window.parent;
                addHandlers();
                this.childWindow.location.href = url;
                break;
            case '_blank':
            default:
                this.childWindow = global.window.open(url);
                this.childWindow.focus();
                addHandlers();

                var checkWindow = (function () {
                    if (this.childWindow) {
                        if (this.childWindow.closed) {
                            this.triggerEvent('close');
                        } else {
                            timer = global.setTimeout(checkWindow, 100);
                        }
                    }
                }).bind(this);
                var timer = global.setTimeout(checkWindow, 100);
                break;
        }

        this.triggerEvent('open');
    };

    ChildWindow.prototype.close = function () {
        this.triggerEvent('close');
    };

    ChildWindow.prototype.on = function (event, handler, options) {
        if (typeof handler !== 'function') {
            return;
        }

        this.eventObject.on(event, handler, options);
    };

    ChildWindow.prototype.off = function (event, handler, options) {
        this.eventObject.off(event, handler, options);
    };

    ChildWindow.prototype.getPostMessage = function () {
        return this.message;
    };

    ChildWindow._NAMESPACE = 'CHILD_WINDOW';

    return ChildWindow;
})();

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./helpers":7,"./postmessage":10,"./version":14}],5:[function(require,module,exports){
var bowser = require('bowser');

module.exports = (function () {
    function Device() {
    }

    /**
     * Mobile devices
     * @returns {boolean}
     */
    Device.prototype.isMobile = function() {
        return bowser.mobile || bowser.tablet;
    };

    return Device;
})();

},{"bowser":"bowser"}],6:[function(require,module,exports){
module.exports = function (message) {
    this.message = message;
    this.name = "XsollaPayStationWidgetException";
    this.toString = (function () {
        return this.name + ': ' + this.message;
    }).bind(this);
};

},{}],7:[function(require,module,exports){
function isEmpty(value) {
  return value === null || value === undefined;
}

function uniq(list) {
  return list.filter(function(x, i, a) {
    return a.indexOf(x) == i
  });
}

function zipObject(props, values) {
  var index = -1,
      length = props ? props.length : 0,
      result = {};

  if (length && !values && !Array.isArray(props[0])) {
    values = [];
  }
  while (++index < length) {
    var key = props[index];
    if (values) {
      result[key] = values[index];
    } else if (key) {
      result[key[0]] = key[1];
    }
  }
  return result;
}

function param(a) {
  var s = [];

  var add = function (k, v) {
      v = typeof v === 'function' ? v() : v;
      v = v === null ? '' : v === undefined ? '' : v;
      s[s.length] = encodeURIComponent(k) + '=' + encodeURIComponent(v);
  };

  var buildParams = function (prefix, obj) {
      var i, len, key;

      if (prefix) {
          if (Array.isArray(obj)) {
              for (i = 0, len = obj.length; i < len; i++) {
                  buildParams(
                      prefix + '[' + (typeof obj[i] === 'object' && obj[i] ? i : '') + ']',
                      obj[i]
                  );
              }
          } else if (String(obj) === '[object Object]') {
              for (key in obj) {
                  buildParams(prefix + '[' + key + ']', obj[key]);
              }
          } else {
              add(prefix, obj);
          }
      } else if (Array.isArray(obj)) {
          for (i = 0, len = obj.length; i < len; i++) {
              add(obj[i].name, obj[i].value);
          }
      } else {
          for (key in obj) {
              buildParams(key, obj[key]);
          }
      }
      return s;
  };

  return buildParams('', a).join('&');
};


function once(f) {
  return function() {
      f(arguments);
      f = function() {};
  }
}

function addEventObject(context, wrapEventInNamespace) {
    var dummyWrapper = function(event) { return event };
    var wrapEventInNamespace = wrapEventInNamespace || dummyWrapper;
    var eventsList = [];

    function isStringContainedSpace(str) {
      return / /.test(str)
    }

    return {
      trigger: (function(eventName, data) {
          var eventInNamespace = wrapEventInNamespace(eventName);
          try {
              var event = new CustomEvent(eventInNamespace, {detail: data}); // Not working in IE
          } catch(e) {
              var event = document.createEvent('CustomEvent');
              event.initCustomEvent(eventInNamespace, true, true, data);
          }
          document.dispatchEvent(event);
      }).bind(context),
      on: (function(eventName, handle, options) {

        function addEvent(eventName, handle, options) {
          var eventInNamespace = wrapEventInNamespace(eventName);
          document.addEventListener(eventInNamespace, handle, options);
          eventsList.push({name: eventInNamespace, handle: handle, options: options });
        }

        if (isStringContainedSpace(eventName)) {
          var events = eventName.split(' ');
          events.forEach(function(parsedEventName) {
            addEvent(parsedEventName, handle, options)
          })
        } else {
          addEvent(eventName, handle, options);
        }

      }).bind(context),

      off: (function(eventName, handle, options) {
        const offAllEvents = !eventName && !handle && !options;

        if (offAllEvents) {
          eventsList.forEach(function(event) {
            document.removeEventListener(event.name, event.handle, event.options);
          });
          return;
        }

        function removeEvent(eventName, handle, options) {
          var eventInNamespace = wrapEventInNamespace(eventName);
          document.removeEventListener(eventInNamespace, handle, options);
          eventsList = eventsList.filter(function(event) {
            return event.name !== eventInNamespace;
          });
        }

        if (isStringContainedSpace(eventName)) {
          var events = eventName.split(' ');
          events.forEach(function(parsedEventName) {
            removeEvent(parsedEventName, handle, options)
          })
        } else {
          removeEvent(eventName, handle, options);
        }

      }).bind(context)
  };
}

module.exports = {
  addEventObject: addEventObject,
  isEmpty: isEmpty,
  uniq: uniq,
  zipObject: zipObject,
  param: param,
  once: once,
}

},{}],8:[function(require,module,exports){
(function (global){
var version = require('./version');
var Helpers = require('./helpers');
var PostMessage = require('./postmessage');

module.exports = (function () {
    function LightBox(isMobile) {
        require('./styles/lightbox.scss');
        this.eventObject = Helpers.addEventObject(this, wrapEventInNamespace);
        this.options = isMobile ? DEFAULT_OPTIONS_MOBILE : DEFAULT_OPTIONS;
        this.message = null;
    }

    var CLASS_PREFIX = 'xpaystation-widget-lightbox';
    var COMMON_OPTIONS = {
        zIndex: 1000,
        overlayOpacity: '.6',
        overlayBackground: '#000000',
        contentBackground: '#ffffff',
        closeByKeyboard: true,
        closeByClick: true,
        modal: false,
        spinner: 'xsolla',
        spinnerColor: null,
        spinnerUrl: null,
        spinnerRotationPeriod: 0
    };
    var DEFAULT_OPTIONS = Object.assign({}, COMMON_OPTIONS, {
        width: null,
        height: '100%',
        contentMargin: '10px'
    });
    var DEFAULT_OPTIONS_MOBILE = Object.assign({}, COMMON_OPTIONS, {
        width: '100%',
        height: '100%', 
        contentMargin: '0px'
    });

    var SPINNERS = {
        xsolla: require('./spinners/xsolla.svg'),
        round: require('./spinners/round.svg'),
        none: ' '
    };

    var MIN_PS_DIMENSIONS = {
        height: 500,
        width: 600
    };

    var handleKeyupEventName = wrapEventInNamespace('keyup');
    var handleResizeEventName = wrapEventInNamespace('resize');

    var handleGlobalKeyup = function(event) {

        var clickEvent = document.createEvent('Event');
        clickEvent.initEvent(handleKeyupEventName, false, true);
        clickEvent.sourceEvent = event;

        document.body.dispatchEvent(clickEvent);
    }

    var handleSpecificKeyup = function(event) {
        if (event.sourceEvent.which == 27) {
            this.closeFrame();
        }
    }

    var handleGlobalResize = function() {
        var resizeEvent = document.createEvent('Event');
        resizeEvent.initEvent(handleResizeEventName, false, true);

        window.dispatchEvent(resizeEvent);
    }

    function wrapEventInNamespace(eventName) {
        return LightBox._NAMESPACE + '_' + eventName;
    }

    /** Private Members **/
    LightBox.prototype.triggerEvent = function () {
        this.eventObject.trigger.apply(this.eventObject, arguments);
    };

    LightBox.prototype.measureScrollbar = function () { // thx walsh: https://davidwalsh.name/detect-scrollbar-width
        var scrollDiv = document.createElement("div");
        scrollDiv.classList.add("scrollbar-measure");
        scrollDiv.setAttribute("style",
            "position: absolute;" +
            "top: -9999px" +
            "width: 50px" +
            "height: 50px" +
            "overflow: scroll"
        );

        document.body.appendChild(scrollDiv);

        var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
        document.body.removeChild(scrollDiv);

        return scrollbarWidth;
    };

    /** Public Members **/
    LightBox.prototype.openFrame = function (url, options) {
        this.options = Object.assign({}, this.options, options);
        var HandleBoundSpecificKeyup = handleSpecificKeyup.bind(this);
        options = this.options;

        var spinner = options.spinner === 'custom' && !!options.spinnerUrl ?
            '<img class="spinner-custom" src="' + encodeURI(options.spinnerUrl) + '" />' : SPINNERS[options.spinner] || Object.values(SPINNERS)[0];

        var template = function (settings) {
            var host = document.createElement('div');
            host.className = settings.prefix;

            var overlay = document.createElement('div');
            overlay.className = settings.prefix + '-overlay';

            var content = document.createElement('div');
            content.className = settings.prefix + '-content' + ' ' + settings.prefix + '-content__hidden';

            var iframe = document.createElement('iframe');
            iframe.className = settings.prefix + '-content-iframe';
            iframe.src = settings.url;
            iframe.frameBorder = '0';
            iframe.allowFullscreen = true;

            var spinner = document.createElement('div');
            spinner.className = settings.prefix + '-spinner';
            spinner.innerHTML = settings.spinner;

            content.appendChild(iframe);

            host.appendChild(overlay);
            host.appendChild(content);
            host.appendChild(spinner);

            return host;
        };

        var bodyElement = global.document.body;
        var lightBoxElement = template({
            prefix: CLASS_PREFIX,
            url: url,
            spinner: spinner
        });
        var lightBoxOverlayElement = lightBoxElement.querySelector('.' + CLASS_PREFIX + '-overlay');
        var lightBoxContentElement = lightBoxElement.querySelector('.' + CLASS_PREFIX + '-content');
        var lightBoxIframeElement = lightBoxContentElement.querySelector('.' + CLASS_PREFIX + '-content-iframe');
        var lightBoxSpinnerElement = lightBoxElement.querySelector('.' + CLASS_PREFIX + '-spinner');

        var psDimensions = {
            width: withDefaultPXUnit(MIN_PS_DIMENSIONS.width),
            height: withDefaultPXUnit(MIN_PS_DIMENSIONS.height)
        };

        function withDefaultPXUnit(value) {
            var isStringWithoutUnit = typeof value === 'string' && String(parseFloat(value)).length === value.length;
            if (isStringWithoutUnit) {
                return value + 'px';
            }
            return typeof value === 'number' ? value + 'px' : value
        }

        lightBoxElement.style.zIndex = options.zIndex;

        lightBoxOverlayElement.style.opacity = options.overlayOpacity;
        lightBoxOverlayElement.style.backgroundColor = options.overlayBackground;

        lightBoxContentElement.style.backgroundColor = options.contentBackground;
        lightBoxContentElement.style.margin = withDefaultPXUnit(options.contentMargin);
        lightBoxContentElement.style.width = options.width ? withDefaultPXUnit(options.width) : 'auto';
        lightBoxContentElement.style.height = options.height ? withDefaultPXUnit(options.height) : 'auto';

        if (options.spinnerColor) {
            lightBoxSpinnerElement.querySelector('path').style.fill = options.spinnerColor;
        }

        if (options.spinner === 'custom') {
            var spinnerCustom = lightBoxSpinnerElement.querySelector('.spinner-custom');
            spinnerCustom.style['-webkit-animation-duration'] = options.spinnerRotationPeriod + 's;';
            spinnerCustom.style['animation-duration'] = options.spinnerRotationPeriod + 's;';
        }

        if (options.closeByClick) {
            lightBoxOverlayElement.addEventListener('click', (function () {
                this.closeFrame();
            }).bind(this));
        }

        bodyElement.appendChild(lightBoxElement);

        if (options.closeByKeyboard) {

            bodyElement.addEventListener(handleKeyupEventName, HandleBoundSpecificKeyup);

            bodyElement.addEventListener('keyup', handleGlobalKeyup, false);
        }

        var showContent = Helpers.once((function () {
            hideSpinner(options);
            lightBoxContentElement.classList.remove(CLASS_PREFIX + '-content__hidden');
            this.triggerEvent('load');
        }).bind(this));

        var lightBoxResize = function () {
            var width = options.width ? options.width : psDimensions.width;
            var height = options.height ? options.height : psDimensions.height;

            lightBoxContentElement.style.left = '0px';
            lightBoxContentElement.style.top = '0px';
            lightBoxContentElement.style.borderRadius = '8px';
            lightBoxContentElement.style.width = withDefaultPXUnit(width);
            lightBoxContentElement.style.height = withDefaultPXUnit(height);

            var containerWidth = lightBoxElement.clientWidth,
                containerHeight = lightBoxElement.clientHeight;

            var contentWidth = outerWidth(lightBoxContentElement),
                contentHeight = outerHeight(lightBoxContentElement);

            var horMargin = contentWidth - lightBoxContentElement.offsetWidth,
                vertMargin = contentHeight - lightBoxContentElement.offsetHeight;

            var horDiff = containerWidth - contentWidth,
                vertDiff = containerHeight - contentHeight;

            if (horDiff < 0) {
                lightBoxContentElement.style.width = containerWidth - horMargin + 'px';
            } else {
                lightBoxContentElement.style.left = Math.round(horDiff / 2) + 'px';
            }

            if (vertDiff < 0) {
                lightBoxContentElement.style.height = containerHeight - vertMargin + 'px';
            } else {
                lightBoxContentElement.style.top = Math.round(vertDiff / 2) + 'px';
            }
        };

        if (options.width && options.height) {
            lightBoxResize = Helpers.once(lightBoxResize.bind(this));
        }

        function outerWidth(el) {
            var width = el.offsetWidth;
            var style = getComputedStyle(el);

            width += parseInt(style.marginLeft) + parseInt(style.marginRight);
            return width;
        }

        function outerHeight(el) {
            var height = el.offsetHeight;
            var style = getComputedStyle(el);

            height += parseInt(style.marginTop) + parseInt(style.marginBottom);
            return height;
        }

        var bodyStyles;
        var hideScrollbar = (function () {
            bodyStyles = Helpers.zipObject(['overflow', 'paddingRight'].map(function (key) {
                return [key, getComputedStyle(bodyElement)[key]];
            }));

            if (global.window.innerWidth > outerWidth(bodyElement)) {
                var bodyPad = parseInt((getComputedStyle(bodyElement)['paddingRight'] || 0), 10);
                bodyElement.style.overflow = 'hidden;';
                bodyElement.style.paddingRight = withDefaultPXUnit(bodyPad + this.measureScrollbar());
            }
        }).bind(this);

        var resetScrollbar = function () {
            if (bodyStyles) {
                Object.keys(bodyStyles).forEach(function(key) {
                    bodyElement.style[key] = bodyStyles[key];
                })
            }
        };

        var showSpinner = function () {
            lightBoxSpinnerElement.style.display = 'block';
        };

        var hideSpinner = function () {
            lightBoxSpinnerElement.style.display = 'none';
        };

        var loadTimer;
        lightBoxIframeElement.addEventListener('load', function handleLoad(event) {
            var timeout = !(options.width && options.height) ? (options.resizeTimeout || 30000) : 1000; // 30000 if psDimensions will not arrive and custom timeout is not provided
            loadTimer = global.setTimeout(function () {
                lightBoxResize();
                showContent();
            }, timeout);
            lightBoxIframeElement.removeEventListener('load', handleLoad);

        });

        var iframeWindow = lightBoxIframeElement.contentWindow || lightBoxIframeElement;

        // Cross-window communication
        this.message = new PostMessage(iframeWindow);
        if (options.width && options.height) {
            this.message.on('dimensions', (function () {
                lightBoxResize();
                showContent();
            }));
        } else {
            this.message.on('dimensions', (function (event) {
                var data = event.detail;
                if (data.dimensions) {
                    psDimensions = Helpers.zipObject(['width', 'height'].map(function (dim) {
                        return [dim, Math.max(MIN_PS_DIMENSIONS[dim] || 0, data.dimensions[dim] || 0) + 'px'];
                    }));

                    lightBoxResize();
                }
                showContent();
            }));
        }
        this.message.on('widget-detection', (function () {
            this.message.send('widget-detected', {version: version, lightBoxOptions: options});
        }).bind(this));
        this.message.on('widget-close', (function () {
            this.closeFrame();
        }).bind(this));
        this.message.on('close', (function () {
            this.closeFrame();
        }).bind(this));
        this.message.on('status', (function (event) {
            this.triggerEvent('status', event.detail);
        }).bind(this));
        this.message.on('user-country', (function (event) {
            this.triggerEvent('user-country', event.detail);
        }).bind(this));

        // Resize
        window.addEventListener(handleResizeEventName, lightBoxResize);
        window.addEventListener('resize', handleGlobalResize);

        // Clean up after close
        var that = this;
        this.on('close', function handleClose(event) {
            that.message.off();
            bodyElement.removeEventListener(handleKeyupEventName, HandleBoundSpecificKeyup)
            bodyElement.removeEventListener('keyup', handleGlobalKeyup);

            window.removeEventListener('resize', handleGlobalResize)

            window.removeEventListener(handleResizeEventName, lightBoxResize);
            lightBoxElement.parentNode.removeChild(lightBoxElement);
            resetScrollbar();
            that.off('close', handleClose);
        });

        showSpinner();
        hideScrollbar();
        this.triggerEvent('open');
    };

    LightBox.prototype.closeFrame = function () {
        if (!this.options.modal) {
            this.triggerEvent('close');
        }
    };

    LightBox.prototype.on = function () {
        this.eventObject.on.apply(this.eventObject, arguments);
    };

    LightBox.prototype.off = function () {
        this.eventObject.off.apply(this.eventObject, arguments);
    };

    LightBox.prototype.getPostMessage = function () {
        return this.message;
    };

    LightBox._NAMESPACE = '.xpaystation-widget-lightbox';

    return LightBox;
})();

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./helpers":7,"./postmessage":10,"./spinners/round.svg":11,"./spinners/xsolla.svg":12,"./styles/lightbox.scss":13,"./version":14}],9:[function(require,module,exports){
function objectAssign() {
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign Polyfill
  Object.assign||Object.defineProperty(Object,"assign",{enumerable:!1,configurable:!0,writable:!0,value:function(e,r){"use strict";if(null==e)throw new TypeError("Cannot convert first argument to object");for(var t=Object(e),n=1;n<arguments.length;n++){var o=arguments[n];if(null!=o)for(var a=Object.keys(Object(o)),c=0,b=a.length;c<b;c++){var i=a[c],l=Object.getOwnPropertyDescriptor(o,i);void 0!==l&&l.enumerable&&(t[i]=o[i])}}return t}});
}

function arrayForEach() {
  Array.prototype.forEach||(Array.prototype.forEach=function(r,o){var t,n;if(null==this)throw new TypeError(" this is null or not defined");var e=Object(this),i=e.length>>>0;if("function"!=typeof r)throw new TypeError(r+" is not a function");for(arguments.length>1&&(t=o),n=0;n<i;){var f;n in e&&(f=e[n],r.call(t,f,n,e)),n++}});
}

function applyPolyfills() {
  objectAssign();
  arrayForEach();
}

module.exports = {
  applyPolyfills: applyPolyfills
}

},{}],10:[function(require,module,exports){
(function (global){
var Helpers = require('./helpers');

module.exports = (function () {
    function wrapEventInNamespace(eventName) {
        return PostMessage._NAMESPACE + '_' + eventName;
    }

    function PostMessage(window) {
        this.eventObject = Helpers.addEventObject(this, wrapEventInNamespace);
        this.linkedWindow = window;

        global.window.addEventListener && global.window.addEventListener("message", (function (event) {
            if (event.source !== this.linkedWindow) {
                return;
            }

            var message = {};
            if (typeof event.data === 'string' && global.JSON !== undefined) {
                try {
                    message = global.JSON.parse(event.data);
                } catch (e) {
                }
            }

            if (message.command) {
                this.eventObject.trigger(message.command, message.data);
            }
        }).bind(this));
    }

    /** Private Members **/
    PostMessage.prototype.eventObject = null;
    PostMessage.prototype.linkedWindow = null;

    /** Public Members **/
    PostMessage.prototype.send = function(command, data, targetOrigin) {
        if (data === undefined) {
            data = {};
        }

        if (targetOrigin === undefined) {
            targetOrigin = '*';
        }

        if (!this.linkedWindow || this.linkedWindow.postMessage === undefined || global.window.JSON === undefined) {
            return false;
        }

        try {
            this.linkedWindow.postMessage(global.JSON.stringify({data: data, command: command}), targetOrigin);
        } catch (e) {
        }

        return true;
    };

    PostMessage.prototype.on = function (event, handle, options) {
        this.eventObject.on(event, handle, options);
    };

    PostMessage.prototype.off = function (event, handle, options) {
        this.eventObject.off(event, handle, options);
    };

    PostMessage._NAMESPACE = 'POST_MESSAGE';


    return PostMessage;
})();

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./helpers":7}],11:[function(require,module,exports){
module.exports = "<svg width=\"47px\" height=\"47px\" class=\"spinner-round\"><path d=\"M4.7852728,10.4210875 C2.94111664,13.0552197 1.63777109,16.0946106 1.03753956,19.3768556 L5.16638971,19.3768556 C5.6429615,17.187554 6.50125243,15.139164 7.66768899,13.305305 L5.95572428,11.5922705 L4.7852728,10.4210875 L4.7852728,10.4210875 Z M10.4693048,4.74565615 C13.1274873,2.8908061 16.1965976,1.58674648 19.5100161,1 L19.5100161,4.99523934 C17.2710923,5.48797782 15.1803193,6.3808529 13.3166907,7.59482153 L11.6337339,5.91081293 L10.4693048,4.74565615 L10.4693048,4.74565615 Z M42.2426309,36.5388386 C44.1112782,33.8575016 45.4206461,30.7581504 46,27.4117269 L41.9441211,27.4117269 C41.4527945,29.6618926 40.5583692,31.762911 39.3404412,33.6349356 L41.0332347,35.3287869 L42.2425306,36.5388386 L42.2426309,36.5388386 Z M36.5707441,42.2264227 C33.9167773,44.0867967 30.8509793,45.3972842 27.5398693,45.9911616 L27.5398693,41.7960549 C29.7376402,41.3202901 31.7936841,40.4593536 33.6336246,39.287568 L35.3554258,41.0104453 L36.5707441,42.2265231 L36.5707441,42.2264227 Z M4.71179965,36.4731535 C2.86744274,33.8069823 1.57463637,30.7309322 1,27.4118273 L5.16889904,27.4118273 C5.64828128,29.6073559 6.51159087,31.661069 7.68465205,33.4984432 L5.95572428,35.2284515 L4.71179965,36.4731535 L4.71179965,36.4731535 Z M10.3640133,42.180423 C13.0462854,44.0745435 16.1527345,45.40552 19.5101165,46 L19.5101165,41.7821947 C17.2817319,41.2916658 15.2000928,40.4048169 13.3430889,39.1995862 L11.6337339,40.9100094 L10.3640133,42.1805235 L10.3640133,42.180423 Z M42.1688567,10.3557038 C44.0373031,13.0048008 45.357411,16.0674929 45.9626612,19.3768556 L41.9469316,19.3768556 C41.4585158,17.1328164 40.5692095,15.0369202 39.3580065,13.1684109 L41.0335358,11.4918346 L42.168957,10.3557038 L42.1688567,10.3557038 Z M36.4651516,4.69995782 C33.8355754,2.87865336 30.8071162,1.59488179 27.5400701,1.00883836 L27.5400701,4.98117831 C29.7484805,5.45915272 31.8137587,6.3260149 33.6604242,7.50643794 L35.3555262,5.8102766 L36.4651516,4.69995782 L36.4651516,4.69995782 Z\" fill=\"#CCCCCC\"></path></svg>";

},{}],12:[function(require,module,exports){
module.exports = "<svg class=\"spinner-xsolla\" width=\"56\" height=\"55\"><path class=\"spinner-xsolla-x\" d=\"M21.03 5.042l-2.112-2.156-3.657 3.695-3.657-3.695-2.112 2.156 3.659 3.673-3.659 3.696 2.112 2.157 3.657-3.697 3.657 3.697 2.112-2.157-3.648-3.696 3.648-3.673z\" fill=\"#F2542D\"></path><path class=\"spinner-xsolla-s\" d=\"M41.232 6.896l2.941-2.974-2.134-2.132-2.92 2.973-.005-.008-2.134 2.135.005.008-.005.005 3.792 3.82-2.915 2.947 2.112 2.156 5.06-5.111-3.798-3.816.001-.001z\" fill=\"#FCCA20\"></path><path class=\"spinner-xsolla-o\" d=\"M48.066 29.159c-1.536 0-2.761 1.263-2.761 2.79 0 1.524 1.226 2.765 2.761 2.765 1.509 0 2.736-1.242 2.736-2.765 0-1.526-1.227-2.79-2.736-2.79m0 8.593c-3.179 0-5.771-2.594-5.771-5.804 0-3.213 2.592-5.808 5.771-5.808 3.155 0 5.745 2.594 5.745 5.808 0 3.21-2.589 5.804-5.745 5.804\" fill=\"#8C3EA4\"></path><path class=\"spinner-xsolla-l\" d=\"M24.389 42.323h2.99v10.437h-2.99v-10.437zm4.334 0h2.989v10.437h-2.989v-10.437z\" fill=\"#B5DC20\"></path><path class=\"spinner-xsolla-a\" d=\"M7.796 31.898l1.404 2.457h-2.835l1.431-2.457h-.001zm-.001-5.757l-6.363 11.102h12.703l-6.341-11.102z\" fill=\"#66CCDA\"></path></svg>";

},{}],13:[function(require,module,exports){
module.exports = require('sassify')('.xpaystation-widget-lightbox{position:fixed;top:0;left:0;bottom:0;right:0;width:100%;height:100%;-webkit-animation:xpaystation-widget-lightbox-fadein 0.15s;animation:xpaystation-widget-lightbox-fadein 0.15s}.xpaystation-widget-lightbox-overlay{position:absolute;top:0;left:0;bottom:0;right:0;z-index:1}.xpaystation-widget-lightbox-content{position:relative;top:0;left:0;z-index:3}.xpaystation-widget-lightbox-content__hidden{visibility:hidden;z-index:-1}.xpaystation-widget-lightbox-content-iframe{width:100%;height:100%;border:0;background:transparent}.xpaystation-widget-lightbox-spinner{position:absolute;top:50%;left:50%;display:none;z-index:2;pointer-events:none}.xpaystation-widget-lightbox-spinner .spinner-xsolla{width:56px;height:55px;margin-top:-28px;margin-left:-26px}.xpaystation-widget-lightbox-spinner .spinner-xsolla .spinner-xsolla-x,.xpaystation-widget-lightbox-spinner .spinner-xsolla .spinner-xsolla-s,.xpaystation-widget-lightbox-spinner .spinner-xsolla .spinner-xsolla-o,.xpaystation-widget-lightbox-spinner .spinner-xsolla .spinner-xsolla-l,.xpaystation-widget-lightbox-spinner .spinner-xsolla .spinner-xsolla-a{-webkit-animation:xpaystation-widget-lightbox-bouncedelay 1s infinite ease-in-out;-webkit-animation-fill-mode:both;animation:xpaystation-widget-lightbox-bouncedelay 1s infinite ease-in-out;animation-fill-mode:both}.xpaystation-widget-lightbox-spinner .spinner-xsolla .spinner-xsolla-x{-webkit-animation-delay:0s;animation-delay:0s}.xpaystation-widget-lightbox-spinner .spinner-xsolla .spinner-xsolla-s{-webkit-animation-delay:.2s;animation-delay:.2s}.xpaystation-widget-lightbox-spinner .spinner-xsolla .spinner-xsolla-o{-webkit-animation-delay:.4s;animation-delay:.4s}.xpaystation-widget-lightbox-spinner .spinner-xsolla .spinner-xsolla-l{-webkit-animation-delay:.6s;animation-delay:.6s}.xpaystation-widget-lightbox-spinner .spinner-xsolla .spinner-xsolla-a{-webkit-animation-delay:.8s;animation-delay:.8s}.xpaystation-widget-lightbox-spinner .spinner-round{margin-top:-23px;margin-left:-23px;-webkit-animation:xpaystation-widget-lightbox-spin 3s infinite linear;animation:xpaystation-widget-lightbox-spin 3s infinite linear}.xpaystation-widget-lightbox-spinner .spinner-custom{-webkit-animation:xpaystation-widget-lightbox-spin infinite linear;animation:xpaystation-widget-lightbox-spin infinite linear}@-webkit-keyframes xpaystation-widget-lightbox-bouncedelay{0%,80%,100%{opacity:0}40%{opacity:1}}@keyframes xpaystation-widget-lightbox-bouncedelay{0%,80%,100%{opacity:0}40%{opacity:1}}@-webkit-keyframes xpaystation-widget-lightbox-fadein{from{opacity:0}to{opacity:1}}@keyframes xpaystation-widget-lightbox-fadein{from{opacity:0}to{opacity:1}}@-webkit-keyframes xpaystation-widget-lightbox-spin{from{-webkit-transform:rotate(0deg)}to{-webkit-transform:rotate(360deg)}}@keyframes xpaystation-widget-lightbox-spin{from{transform:rotate(0deg)}to{transform:rotate(360deg)}}  /*# sourceMappingURL=data:application/json;base64,ewoJInZlcnNpb24iOiAzLAoJImZpbGUiOiAibGlnaHRib3guc2NzcyIsCgkic291cmNlcyI6IFsKCQkibGlnaHRib3guc2NzcyIKCV0sCgkic291cmNlc0NvbnRlbnQiOiBbCgkJIiRsaWdodGJveC1wcmVmaXg6ICd4cGF5c3RhdGlvbi13aWRnZXQtbGlnaHRib3gnO1xuJGxpZ2h0Ym94LWNsYXNzOiAnLicgKyAkbGlnaHRib3gtcHJlZml4O1xuXG4jeyRsaWdodGJveC1jbGFzc30ge1xuICBwb3NpdGlvbjogZml4ZWQ7XG4gIHRvcDogMDtcbiAgbGVmdDogMDtcbiAgYm90dG9tOiAwO1xuICByaWdodDogMDtcbiAgd2lkdGg6IDEwMCU7XG4gIGhlaWdodDogMTAwJTtcbiAgLXdlYmtpdC1hbmltYXRpb246ICN7JGxpZ2h0Ym94LXByZWZpeH0tZmFkZWluIC4xNXM7XG4gIGFuaW1hdGlvbjogI3skbGlnaHRib3gtcHJlZml4fS1mYWRlaW4gLjE1cztcbn1cblxuI3skbGlnaHRib3gtY2xhc3N9LW92ZXJsYXkge1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIHRvcDowO1xuICBsZWZ0OiAwO1xuICBib3R0b206IDA7XG4gIHJpZ2h0OiAwO1xuICB6LWluZGV4OiAxO1xufVxuXG4jeyRsaWdodGJveC1jbGFzc30tY29udGVudCB7XG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgdG9wOiAwO1xuICBsZWZ0OiAwO1xuICB6LWluZGV4OiAzO1xufVxuXG4jeyRsaWdodGJveC1jbGFzc30tY29udGVudF9faGlkZGVuIHtcbiAgdmlzaWJpbGl0eTogaGlkZGVuO1xuICB6LWluZGV4OiAtMTtcbn1cblxuI3skbGlnaHRib3gtY2xhc3N9LWNvbnRlbnQtaWZyYW1lIHtcbiAgd2lkdGg6IDEwMCU7XG4gIGhlaWdodDogMTAwJTtcbiAgYm9yZGVyOiAwO1xuICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcbn1cblxuI3skbGlnaHRib3gtY2xhc3N9LXNwaW5uZXIge1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIHRvcDogNTAlO1xuICBsZWZ0OiA1MCU7XG4gIGRpc3BsYXk6IG5vbmU7XG4gIHotaW5kZXg6IDI7XG4gIHBvaW50ZXItZXZlbnRzOiBub25lO1xuXG4gIC5zcGlubmVyLXhzb2xsYSB7XG4gICAgd2lkdGg6IDU2cHg7XG4gICAgaGVpZ2h0OiA1NXB4O1xuICAgIG1hcmdpbjoge1xuICAgICAgdG9wOiAtMjhweDtcbiAgICAgIGxlZnQ6IC0yNnB4O1xuICAgIH1cblxuICAgIC5zcGlubmVyLXhzb2xsYS14LCAuc3Bpbm5lci14c29sbGEtcywgLnNwaW5uZXIteHNvbGxhLW8sIC5zcGlubmVyLXhzb2xsYS1sLCAuc3Bpbm5lci14c29sbGEtYSB7XG4gICAgICAtd2Via2l0LWFuaW1hdGlvbjogI3skbGlnaHRib3gtcHJlZml4fS1ib3VuY2VkZWxheSAxcyBpbmZpbml0ZSBlYXNlLWluLW91dDtcbiAgICAgIC13ZWJraXQtYW5pbWF0aW9uLWZpbGwtbW9kZTogYm90aDtcbiAgICAgIGFuaW1hdGlvbjogI3skbGlnaHRib3gtcHJlZml4fS1ib3VuY2VkZWxheSAxcyBpbmZpbml0ZSBlYXNlLWluLW91dDtcbiAgICAgIGFuaW1hdGlvbi1maWxsLW1vZGU6IGJvdGg7XG4gICAgfVxuXG4gICAgLnNwaW5uZXIteHNvbGxhLXgge1xuICAgICAgLXdlYmtpdC1hbmltYXRpb24tZGVsYXk6IDBzO1xuICAgICAgYW5pbWF0aW9uLWRlbGF5OiAwcztcbiAgICB9XG5cbiAgICAuc3Bpbm5lci14c29sbGEtcyB7XG4gICAgICAtd2Via2l0LWFuaW1hdGlvbi1kZWxheTogLjJzO1xuICAgICAgYW5pbWF0aW9uLWRlbGF5OiAuMnM7XG4gICAgfVxuXG4gICAgLnNwaW5uZXIteHNvbGxhLW8ge1xuICAgICAgLXdlYmtpdC1hbmltYXRpb24tZGVsYXk6IC40cztcbiAgICAgIGFuaW1hdGlvbi1kZWxheTogLjRzO1xuICAgIH1cblxuICAgIC5zcGlubmVyLXhzb2xsYS1sIHtcbiAgICAgIC13ZWJraXQtYW5pbWF0aW9uLWRlbGF5OiAuNnM7XG4gICAgICBhbmltYXRpb24tZGVsYXk6IC42cztcbiAgICB9XG5cbiAgICAuc3Bpbm5lci14c29sbGEtYSB7XG4gICAgICAtd2Via2l0LWFuaW1hdGlvbi1kZWxheTogLjhzO1xuICAgICAgYW5pbWF0aW9uLWRlbGF5OiAuOHM7XG4gICAgfVxuICB9XG5cbiAgLnNwaW5uZXItcm91bmQge1xuICAgIG1hcmdpbjoge1xuICAgICAgdG9wOiAtMjNweDtcbiAgICAgIGxlZnQ6IC0yM3B4O1xuICAgIH1cbiAgICAtd2Via2l0LWFuaW1hdGlvbjogI3skbGlnaHRib3gtcHJlZml4fS1zcGluIDNzIGluZmluaXRlIGxpbmVhcjtcbiAgICBhbmltYXRpb246ICN7JGxpZ2h0Ym94LXByZWZpeH0tc3BpbiAzcyBpbmZpbml0ZSBsaW5lYXI7XG4gIH1cblxuICAuc3Bpbm5lci1jdXN0b20ge1xuICAgIC13ZWJraXQtYW5pbWF0aW9uOiAjeyRsaWdodGJveC1wcmVmaXh9LXNwaW4gaW5maW5pdGUgbGluZWFyO1xuICAgIGFuaW1hdGlvbjogI3skbGlnaHRib3gtcHJlZml4fS1zcGluIGluZmluaXRlIGxpbmVhcjtcbiAgfVxufVxuXG5ALXdlYmtpdC1rZXlmcmFtZXMgI3skbGlnaHRib3gtcHJlZml4fS1ib3VuY2VkZWxheSB7XG4gIDAlLCA4MCUsIDEwMCUgeyBvcGFjaXR5OiAwOyB9XG4gIDQwJSB7IG9wYWNpdHk6IDEgfVxufVxuXG5Aa2V5ZnJhbWVzICN7JGxpZ2h0Ym94LXByZWZpeH0tYm91bmNlZGVsYXkge1xuICAwJSwgODAlLCAxMDAlIHsgb3BhY2l0eTogMDsgfVxuICA0MCUgeyBvcGFjaXR5OiAxOyB9XG59XG5cbkAtd2Via2l0LWtleWZyYW1lcyAjeyRsaWdodGJveC1wcmVmaXh9LWZhZGVpbiB7XG4gIGZyb20geyBvcGFjaXR5OiAwOyB9XG4gIHRvIHsgb3BhY2l0eTogMTsgfVxufVxuXG5Aa2V5ZnJhbWVzICN7JGxpZ2h0Ym94LXByZWZpeH0tZmFkZWluIHtcbiAgZnJvbSB7IG9wYWNpdHk6IDA7IH1cbiAgdG8geyBvcGFjaXR5OiAxOyB9XG59XG5cbkAtd2Via2l0LWtleWZyYW1lcyAjeyRsaWdodGJveC1wcmVmaXh9LXNwaW4ge1xuICBmcm9tIHsgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTsgfVxuICB0byB7IC13ZWJraXQtdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTsgfVxufVxuXG5Aa2V5ZnJhbWVzICN7JGxpZ2h0Ym94LXByZWZpeH0tc3BpbiB7XG4gIGZyb20geyB0cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTsgfVxuICB0byB7IHRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7IH1cbn1cbiIKCV0sCgkibWFwcGluZ3MiOiAiQUFHQSxBQUFBLDRCQUE0QixBQUE1QixDQUNFLFFBQVEsQ0FBRSxLQUFNLENBQ2hCLEdBQUcsQ0FBRSxDQUFFLENBQ1AsSUFBSSxDQUFFLENBQUUsQ0FDUixNQUFNLENBQUUsQ0FBRSxDQUNWLEtBQUssQ0FBRSxDQUFFLENBQ1QsS0FBSyxDQUFFLElBQUssQ0FDWixNQUFNLENBQUUsSUFBSyxDQUNiLGlCQUFpQixDQUFFLGtDQUEwQixDQUFRLEtBQUksQ0FDekQsU0FBUyxDQUFFLGtDQUEwQixDQUFRLEtBQUksQ0FDbEQsQUFFRCxBQUFBLG9DQUFvQyxBQUFwQyxDQUNFLFFBQVEsQ0FBRSxRQUFTLENBQ25CLEdBQUcsQ0FBQyxDQUFFLENBQ04sSUFBSSxDQUFFLENBQUUsQ0FDUixNQUFNLENBQUUsQ0FBRSxDQUNWLEtBQUssQ0FBRSxDQUFFLENBQ1QsT0FBTyxDQUFFLENBQUUsQ0FDWixBQUVELEFBQUEsb0NBQW9DLEFBQXBDLENBQ0UsUUFBUSxDQUFFLFFBQVMsQ0FDbkIsR0FBRyxDQUFFLENBQUUsQ0FDUCxJQUFJLENBQUUsQ0FBRSxDQUNSLE9BQU8sQ0FBRSxDQUFFLENBQ1osQUFFRCxBQUFBLDRDQUE0QyxBQUE1QyxDQUNFLFVBQVUsQ0FBRSxNQUFPLENBQ25CLE9BQU8sQ0FBRSxFQUFHLENBQ2IsQUFFRCxBQUFBLDJDQUEyQyxBQUEzQyxDQUNFLEtBQUssQ0FBRSxJQUFLLENBQ1osTUFBTSxDQUFFLElBQUssQ0FDYixNQUFNLENBQUUsQ0FBRSxDQUNWLFVBQVUsQ0FBRSxXQUFZLENBQ3pCLEFBRUQsQUFBQSxvQ0FBb0MsQUFBcEMsQ0FDRSxRQUFRLENBQUUsUUFBUyxDQUNuQixHQUFHLENBQUUsR0FBSSxDQUNULElBQUksQ0FBRSxHQUFJLENBQ1YsT0FBTyxDQUFFLElBQUssQ0FDZCxPQUFPLENBQUUsQ0FBRSxDQUNYLGNBQWMsQ0FBRSxJQUFLLENBd0R0QixBQTlERCxBQVFFLG9DQVJrQyxDQVFsQyxlQUFlLEFBQUMsQ0FDZCxLQUFLLENBQUUsSUFBSyxDQUNaLE1BQU0sQ0FBRSxJQUFLLENBQ2IsTUFBTSxBQUFDLENBQUMsQUFDTixHQUFHLENBQUUsS0FBTSxDQURiLE1BQU0sQUFBQyxDQUFDLEFBRU4sSUFBSSxDQUFFLEtBQU0sQ0FrQ2YsQUEvQ0gsQUFnQkksb0NBaEJnQyxDQVFsQyxlQUFlLENBUWIsaUJBQWlCLENBaEJyQixBQWdCdUIsb0NBaEJhLENBUWxDLGVBQWUsQ0FRTSxpQkFBaUIsQ0FoQnhDLEFBZ0IwQyxvQ0FoQk4sQ0FRbEMsZUFBZSxDQVF5QixpQkFBaUIsQ0FoQjNELEFBZ0I2RCxvQ0FoQnpCLENBUWxDLGVBQWUsQ0FRNEMsaUJBQWlCLENBaEI5RSxBQWdCZ0Ysb0NBaEI1QyxDQVFsQyxlQUFlLENBUStELGlCQUFpQixBQUFDLENBQzVGLGlCQUFpQixDQUFFLHVDQUErQixDQUFhLEVBQUUsQ0FBQyxRQUFRLENBQUMsV0FBVyxDQUN0RiwyQkFBMkIsQ0FBRSxJQUFLLENBQ2xDLFNBQVMsQ0FBRSx1Q0FBK0IsQ0FBYSxFQUFFLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FDOUUsbUJBQW1CLENBQUUsSUFBSyxDQUMzQixBQXJCTCxBQXVCSSxvQ0F2QmdDLENBUWxDLGVBQWUsQ0FlYixpQkFBaUIsQUFBQyxDQUNoQix1QkFBdUIsQ0FBRSxFQUFHLENBQzVCLGVBQWUsQ0FBRSxFQUFHLENBQ3JCLEFBMUJMLEFBNEJJLG9DQTVCZ0MsQ0FRbEMsZUFBZSxDQW9CYixpQkFBaUIsQUFBQyxDQUNoQix1QkFBdUIsQ0FBRSxHQUFJLENBQzdCLGVBQWUsQ0FBRSxHQUFJLENBQ3RCLEFBL0JMLEFBaUNJLG9DQWpDZ0MsQ0FRbEMsZUFBZSxDQXlCYixpQkFBaUIsQUFBQyxDQUNoQix1QkFBdUIsQ0FBRSxHQUFJLENBQzdCLGVBQWUsQ0FBRSxHQUFJLENBQ3RCLEFBcENMLEFBc0NJLG9DQXRDZ0MsQ0FRbEMsZUFBZSxDQThCYixpQkFBaUIsQUFBQyxDQUNoQix1QkFBdUIsQ0FBRSxHQUFJLENBQzdCLGVBQWUsQ0FBRSxHQUFJLENBQ3RCLEFBekNMLEFBMkNJLG9DQTNDZ0MsQ0FRbEMsZUFBZSxDQW1DYixpQkFBaUIsQUFBQyxDQUNoQix1QkFBdUIsQ0FBRSxHQUFJLENBQzdCLGVBQWUsQ0FBRSxHQUFJLENBQ3RCLEFBOUNMLEFBaURFLG9DQWpEa0MsQ0FpRGxDLGNBQWMsQUFBQyxDQUNiLE1BQU0sQUFBQyxDQUFDLEFBQ04sR0FBRyxDQUFFLEtBQU0sQ0FEYixNQUFNLEFBQUMsQ0FBQyxBQUVOLElBQUksQ0FBRSxLQUFNLENBRWQsaUJBQWlCLENBQUUsZ0NBQXdCLENBQU0sRUFBRSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQ25FLFNBQVMsQ0FBRSxnQ0FBd0IsQ0FBTSxFQUFFLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FDNUQsQUF4REgsQUEwREUsb0NBMURrQyxDQTBEbEMsZUFBZSxBQUFDLENBQ2QsaUJBQWlCLENBQUUsZ0NBQXdCLENBQU0sUUFBUSxDQUFDLE1BQU0sQ0FDaEUsU0FBUyxDQUFFLGdDQUF3QixDQUFNLFFBQVEsQ0FBQyxNQUFNLENBQ3pELEFBR0gsa0JBQWtCLENBQWxCLHVDQUFrQixDQUNoQixBQUFBLEVBQUUsQ0FBRSxBQUFBLEdBQUcsQ0FBRSxBQUFBLElBQUksQ0FBRyxPQUFPLENBQUUsQ0FBRSxDQUMzQixBQUFBLEdBQUcsQ0FBRyxPQUFPLENBQUUsQ0FBRyxFQUdwQixVQUFVLENBQVYsdUNBQVUsQ0FDUixBQUFBLEVBQUUsQ0FBRSxBQUFBLEdBQUcsQ0FBRSxBQUFBLElBQUksQ0FBRyxPQUFPLENBQUUsQ0FBRSxDQUMzQixBQUFBLEdBQUcsQ0FBRyxPQUFPLENBQUUsQ0FBRSxFQUduQixrQkFBa0IsQ0FBbEIsa0NBQWtCLENBQ2hCLEFBQUEsSUFBSSxDQUFHLE9BQU8sQ0FBRSxDQUFFLENBQ2xCLEFBQUEsRUFBRSxDQUFHLE9BQU8sQ0FBRSxDQUFFLEVBR2xCLFVBQVUsQ0FBVixrQ0FBVSxDQUNSLEFBQUEsSUFBSSxDQUFHLE9BQU8sQ0FBRSxDQUFFLENBQ2xCLEFBQUEsRUFBRSxDQUFHLE9BQU8sQ0FBRSxDQUFFLEVBR2xCLGtCQUFrQixDQUFsQixnQ0FBa0IsQ0FDaEIsQUFBQSxJQUFJLENBQUcsaUJBQWlCLENBQUUsWUFBTSxDQUNoQyxBQUFBLEVBQUUsQ0FBRyxpQkFBaUIsQ0FBRSxjQUFNLEVBR2hDLFVBQVUsQ0FBVixnQ0FBVSxDQUNSLEFBQUEsSUFBSSxDQUFHLFNBQVMsQ0FBRSxZQUFNLENBQ3hCLEFBQUEsRUFBRSxDQUFHLFNBQVMsQ0FBRSxjQUFNIiwKCSJuYW1lcyI6IFtdCn0= */');;
},{"sassify":2}],14:[function(require,module,exports){
module.exports = '1.2.3';

},{}],"bowser":[function(require,module,exports){
/*!
 * Bowser - a browser detector
 * https://github.com/ded/bowser
 * MIT License | (c) Dustin Diaz 2015
 */

!function (root, name, definition) {
  if (typeof module != 'undefined' && module.exports) module.exports = definition()
  else if (typeof define == 'function' && define.amd) define(name, definition)
  else root[name] = definition()
}(this, 'bowser', function () {
  /**
    * See useragents.js for examples of navigator.userAgent
    */

  var t = true

  function detect(ua) {

    function getFirstMatch(regex) {
      var match = ua.match(regex);
      return (match && match.length > 1 && match[1]) || '';
    }

    function getSecondMatch(regex) {
      var match = ua.match(regex);
      return (match && match.length > 1 && match[2]) || '';
    }

    var iosdevice = getFirstMatch(/(ipod|iphone|ipad)/i).toLowerCase()
      , likeAndroid = /like android/i.test(ua)
      , android = !likeAndroid && /android/i.test(ua)
      , nexusMobile = /nexus\s*[0-6]\s*/i.test(ua)
      , nexusTablet = !nexusMobile && /nexus\s*[0-9]+/i.test(ua)
      , chromeos = /CrOS/.test(ua)
      , silk = /silk/i.test(ua)
      , sailfish = /sailfish/i.test(ua)
      , tizen = /tizen/i.test(ua)
      , webos = /(web|hpw)(o|0)s/i.test(ua)
      , windowsphone = /windows phone/i.test(ua)
      , samsungBrowser = /SamsungBrowser/i.test(ua)
      , windows = !windowsphone && /windows/i.test(ua)
      , mac = !iosdevice && !silk && /macintosh/i.test(ua)
      , linux = !android && !sailfish && !tizen && !webos && /linux/i.test(ua)
      , edgeVersion = getSecondMatch(/edg([ea]|ios)\/(\d+(\.\d+)?)/i)
      , versionIdentifier = getFirstMatch(/version\/(\d+(\.\d+)?)/i)
      , tablet = /tablet/i.test(ua) && !/tablet pc/i.test(ua)
      , mobile = !tablet && /[^-]mobi/i.test(ua)
      , xbox = /xbox/i.test(ua)
      , result

    if (/opera/i.test(ua)) {
      //  an old Opera
      result = {
        name: 'Opera'
      , opera: t
      , version: versionIdentifier || getFirstMatch(/(?:opera|opr|opios)[\s\/](\d+(\.\d+)?)/i)
      }
    } else if (/opr\/|opios/i.test(ua)) {
      // a new Opera
      result = {
        name: 'Opera'
        , opera: t
        , version: getFirstMatch(/(?:opr|opios)[\s\/](\d+(\.\d+)?)/i) || versionIdentifier
      }
    }
    else if (/SamsungBrowser/i.test(ua)) {
      result = {
        name: 'Samsung Internet for Android'
        , samsungBrowser: t
        , version: versionIdentifier || getFirstMatch(/(?:SamsungBrowser)[\s\/](\d+(\.\d+)?)/i)
      }
    }
    else if (/Whale/i.test(ua)) {
      result = {
        name: 'NAVER Whale browser'
        , whale: t
        , version: getFirstMatch(/(?:whale)[\s\/](\d+(?:\.\d+)+)/i)
      }
    }
    else if (/MZBrowser/i.test(ua)) {
      result = {
        name: 'MZ Browser'
        , mzbrowser: t
        , version: getFirstMatch(/(?:MZBrowser)[\s\/](\d+(?:\.\d+)+)/i)
      }
    }
    else if (/coast/i.test(ua)) {
      result = {
        name: 'Opera Coast'
        , coast: t
        , version: versionIdentifier || getFirstMatch(/(?:coast)[\s\/](\d+(\.\d+)?)/i)
      }
    }
    else if (/focus/i.test(ua)) {
      result = {
        name: 'Focus'
        , focus: t
        , version: getFirstMatch(/(?:focus)[\s\/](\d+(?:\.\d+)+)/i)
      }
    }
    else if (/yabrowser/i.test(ua)) {
      result = {
        name: 'Yandex Browser'
      , yandexbrowser: t
      , version: versionIdentifier || getFirstMatch(/(?:yabrowser)[\s\/](\d+(\.\d+)?)/i)
      }
    }
    else if (/ucbrowser/i.test(ua)) {
      result = {
          name: 'UC Browser'
        , ucbrowser: t
        , version: getFirstMatch(/(?:ucbrowser)[\s\/](\d+(?:\.\d+)+)/i)
      }
    }
    else if (/mxios/i.test(ua)) {
      result = {
        name: 'Maxthon'
        , maxthon: t
        , version: getFirstMatch(/(?:mxios)[\s\/](\d+(?:\.\d+)+)/i)
      }
    }
    else if (/epiphany/i.test(ua)) {
      result = {
        name: 'Epiphany'
        , epiphany: t
        , version: getFirstMatch(/(?:epiphany)[\s\/](\d+(?:\.\d+)+)/i)
      }
    }
    else if (/puffin/i.test(ua)) {
      result = {
        name: 'Puffin'
        , puffin: t
        , version: getFirstMatch(/(?:puffin)[\s\/](\d+(?:\.\d+)?)/i)
      }
    }
    else if (/sleipnir/i.test(ua)) {
      result = {
        name: 'Sleipnir'
        , sleipnir: t
        , version: getFirstMatch(/(?:sleipnir)[\s\/](\d+(?:\.\d+)+)/i)
      }
    }
    else if (/k-meleon/i.test(ua)) {
      result = {
        name: 'K-Meleon'
        , kMeleon: t
        , version: getFirstMatch(/(?:k-meleon)[\s\/](\d+(?:\.\d+)+)/i)
      }
    }
    else if (windowsphone) {
      result = {
        name: 'Windows Phone'
      , osname: 'Windows Phone'
      , windowsphone: t
      }
      if (edgeVersion) {
        result.msedge = t
        result.version = edgeVersion
      }
      else {
        result.msie = t
        result.version = getFirstMatch(/iemobile\/(\d+(\.\d+)?)/i)
      }
    }
    else if (/msie|trident/i.test(ua)) {
      result = {
        name: 'Internet Explorer'
      , msie: t
      , version: getFirstMatch(/(?:msie |rv:)(\d+(\.\d+)?)/i)
      }
    } else if (chromeos) {
      result = {
        name: 'Chrome'
      , osname: 'Chrome OS'
      , chromeos: t
      , chromeBook: t
      , chrome: t
      , version: getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.\d+)?)/i)
      }
    } else if (/edg([ea]|ios)/i.test(ua)) {
      result = {
        name: 'Microsoft Edge'
      , msedge: t
      , version: edgeVersion
      }
    }
    else if (/vivaldi/i.test(ua)) {
      result = {
        name: 'Vivaldi'
        , vivaldi: t
        , version: getFirstMatch(/vivaldi\/(\d+(\.\d+)?)/i) || versionIdentifier
      }
    }
    else if (sailfish) {
      result = {
        name: 'Sailfish'
      , osname: 'Sailfish OS'
      , sailfish: t
      , version: getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i)
      }
    }
    else if (/seamonkey\//i.test(ua)) {
      result = {
        name: 'SeaMonkey'
      , seamonkey: t
      , version: getFirstMatch(/seamonkey\/(\d+(\.\d+)?)/i)
      }
    }
    else if (/firefox|iceweasel|fxios/i.test(ua)) {
      result = {
        name: 'Firefox'
      , firefox: t
      , version: getFirstMatch(/(?:firefox|iceweasel|fxios)[ \/](\d+(\.\d+)?)/i)
      }
      if (/\((mobile|tablet);[^\)]*rv:[\d\.]+\)/i.test(ua)) {
        result.firefoxos = t
        result.osname = 'Firefox OS'
      }
    }
    else if (silk) {
      result =  {
        name: 'Amazon Silk'
      , silk: t
      , version : getFirstMatch(/silk\/(\d+(\.\d+)?)/i)
      }
    }
    else if (/phantom/i.test(ua)) {
      result = {
        name: 'PhantomJS'
      , phantom: t
      , version: getFirstMatch(/phantomjs\/(\d+(\.\d+)?)/i)
      }
    }
    else if (/slimerjs/i.test(ua)) {
      result = {
        name: 'SlimerJS'
        , slimer: t
        , version: getFirstMatch(/slimerjs\/(\d+(\.\d+)?)/i)
      }
    }
    else if (/blackberry|\bbb\d+/i.test(ua) || /rim\stablet/i.test(ua)) {
      result = {
        name: 'BlackBerry'
      , osname: 'BlackBerry OS'
      , blackberry: t
      , version: versionIdentifier || getFirstMatch(/blackberry[\d]+\/(\d+(\.\d+)?)/i)
      }
    }
    else if (webos) {
      result = {
        name: 'WebOS'
      , osname: 'WebOS'
      , webos: t
      , version: versionIdentifier || getFirstMatch(/w(?:eb)?osbrowser\/(\d+(\.\d+)?)/i)
      };
      /touchpad\//i.test(ua) && (result.touchpad = t)
    }
    else if (/bada/i.test(ua)) {
      result = {
        name: 'Bada'
      , osname: 'Bada'
      , bada: t
      , version: getFirstMatch(/dolfin\/(\d+(\.\d+)?)/i)
      };
    }
    else if (tizen) {
      result = {
        name: 'Tizen'
      , osname: 'Tizen'
      , tizen: t
      , version: getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.\d+)?)/i) || versionIdentifier
      };
    }
    else if (/qupzilla/i.test(ua)) {
      result = {
        name: 'QupZilla'
        , qupzilla: t
        , version: getFirstMatch(/(?:qupzilla)[\s\/](\d+(?:\.\d+)+)/i) || versionIdentifier
      }
    }
    else if (/chromium/i.test(ua)) {
      result = {
        name: 'Chromium'
        , chromium: t
        , version: getFirstMatch(/(?:chromium)[\s\/](\d+(?:\.\d+)?)/i) || versionIdentifier
      }
    }
    else if (/chrome|crios|crmo/i.test(ua)) {
      result = {
        name: 'Chrome'
        , chrome: t
        , version: getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.\d+)?)/i)
      }
    }
    else if (android) {
      result = {
        name: 'Android'
        , version: versionIdentifier
      }
    }
    else if (/safari|applewebkit/i.test(ua)) {
      result = {
        name: 'Safari'
      , safari: t
      }
      if (versionIdentifier) {
        result.version = versionIdentifier
      }
    }
    else if (iosdevice) {
      result = {
        name : iosdevice == 'iphone' ? 'iPhone' : iosdevice == 'ipad' ? 'iPad' : 'iPod'
      }
      // WTF: version is not part of user agent in web apps
      if (versionIdentifier) {
        result.version = versionIdentifier
      }
    }
    else if(/googlebot/i.test(ua)) {
      result = {
        name: 'Googlebot'
      , googlebot: t
      , version: getFirstMatch(/googlebot\/(\d+(\.\d+))/i) || versionIdentifier
      }
    }
    else {
      result = {
        name: getFirstMatch(/^(.*)\/(.*) /),
        version: getSecondMatch(/^(.*)\/(.*) /)
     };
   }

    // set webkit or gecko flag for browsers based on these engines
    if (!result.msedge && /(apple)?webkit/i.test(ua)) {
      if (/(apple)?webkit\/537\.36/i.test(ua)) {
        result.name = result.name || "Blink"
        result.blink = t
      } else {
        result.name = result.name || "Webkit"
        result.webkit = t
      }
      if (!result.version && versionIdentifier) {
        result.version = versionIdentifier
      }
    } else if (!result.opera && /gecko\//i.test(ua)) {
      result.name = result.name || "Gecko"
      result.gecko = t
      result.version = result.version || getFirstMatch(/gecko\/(\d+(\.\d+)?)/i)
    }

    // set OS flags for platforms that have multiple browsers
    if (!result.windowsphone && (android || result.silk)) {
      result.android = t
      result.osname = 'Android'
    } else if (!result.windowsphone && iosdevice) {
      result[iosdevice] = t
      result.ios = t
      result.osname = 'iOS'
    } else if (mac) {
      result.mac = t
      result.osname = 'macOS'
    } else if (xbox) {
      result.xbox = t
      result.osname = 'Xbox'
    } else if (windows) {
      result.windows = t
      result.osname = 'Windows'
    } else if (linux) {
      result.linux = t
      result.osname = 'Linux'
    }

    function getWindowsVersion (s) {
      switch (s) {
        case 'NT': return 'NT'
        case 'XP': return 'XP'
        case 'NT 5.0': return '2000'
        case 'NT 5.1': return 'XP'
        case 'NT 5.2': return '2003'
        case 'NT 6.0': return 'Vista'
        case 'NT 6.1': return '7'
        case 'NT 6.2': return '8'
        case 'NT 6.3': return '8.1'
        case 'NT 10.0': return '10'
        default: return undefined
      }
    }

    // OS version extraction
    var osVersion = '';
    if (result.windows) {
      osVersion = getWindowsVersion(getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i))
    } else if (result.windowsphone) {
      osVersion = getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i);
    } else if (result.mac) {
      osVersion = getFirstMatch(/Mac OS X (\d+([_\.\s]\d+)*)/i);
      osVersion = osVersion.replace(/[_\s]/g, '.');
    } else if (iosdevice) {
      osVersion = getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i);
      osVersion = osVersion.replace(/[_\s]/g, '.');
    } else if (android) {
      osVersion = getFirstMatch(/android[ \/-](\d+(\.\d+)*)/i);
    } else if (result.webos) {
      osVersion = getFirstMatch(/(?:web|hpw)os\/(\d+(\.\d+)*)/i);
    } else if (result.blackberry) {
      osVersion = getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i);
    } else if (result.bada) {
      osVersion = getFirstMatch(/bada\/(\d+(\.\d+)*)/i);
    } else if (result.tizen) {
      osVersion = getFirstMatch(/tizen[\/\s](\d+(\.\d+)*)/i);
    }
    if (osVersion) {
      result.osversion = osVersion;
    }

    // device type extraction
    var osMajorVersion = !result.windows && osVersion.split('.')[0];
    if (
         tablet
      || nexusTablet
      || iosdevice == 'ipad'
      || (android && (osMajorVersion == 3 || (osMajorVersion >= 4 && !mobile)))
      || result.silk
    ) {
      result.tablet = t
    } else if (
         mobile
      || iosdevice == 'iphone'
      || iosdevice == 'ipod'
      || android
      || nexusMobile
      || result.blackberry
      || result.webos
      || result.bada
    ) {
      result.mobile = t
    }

    // Graded Browser Support
    // http://developer.yahoo.com/yui/articles/gbs
    if (result.msedge ||
        (result.msie && result.version >= 10) ||
        (result.yandexbrowser && result.version >= 15) ||
		    (result.vivaldi && result.version >= 1.0) ||
        (result.chrome && result.version >= 20) ||
        (result.samsungBrowser && result.version >= 4) ||
        (result.whale && compareVersions([result.version, '1.0']) === 1) ||
        (result.mzbrowser && compareVersions([result.version, '6.0']) === 1) ||
        (result.focus && compareVersions([result.version, '1.0']) === 1) ||
        (result.firefox && result.version >= 20.0) ||
        (result.safari && result.version >= 6) ||
        (result.opera && result.version >= 10.0) ||
        (result.ios && result.osversion && result.osversion.split(".")[0] >= 6) ||
        (result.blackberry && result.version >= 10.1)
        || (result.chromium && result.version >= 20)
        ) {
      result.a = t;
    }
    else if ((result.msie && result.version < 10) ||
        (result.chrome && result.version < 20) ||
        (result.firefox && result.version < 20.0) ||
        (result.safari && result.version < 6) ||
        (result.opera && result.version < 10.0) ||
        (result.ios && result.osversion && result.osversion.split(".")[0] < 6)
        || (result.chromium && result.version < 20)
        ) {
      result.c = t
    } else result.x = t

    return result
  }

  var bowser = detect(typeof navigator !== 'undefined' ? navigator.userAgent || '' : '')

  bowser.test = function (browserList) {
    for (var i = 0; i < browserList.length; ++i) {
      var browserItem = browserList[i];
      if (typeof browserItem=== 'string') {
        if (browserItem in bowser) {
          return true;
        }
      }
    }
    return false;
  }

  /**
   * Get version precisions count
   *
   * @example
   *   getVersionPrecision("1.10.3") // 3
   *
   * @param  {string} version
   * @return {number}
   */
  function getVersionPrecision(version) {
    return version.split(".").length;
  }

  /**
   * Array::map polyfill
   *
   * @param  {Array} arr
   * @param  {Function} iterator
   * @return {Array}
   */
  function map(arr, iterator) {
    var result = [], i;
    if (Array.prototype.map) {
      return Array.prototype.map.call(arr, iterator);
    }
    for (i = 0; i < arr.length; i++) {
      result.push(iterator(arr[i]));
    }
    return result;
  }

  /**
   * Calculate browser version weight
   *
   * @example
   *   compareVersions(['1.10.2.1',  '1.8.2.1.90'])    // 1
   *   compareVersions(['1.010.2.1', '1.09.2.1.90']);  // 1
   *   compareVersions(['1.10.2.1',  '1.10.2.1']);     // 0
   *   compareVersions(['1.10.2.1',  '1.0800.2']);     // -1
   *
   * @param  {Array<String>} versions versions to compare
   * @return {Number} comparison result
   */
  function compareVersions(versions) {
    // 1) get common precision for both versions, for example for "10.0" and "9" it should be 2
    var precision = Math.max(getVersionPrecision(versions[0]), getVersionPrecision(versions[1]));
    var chunks = map(versions, function (version) {
      var delta = precision - getVersionPrecision(version);

      // 2) "9" -> "9.0" (for precision = 2)
      version = version + new Array(delta + 1).join(".0");

      // 3) "9.0" -> ["000000000"", "000000009"]
      return map(version.split("."), function (chunk) {
        return new Array(20 - chunk.length).join("0") + chunk;
      }).reverse();
    });

    // iterate in reverse order by reversed chunks array
    while (--precision >= 0) {
      // 4) compare: "000000009" > "000000010" = false (but "9" > "10" = true)
      if (chunks[0][precision] > chunks[1][precision]) {
        return 1;
      }
      else if (chunks[0][precision] === chunks[1][precision]) {
        if (precision === 0) {
          // all version chunks are same
          return 0;
        }
      }
      else {
        return -1;
      }
    }
  }

  /**
   * Check if browser is unsupported
   *
   * @example
   *   bowser.isUnsupportedBrowser({
   *     msie: "10",
   *     firefox: "23",
   *     chrome: "29",
   *     safari: "5.1",
   *     opera: "16",
   *     phantom: "534"
   *   });
   *
   * @param  {Object}  minVersions map of minimal version to browser
   * @param  {Boolean} [strictMode = false] flag to return false if browser wasn't found in map
   * @param  {String}  [ua] user agent string
   * @return {Boolean}
   */
  function isUnsupportedBrowser(minVersions, strictMode, ua) {
    var _bowser = bowser;

    // make strictMode param optional with ua param usage
    if (typeof strictMode === 'string') {
      ua = strictMode;
      strictMode = void(0);
    }

    if (strictMode === void(0)) {
      strictMode = false;
    }
    if (ua) {
      _bowser = detect(ua);
    }

    var version = "" + _bowser.version;
    for (var browser in minVersions) {
      if (minVersions.hasOwnProperty(browser)) {
        if (_bowser[browser]) {
          if (typeof minVersions[browser] !== 'string') {
            throw new Error('Browser version in the minVersion map should be a string: ' + browser + ': ' + String(minVersions));
          }

          // browser version and min supported version.
          return compareVersions([version, minVersions[browser]]) < 0;
        }
      }
    }

    return strictMode; // not found
  }

  /**
   * Check if browser is supported
   *
   * @param  {Object} minVersions map of minimal version to browser
   * @param  {Boolean} [strictMode = false] flag to return false if browser wasn't found in map
   * @param  {String}  [ua] user agent string
   * @return {Boolean}
   */
  function check(minVersions, strictMode, ua) {
    return !isUnsupportedBrowser(minVersions, strictMode, ua);
  }

  bowser.isUnsupportedBrowser = isUnsupportedBrowser;
  bowser.compareVersions = compareVersions;
  bowser.check = check;

  /*
   * Set our detect method to the main bowser object so we can
   * reuse it to test other user agents.
   * This is needed to implement future tests.
   */
  bowser._detect = detect;

  /*
   * Set our detect public method to the main bowser object
   * This is needed to implement bowser in server side
   */
  bowser.detect = detect;
  return bowser
});

},{}],"main":[function(require,module,exports){
var Helpers = require('./helpers')
var App = require('./app');
var polyfills = require('./polyfills');

polyfills.applyPolyfills();

var instance;

module.exports = (function () {
    var getInstance = function () {
        if (!instance) {
            instance = new App();
        }
        return instance;
    };

    return Object.assign(Helpers.zipObject(['init', 'open', 'close', 'on', 'off', 'sendMessage', 'onMessage'].map(function (methodName) {
        var app = getInstance();
        return [methodName, function () {
            return app[methodName].apply(app, arguments);
        }];
    })), {
        eventTypes: App.eventTypes,
    });
})();

},{"./app":3,"./helpers":7,"./polyfills":9}]},{},["main"])("main")
});

//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvY3NzaWZ5L2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvc2Fzc2lmeS9saWIvc2Fzc2lmeS1icm93c2VyLmpzIiwic3JjL2FwcC5qcyIsInNyYy9jaGlsZHdpbmRvdy5qcyIsInNyYy9kZXZpY2UuanMiLCJzcmMvZXhjZXB0aW9uLmpzIiwic3JjL2hlbHBlcnMuanMiLCJzcmMvbGlnaHRib3guanMiLCJzcmMvcG9seWZpbGxzLmpzIiwic3JjL3Bvc3RtZXNzYWdlLmpzIiwic3JjL3NwaW5uZXJzL3JvdW5kLnN2ZyIsInNyYy9zcGlubmVycy94c29sbGEuc3ZnIiwic3JjL3N0eWxlcy9saWdodGJveC5zY3NzIiwic3JjL3ZlcnNpb24uanMiLCJib3dlcl9jb21wb25lbnRzL2Jvd3Nlci9zcmMvYm93c2VyLmpzIiwic3JjL21haW4uanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDdFNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDOUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDN0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzVYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3JFQTtBQUNBOztBQ0RBO0FBQ0E7O0FDREE7O0FDQUE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcG9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNzcywgY3VzdG9tRG9jdW1lbnQpIHtcbiAgdmFyIGRvYyA9IGN1c3RvbURvY3VtZW50IHx8IGRvY3VtZW50O1xuICBpZiAoZG9jLmNyZWF0ZVN0eWxlU2hlZXQpIHtcbiAgICB2YXIgc2hlZXQgPSBkb2MuY3JlYXRlU3R5bGVTaGVldCgpXG4gICAgc2hlZXQuY3NzVGV4dCA9IGNzcztcbiAgICByZXR1cm4gc2hlZXQub3duZXJOb2RlO1xuICB9IGVsc2Uge1xuICAgIHZhciBoZWFkID0gZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0sXG4gICAgICAgIHN0eWxlID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG5cbiAgICBzdHlsZS50eXBlID0gJ3RleHQvY3NzJztcblxuICAgIGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG4gICAgICBzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlLmFwcGVuZENoaWxkKGRvYy5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcbiAgICB9XG5cbiAgICBoZWFkLmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgICByZXR1cm4gc3R5bGU7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzLmJ5VXJsID0gZnVuY3Rpb24odXJsKSB7XG4gIGlmIChkb2N1bWVudC5jcmVhdGVTdHlsZVNoZWV0KSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVN0eWxlU2hlZXQodXJsKS5vd25lck5vZGU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGhlYWQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdLFxuICAgICAgICBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGluaycpO1xuXG4gICAgbGluay5yZWwgPSAnc3R5bGVzaGVldCc7XG4gICAgbGluay5ocmVmID0gdXJsO1xuXG4gICAgaGVhZC5hcHBlbmRDaGlsZChsaW5rKTtcbiAgICByZXR1cm4gbGluaztcbiAgfVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnY3NzaWZ5Jyk7IiwidmFyIEhlbHBlcnMgPSByZXF1aXJlKCcuL2hlbHBlcnMnKTtcbnZhciBFeGNlcHRpb24gPSByZXF1aXJlKCcuL2V4Y2VwdGlvbicpO1xudmFyIExpZ2h0Qm94ID0gcmVxdWlyZSgnLi9saWdodGJveCcpO1xudmFyIENoaWxkV2luZG93ID0gcmVxdWlyZSgnLi9jaGlsZHdpbmRvdycpO1xudmFyIERldmljZSA9IHJlcXVpcmUoJy4vZGV2aWNlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiByZWFkeShmbikge1xuICAgICAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gJ2xvYWRpbmcnKXtcbiAgICAgICAgICBmbigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBmbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBBcHAoKSB7XG4gICAgICAgIHRoaXMuY29uZmlnID0gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9DT05GSUcpO1xuICAgICAgICB0aGlzLmV2ZW50T2JqZWN0ID0gSGVscGVycy5hZGRFdmVudE9iamVjdCh0aGlzKTtcbiAgICAgICAgdGhpcy5pc0luaXRpYXRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnBvc3RNZXNzYWdlID0gbnVsbDtcbiAgICB9XG5cbiAgICBBcHAuZXZlbnRUeXBlcyA9IHtcbiAgICAgICAgSU5JVDogJ2luaXQnLFxuICAgICAgICBPUEVOOiAnb3BlbicsXG4gICAgICAgIE9QRU5fV0lORE9XOiAnb3Blbi13aW5kb3cnLFxuICAgICAgICBPUEVOX0xJR0hUQk9YOiAnb3Blbi1saWdodGJveCcsXG4gICAgICAgIExPQUQ6ICdsb2FkJyxcbiAgICAgICAgQ0xPU0U6ICdjbG9zZScsXG4gICAgICAgIENMT1NFX1dJTkRPVzogJ2Nsb3NlLXdpbmRvdycsXG4gICAgICAgIENMT1NFX0xJR0hUQk9YOiAnY2xvc2UtbGlnaHRib3gnLFxuICAgICAgICBTVEFUVVM6ICdzdGF0dXMnLFxuICAgICAgICBTVEFUVVNfSU5WT0lDRTogJ3N0YXR1cy1pbnZvaWNlJyxcbiAgICAgICAgU1RBVFVTX0RFTElWRVJJTkc6ICdzdGF0dXMtZGVsaXZlcmluZycsXG4gICAgICAgIFNUQVRVU19UUk9VQkxFRDogJ3N0YXR1cy10cm91YmxlZCcsXG4gICAgICAgIFNUQVRVU19ET05FOiAnc3RhdHVzLWRvbmUnLFxuICAgICAgICBVU0VSX0NPVU5UUlk6ICd1c2VyLWNvdW50cnknXG4gICAgfTtcblxuICAgIHZhciBERUZBVUxUX0NPTkZJRyA9IHtcbiAgICAgICAgYWNjZXNzX3Rva2VuOiBudWxsLFxuICAgICAgICBhY2Nlc3NfZGF0YTogbnVsbCxcbiAgICAgICAgc2FuZGJveDogZmFsc2UsXG4gICAgICAgIGxpZ2h0Ym94OiB7fSxcbiAgICAgICAgY2hpbGRXaW5kb3c6IHt9LFxuICAgICAgICBob3N0OiAnc2VjdXJlLnhzb2xsYS5jb20nLFxuICAgICAgICBpZnJhbWVPbmx5OiBmYWxzZVxuICAgIH07XG4gICAgdmFyIFNBTkRCT1hfUEFZU1RBVElPTl9VUkwgPSAnaHR0cHM6Ly9zYW5kYm94LXNlY3VyZS54c29sbGEuY29tL3BheXN0YXRpb24yLz8nO1xuICAgIHZhciBFVkVOVF9OQU1FU1BBQ0UgPSAnLnhwYXlzdGF0aW9uLXdpZGdldCc7XG4gICAgdmFyIEFUVFJfUFJFRklYID0gJ2RhdGEteHBheXN0YXRpb24td2lkZ2V0LW9wZW4nO1xuXG4gICAgLyoqIFByaXZhdGUgTWVtYmVycyAqKi9cbiAgICBBcHAucHJvdG90eXBlLmNvbmZpZyA9IHt9O1xuICAgIEFwcC5wcm90b3R5cGUuaXNJbml0aWF0ZWQgPSBmYWxzZTtcbiAgICBBcHAucHJvdG90eXBlLmV2ZW50T2JqZWN0ID0gSGVscGVycy5hZGRFdmVudE9iamVjdCh0aGlzKTtcblxuICAgIEFwcC5wcm90b3R5cGUuZ2V0UGF5bWVudFVybCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLnBheW1lbnRfdXJsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25maWcucGF5bWVudF91cmw7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBxdWVyeSA9IHt9O1xuICAgICAgICBpZiAodGhpcy5jb25maWcuYWNjZXNzX3Rva2VuKSB7XG4gICAgICAgICAgICBxdWVyeS5hY2Nlc3NfdG9rZW4gPSB0aGlzLmNvbmZpZy5hY2Nlc3NfdG9rZW47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBxdWVyeS5hY2Nlc3NfZGF0YSA9IEpTT04uc3RyaW5naWZ5KHRoaXMuY29uZmlnLmFjY2Vzc19kYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHVybFdpdGhvdXRRdWVyeVBhcmFtcyA9IHRoaXMuY29uZmlnLnNhbmRib3ggP1xuICAgICAgICAgICAgU0FOREJPWF9QQVlTVEFUSU9OX1VSTCA6XG4gICAgICAgICAgICAnaHR0cHM6Ly8nICsgdGhpcy5jb25maWcuaG9zdCArICcvcGF5c3RhdGlvbjIvPyc7XG4gICAgICAgIHJldHVybiB1cmxXaXRob3V0UXVlcnlQYXJhbXMgKyBIZWxwZXJzLnBhcmFtKHF1ZXJ5KTtcbiAgICB9O1xuXG4gICAgQXBwLnByb3RvdHlwZS5jaGVja0NvbmZpZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKEhlbHBlcnMuaXNFbXB0eSh0aGlzLmNvbmZpZy5hY2Nlc3NfdG9rZW4pICYmIEhlbHBlcnMuaXNFbXB0eSh0aGlzLmNvbmZpZy5hY2Nlc3NfZGF0YSkgJiYgSGVscGVycy5pc0VtcHR5KHRoaXMuY29uZmlnLnBheW1lbnRfdXJsKSkge1xuICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKCdObyBhY2Nlc3MgdG9rZW4gb3IgYWNjZXNzIGRhdGEgb3IgcGF5bWVudCBVUkwgZ2l2ZW4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghSGVscGVycy5pc0VtcHR5KHRoaXMuY29uZmlnLmFjY2Vzc19kYXRhKSAmJiB0eXBlb2YgdGhpcy5jb25maWcuYWNjZXNzX2RhdGEgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0aGlzLnRocm93RXJyb3IoJ0ludmFsaWQgYWNjZXNzIGRhdGEgZm9ybWF0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoSGVscGVycy5pc0VtcHR5KHRoaXMuY29uZmlnLmhvc3QpKSB7XG4gICAgICAgICAgICB0aGlzLnRocm93RXJyb3IoJ0ludmFsaWQgaG9zdCcpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIEFwcC5wcm90b3R5cGUuY2hlY2tBcHAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzSW5pdGlhdGVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcignSW5pdGlhbGl6ZSB3aWRnZXQgYmVmb3JlIG9wZW5pbmcnKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBBcHAucHJvdG90eXBlLnRocm93RXJyb3IgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKG1lc3NhZ2UpO1xuICAgIH07XG5cbiAgICBBcHAucHJvdG90eXBlLnRyaWdnZXJFdmVudCA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGRhdGEpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIFtdLmZvckVhY2guY2FsbChhcmd1bWVudHMsIChmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0hUTUxFdmVudHMnKTtcbiAgICAgICAgICAgICAgICBldmVudC5pbml0RXZlbnQoZXZlbnROYW1lLCB0cnVlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgICAgICB9KS5iaW5kKHRoaXMpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRPYmplY3QudHJpZ2dlcihldmVudE5hbWUsIGRhdGEpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIEFwcC5wcm90b3R5cGUudHJpZ2dlckN1c3RvbUV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgZGF0YSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KGV2ZW50TmFtZSwge2RldGFpbDogZGF0YX0pOyAvLyBOb3Qgd29ya2luZyBpbiBJRVxuICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgIHZhciBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpO1xuICAgICAgICAgICAgZXZlbnQuaW5pdEN1c3RvbUV2ZW50KGV2ZW50TmFtZSwgdHJ1ZSwgdHJ1ZSwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgd2lkZ2V0IHdpdGggb3B0aW9uc1xuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICovXG4gICAgQXBwLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICBmdW5jdGlvbiBpbml0aWFsaXplKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuaXNJbml0aWF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5jb25maWcgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX0NPTkZJRywgb3B0aW9ucyk7XG5cbiAgICAgICAgICAgIHZhciBib2R5RWxlbWVudCA9IGdsb2JhbC5kb2N1bWVudC5ib2R5O1xuICAgICAgICAgICAgdmFyIGNsaWNrRXZlbnROYW1lID0gJ2NsaWNrJyArIEVWRU5UX05BTUVTUEFDRTtcblxuICAgICAgICAgICAgdmFyIGhhbmRsZUNsaWNrRXZlbnQgPSAoZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0RWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ1snICsgQVRUUl9QUkVGSVggKyAnXScpO1xuICAgICAgICAgICAgICAgIGlmIChldmVudC5zb3VyY2VFdmVudC50YXJnZXQgPT09IHRhcmdldEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcGVuLmNhbGwodGhpcywgdGFyZ2V0RWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkuYmluZCh0aGlzKTtcblxuICAgICAgICAgICAgYm9keUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihjbGlja0V2ZW50TmFtZSwgaGFuZGxlQ2xpY2tFdmVudCk7XG5cbiAgICAgICAgICAgIHZhciBjbGlja0V2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgICAgICAgICBjbGlja0V2ZW50LmluaXRFdmVudChjbGlja0V2ZW50TmFtZSwgZmFsc2UsIHRydWUpO1xuXG4gICAgICAgICAgICBib2R5RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgIGNsaWNrRXZlbnQuc291cmNlRXZlbnQgPSBldmVudDtcbiAgICAgICAgICAgICAgICBib2R5RWxlbWVudC5kaXNwYXRjaEV2ZW50KGNsaWNrRXZlbnQpO1xuICAgICAgICAgICAgfSkuYmluZCh0aGlzKSwgZmFsc2UpO1xuXG4gICAgICAgICAgICBib2R5RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGNsaWNrRXZlbnROYW1lLCBoYW5kbGVDbGlja0V2ZW50KTtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlckV2ZW50KEFwcC5ldmVudFR5cGVzLklOSVQpO1xuICAgICAgICB9XG4gICAgICAgIHJlYWR5KGluaXRpYWxpemUuYmluZCh0aGlzLCBvcHRpb25zKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3BlbiBwYXltZW50IGludGVyZmFjZSAoUGF5U3RhdGlvbilcbiAgICAgKi9cbiAgICBBcHAucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY2hlY2tDb25maWcoKTtcbiAgICAgICAgdGhpcy5jaGVja0FwcCgpO1xuXG4gICAgICAgIHZhciB0cmlnZ2VyU3BsaXRTdGF0dXMgPSAoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoKChkYXRhIHx8IHt9KS5wYXltZW50SW5mbyB8fCB7fSkuc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnaW52b2ljZSc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlckV2ZW50KEFwcC5ldmVudFR5cGVzLlNUQVRVU19JTlZPSUNFLCBkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZGVsaXZlcmluZyc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlckV2ZW50KEFwcC5ldmVudFR5cGVzLlNUQVRVU19ERUxJVkVSSU5HLCBkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAndHJvdWJsZWQnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXJFdmVudChBcHAuZXZlbnRUeXBlcy5TVEFUVVNfVFJPVUJMRUQsIGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdkb25lJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyRXZlbnQoQXBwLmV2ZW50VHlwZXMuU1RBVFVTX0RPTkUsIGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkuYmluZCh0aGlzKTtcblxuICAgICAgICB2YXIgdXJsID0gdGhpcy5nZXRQYXltZW50VXJsKCk7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVTdGF0dXMoZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBzdGF0dXNEYXRhID0gZXZlbnQuZGV0YWlsO1xuICAgICAgICAgICAgdGhhdC50cmlnZ2VyRXZlbnQoQXBwLmV2ZW50VHlwZXMuU1RBVFVTLCBzdGF0dXNEYXRhKTtcbiAgICAgICAgICAgIHRyaWdnZXJTcGxpdFN0YXR1cyhzdGF0dXNEYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZVVzZXJMb2NhbGUoZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciB1c2VyQ291bnRyeSA9IHtcbiAgICAgICAgICAgICAgICB1c2VyX2NvdW50cnk6IGV2ZW50LmRldGFpbC51c2VyX2NvdW50cnlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGF0LnRyaWdnZXJDdXN0b21FdmVudChBcHAuZXZlbnRUeXBlcy5VU0VSX0NPVU5UUlksIHVzZXJDb3VudHJ5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucG9zdE1lc3NhZ2UgPSBudWxsO1xuICAgICAgICBpZiAoKG5ldyBEZXZpY2UpLmlzTW9iaWxlKCkgJiYgIXRoaXMuY29uZmlnLmlmcmFtZU9ubHkpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZFdpbmRvdyA9IG5ldyBDaGlsZFdpbmRvdztcbiAgICAgICAgICAgIGNoaWxkV2luZG93Lm9uKCdvcGVuJywgZnVuY3Rpb24gaGFuZGxlT3BlbigpIHtcbiAgICAgICAgICAgICAgICB0aGF0LnBvc3RNZXNzYWdlID0gY2hpbGRXaW5kb3cuZ2V0UG9zdE1lc3NhZ2UoKTtcbiAgICAgICAgICAgICAgICB0aGF0LnRyaWdnZXJFdmVudChBcHAuZXZlbnRUeXBlcy5PUEVOKTtcbiAgICAgICAgICAgICAgICB0aGF0LnRyaWdnZXJFdmVudChBcHAuZXZlbnRUeXBlcy5PUEVOX1dJTkRPVyk7XG4gICAgICAgICAgICAgICAgY2hpbGRXaW5kb3cub2ZmKCdvcGVuJywgaGFuZGxlT3Blbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNoaWxkV2luZG93Lm9uKCdsb2FkJywgZnVuY3Rpb24gaGFuZGxlTG9hZCgpIHtcbiAgICAgICAgICAgICAgICB0aGF0LnRyaWdnZXJFdmVudChBcHAuZXZlbnRUeXBlcy5MT0FEKTtcbiAgICAgICAgICAgICAgICBjaGlsZFdpbmRvdy5vZmYoJ2xvYWQnLCBoYW5kbGVMb2FkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2hpbGRXaW5kb3cub24oJ2Nsb3NlJywgZnVuY3Rpb24gaGFuZGxlQ2xvc2UoKSB7XG4gICAgICAgICAgICAgICAgdGhhdC50cmlnZ2VyRXZlbnQoQXBwLmV2ZW50VHlwZXMuQ0xPU0UpO1xuICAgICAgICAgICAgICAgIHRoYXQudHJpZ2dlckV2ZW50KEFwcC5ldmVudFR5cGVzLkNMT1NFX1dJTkRPVyk7XG4gICAgICAgICAgICAgICAgY2hpbGRXaW5kb3cub2ZmKCdzdGF0dXMnLCBoYW5kbGVTdGF0dXMpO1xuICAgICAgICAgICAgICAgIGNoaWxkV2luZG93Lm9mZihBcHAuZXZlbnRUeXBlcy5VU0VSX0NPVU5UUlksIGhhbmRsZVVzZXJMb2NhbGUpO1xuICAgICAgICAgICAgICAgIGNoaWxkV2luZG93Lm9mZignY2xvc2UnLCBoYW5kbGVDbG9zZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNoaWxkV2luZG93Lm9uKCdzdGF0dXMnLCBoYW5kbGVTdGF0dXMpO1xuICAgICAgICAgICAgY2hpbGRXaW5kb3cub24oQXBwLmV2ZW50VHlwZXMuVVNFUl9DT1VOVFJZLCBoYW5kbGVVc2VyTG9jYWxlKTtcbiAgICAgICAgICAgIGNoaWxkV2luZG93Lm9wZW4odXJsLCB0aGlzLmNvbmZpZy5jaGlsZFdpbmRvdyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgbGlnaHRCb3ggPSBuZXcgTGlnaHRCb3goKG5ldyBEZXZpY2UpLmlzTW9iaWxlKCkgJiYgdGhpcy5jb25maWcuaWZyYW1lT25seSk7XG4gICAgICAgICAgICBsaWdodEJveC5vbignb3BlbicsIGZ1bmN0aW9uIGhhbmRsZU9wZW4oKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5wb3N0TWVzc2FnZSA9IGxpZ2h0Qm94LmdldFBvc3RNZXNzYWdlKCk7XG4gICAgICAgICAgICAgICAgdGhhdC50cmlnZ2VyRXZlbnQoQXBwLmV2ZW50VHlwZXMuT1BFTik7XG4gICAgICAgICAgICAgICAgdGhhdC50cmlnZ2VyRXZlbnQoQXBwLmV2ZW50VHlwZXMuT1BFTl9MSUdIVEJPWCk7XG4gICAgICAgICAgICAgICAgbGlnaHRCb3gub2ZmKCdvcGVuJywgaGFuZGxlT3Blbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxpZ2h0Qm94Lm9uKCdsb2FkJywgZnVuY3Rpb24gaGFuZGxlTG9hZCgpIHtcbiAgICAgICAgICAgICAgICB0aGF0LnRyaWdnZXJFdmVudChBcHAuZXZlbnRUeXBlcy5MT0FEKTtcbiAgICAgICAgICAgICAgICBsaWdodEJveC5vZmYoJ2xvYWQnLCBoYW5kbGVMb2FkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGlnaHRCb3gub24oJ2Nsb3NlJywgZnVuY3Rpb24gaGFuZGxlQ2xvc2UoKSB7XG4gICAgICAgICAgICAgICAgdGhhdC50cmlnZ2VyRXZlbnQoQXBwLmV2ZW50VHlwZXMuQ0xPU0UpO1xuICAgICAgICAgICAgICAgIHRoYXQudHJpZ2dlckV2ZW50KEFwcC5ldmVudFR5cGVzLkNMT1NFX0xJR0hUQk9YKTtcbiAgICAgICAgICAgICAgICBsaWdodEJveC5vZmYoJ3N0YXR1cycsIGhhbmRsZVN0YXR1cyk7XG4gICAgICAgICAgICAgICAgbGlnaHRCb3gub2ZmKEFwcC5ldmVudFR5cGVzLlVTRVJfQ09VTlRSWSwgaGFuZGxlVXNlckxvY2FsZSk7XG4gICAgICAgICAgICAgICAgbGlnaHRCb3gub2ZmKCdjbG9zZScsIGhhbmRsZUNsb3NlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGlnaHRCb3gub24oJ3N0YXR1cycsIGhhbmRsZVN0YXR1cyk7XG4gICAgICAgICAgICBsaWdodEJveC5vbihBcHAuZXZlbnRUeXBlcy5VU0VSX0NPVU5UUlksIGhhbmRsZVVzZXJMb2NhbGUpO1xuICAgICAgICAgICAgbGlnaHRCb3gub3BlbkZyYW1lKHVybCwgdGhpcy5jb25maWcubGlnaHRib3gpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEF0dGFjaCBhbiBldmVudCBoYW5kbGVyIGZ1bmN0aW9uIGZvciBvbmUgb3IgbW9yZSBldmVudHMgdG8gdGhlIHdpZGdldFxuICAgICAqIEBwYXJhbSBldmVudCBPbmUgb3IgbW9yZSBzcGFjZS1zZXBhcmF0ZWQgZXZlbnQgdHlwZXMgKGluaXQsIG9wZW4sIGxvYWQsIGNsb3NlLCBzdGF0dXMsIHN0YXR1cy1pbnZvaWNlLCBzdGF0dXMtZGVsaXZlcmluZywgc3RhdHVzLXRyb3VibGVkLCBzdGF0dXMtZG9uZSlcbiAgICAgKiBAcGFyYW0gaGFuZGxlciBBIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgd2hlbiB0aGUgZXZlbnQgaXMgdHJpZ2dlcmVkXG4gICAgICovXG4gICAgQXBwLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldmVudCwgaGFuZGxlciwgb3B0aW9ucykge1xuICAgICAgICBpZiAodHlwZW9mIGhhbmRsZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGhhbmRsZXJEZWNvcmF0b3IgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaGFuZGxlcihldmVudCwgZXZlbnQuZGV0YWlsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZXZlbnRPYmplY3Qub24oZXZlbnQsIGhhbmRsZXJEZWNvcmF0b3IsIG9wdGlvbnMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYW4gZXZlbnQgaGFuZGxlclxuICAgICAqIEBwYXJhbSBldmVudCBPbmUgb3IgbW9yZSBzcGFjZS1zZXBhcmF0ZWQgZXZlbnQgdHlwZXNcbiAgICAgKiBAcGFyYW0gaGFuZGxlciBBIGhhbmRsZXIgZnVuY3Rpb24gcHJldmlvdXNseSBhdHRhY2hlZCBmb3IgdGhlIGV2ZW50KHMpXG4gICAgICovXG4gICAgQXBwLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbiAoZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5ldmVudE9iamVjdC5vZmYoZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZW5kIGEgbWVzc2FnZSBkaXJlY3RseSB0byBQYXlTdGF0aW9uXG4gICAgICogQHBhcmFtIGNvbW1hbmRcbiAgICAgKiBAcGFyYW0gZGF0YVxuICAgICAqL1xuICAgIEFwcC5wcm90b3R5cGUuc2VuZE1lc3NhZ2UgPSBmdW5jdGlvbiAoY29tbWFuZCwgZGF0YSkge1xuICAgICAgICBpZiAodGhpcy5wb3N0TWVzc2FnZSkge1xuICAgICAgICAgICAgdGhpcy5wb3N0TWVzc2FnZS5zZW5kLmFwcGx5KHRoaXMucG9zdE1lc3NhZ2UsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQXR0YWNoIGFuIGV2ZW50IGhhbmRsZXIgZnVuY3Rpb24gZm9yIG1lc3NhZ2UgZXZlbnQgZnJvbSBQYXlTdGF0aW9uXG4gICAgICogQHBhcmFtIGNvbW1hbmRcbiAgICAgKiBAcGFyYW0gaGFuZGxlclxuICAgICAqL1xuICAgIEFwcC5wcm90b3R5cGUub25NZXNzYWdlID0gZnVuY3Rpb24gKGNvbW1hbmQsIGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKHRoaXMucG9zdE1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHRoaXMucG9zdE1lc3NhZ2Uub24uYXBwbHkodGhpcy5wb3N0TWVzc2FnZSwgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gQXBwO1xufSkoKTtcbiIsInZhciB2ZXJzaW9uID0gcmVxdWlyZSgnLi92ZXJzaW9uJyk7XG52YXIgSGVscGVycyA9IHJlcXVpcmUoJy4vaGVscGVycycpO1xudmFyIFBvc3RNZXNzYWdlID0gcmVxdWlyZSgnLi9wb3N0bWVzc2FnZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2hpbGRXaW5kb3coKSB7XG4gICAgICAgIHRoaXMuZXZlbnRPYmplY3QgPSBIZWxwZXJzLmFkZEV2ZW50T2JqZWN0KHRoaXMsIHdyYXBFdmVudEluTmFtZXNwYWNlKTtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3cmFwRXZlbnRJbk5hbWVzcGFjZShldmVudE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIENoaWxkV2luZG93Ll9OQU1FU1BBQ0UgKyAnXycgKyBldmVudE5hbWU7XG4gICAgfVxuXG4gICAgdmFyIERFRkFVTFRfT1BUSU9OUyA9IHtcbiAgICAgICAgdGFyZ2V0OiAnX2JsYW5rJ1xuICAgIH07XG5cbiAgICAvKiogUHJpdmF0ZSBNZW1iZXJzICoqL1xuICAgIENoaWxkV2luZG93LnByb3RvdHlwZS5ldmVudE9iamVjdCA9IG51bGw7XG4gICAgQ2hpbGRXaW5kb3cucHJvdG90eXBlLmNoaWxkV2luZG93ID0gbnVsbDtcblxuICAgIENoaWxkV2luZG93LnByb3RvdHlwZS50cmlnZ2VyRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQsIGRhdGEpIHtcbiAgICAgICAgdGhpcy5ldmVudE9iamVjdC50cmlnZ2VyKGV2ZW50LCBkYXRhKTtcbiAgICB9O1xuXG4gICAgLyoqIFB1YmxpYyBNZW1iZXJzICoqL1xuICAgIENoaWxkV2luZG93LnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKHVybCwgb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9PUFRJT05TLCBvcHRpb25zKTtcblxuICAgICAgICBpZiAodGhpcy5jaGlsZFdpbmRvdyAmJiAhdGhpcy5jaGlsZFdpbmRvdy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRXaW5kb3cubG9jYXRpb24uaHJlZiA9IHVybDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgdmFyIGFkZEhhbmRsZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhhdC5vbignY2xvc2UnLCBmdW5jdGlvbiBoYW5kbGVDbG9zZSgpIHtcbiAgICAgICAgICAgICAgICBpZiAodGltZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2xvYmFsLmNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGF0LmNoaWxkV2luZG93KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuY2hpbGRXaW5kb3cuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGF0Lm9mZignY2xvc2UnLCBoYW5kbGVDbG9zZSlcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBDcm9zcy13aW5kb3cgY29tbXVuaWNhdGlvblxuICAgICAgICAgICAgdGhhdC5tZXNzYWdlID0gbmV3IFBvc3RNZXNzYWdlKHRoYXQuY2hpbGRXaW5kb3cpO1xuICAgICAgICAgICAgdGhhdC5tZXNzYWdlLm9uKCdkaW1lbnNpb25zIHdpZGdldC1kZXRlY3Rpb24nLCBmdW5jdGlvbiBoYW5kbGVXaWRnZXREZXRlY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhhdC50cmlnZ2VyRXZlbnQoJ2xvYWQnKTtcbiAgICAgICAgICAgICAgICB0aGF0Lm1lc3NhZ2Uub2ZmKCdkaW1lbnNpb25zIHdpZGdldC1kZXRlY3Rpb24nLCBoYW5kbGVXaWRnZXREZXRlY3Rpb24pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGF0Lm1lc3NhZ2Uub24oJ3dpZGdldC1kZXRlY3Rpb24nLCBmdW5jdGlvbiBoYW5kbGVXaWRnZXREZXRlY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5tZXNzYWdlLnNlbmQoJ3dpZGdldC1kZXRlY3RlZCcsIHt2ZXJzaW9uOiB2ZXJzaW9uLCBjaGlsZFdpbmRvd09wdGlvbnM6IG9wdGlvbnN9KTtcbiAgICAgICAgICAgICAgICB0aGF0Lm1lc3NhZ2Uub2ZmKCd3aWRnZXQtZGV0ZWN0aW9uJywgaGFuZGxlV2lkZ2V0RGV0ZWN0aW9uKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhhdC5tZXNzYWdlLm9uKCdzdGF0dXMnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICB0aGF0LnRyaWdnZXJFdmVudCgnc3RhdHVzJywgZXZlbnQuZGV0YWlsKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhhdC5vbignY2xvc2UnLCBmdW5jdGlvbiBoYW5kbGVDbG9zZSgpIHtcbiAgICAgICAgICAgICAgICB0aGF0Lm1lc3NhZ2Uub2ZmKCk7XG4gICAgICAgICAgICAgICAgdGhhdC5vZmYoJ2Nsb3NlJywgaGFuZGxlQ2xvc2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGF0Lm1lc3NhZ2Uub24oJ3VzZXItY291bnRyeScsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgIHRoYXQudHJpZ2dlckV2ZW50KCd1c2VyLWNvdW50cnknLCBldmVudC5kZXRhaWwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgc3dpdGNoIChvcHRpb25zLnRhcmdldCkge1xuICAgICAgICAgICAgY2FzZSAnX3NlbGYnOlxuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRXaW5kb3cgPSBnbG9iYWwud2luZG93O1xuICAgICAgICAgICAgICAgIGFkZEhhbmRsZXJzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZFdpbmRvdy5sb2NhdGlvbi5ocmVmID0gdXJsO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnX3BhcmVudCc6XG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZFdpbmRvdyA9IGdsb2JhbC53aW5kb3cucGFyZW50O1xuICAgICAgICAgICAgICAgIGFkZEhhbmRsZXJzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZFdpbmRvdy5sb2NhdGlvbi5ocmVmID0gdXJsO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnX2JsYW5rJzpcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZFdpbmRvdyA9IGdsb2JhbC53aW5kb3cub3Blbih1cmwpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRXaW5kb3cuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICBhZGRIYW5kbGVycygpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGNoZWNrV2luZG93ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hpbGRXaW5kb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoaWxkV2luZG93LmNsb3NlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlckV2ZW50KCdjbG9zZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lciA9IGdsb2JhbC5zZXRUaW1lb3V0KGNoZWNrV2luZG93LCAxMDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkuYmluZCh0aGlzKTtcbiAgICAgICAgICAgICAgICB2YXIgdGltZXIgPSBnbG9iYWwuc2V0VGltZW91dChjaGVja1dpbmRvdywgMTAwKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudHJpZ2dlckV2ZW50KCdvcGVuJyk7XG4gICAgfTtcblxuICAgIENoaWxkV2luZG93LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyRXZlbnQoJ2Nsb3NlJyk7XG4gICAgfTtcblxuICAgIENoaWxkV2luZG93LnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldmVudCwgaGFuZGxlciwgb3B0aW9ucykge1xuICAgICAgICBpZiAodHlwZW9mIGhhbmRsZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZXZlbnRPYmplY3Qub24oZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgIH07XG5cbiAgICBDaGlsZFdpbmRvdy5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24gKGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuZXZlbnRPYmplY3Qub2ZmKGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICB9O1xuXG4gICAgQ2hpbGRXaW5kb3cucHJvdG90eXBlLmdldFBvc3RNZXNzYWdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlO1xuICAgIH07XG5cbiAgICBDaGlsZFdpbmRvdy5fTkFNRVNQQUNFID0gJ0NISUxEX1dJTkRPVyc7XG5cbiAgICByZXR1cm4gQ2hpbGRXaW5kb3c7XG59KSgpO1xuIiwidmFyIGJvd3NlciA9IHJlcXVpcmUoJ2Jvd3NlcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGV2aWNlKCkge1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1vYmlsZSBkZXZpY2VzXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgRGV2aWNlLnByb3RvdHlwZS5pc01vYmlsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gYm93c2VyLm1vYmlsZSB8fCBib3dzZXIudGFibGV0O1xuICAgIH07XG5cbiAgICByZXR1cm4gRGV2aWNlO1xufSkoKTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHRoaXMubmFtZSA9IFwiWHNvbGxhUGF5U3RhdGlvbldpZGdldEV4Y2VwdGlvblwiO1xuICAgIHRoaXMudG9TdHJpbmcgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYW1lICsgJzogJyArIHRoaXMubWVzc2FnZTtcbiAgICB9KS5iaW5kKHRoaXMpO1xufTtcbiIsImZ1bmN0aW9uIGlzRW1wdHkodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHVuaXEobGlzdCkge1xuICByZXR1cm4gbGlzdC5maWx0ZXIoZnVuY3Rpb24oeCwgaSwgYSkge1xuICAgIHJldHVybiBhLmluZGV4T2YoeCkgPT0gaVxuICB9KTtcbn1cblxuZnVuY3Rpb24gemlwT2JqZWN0KHByb3BzLCB2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwcm9wcyA/IHByb3BzLmxlbmd0aCA6IDAsXG4gICAgICByZXN1bHQgPSB7fTtcblxuICBpZiAobGVuZ3RoICYmICF2YWx1ZXMgJiYgIUFycmF5LmlzQXJyYXkocHJvcHNbMF0pKSB7XG4gICAgdmFsdWVzID0gW107XG4gIH1cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuICAgIGlmICh2YWx1ZXMpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gdmFsdWVzW2luZGV4XTtcbiAgICB9IGVsc2UgaWYgKGtleSkge1xuICAgICAgcmVzdWx0W2tleVswXV0gPSBrZXlbMV07XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHBhcmFtKGEpIHtcbiAgdmFyIHMgPSBbXTtcblxuICB2YXIgYWRkID0gZnVuY3Rpb24gKGssIHYpIHtcbiAgICAgIHYgPSB0eXBlb2YgdiA9PT0gJ2Z1bmN0aW9uJyA/IHYoKSA6IHY7XG4gICAgICB2ID0gdiA9PT0gbnVsbCA/ICcnIDogdiA9PT0gdW5kZWZpbmVkID8gJycgOiB2O1xuICAgICAgc1tzLmxlbmd0aF0gPSBlbmNvZGVVUklDb21wb25lbnQoaykgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodik7XG4gIH07XG5cbiAgdmFyIGJ1aWxkUGFyYW1zID0gZnVuY3Rpb24gKHByZWZpeCwgb2JqKSB7XG4gICAgICB2YXIgaSwgbGVuLCBrZXk7XG5cbiAgICAgIGlmIChwcmVmaXgpIHtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IG9iai5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgYnVpbGRQYXJhbXMoXG4gICAgICAgICAgICAgICAgICAgICAgcHJlZml4ICsgJ1snICsgKHR5cGVvZiBvYmpbaV0gPT09ICdvYmplY3QnICYmIG9ialtpXSA/IGkgOiAnJykgKyAnXScsXG4gICAgICAgICAgICAgICAgICAgICAgb2JqW2ldXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChTdHJpbmcob2JqKSA9PT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICAgICAgICAgICAgZm9yIChrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgICBidWlsZFBhcmFtcyhwcmVmaXggKyAnWycgKyBrZXkgKyAnXScsIG9ialtrZXldKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGFkZChwcmVmaXgsIG9iaik7XG4gICAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBvYmoubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgYWRkKG9ialtpXS5uYW1lLCBvYmpbaV0udmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yIChrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICAgIGJ1aWxkUGFyYW1zKGtleSwgb2JqW2tleV0pO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzO1xuICB9O1xuXG4gIHJldHVybiBidWlsZFBhcmFtcygnJywgYSkuam9pbignJicpO1xufTtcblxuXG5mdW5jdGlvbiBvbmNlKGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgZihhcmd1bWVudHMpO1xuICAgICAgZiA9IGZ1bmN0aW9uKCkge307XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkRXZlbnRPYmplY3QoY29udGV4dCwgd3JhcEV2ZW50SW5OYW1lc3BhY2UpIHtcbiAgICB2YXIgZHVtbXlXcmFwcGVyID0gZnVuY3Rpb24oZXZlbnQpIHsgcmV0dXJuIGV2ZW50IH07XG4gICAgdmFyIHdyYXBFdmVudEluTmFtZXNwYWNlID0gd3JhcEV2ZW50SW5OYW1lc3BhY2UgfHwgZHVtbXlXcmFwcGVyO1xuICAgIHZhciBldmVudHNMaXN0ID0gW107XG5cbiAgICBmdW5jdGlvbiBpc1N0cmluZ0NvbnRhaW5lZFNwYWNlKHN0cikge1xuICAgICAgcmV0dXJuIC8gLy50ZXN0KHN0cilcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHJpZ2dlcjogKGZ1bmN0aW9uKGV2ZW50TmFtZSwgZGF0YSkge1xuICAgICAgICAgIHZhciBldmVudEluTmFtZXNwYWNlID0gd3JhcEV2ZW50SW5OYW1lc3BhY2UoZXZlbnROYW1lKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB2YXIgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoZXZlbnRJbk5hbWVzcGFjZSwge2RldGFpbDogZGF0YX0pOyAvLyBOb3Qgd29ya2luZyBpbiBJRVxuICAgICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgICB2YXIgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnQ3VzdG9tRXZlbnQnKTtcbiAgICAgICAgICAgICAgZXZlbnQuaW5pdEN1c3RvbUV2ZW50KGV2ZW50SW5OYW1lc3BhY2UsIHRydWUsIHRydWUsIGRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgIH0pLmJpbmQoY29udGV4dCksXG4gICAgICBvbjogKGZ1bmN0aW9uKGV2ZW50TmFtZSwgaGFuZGxlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgZnVuY3Rpb24gYWRkRXZlbnQoZXZlbnROYW1lLCBoYW5kbGUsIG9wdGlvbnMpIHtcbiAgICAgICAgICB2YXIgZXZlbnRJbk5hbWVzcGFjZSA9IHdyYXBFdmVudEluTmFtZXNwYWNlKGV2ZW50TmFtZSk7XG4gICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudEluTmFtZXNwYWNlLCBoYW5kbGUsIG9wdGlvbnMpO1xuICAgICAgICAgIGV2ZW50c0xpc3QucHVzaCh7bmFtZTogZXZlbnRJbk5hbWVzcGFjZSwgaGFuZGxlOiBoYW5kbGUsIG9wdGlvbnM6IG9wdGlvbnMgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNTdHJpbmdDb250YWluZWRTcGFjZShldmVudE5hbWUpKSB7XG4gICAgICAgICAgdmFyIGV2ZW50cyA9IGV2ZW50TmFtZS5zcGxpdCgnICcpO1xuICAgICAgICAgIGV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uKHBhcnNlZEV2ZW50TmFtZSkge1xuICAgICAgICAgICAgYWRkRXZlbnQocGFyc2VkRXZlbnROYW1lLCBoYW5kbGUsIG9wdGlvbnMpXG4gICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGRFdmVudChldmVudE5hbWUsIGhhbmRsZSwgb3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgfSkuYmluZChjb250ZXh0KSxcblxuICAgICAgb2ZmOiAoZnVuY3Rpb24oZXZlbnROYW1lLCBoYW5kbGUsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3Qgb2ZmQWxsRXZlbnRzID0gIWV2ZW50TmFtZSAmJiAhaGFuZGxlICYmICFvcHRpb25zO1xuXG4gICAgICAgIGlmIChvZmZBbGxFdmVudHMpIHtcbiAgICAgICAgICBldmVudHNMaXN0LmZvckVhY2goZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQubmFtZSwgZXZlbnQuaGFuZGxlLCBldmVudC5vcHRpb25zKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByZW1vdmVFdmVudChldmVudE5hbWUsIGhhbmRsZSwgb3B0aW9ucykge1xuICAgICAgICAgIHZhciBldmVudEluTmFtZXNwYWNlID0gd3JhcEV2ZW50SW5OYW1lc3BhY2UoZXZlbnROYW1lKTtcbiAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50SW5OYW1lc3BhY2UsIGhhbmRsZSwgb3B0aW9ucyk7XG4gICAgICAgICAgZXZlbnRzTGlzdCA9IGV2ZW50c0xpc3QuZmlsdGVyKGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZXZlbnQubmFtZSAhPT0gZXZlbnRJbk5hbWVzcGFjZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1N0cmluZ0NvbnRhaW5lZFNwYWNlKGV2ZW50TmFtZSkpIHtcbiAgICAgICAgICB2YXIgZXZlbnRzID0gZXZlbnROYW1lLnNwbGl0KCcgJyk7XG4gICAgICAgICAgZXZlbnRzLmZvckVhY2goZnVuY3Rpb24ocGFyc2VkRXZlbnROYW1lKSB7XG4gICAgICAgICAgICByZW1vdmVFdmVudChwYXJzZWRFdmVudE5hbWUsIGhhbmRsZSwgb3B0aW9ucylcbiAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlbW92ZUV2ZW50KGV2ZW50TmFtZSwgaGFuZGxlLCBvcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICB9KS5iaW5kKGNvbnRleHQpXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBhZGRFdmVudE9iamVjdDogYWRkRXZlbnRPYmplY3QsXG4gIGlzRW1wdHk6IGlzRW1wdHksXG4gIHVuaXE6IHVuaXEsXG4gIHppcE9iamVjdDogemlwT2JqZWN0LFxuICBwYXJhbTogcGFyYW0sXG4gIG9uY2U6IG9uY2UsXG59XG4iLCJ2YXIgdmVyc2lvbiA9IHJlcXVpcmUoJy4vdmVyc2lvbicpO1xudmFyIEhlbHBlcnMgPSByZXF1aXJlKCcuL2hlbHBlcnMnKTtcbnZhciBQb3N0TWVzc2FnZSA9IHJlcXVpcmUoJy4vcG9zdG1lc3NhZ2UnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExpZ2h0Qm94KGlzTW9iaWxlKSB7XG4gICAgICAgIHJlcXVpcmUoJy4vc3R5bGVzL2xpZ2h0Ym94LnNjc3MnKTtcbiAgICAgICAgdGhpcy5ldmVudE9iamVjdCA9IEhlbHBlcnMuYWRkRXZlbnRPYmplY3QodGhpcywgd3JhcEV2ZW50SW5OYW1lc3BhY2UpO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBpc01vYmlsZSA/IERFRkFVTFRfT1BUSU9OU19NT0JJTEUgOiBERUZBVUxUX09QVElPTlM7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG51bGw7XG4gICAgfVxuXG4gICAgdmFyIENMQVNTX1BSRUZJWCA9ICd4cGF5c3RhdGlvbi13aWRnZXQtbGlnaHRib3gnO1xuICAgIHZhciBDT01NT05fT1BUSU9OUyA9IHtcbiAgICAgICAgekluZGV4OiAxMDAwLFxuICAgICAgICBvdmVybGF5T3BhY2l0eTogJy42JyxcbiAgICAgICAgb3ZlcmxheUJhY2tncm91bmQ6ICcjMDAwMDAwJyxcbiAgICAgICAgY29udGVudEJhY2tncm91bmQ6ICcjZmZmZmZmJyxcbiAgICAgICAgY2xvc2VCeUtleWJvYXJkOiB0cnVlLFxuICAgICAgICBjbG9zZUJ5Q2xpY2s6IHRydWUsXG4gICAgICAgIG1vZGFsOiBmYWxzZSxcbiAgICAgICAgc3Bpbm5lcjogJ3hzb2xsYScsXG4gICAgICAgIHNwaW5uZXJDb2xvcjogbnVsbCxcbiAgICAgICAgc3Bpbm5lclVybDogbnVsbCxcbiAgICAgICAgc3Bpbm5lclJvdGF0aW9uUGVyaW9kOiAwXG4gICAgfTtcbiAgICB2YXIgREVGQVVMVF9PUFRJT05TID0gT2JqZWN0LmFzc2lnbih7fSwgQ09NTU9OX09QVElPTlMsIHtcbiAgICAgICAgd2lkdGg6IG51bGwsXG4gICAgICAgIGhlaWdodDogJzEwMCUnLFxuICAgICAgICBjb250ZW50TWFyZ2luOiAnMTBweCdcbiAgICB9KTtcbiAgICB2YXIgREVGQVVMVF9PUFRJT05TX01PQklMRSA9IE9iamVjdC5hc3NpZ24oe30sIENPTU1PTl9PUFRJT05TLCB7XG4gICAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICAgIGhlaWdodDogJzEwMCUnLCBcbiAgICAgICAgY29udGVudE1hcmdpbjogJzBweCdcbiAgICB9KTtcblxuICAgIHZhciBTUElOTkVSUyA9IHtcbiAgICAgICAgeHNvbGxhOiByZXF1aXJlKCcuL3NwaW5uZXJzL3hzb2xsYS5zdmcnKSxcbiAgICAgICAgcm91bmQ6IHJlcXVpcmUoJy4vc3Bpbm5lcnMvcm91bmQuc3ZnJyksXG4gICAgICAgIG5vbmU6ICcgJ1xuICAgIH07XG5cbiAgICB2YXIgTUlOX1BTX0RJTUVOU0lPTlMgPSB7XG4gICAgICAgIGhlaWdodDogNTAwLFxuICAgICAgICB3aWR0aDogNjAwXG4gICAgfTtcblxuICAgIHZhciBoYW5kbGVLZXl1cEV2ZW50TmFtZSA9IHdyYXBFdmVudEluTmFtZXNwYWNlKCdrZXl1cCcpO1xuICAgIHZhciBoYW5kbGVSZXNpemVFdmVudE5hbWUgPSB3cmFwRXZlbnRJbk5hbWVzcGFjZSgncmVzaXplJyk7XG5cbiAgICB2YXIgaGFuZGxlR2xvYmFsS2V5dXAgPSBmdW5jdGlvbihldmVudCkge1xuXG4gICAgICAgIHZhciBjbGlja0V2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgICAgIGNsaWNrRXZlbnQuaW5pdEV2ZW50KGhhbmRsZUtleXVwRXZlbnROYW1lLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIGNsaWNrRXZlbnQuc291cmNlRXZlbnQgPSBldmVudDtcblxuICAgICAgICBkb2N1bWVudC5ib2R5LmRpc3BhdGNoRXZlbnQoY2xpY2tFdmVudCk7XG4gICAgfVxuXG4gICAgdmFyIGhhbmRsZVNwZWNpZmljS2V5dXAgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQuc291cmNlRXZlbnQud2hpY2ggPT0gMjcpIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VGcmFtZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGhhbmRsZUdsb2JhbFJlc2l6ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVzaXplRXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICAgICAgcmVzaXplRXZlbnQuaW5pdEV2ZW50KGhhbmRsZVJlc2l6ZUV2ZW50TmFtZSwgZmFsc2UsIHRydWUpO1xuXG4gICAgICAgIHdpbmRvdy5kaXNwYXRjaEV2ZW50KHJlc2l6ZUV2ZW50KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3cmFwRXZlbnRJbk5hbWVzcGFjZShldmVudE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIExpZ2h0Qm94Ll9OQU1FU1BBQ0UgKyAnXycgKyBldmVudE5hbWU7XG4gICAgfVxuXG4gICAgLyoqIFByaXZhdGUgTWVtYmVycyAqKi9cbiAgICBMaWdodEJveC5wcm90b3R5cGUudHJpZ2dlckV2ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmV2ZW50T2JqZWN0LnRyaWdnZXIuYXBwbHkodGhpcy5ldmVudE9iamVjdCwgYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgTGlnaHRCb3gucHJvdG90eXBlLm1lYXN1cmVTY3JvbGxiYXIgPSBmdW5jdGlvbiAoKSB7IC8vIHRoeCB3YWxzaDogaHR0cHM6Ly9kYXZpZHdhbHNoLm5hbWUvZGV0ZWN0LXNjcm9sbGJhci13aWR0aFxuICAgICAgICB2YXIgc2Nyb2xsRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgc2Nyb2xsRGl2LmNsYXNzTGlzdC5hZGQoXCJzY3JvbGxiYXItbWVhc3VyZVwiKTtcbiAgICAgICAgc2Nyb2xsRGl2LnNldEF0dHJpYnV0ZShcInN0eWxlXCIsXG4gICAgICAgICAgICBcInBvc2l0aW9uOiBhYnNvbHV0ZTtcIiArXG4gICAgICAgICAgICBcInRvcDogLTk5OTlweFwiICtcbiAgICAgICAgICAgIFwid2lkdGg6IDUwcHhcIiArXG4gICAgICAgICAgICBcImhlaWdodDogNTBweFwiICtcbiAgICAgICAgICAgIFwib3ZlcmZsb3c6IHNjcm9sbFwiXG4gICAgICAgICk7XG5cbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzY3JvbGxEaXYpO1xuXG4gICAgICAgIHZhciBzY3JvbGxiYXJXaWR0aCA9IHNjcm9sbERpdi5vZmZzZXRXaWR0aCAtIHNjcm9sbERpdi5jbGllbnRXaWR0aDtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChzY3JvbGxEaXYpO1xuXG4gICAgICAgIHJldHVybiBzY3JvbGxiYXJXaWR0aDtcbiAgICB9O1xuXG4gICAgLyoqIFB1YmxpYyBNZW1iZXJzICoqL1xuICAgIExpZ2h0Qm94LnByb3RvdHlwZS5vcGVuRnJhbWUgPSBmdW5jdGlvbiAodXJsLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgIHZhciBIYW5kbGVCb3VuZFNwZWNpZmljS2V5dXAgPSBoYW5kbGVTcGVjaWZpY0tleXVwLmJpbmQodGhpcyk7XG4gICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICAgICAgdmFyIHNwaW5uZXIgPSBvcHRpb25zLnNwaW5uZXIgPT09ICdjdXN0b20nICYmICEhb3B0aW9ucy5zcGlubmVyVXJsID9cbiAgICAgICAgICAgICc8aW1nIGNsYXNzPVwic3Bpbm5lci1jdXN0b21cIiBzcmM9XCInICsgZW5jb2RlVVJJKG9wdGlvbnMuc3Bpbm5lclVybCkgKyAnXCIgLz4nIDogU1BJTk5FUlNbb3B0aW9ucy5zcGlubmVyXSB8fCBPYmplY3QudmFsdWVzKFNQSU5ORVJTKVswXTtcblxuICAgICAgICB2YXIgdGVtcGxhdGUgPSBmdW5jdGlvbiAoc2V0dGluZ3MpIHtcbiAgICAgICAgICAgIHZhciBob3N0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBob3N0LmNsYXNzTmFtZSA9IHNldHRpbmdzLnByZWZpeDtcblxuICAgICAgICAgICAgdmFyIG92ZXJsYXkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIG92ZXJsYXkuY2xhc3NOYW1lID0gc2V0dGluZ3MucHJlZml4ICsgJy1vdmVybGF5JztcblxuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIGNvbnRlbnQuY2xhc3NOYW1lID0gc2V0dGluZ3MucHJlZml4ICsgJy1jb250ZW50JyArICcgJyArIHNldHRpbmdzLnByZWZpeCArICctY29udGVudF9faGlkZGVuJztcblxuICAgICAgICAgICAgdmFyIGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgICAgICAgICAgaWZyYW1lLmNsYXNzTmFtZSA9IHNldHRpbmdzLnByZWZpeCArICctY29udGVudC1pZnJhbWUnO1xuICAgICAgICAgICAgaWZyYW1lLnNyYyA9IHNldHRpbmdzLnVybDtcbiAgICAgICAgICAgIGlmcmFtZS5mcmFtZUJvcmRlciA9ICcwJztcbiAgICAgICAgICAgIGlmcmFtZS5hbGxvd0Z1bGxzY3JlZW4gPSB0cnVlO1xuXG4gICAgICAgICAgICB2YXIgc3Bpbm5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgc3Bpbm5lci5jbGFzc05hbWUgPSBzZXR0aW5ncy5wcmVmaXggKyAnLXNwaW5uZXInO1xuICAgICAgICAgICAgc3Bpbm5lci5pbm5lckhUTUwgPSBzZXR0aW5ncy5zcGlubmVyO1xuXG4gICAgICAgICAgICBjb250ZW50LmFwcGVuZENoaWxkKGlmcmFtZSk7XG5cbiAgICAgICAgICAgIGhvc3QuYXBwZW5kQ2hpbGQob3ZlcmxheSk7XG4gICAgICAgICAgICBob3N0LmFwcGVuZENoaWxkKGNvbnRlbnQpO1xuICAgICAgICAgICAgaG9zdC5hcHBlbmRDaGlsZChzcGlubmVyKTtcblxuICAgICAgICAgICAgcmV0dXJuIGhvc3Q7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGJvZHlFbGVtZW50ID0gZ2xvYmFsLmRvY3VtZW50LmJvZHk7XG4gICAgICAgIHZhciBsaWdodEJveEVsZW1lbnQgPSB0ZW1wbGF0ZSh7XG4gICAgICAgICAgICBwcmVmaXg6IENMQVNTX1BSRUZJWCxcbiAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgc3Bpbm5lcjogc3Bpbm5lclxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGxpZ2h0Qm94T3ZlcmxheUVsZW1lbnQgPSBsaWdodEJveEVsZW1lbnQucXVlcnlTZWxlY3RvcignLicgKyBDTEFTU19QUkVGSVggKyAnLW92ZXJsYXknKTtcbiAgICAgICAgdmFyIGxpZ2h0Qm94Q29udGVudEVsZW1lbnQgPSBsaWdodEJveEVsZW1lbnQucXVlcnlTZWxlY3RvcignLicgKyBDTEFTU19QUkVGSVggKyAnLWNvbnRlbnQnKTtcbiAgICAgICAgdmFyIGxpZ2h0Qm94SWZyYW1lRWxlbWVudCA9IGxpZ2h0Qm94Q29udGVudEVsZW1lbnQucXVlcnlTZWxlY3RvcignLicgKyBDTEFTU19QUkVGSVggKyAnLWNvbnRlbnQtaWZyYW1lJyk7XG4gICAgICAgIHZhciBsaWdodEJveFNwaW5uZXJFbGVtZW50ID0gbGlnaHRCb3hFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy4nICsgQ0xBU1NfUFJFRklYICsgJy1zcGlubmVyJyk7XG5cbiAgICAgICAgdmFyIHBzRGltZW5zaW9ucyA9IHtcbiAgICAgICAgICAgIHdpZHRoOiB3aXRoRGVmYXVsdFBYVW5pdChNSU5fUFNfRElNRU5TSU9OUy53aWR0aCksXG4gICAgICAgICAgICBoZWlnaHQ6IHdpdGhEZWZhdWx0UFhVbml0KE1JTl9QU19ESU1FTlNJT05TLmhlaWdodClcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiB3aXRoRGVmYXVsdFBYVW5pdCh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIGlzU3RyaW5nV2l0aG91dFVuaXQgPSB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIFN0cmluZyhwYXJzZUZsb2F0KHZhbHVlKSkubGVuZ3RoID09PSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoaXNTdHJpbmdXaXRob3V0VW5pdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSArICdweCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyA/IHZhbHVlICsgJ3B4JyA6IHZhbHVlXG4gICAgICAgIH1cblxuICAgICAgICBsaWdodEJveEVsZW1lbnQuc3R5bGUuekluZGV4ID0gb3B0aW9ucy56SW5kZXg7XG5cbiAgICAgICAgbGlnaHRCb3hPdmVybGF5RWxlbWVudC5zdHlsZS5vcGFjaXR5ID0gb3B0aW9ucy5vdmVybGF5T3BhY2l0eTtcbiAgICAgICAgbGlnaHRCb3hPdmVybGF5RWxlbWVudC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBvcHRpb25zLm92ZXJsYXlCYWNrZ3JvdW5kO1xuXG4gICAgICAgIGxpZ2h0Qm94Q29udGVudEVsZW1lbnQuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gb3B0aW9ucy5jb250ZW50QmFja2dyb3VuZDtcbiAgICAgICAgbGlnaHRCb3hDb250ZW50RWxlbWVudC5zdHlsZS5tYXJnaW4gPSB3aXRoRGVmYXVsdFBYVW5pdChvcHRpb25zLmNvbnRlbnRNYXJnaW4pO1xuICAgICAgICBsaWdodEJveENvbnRlbnRFbGVtZW50LnN0eWxlLndpZHRoID0gb3B0aW9ucy53aWR0aCA/IHdpdGhEZWZhdWx0UFhVbml0KG9wdGlvbnMud2lkdGgpIDogJ2F1dG8nO1xuICAgICAgICBsaWdodEJveENvbnRlbnRFbGVtZW50LnN0eWxlLmhlaWdodCA9IG9wdGlvbnMuaGVpZ2h0ID8gd2l0aERlZmF1bHRQWFVuaXQob3B0aW9ucy5oZWlnaHQpIDogJ2F1dG8nO1xuXG4gICAgICAgIGlmIChvcHRpb25zLnNwaW5uZXJDb2xvcikge1xuICAgICAgICAgICAgbGlnaHRCb3hTcGlubmVyRWxlbWVudC5xdWVyeVNlbGVjdG9yKCdwYXRoJykuc3R5bGUuZmlsbCA9IG9wdGlvbnMuc3Bpbm5lckNvbG9yO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuc3Bpbm5lciA9PT0gJ2N1c3RvbScpIHtcbiAgICAgICAgICAgIHZhciBzcGlubmVyQ3VzdG9tID0gbGlnaHRCb3hTcGlubmVyRWxlbWVudC5xdWVyeVNlbGVjdG9yKCcuc3Bpbm5lci1jdXN0b20nKTtcbiAgICAgICAgICAgIHNwaW5uZXJDdXN0b20uc3R5bGVbJy13ZWJraXQtYW5pbWF0aW9uLWR1cmF0aW9uJ10gPSBvcHRpb25zLnNwaW5uZXJSb3RhdGlvblBlcmlvZCArICdzOyc7XG4gICAgICAgICAgICBzcGlubmVyQ3VzdG9tLnN0eWxlWydhbmltYXRpb24tZHVyYXRpb24nXSA9IG9wdGlvbnMuc3Bpbm5lclJvdGF0aW9uUGVyaW9kICsgJ3M7JztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLmNsb3NlQnlDbGljaykge1xuICAgICAgICAgICAgbGlnaHRCb3hPdmVybGF5RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZUZyYW1lKCk7XG4gICAgICAgICAgICB9KS5iaW5kKHRoaXMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJvZHlFbGVtZW50LmFwcGVuZENoaWxkKGxpZ2h0Qm94RWxlbWVudCk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuY2xvc2VCeUtleWJvYXJkKSB7XG5cbiAgICAgICAgICAgIGJvZHlFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoaGFuZGxlS2V5dXBFdmVudE5hbWUsIEhhbmRsZUJvdW5kU3BlY2lmaWNLZXl1cCk7XG5cbiAgICAgICAgICAgIGJvZHlFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgaGFuZGxlR2xvYmFsS2V5dXAsIGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzaG93Q29udGVudCA9IEhlbHBlcnMub25jZSgoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaGlkZVNwaW5uZXIob3B0aW9ucyk7XG4gICAgICAgICAgICBsaWdodEJveENvbnRlbnRFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfUFJFRklYICsgJy1jb250ZW50X19oaWRkZW4nKTtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlckV2ZW50KCdsb2FkJyk7XG4gICAgICAgIH0pLmJpbmQodGhpcykpO1xuXG4gICAgICAgIHZhciBsaWdodEJveFJlc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IG9wdGlvbnMud2lkdGggPyBvcHRpb25zLndpZHRoIDogcHNEaW1lbnNpb25zLndpZHRoO1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IG9wdGlvbnMuaGVpZ2h0ID8gb3B0aW9ucy5oZWlnaHQgOiBwc0RpbWVuc2lvbnMuaGVpZ2h0O1xuXG4gICAgICAgICAgICBsaWdodEJveENvbnRlbnRFbGVtZW50LnN0eWxlLmxlZnQgPSAnMHB4JztcbiAgICAgICAgICAgIGxpZ2h0Qm94Q29udGVudEVsZW1lbnQuc3R5bGUudG9wID0gJzBweCc7XG4gICAgICAgICAgICBsaWdodEJveENvbnRlbnRFbGVtZW50LnN0eWxlLmJvcmRlclJhZGl1cyA9ICc4cHgnO1xuICAgICAgICAgICAgbGlnaHRCb3hDb250ZW50RWxlbWVudC5zdHlsZS53aWR0aCA9IHdpdGhEZWZhdWx0UFhVbml0KHdpZHRoKTtcbiAgICAgICAgICAgIGxpZ2h0Qm94Q29udGVudEVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gd2l0aERlZmF1bHRQWFVuaXQoaGVpZ2h0KTtcblxuICAgICAgICAgICAgdmFyIGNvbnRhaW5lcldpZHRoID0gbGlnaHRCb3hFbGVtZW50LmNsaWVudFdpZHRoLFxuICAgICAgICAgICAgICAgIGNvbnRhaW5lckhlaWdodCA9IGxpZ2h0Qm94RWxlbWVudC5jbGllbnRIZWlnaHQ7XG5cbiAgICAgICAgICAgIHZhciBjb250ZW50V2lkdGggPSBvdXRlcldpZHRoKGxpZ2h0Qm94Q29udGVudEVsZW1lbnQpLFxuICAgICAgICAgICAgICAgIGNvbnRlbnRIZWlnaHQgPSBvdXRlckhlaWdodChsaWdodEJveENvbnRlbnRFbGVtZW50KTtcblxuICAgICAgICAgICAgdmFyIGhvck1hcmdpbiA9IGNvbnRlbnRXaWR0aCAtIGxpZ2h0Qm94Q29udGVudEVsZW1lbnQub2Zmc2V0V2lkdGgsXG4gICAgICAgICAgICAgICAgdmVydE1hcmdpbiA9IGNvbnRlbnRIZWlnaHQgLSBsaWdodEJveENvbnRlbnRFbGVtZW50Lm9mZnNldEhlaWdodDtcblxuICAgICAgICAgICAgdmFyIGhvckRpZmYgPSBjb250YWluZXJXaWR0aCAtIGNvbnRlbnRXaWR0aCxcbiAgICAgICAgICAgICAgICB2ZXJ0RGlmZiA9IGNvbnRhaW5lckhlaWdodCAtIGNvbnRlbnRIZWlnaHQ7XG5cbiAgICAgICAgICAgIGlmIChob3JEaWZmIDwgMCkge1xuICAgICAgICAgICAgICAgIGxpZ2h0Qm94Q29udGVudEVsZW1lbnQuc3R5bGUud2lkdGggPSBjb250YWluZXJXaWR0aCAtIGhvck1hcmdpbiArICdweCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxpZ2h0Qm94Q29udGVudEVsZW1lbnQuc3R5bGUubGVmdCA9IE1hdGgucm91bmQoaG9yRGlmZiAvIDIpICsgJ3B4JztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHZlcnREaWZmIDwgMCkge1xuICAgICAgICAgICAgICAgIGxpZ2h0Qm94Q29udGVudEVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gY29udGFpbmVySGVpZ2h0IC0gdmVydE1hcmdpbiArICdweCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxpZ2h0Qm94Q29udGVudEVsZW1lbnQuc3R5bGUudG9wID0gTWF0aC5yb3VuZCh2ZXJ0RGlmZiAvIDIpICsgJ3B4JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAob3B0aW9ucy53aWR0aCAmJiBvcHRpb25zLmhlaWdodCkge1xuICAgICAgICAgICAgbGlnaHRCb3hSZXNpemUgPSBIZWxwZXJzLm9uY2UobGlnaHRCb3hSZXNpemUuYmluZCh0aGlzKSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBvdXRlcldpZHRoKGVsKSB7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSBlbC5vZmZzZXRXaWR0aDtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZWwpO1xuXG4gICAgICAgICAgICB3aWR0aCArPSBwYXJzZUludChzdHlsZS5tYXJnaW5MZWZ0KSArIHBhcnNlSW50KHN0eWxlLm1hcmdpblJpZ2h0KTtcbiAgICAgICAgICAgIHJldHVybiB3aWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG91dGVySGVpZ2h0KGVsKSB7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gZWwub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG5cbiAgICAgICAgICAgIGhlaWdodCArPSBwYXJzZUludChzdHlsZS5tYXJnaW5Ub3ApICsgcGFyc2VJbnQoc3R5bGUubWFyZ2luQm90dG9tKTtcbiAgICAgICAgICAgIHJldHVybiBoZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYm9keVN0eWxlcztcbiAgICAgICAgdmFyIGhpZGVTY3JvbGxiYXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgYm9keVN0eWxlcyA9IEhlbHBlcnMuemlwT2JqZWN0KFsnb3ZlcmZsb3cnLCAncGFkZGluZ1JpZ2h0J10ubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2tleSwgZ2V0Q29tcHV0ZWRTdHlsZShib2R5RWxlbWVudClba2V5XV07XG4gICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgIGlmIChnbG9iYWwud2luZG93LmlubmVyV2lkdGggPiBvdXRlcldpZHRoKGJvZHlFbGVtZW50KSkge1xuICAgICAgICAgICAgICAgIHZhciBib2R5UGFkID0gcGFyc2VJbnQoKGdldENvbXB1dGVkU3R5bGUoYm9keUVsZW1lbnQpWydwYWRkaW5nUmlnaHQnXSB8fCAwKSwgMTApO1xuICAgICAgICAgICAgICAgIGJvZHlFbGVtZW50LnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbjsnO1xuICAgICAgICAgICAgICAgIGJvZHlFbGVtZW50LnN0eWxlLnBhZGRpbmdSaWdodCA9IHdpdGhEZWZhdWx0UFhVbml0KGJvZHlQYWQgKyB0aGlzLm1lYXN1cmVTY3JvbGxiYXIoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLmJpbmQodGhpcyk7XG5cbiAgICAgICAgdmFyIHJlc2V0U2Nyb2xsYmFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGJvZHlTdHlsZXMpIHtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhib2R5U3R5bGVzKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgICAgICBib2R5RWxlbWVudC5zdHlsZVtrZXldID0gYm9keVN0eWxlc1trZXldO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHNob3dTcGlubmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgbGlnaHRCb3hTcGlubmVyRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgaGlkZVNwaW5uZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBsaWdodEJveFNwaW5uZXJFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGxvYWRUaW1lcjtcbiAgICAgICAgbGlnaHRCb3hJZnJhbWVFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBmdW5jdGlvbiBoYW5kbGVMb2FkKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgdGltZW91dCA9ICEob3B0aW9ucy53aWR0aCAmJiBvcHRpb25zLmhlaWdodCkgPyAob3B0aW9ucy5yZXNpemVUaW1lb3V0IHx8IDMwMDAwKSA6IDEwMDA7IC8vIDMwMDAwIGlmIHBzRGltZW5zaW9ucyB3aWxsIG5vdCBhcnJpdmUgYW5kIGN1c3RvbSB0aW1lb3V0IGlzIG5vdCBwcm92aWRlZFxuICAgICAgICAgICAgbG9hZFRpbWVyID0gZ2xvYmFsLnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGxpZ2h0Qm94UmVzaXplKCk7XG4gICAgICAgICAgICAgICAgc2hvd0NvbnRlbnQoKTtcbiAgICAgICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICAgICAgbGlnaHRCb3hJZnJhbWVFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBoYW5kbGVMb2FkKTtcblxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgaWZyYW1lV2luZG93ID0gbGlnaHRCb3hJZnJhbWVFbGVtZW50LmNvbnRlbnRXaW5kb3cgfHwgbGlnaHRCb3hJZnJhbWVFbGVtZW50O1xuXG4gICAgICAgIC8vIENyb3NzLXdpbmRvdyBjb21tdW5pY2F0aW9uXG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG5ldyBQb3N0TWVzc2FnZShpZnJhbWVXaW5kb3cpO1xuICAgICAgICBpZiAob3B0aW9ucy53aWR0aCAmJiBvcHRpb25zLmhlaWdodCkge1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlLm9uKCdkaW1lbnNpb25zJywgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBsaWdodEJveFJlc2l6ZSgpO1xuICAgICAgICAgICAgICAgIHNob3dDb250ZW50KCk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2Uub24oJ2RpbWVuc2lvbnMnLCAoZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBldmVudC5kZXRhaWw7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuZGltZW5zaW9ucykge1xuICAgICAgICAgICAgICAgICAgICBwc0RpbWVuc2lvbnMgPSBIZWxwZXJzLnppcE9iamVjdChbJ3dpZHRoJywgJ2hlaWdodCddLm1hcChmdW5jdGlvbiAoZGltKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2RpbSwgTWF0aC5tYXgoTUlOX1BTX0RJTUVOU0lPTlNbZGltXSB8fCAwLCBkYXRhLmRpbWVuc2lvbnNbZGltXSB8fCAwKSArICdweCddO1xuICAgICAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgICAgICAgICAgbGlnaHRCb3hSZXNpemUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2hvd0NvbnRlbnQoKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1lc3NhZ2Uub24oJ3dpZGdldC1kZXRlY3Rpb24nLCAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlLnNlbmQoJ3dpZGdldC1kZXRlY3RlZCcsIHt2ZXJzaW9uOiB2ZXJzaW9uLCBsaWdodEJveE9wdGlvbnM6IG9wdGlvbnN9KTtcbiAgICAgICAgfSkuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMubWVzc2FnZS5vbignd2lkZ2V0LWNsb3NlJywgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VGcmFtZSgpO1xuICAgICAgICB9KS5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5tZXNzYWdlLm9uKCdzdGF0dXMnLCAoZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXJFdmVudCgnc3RhdHVzJywgZXZlbnQuZGV0YWlsKTtcbiAgICAgICAgfSkuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMubWVzc2FnZS5vbigndXNlci1jb3VudHJ5JywgKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyRXZlbnQoJ3VzZXItY291bnRyeScsIGV2ZW50LmRldGFpbCk7XG4gICAgICAgIH0pLmJpbmQodGhpcykpO1xuXG4gICAgICAgIC8vIFJlc2l6ZVxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihoYW5kbGVSZXNpemVFdmVudE5hbWUsIGxpZ2h0Qm94UmVzaXplKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZUdsb2JhbFJlc2l6ZSk7XG5cbiAgICAgICAgLy8gQ2xlYW4gdXAgYWZ0ZXIgY2xvc2VcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICB0aGlzLm9uKCdjbG9zZScsIGZ1bmN0aW9uIGhhbmRsZUNsb3NlKGV2ZW50KSB7XG4gICAgICAgICAgICB0aGF0Lm1lc3NhZ2Uub2ZmKCk7XG4gICAgICAgICAgICBib2R5RWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGhhbmRsZUtleXVwRXZlbnROYW1lLCBIYW5kbGVCb3VuZFNwZWNpZmljS2V5dXApXG4gICAgICAgICAgICBib2R5RWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXl1cCcsIGhhbmRsZUdsb2JhbEtleXVwKTtcblxuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZUdsb2JhbFJlc2l6ZSlcblxuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoaGFuZGxlUmVzaXplRXZlbnROYW1lLCBsaWdodEJveFJlc2l6ZSk7XG4gICAgICAgICAgICBsaWdodEJveEVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChsaWdodEJveEVsZW1lbnQpO1xuICAgICAgICAgICAgcmVzZXRTY3JvbGxiYXIoKTtcbiAgICAgICAgICAgIHRoYXQub2ZmKCdjbG9zZScsIGhhbmRsZUNsb3NlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc2hvd1NwaW5uZXIoKTtcbiAgICAgICAgaGlkZVNjcm9sbGJhcigpO1xuICAgICAgICB0aGlzLnRyaWdnZXJFdmVudCgnb3BlbicpO1xuICAgIH07XG5cbiAgICBMaWdodEJveC5wcm90b3R5cGUuY2xvc2VGcmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMubW9kYWwpIHtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlckV2ZW50KCdjbG9zZScpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIExpZ2h0Qm94LnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5ldmVudE9iamVjdC5vbi5hcHBseSh0aGlzLmV2ZW50T2JqZWN0LCBhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICBMaWdodEJveC5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmV2ZW50T2JqZWN0Lm9mZi5hcHBseSh0aGlzLmV2ZW50T2JqZWN0LCBhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICBMaWdodEJveC5wcm90b3R5cGUuZ2V0UG9zdE1lc3NhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2U7XG4gICAgfTtcblxuICAgIExpZ2h0Qm94Ll9OQU1FU1BBQ0UgPSAnLnhwYXlzdGF0aW9uLXdpZGdldC1saWdodGJveCc7XG5cbiAgICByZXR1cm4gTGlnaHRCb3g7XG59KSgpO1xuIiwiZnVuY3Rpb24gb2JqZWN0QXNzaWduKCkge1xuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvYXNzaWduIFBvbHlmaWxsXG4gIE9iamVjdC5hc3NpZ258fE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYmplY3QsXCJhc3NpZ25cIix7ZW51bWVyYWJsZTohMSxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6ZnVuY3Rpb24oZSxyKXtcInVzZSBzdHJpY3RcIjtpZihudWxsPT1lKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY29udmVydCBmaXJzdCBhcmd1bWVudCB0byBvYmplY3RcIik7Zm9yKHZhciB0PU9iamVjdChlKSxuPTE7bjxhcmd1bWVudHMubGVuZ3RoO24rKyl7dmFyIG89YXJndW1lbnRzW25dO2lmKG51bGwhPW8pZm9yKHZhciBhPU9iamVjdC5rZXlzKE9iamVjdChvKSksYz0wLGI9YS5sZW5ndGg7YzxiO2MrKyl7dmFyIGk9YVtjXSxsPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobyxpKTt2b2lkIDAhPT1sJiZsLmVudW1lcmFibGUmJih0W2ldPW9baV0pfX1yZXR1cm4gdH19KTtcbn1cblxuZnVuY3Rpb24gYXJyYXlGb3JFYWNoKCkge1xuICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaHx8KEFycmF5LnByb3RvdHlwZS5mb3JFYWNoPWZ1bmN0aW9uKHIsbyl7dmFyIHQsbjtpZihudWxsPT10aGlzKXRocm93IG5ldyBUeXBlRXJyb3IoXCIgdGhpcyBpcyBudWxsIG9yIG5vdCBkZWZpbmVkXCIpO3ZhciBlPU9iamVjdCh0aGlzKSxpPWUubGVuZ3RoPj4+MDtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiByKXRocm93IG5ldyBUeXBlRXJyb3IocitcIiBpcyBub3QgYSBmdW5jdGlvblwiKTtmb3IoYXJndW1lbnRzLmxlbmd0aD4xJiYodD1vKSxuPTA7bjxpOyl7dmFyIGY7biBpbiBlJiYoZj1lW25dLHIuY2FsbCh0LGYsbixlKSksbisrfX0pO1xufVxuXG5mdW5jdGlvbiBhcHBseVBvbHlmaWxscygpIHtcbiAgb2JqZWN0QXNzaWduKCk7XG4gIGFycmF5Rm9yRWFjaCgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYXBwbHlQb2x5ZmlsbHM6IGFwcGx5UG9seWZpbGxzXG59XG4iLCJ2YXIgSGVscGVycyA9IHJlcXVpcmUoJy4vaGVscGVycycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gd3JhcEV2ZW50SW5OYW1lc3BhY2UoZXZlbnROYW1lKSB7XG4gICAgICAgIHJldHVybiBQb3N0TWVzc2FnZS5fTkFNRVNQQUNFICsgJ18nICsgZXZlbnROYW1lO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFBvc3RNZXNzYWdlKHdpbmRvdykge1xuICAgICAgICB0aGlzLmV2ZW50T2JqZWN0ID0gSGVscGVycy5hZGRFdmVudE9iamVjdCh0aGlzLCB3cmFwRXZlbnRJbk5hbWVzcGFjZSk7XG4gICAgICAgIHRoaXMubGlua2VkV2luZG93ID0gd2luZG93O1xuXG4gICAgICAgIGdsb2JhbC53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciAmJiBnbG9iYWwud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5zb3VyY2UgIT09IHRoaXMubGlua2VkV2luZG93KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9IHt9O1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBldmVudC5kYXRhID09PSAnc3RyaW5nJyAmJiBnbG9iYWwuSlNPTiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IGdsb2JhbC5KU09OLnBhcnNlKGV2ZW50LmRhdGEpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmNvbW1hbmQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50T2JqZWN0LnRyaWdnZXIobWVzc2FnZS5jb21tYW5kLCBtZXNzYWdlLmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KS5iaW5kKHRoaXMpKTtcbiAgICB9XG5cbiAgICAvKiogUHJpdmF0ZSBNZW1iZXJzICoqL1xuICAgIFBvc3RNZXNzYWdlLnByb3RvdHlwZS5ldmVudE9iamVjdCA9IG51bGw7XG4gICAgUG9zdE1lc3NhZ2UucHJvdG90eXBlLmxpbmtlZFdpbmRvdyA9IG51bGw7XG5cbiAgICAvKiogUHVibGljIE1lbWJlcnMgKiovXG4gICAgUG9zdE1lc3NhZ2UucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihjb21tYW5kLCBkYXRhLCB0YXJnZXRPcmlnaW4pIHtcbiAgICAgICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZGF0YSA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRhcmdldE9yaWdpbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0YXJnZXRPcmlnaW4gPSAnKic7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMubGlua2VkV2luZG93IHx8IHRoaXMubGlua2VkV2luZG93LnBvc3RNZXNzYWdlID09PSB1bmRlZmluZWQgfHwgZ2xvYmFsLndpbmRvdy5KU09OID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmxpbmtlZFdpbmRvdy5wb3N0TWVzc2FnZShnbG9iYWwuSlNPTi5zdHJpbmdpZnkoe2RhdGE6IGRhdGEsIGNvbW1hbmQ6IGNvbW1hbmR9KSwgdGFyZ2V0T3JpZ2luKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIFBvc3RNZXNzYWdlLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldmVudCwgaGFuZGxlLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuZXZlbnRPYmplY3Qub24oZXZlbnQsIGhhbmRsZSwgb3B0aW9ucyk7XG4gICAgfTtcblxuICAgIFBvc3RNZXNzYWdlLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbiAoZXZlbnQsIGhhbmRsZSwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmV2ZW50T2JqZWN0Lm9mZihldmVudCwgaGFuZGxlLCBvcHRpb25zKTtcbiAgICB9O1xuXG4gICAgUG9zdE1lc3NhZ2UuX05BTUVTUEFDRSA9ICdQT1NUX01FU1NBR0UnO1xuXG5cbiAgICByZXR1cm4gUG9zdE1lc3NhZ2U7XG59KSgpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxzdmcgd2lkdGg9XFxcIjQ3cHhcXFwiIGhlaWdodD1cXFwiNDdweFxcXCIgY2xhc3M9XFxcInNwaW5uZXItcm91bmRcXFwiPjxwYXRoIGQ9XFxcIk00Ljc4NTI3MjgsMTAuNDIxMDg3NSBDMi45NDExMTY2NCwxMy4wNTUyMTk3IDEuNjM3NzcxMDksMTYuMDk0NjEwNiAxLjAzNzUzOTU2LDE5LjM3Njg1NTYgTDUuMTY2Mzg5NzEsMTkuMzc2ODU1NiBDNS42NDI5NjE1LDE3LjE4NzU1NCA2LjUwMTI1MjQzLDE1LjEzOTE2NCA3LjY2NzY4ODk5LDEzLjMwNTMwNSBMNS45NTU3MjQyOCwxMS41OTIyNzA1IEw0Ljc4NTI3MjgsMTAuNDIxMDg3NSBMNC43ODUyNzI4LDEwLjQyMTA4NzUgWiBNMTAuNDY5MzA0OCw0Ljc0NTY1NjE1IEMxMy4xMjc0ODczLDIuODkwODA2MSAxNi4xOTY1OTc2LDEuNTg2NzQ2NDggMTkuNTEwMDE2MSwxIEwxOS41MTAwMTYxLDQuOTk1MjM5MzQgQzE3LjI3MTA5MjMsNS40ODc5Nzc4MiAxNS4xODAzMTkzLDYuMzgwODUyOSAxMy4zMTY2OTA3LDcuNTk0ODIxNTMgTDExLjYzMzczMzksNS45MTA4MTI5MyBMMTAuNDY5MzA0OCw0Ljc0NTY1NjE1IEwxMC40NjkzMDQ4LDQuNzQ1NjU2MTUgWiBNNDIuMjQyNjMwOSwzNi41Mzg4Mzg2IEM0NC4xMTEyNzgyLDMzLjg1NzUwMTYgNDUuNDIwNjQ2MSwzMC43NTgxNTA0IDQ2LDI3LjQxMTcyNjkgTDQxLjk0NDEyMTEsMjcuNDExNzI2OSBDNDEuNDUyNzk0NSwyOS42NjE4OTI2IDQwLjU1ODM2OTIsMzEuNzYyOTExIDM5LjM0MDQ0MTIsMzMuNjM0OTM1NiBMNDEuMDMzMjM0NywzNS4zMjg3ODY5IEw0Mi4yNDI1MzA2LDM2LjUzODgzODYgTDQyLjI0MjYzMDksMzYuNTM4ODM4NiBaIE0zNi41NzA3NDQxLDQyLjIyNjQyMjcgQzMzLjkxNjc3NzMsNDQuMDg2Nzk2NyAzMC44NTA5NzkzLDQ1LjM5NzI4NDIgMjcuNTM5ODY5Myw0NS45OTExNjE2IEwyNy41Mzk4NjkzLDQxLjc5NjA1NDkgQzI5LjczNzY0MDIsNDEuMzIwMjkwMSAzMS43OTM2ODQxLDQwLjQ1OTM1MzYgMzMuNjMzNjI0NiwzOS4yODc1NjggTDM1LjM1NTQyNTgsNDEuMDEwNDQ1MyBMMzYuNTcwNzQ0MSw0Mi4yMjY1MjMxIEwzNi41NzA3NDQxLDQyLjIyNjQyMjcgWiBNNC43MTE3OTk2NSwzNi40NzMxNTM1IEMyLjg2NzQ0Mjc0LDMzLjgwNjk4MjMgMS41NzQ2MzYzNywzMC43MzA5MzIyIDEsMjcuNDExODI3MyBMNS4xNjg4OTkwNCwyNy40MTE4MjczIEM1LjY0ODI4MTI4LDI5LjYwNzM1NTkgNi41MTE1OTA4NywzMS42NjEwNjkgNy42ODQ2NTIwNSwzMy40OTg0NDMyIEw1Ljk1NTcyNDI4LDM1LjIyODQ1MTUgTDQuNzExNzk5NjUsMzYuNDczMTUzNSBMNC43MTE3OTk2NSwzNi40NzMxNTM1IFogTTEwLjM2NDAxMzMsNDIuMTgwNDIzIEMxMy4wNDYyODU0LDQ0LjA3NDU0MzUgMTYuMTUyNzM0NSw0NS40MDU1MiAxOS41MTAxMTY1LDQ2IEwxOS41MTAxMTY1LDQxLjc4MjE5NDcgQzE3LjI4MTczMTksNDEuMjkxNjY1OCAxNS4yMDAwOTI4LDQwLjQwNDgxNjkgMTMuMzQzMDg4OSwzOS4xOTk1ODYyIEwxMS42MzM3MzM5LDQwLjkxMDAwOTQgTDEwLjM2NDAxMzMsNDIuMTgwNTIzNSBMMTAuMzY0MDEzMyw0Mi4xODA0MjMgWiBNNDIuMTY4ODU2NywxMC4zNTU3MDM4IEM0NC4wMzczMDMxLDEzLjAwNDgwMDggNDUuMzU3NDExLDE2LjA2NzQ5MjkgNDUuOTYyNjYxMiwxOS4zNzY4NTU2IEw0MS45NDY5MzE2LDE5LjM3Njg1NTYgQzQxLjQ1ODUxNTgsMTcuMTMyODE2NCA0MC41NjkyMDk1LDE1LjAzNjkyMDIgMzkuMzU4MDA2NSwxMy4xNjg0MTA5IEw0MS4wMzM1MzU4LDExLjQ5MTgzNDYgTDQyLjE2ODk1NywxMC4zNTU3MDM4IEw0Mi4xNjg4NTY3LDEwLjM1NTcwMzggWiBNMzYuNDY1MTUxNiw0LjY5OTk1NzgyIEMzMy44MzU1NzU0LDIuODc4NjUzMzYgMzAuODA3MTE2MiwxLjU5NDg4MTc5IDI3LjU0MDA3MDEsMS4wMDg4MzgzNiBMMjcuNTQwMDcwMSw0Ljk4MTE3ODMxIEMyOS43NDg0ODA1LDUuNDU5MTUyNzIgMzEuODEzNzU4Nyw2LjMyNjAxNDkgMzMuNjYwNDI0Miw3LjUwNjQzNzk0IEwzNS4zNTU1MjYyLDUuODEwMjc2NiBMMzYuNDY1MTUxNiw0LjY5OTk1NzgyIEwzNi40NjUxNTE2LDQuNjk5OTU3ODIgWlxcXCIgZmlsbD1cXFwiI0NDQ0NDQ1xcXCI+PC9wYXRoPjwvc3ZnPlwiO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxzdmcgY2xhc3M9XFxcInNwaW5uZXIteHNvbGxhXFxcIiB3aWR0aD1cXFwiNTZcXFwiIGhlaWdodD1cXFwiNTVcXFwiPjxwYXRoIGNsYXNzPVxcXCJzcGlubmVyLXhzb2xsYS14XFxcIiBkPVxcXCJNMjEuMDMgNS4wNDJsLTIuMTEyLTIuMTU2LTMuNjU3IDMuNjk1LTMuNjU3LTMuNjk1LTIuMTEyIDIuMTU2IDMuNjU5IDMuNjczLTMuNjU5IDMuNjk2IDIuMTEyIDIuMTU3IDMuNjU3LTMuNjk3IDMuNjU3IDMuNjk3IDIuMTEyLTIuMTU3LTMuNjQ4LTMuNjk2IDMuNjQ4LTMuNjczelxcXCIgZmlsbD1cXFwiI0YyNTQyRFxcXCI+PC9wYXRoPjxwYXRoIGNsYXNzPVxcXCJzcGlubmVyLXhzb2xsYS1zXFxcIiBkPVxcXCJNNDEuMjMyIDYuODk2bDIuOTQxLTIuOTc0LTIuMTM0LTIuMTMyLTIuOTIgMi45NzMtLjAwNS0uMDA4LTIuMTM0IDIuMTM1LjAwNS4wMDgtLjAwNS4wMDUgMy43OTIgMy44Mi0yLjkxNSAyLjk0NyAyLjExMiAyLjE1NiA1LjA2LTUuMTExLTMuNzk4LTMuODE2LjAwMS0uMDAxelxcXCIgZmlsbD1cXFwiI0ZDQ0EyMFxcXCI+PC9wYXRoPjxwYXRoIGNsYXNzPVxcXCJzcGlubmVyLXhzb2xsYS1vXFxcIiBkPVxcXCJNNDguMDY2IDI5LjE1OWMtMS41MzYgMC0yLjc2MSAxLjI2My0yLjc2MSAyLjc5IDAgMS41MjQgMS4yMjYgMi43NjUgMi43NjEgMi43NjUgMS41MDkgMCAyLjczNi0xLjI0MiAyLjczNi0yLjc2NSAwLTEuNTI2LTEuMjI3LTIuNzktMi43MzYtMi43OW0wIDguNTkzYy0zLjE3OSAwLTUuNzcxLTIuNTk0LTUuNzcxLTUuODA0IDAtMy4yMTMgMi41OTItNS44MDggNS43NzEtNS44MDggMy4xNTUgMCA1Ljc0NSAyLjU5NCA1Ljc0NSA1LjgwOCAwIDMuMjEtMi41ODkgNS44MDQtNS43NDUgNS44MDRcXFwiIGZpbGw9XFxcIiM4QzNFQTRcXFwiPjwvcGF0aD48cGF0aCBjbGFzcz1cXFwic3Bpbm5lci14c29sbGEtbFxcXCIgZD1cXFwiTTI0LjM4OSA0Mi4zMjNoMi45OXYxMC40MzdoLTIuOTl2LTEwLjQzN3ptNC4zMzQgMGgyLjk4OXYxMC40MzdoLTIuOTg5di0xMC40Mzd6XFxcIiBmaWxsPVxcXCIjQjVEQzIwXFxcIj48L3BhdGg+PHBhdGggY2xhc3M9XFxcInNwaW5uZXIteHNvbGxhLWFcXFwiIGQ9XFxcIk03Ljc5NiAzMS44OThsMS40MDQgMi40NTdoLTIuODM1bDEuNDMxLTIuNDU3aC0uMDAxem0tLjAwMS01Ljc1N2wtNi4zNjMgMTEuMTAyaDEyLjcwM2wtNi4zNDEtMTEuMTAyelxcXCIgZmlsbD1cXFwiIzY2Q0NEQVxcXCI+PC9wYXRoPjwvc3ZnPlwiO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCdzYXNzaWZ5JykoJy54cGF5c3RhdGlvbi13aWRnZXQtbGlnaHRib3h7cG9zaXRpb246Zml4ZWQ7dG9wOjA7bGVmdDowO2JvdHRvbTowO3JpZ2h0OjA7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwJTstd2Via2l0LWFuaW1hdGlvbjp4cGF5c3RhdGlvbi13aWRnZXQtbGlnaHRib3gtZmFkZWluIDAuMTVzO2FuaW1hdGlvbjp4cGF5c3RhdGlvbi13aWRnZXQtbGlnaHRib3gtZmFkZWluIDAuMTVzfS54cGF5c3RhdGlvbi13aWRnZXQtbGlnaHRib3gtb3ZlcmxheXtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtsZWZ0OjA7Ym90dG9tOjA7cmlnaHQ6MDt6LWluZGV4OjF9LnhwYXlzdGF0aW9uLXdpZGdldC1saWdodGJveC1jb250ZW50e3Bvc2l0aW9uOnJlbGF0aXZlO3RvcDowO2xlZnQ6MDt6LWluZGV4OjN9LnhwYXlzdGF0aW9uLXdpZGdldC1saWdodGJveC1jb250ZW50X19oaWRkZW57dmlzaWJpbGl0eTpoaWRkZW47ei1pbmRleDotMX0ueHBheXN0YXRpb24td2lkZ2V0LWxpZ2h0Ym94LWNvbnRlbnQtaWZyYW1le3dpZHRoOjEwMCU7aGVpZ2h0OjEwMCU7Ym9yZGVyOjA7YmFja2dyb3VuZDp0cmFuc3BhcmVudH0ueHBheXN0YXRpb24td2lkZ2V0LWxpZ2h0Ym94LXNwaW5uZXJ7cG9zaXRpb246YWJzb2x1dGU7dG9wOjUwJTtsZWZ0OjUwJTtkaXNwbGF5Om5vbmU7ei1pbmRleDoyO3BvaW50ZXItZXZlbnRzOm5vbmV9LnhwYXlzdGF0aW9uLXdpZGdldC1saWdodGJveC1zcGlubmVyIC5zcGlubmVyLXhzb2xsYXt3aWR0aDo1NnB4O2hlaWdodDo1NXB4O21hcmdpbi10b3A6LTI4cHg7bWFyZ2luLWxlZnQ6LTI2cHh9LnhwYXlzdGF0aW9uLXdpZGdldC1saWdodGJveC1zcGlubmVyIC5zcGlubmVyLXhzb2xsYSAuc3Bpbm5lci14c29sbGEteCwueHBheXN0YXRpb24td2lkZ2V0LWxpZ2h0Ym94LXNwaW5uZXIgLnNwaW5uZXIteHNvbGxhIC5zcGlubmVyLXhzb2xsYS1zLC54cGF5c3RhdGlvbi13aWRnZXQtbGlnaHRib3gtc3Bpbm5lciAuc3Bpbm5lci14c29sbGEgLnNwaW5uZXIteHNvbGxhLW8sLnhwYXlzdGF0aW9uLXdpZGdldC1saWdodGJveC1zcGlubmVyIC5zcGlubmVyLXhzb2xsYSAuc3Bpbm5lci14c29sbGEtbCwueHBheXN0YXRpb24td2lkZ2V0LWxpZ2h0Ym94LXNwaW5uZXIgLnNwaW5uZXIteHNvbGxhIC5zcGlubmVyLXhzb2xsYS1hey13ZWJraXQtYW5pbWF0aW9uOnhwYXlzdGF0aW9uLXdpZGdldC1saWdodGJveC1ib3VuY2VkZWxheSAxcyBpbmZpbml0ZSBlYXNlLWluLW91dDstd2Via2l0LWFuaW1hdGlvbi1maWxsLW1vZGU6Ym90aDthbmltYXRpb246eHBheXN0YXRpb24td2lkZ2V0LWxpZ2h0Ym94LWJvdW5jZWRlbGF5IDFzIGluZmluaXRlIGVhc2UtaW4tb3V0O2FuaW1hdGlvbi1maWxsLW1vZGU6Ym90aH0ueHBheXN0YXRpb24td2lkZ2V0LWxpZ2h0Ym94LXNwaW5uZXIgLnNwaW5uZXIteHNvbGxhIC5zcGlubmVyLXhzb2xsYS14ey13ZWJraXQtYW5pbWF0aW9uLWRlbGF5OjBzO2FuaW1hdGlvbi1kZWxheTowc30ueHBheXN0YXRpb24td2lkZ2V0LWxpZ2h0Ym94LXNwaW5uZXIgLnNwaW5uZXIteHNvbGxhIC5zcGlubmVyLXhzb2xsYS1zey13ZWJraXQtYW5pbWF0aW9uLWRlbGF5Oi4yczthbmltYXRpb24tZGVsYXk6LjJzfS54cGF5c3RhdGlvbi13aWRnZXQtbGlnaHRib3gtc3Bpbm5lciAuc3Bpbm5lci14c29sbGEgLnNwaW5uZXIteHNvbGxhLW97LXdlYmtpdC1hbmltYXRpb24tZGVsYXk6LjRzO2FuaW1hdGlvbi1kZWxheTouNHN9LnhwYXlzdGF0aW9uLXdpZGdldC1saWdodGJveC1zcGlubmVyIC5zcGlubmVyLXhzb2xsYSAuc3Bpbm5lci14c29sbGEtbHstd2Via2l0LWFuaW1hdGlvbi1kZWxheTouNnM7YW5pbWF0aW9uLWRlbGF5Oi42c30ueHBheXN0YXRpb24td2lkZ2V0LWxpZ2h0Ym94LXNwaW5uZXIgLnNwaW5uZXIteHNvbGxhIC5zcGlubmVyLXhzb2xsYS1hey13ZWJraXQtYW5pbWF0aW9uLWRlbGF5Oi44czthbmltYXRpb24tZGVsYXk6LjhzfS54cGF5c3RhdGlvbi13aWRnZXQtbGlnaHRib3gtc3Bpbm5lciAuc3Bpbm5lci1yb3VuZHttYXJnaW4tdG9wOi0yM3B4O21hcmdpbi1sZWZ0Oi0yM3B4Oy13ZWJraXQtYW5pbWF0aW9uOnhwYXlzdGF0aW9uLXdpZGdldC1saWdodGJveC1zcGluIDNzIGluZmluaXRlIGxpbmVhcjthbmltYXRpb246eHBheXN0YXRpb24td2lkZ2V0LWxpZ2h0Ym94LXNwaW4gM3MgaW5maW5pdGUgbGluZWFyfS54cGF5c3RhdGlvbi13aWRnZXQtbGlnaHRib3gtc3Bpbm5lciAuc3Bpbm5lci1jdXN0b217LXdlYmtpdC1hbmltYXRpb246eHBheXN0YXRpb24td2lkZ2V0LWxpZ2h0Ym94LXNwaW4gaW5maW5pdGUgbGluZWFyO2FuaW1hdGlvbjp4cGF5c3RhdGlvbi13aWRnZXQtbGlnaHRib3gtc3BpbiBpbmZpbml0ZSBsaW5lYXJ9QC13ZWJraXQta2V5ZnJhbWVzIHhwYXlzdGF0aW9uLXdpZGdldC1saWdodGJveC1ib3VuY2VkZWxheXswJSw4MCUsMTAwJXtvcGFjaXR5OjB9NDAle29wYWNpdHk6MX19QGtleWZyYW1lcyB4cGF5c3RhdGlvbi13aWRnZXQtbGlnaHRib3gtYm91bmNlZGVsYXl7MCUsODAlLDEwMCV7b3BhY2l0eTowfTQwJXtvcGFjaXR5OjF9fUAtd2Via2l0LWtleWZyYW1lcyB4cGF5c3RhdGlvbi13aWRnZXQtbGlnaHRib3gtZmFkZWlue2Zyb217b3BhY2l0eTowfXRve29wYWNpdHk6MX19QGtleWZyYW1lcyB4cGF5c3RhdGlvbi13aWRnZXQtbGlnaHRib3gtZmFkZWlue2Zyb217b3BhY2l0eTowfXRve29wYWNpdHk6MX19QC13ZWJraXQta2V5ZnJhbWVzIHhwYXlzdGF0aW9uLXdpZGdldC1saWdodGJveC1zcGlue2Zyb217LXdlYmtpdC10cmFuc2Zvcm06cm90YXRlKDBkZWcpfXRvey13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSgzNjBkZWcpfX1Aa2V5ZnJhbWVzIHhwYXlzdGF0aW9uLXdpZGdldC1saWdodGJveC1zcGlue2Zyb217dHJhbnNmb3JtOnJvdGF0ZSgwZGVnKX10b3t0cmFuc2Zvcm06cm90YXRlKDM2MGRlZyl9fSAgLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxld29KSW5abGNuTnBiMjRpT2lBekxBb0pJbVpwYkdVaU9pQWliR2xuYUhSaWIzZ3VjMk56Y3lJc0Nna2ljMjkxY21ObGN5STZJRnNLQ1FraWJHbG5hSFJpYjNndWMyTnpjeUlLQ1Ywc0Nna2ljMjkxY21ObGMwTnZiblJsYm5RaU9pQmJDZ2tKSWlSc2FXZG9kR0p2ZUMxd2NtVm1hWGc2SUNkNGNHRjVjM1JoZEdsdmJpMTNhV1JuWlhRdGJHbG5hSFJpYjNnbk8xeHVKR3hwWjJoMFltOTRMV05zWVhOek9pQW5MaWNnS3lBa2JHbG5hSFJpYjNndGNISmxabWw0TzF4dVhHNGpleVJzYVdkb2RHSnZlQzFqYkdGemMzMGdlMXh1SUNCd2IzTnBkR2x2YmpvZ1ptbDRaV1E3WEc0Z0lIUnZjRG9nTUR0Y2JpQWdiR1ZtZERvZ01EdGNiaUFnWW05MGRHOXRPaUF3TzF4dUlDQnlhV2RvZERvZ01EdGNiaUFnZDJsa2RHZzZJREV3TUNVN1hHNGdJR2hsYVdkb2REb2dNVEF3SlR0Y2JpQWdMWGRsWW10cGRDMWhibWx0WVhScGIyNDZJQ043Skd4cFoyaDBZbTk0TFhCeVpXWnBlSDB0Wm1Ga1pXbHVJQzR4TlhNN1hHNGdJR0Z1YVcxaGRHbHZiam9nSTNza2JHbG5hSFJpYjNndGNISmxabWw0ZlMxbVlXUmxhVzRnTGpFMWN6dGNibjFjYmx4dUkzc2tiR2xuYUhSaWIzZ3RZMnhoYzNOOUxXOTJaWEpzWVhrZ2UxeHVJQ0J3YjNOcGRHbHZiam9nWVdKemIyeDFkR1U3WEc0Z0lIUnZjRG93TzF4dUlDQnNaV1owT2lBd08xeHVJQ0JpYjNSMGIyMDZJREE3WEc0Z0lISnBaMmgwT2lBd08xeHVJQ0I2TFdsdVpHVjRPaUF4TzF4dWZWeHVYRzRqZXlSc2FXZG9kR0p2ZUMxamJHRnpjMzB0WTI5dWRHVnVkQ0I3WEc0Z0lIQnZjMmwwYVc5dU9pQnlaV3hoZEdsMlpUdGNiaUFnZEc5d09pQXdPMXh1SUNCc1pXWjBPaUF3TzF4dUlDQjZMV2x1WkdWNE9pQXpPMXh1ZlZ4dVhHNGpleVJzYVdkb2RHSnZlQzFqYkdGemMzMHRZMjl1ZEdWdWRGOWZhR2xrWkdWdUlIdGNiaUFnZG1semFXSnBiR2wwZVRvZ2FHbGtaR1Z1TzF4dUlDQjZMV2x1WkdWNE9pQXRNVHRjYm4xY2JseHVJM3NrYkdsbmFIUmliM2d0WTJ4aGMzTjlMV052Ym5SbGJuUXRhV1p5WVcxbElIdGNiaUFnZDJsa2RHZzZJREV3TUNVN1hHNGdJR2hsYVdkb2REb2dNVEF3SlR0Y2JpQWdZbTl5WkdWeU9pQXdPMXh1SUNCaVlXTnJaM0p2ZFc1a09pQjBjbUZ1YzNCaGNtVnVkRHRjYm4xY2JseHVJM3NrYkdsbmFIUmliM2d0WTJ4aGMzTjlMWE53YVc1dVpYSWdlMXh1SUNCd2IzTnBkR2x2YmpvZ1lXSnpiMngxZEdVN1hHNGdJSFJ2Y0RvZ05UQWxPMXh1SUNCc1pXWjBPaUExTUNVN1hHNGdJR1JwYzNCc1lYazZJRzV2Ym1VN1hHNGdJSG90YVc1a1pYZzZJREk3WEc0Z0lIQnZhVzUwWlhJdFpYWmxiblJ6T2lCdWIyNWxPMXh1WEc0Z0lDNXpjR2x1Ym1WeUxYaHpiMnhzWVNCN1hHNGdJQ0FnZDJsa2RHZzZJRFUyY0hnN1hHNGdJQ0FnYUdWcFoyaDBPaUExTlhCNE8xeHVJQ0FnSUcxaGNtZHBiam9nZTF4dUlDQWdJQ0FnZEc5d09pQXRNamh3ZUR0Y2JpQWdJQ0FnSUd4bFpuUTZJQzB5Tm5CNE8xeHVJQ0FnSUgxY2JseHVJQ0FnSUM1emNHbHVibVZ5TFhoemIyeHNZUzE0TENBdWMzQnBibTVsY2kxNGMyOXNiR0V0Y3l3Z0xuTndhVzV1WlhJdGVITnZiR3hoTFc4c0lDNXpjR2x1Ym1WeUxYaHpiMnhzWVMxc0xDQXVjM0JwYm01bGNpMTRjMjlzYkdFdFlTQjdYRzRnSUNBZ0lDQXRkMlZpYTJsMExXRnVhVzFoZEdsdmJqb2dJM3NrYkdsbmFIUmliM2d0Y0hKbFptbDRmUzFpYjNWdVkyVmtaV3hoZVNBeGN5QnBibVpwYm1sMFpTQmxZWE5sTFdsdUxXOTFkRHRjYmlBZ0lDQWdJQzEzWldKcmFYUXRZVzVwYldGMGFXOXVMV1pwYkd3dGJXOWtaVG9nWW05MGFEdGNiaUFnSUNBZ0lHRnVhVzFoZEdsdmJqb2dJM3NrYkdsbmFIUmliM2d0Y0hKbFptbDRmUzFpYjNWdVkyVmtaV3hoZVNBeGN5QnBibVpwYm1sMFpTQmxZWE5sTFdsdUxXOTFkRHRjYmlBZ0lDQWdJR0Z1YVcxaGRHbHZiaTFtYVd4c0xXMXZaR1U2SUdKdmRHZzdYRzRnSUNBZ2ZWeHVYRzRnSUNBZ0xuTndhVzV1WlhJdGVITnZiR3hoTFhnZ2UxeHVJQ0FnSUNBZ0xYZGxZbXRwZEMxaGJtbHRZWFJwYjI0dFpHVnNZWGs2SURCek8xeHVJQ0FnSUNBZ1lXNXBiV0YwYVc5dUxXUmxiR0Y1T2lBd2N6dGNiaUFnSUNCOVhHNWNiaUFnSUNBdWMzQnBibTVsY2kxNGMyOXNiR0V0Y3lCN1hHNGdJQ0FnSUNBdGQyVmlhMmwwTFdGdWFXMWhkR2x2Ymkxa1pXeGhlVG9nTGpKek8xeHVJQ0FnSUNBZ1lXNXBiV0YwYVc5dUxXUmxiR0Y1T2lBdU1uTTdYRzRnSUNBZ2ZWeHVYRzRnSUNBZ0xuTndhVzV1WlhJdGVITnZiR3hoTFc4Z2UxeHVJQ0FnSUNBZ0xYZGxZbXRwZEMxaGJtbHRZWFJwYjI0dFpHVnNZWGs2SUM0MGN6dGNiaUFnSUNBZ0lHRnVhVzFoZEdsdmJpMWtaV3hoZVRvZ0xqUnpPMXh1SUNBZ0lIMWNibHh1SUNBZ0lDNXpjR2x1Ym1WeUxYaHpiMnhzWVMxc0lIdGNiaUFnSUNBZ0lDMTNaV0pyYVhRdFlXNXBiV0YwYVc5dUxXUmxiR0Y1T2lBdU5uTTdYRzRnSUNBZ0lDQmhibWx0WVhScGIyNHRaR1ZzWVhrNklDNDJjenRjYmlBZ0lDQjlYRzVjYmlBZ0lDQXVjM0JwYm01bGNpMTRjMjlzYkdFdFlTQjdYRzRnSUNBZ0lDQXRkMlZpYTJsMExXRnVhVzFoZEdsdmJpMWtaV3hoZVRvZ0xqaHpPMXh1SUNBZ0lDQWdZVzVwYldGMGFXOXVMV1JsYkdGNU9pQXVPSE03WEc0Z0lDQWdmVnh1SUNCOVhHNWNiaUFnTG5Od2FXNXVaWEl0Y205MWJtUWdlMXh1SUNBZ0lHMWhjbWRwYmpvZ2UxeHVJQ0FnSUNBZ2RHOXdPaUF0TWpOd2VEdGNiaUFnSUNBZ0lHeGxablE2SUMweU0zQjRPMXh1SUNBZ0lIMWNiaUFnSUNBdGQyVmlhMmwwTFdGdWFXMWhkR2x2YmpvZ0kzc2tiR2xuYUhSaWIzZ3RjSEpsWm1sNGZTMXpjR2x1SUROeklHbHVabWx1YVhSbElHeHBibVZoY2p0Y2JpQWdJQ0JoYm1sdFlYUnBiMjQ2SUNON0pHeHBaMmgwWW05NExYQnlaV1pwZUgwdGMzQnBiaUF6Y3lCcGJtWnBibWwwWlNCc2FXNWxZWEk3WEc0Z0lIMWNibHh1SUNBdWMzQnBibTVsY2kxamRYTjBiMjBnZTF4dUlDQWdJQzEzWldKcmFYUXRZVzVwYldGMGFXOXVPaUFqZXlSc2FXZG9kR0p2ZUMxd2NtVm1hWGg5TFhOd2FXNGdhVzVtYVc1cGRHVWdiR2x1WldGeU8xeHVJQ0FnSUdGdWFXMWhkR2x2YmpvZ0kzc2tiR2xuYUhSaWIzZ3RjSEpsWm1sNGZTMXpjR2x1SUdsdVptbHVhWFJsSUd4cGJtVmhjanRjYmlBZ2ZWeHVmVnh1WEc1QUxYZGxZbXRwZEMxclpYbG1jbUZ0WlhNZ0kzc2tiR2xuYUhSaWIzZ3RjSEpsWm1sNGZTMWliM1Z1WTJWa1pXeGhlU0I3WEc0Z0lEQWxMQ0E0TUNVc0lERXdNQ1VnZXlCdmNHRmphWFI1T2lBd095QjlYRzRnSURRd0pTQjdJRzl3WVdOcGRIazZJREVnZlZ4dWZWeHVYRzVBYTJWNVpuSmhiV1Z6SUNON0pHeHBaMmgwWW05NExYQnlaV1pwZUgwdFltOTFibU5sWkdWc1lYa2dlMXh1SUNBd0pTd2dPREFsTENBeE1EQWxJSHNnYjNCaFkybDBlVG9nTURzZ2ZWeHVJQ0EwTUNVZ2V5QnZjR0ZqYVhSNU9pQXhPeUI5WEc1OVhHNWNia0F0ZDJWaWEybDBMV3RsZVdaeVlXMWxjeUFqZXlSc2FXZG9kR0p2ZUMxd2NtVm1hWGg5TFdaaFpHVnBiaUI3WEc0Z0lHWnliMjBnZXlCdmNHRmphWFI1T2lBd095QjlYRzRnSUhSdklIc2diM0JoWTJsMGVUb2dNVHNnZlZ4dWZWeHVYRzVBYTJWNVpuSmhiV1Z6SUNON0pHeHBaMmgwWW05NExYQnlaV1pwZUgwdFptRmtaV2x1SUh0Y2JpQWdabkp2YlNCN0lHOXdZV05wZEhrNklEQTdJSDFjYmlBZ2RHOGdleUJ2Y0dGamFYUjVPaUF4T3lCOVhHNTlYRzVjYmtBdGQyVmlhMmwwTFd0bGVXWnlZVzFsY3lBamV5UnNhV2RvZEdKdmVDMXdjbVZtYVhoOUxYTndhVzRnZTF4dUlDQm1jbTl0SUhzZ0xYZGxZbXRwZEMxMGNtRnVjMlp2Y20wNklISnZkR0YwWlNnd1pHVm5LVHNnZlZ4dUlDQjBieUI3SUMxM1pXSnJhWFF0ZEhKaGJuTm1iM0p0T2lCeWIzUmhkR1VvTXpZd1pHVm5LVHNnZlZ4dWZWeHVYRzVBYTJWNVpuSmhiV1Z6SUNON0pHeHBaMmgwWW05NExYQnlaV1pwZUgwdGMzQnBiaUI3WEc0Z0lHWnliMjBnZXlCMGNtRnVjMlp2Y20wNklISnZkR0YwWlNnd1pHVm5LVHNnZlZ4dUlDQjBieUI3SUhSeVlXNXpabTl5YlRvZ2NtOTBZWFJsS0RNMk1HUmxaeWs3SUgxY2JuMWNiaUlLQ1Ywc0Nna2liV0Z3Y0dsdVozTWlPaUFpUVVGSFFTeEJRVUZCTERSQ1FVRTBRaXhCUVVFMVFpeERRVU5GTEZGQlFWRXNRMEZCUlN4TFFVRk5MRU5CUTJoQ0xFZEJRVWNzUTBGQlJTeERRVUZGTEVOQlExQXNTVUZCU1N4RFFVRkZMRU5CUVVVc1EwRkRVaXhOUVVGTkxFTkJRVVVzUTBGQlJTeERRVU5XTEV0QlFVc3NRMEZCUlN4RFFVRkZMRU5CUTFRc1MwRkJTeXhEUVVGRkxFbEJRVXNzUTBGRFdpeE5RVUZOTEVOQlFVVXNTVUZCU3l4RFFVTmlMR2xDUVVGcFFpeERRVUZGTEd0RFFVRXdRaXhEUVVGUkxFdEJRVWtzUTBGRGVrUXNVMEZCVXl4RFFVRkZMR3REUVVFd1FpeERRVUZSTEV0QlFVa3NRMEZEYkVRc1FVRkZSQ3hCUVVGQkxHOURRVUZ2UXl4QlFVRndReXhEUVVORkxGRkJRVkVzUTBGQlJTeFJRVUZUTEVOQlEyNUNMRWRCUVVjc1EwRkJReXhEUVVGRkxFTkJRMDRzU1VGQlNTeERRVUZGTEVOQlFVVXNRMEZEVWl4TlFVRk5MRU5CUVVVc1EwRkJSU3hEUVVOV0xFdEJRVXNzUTBGQlJTeERRVUZGTEVOQlExUXNUMEZCVHl4RFFVRkZMRU5CUVVVc1EwRkRXaXhCUVVWRUxFRkJRVUVzYjBOQlFXOURMRUZCUVhCRExFTkJRMFVzVVVGQlVTeERRVUZGTEZGQlFWTXNRMEZEYmtJc1IwRkJSeXhEUVVGRkxFTkJRVVVzUTBGRFVDeEpRVUZKTEVOQlFVVXNRMEZCUlN4RFFVTlNMRTlCUVU4c1EwRkJSU3hEUVVGRkxFTkJRMW9zUVVGRlJDeEJRVUZCTERSRFFVRTBReXhCUVVFMVF5eERRVU5GTEZWQlFWVXNRMEZCUlN4TlFVRlBMRU5CUTI1Q0xFOUJRVThzUTBGQlJTeEZRVUZITEVOQlEySXNRVUZGUkN4QlFVRkJMREpEUVVFeVF5eEJRVUV6UXl4RFFVTkZMRXRCUVVzc1EwRkJSU3hKUVVGTExFTkJRMW9zVFVGQlRTeERRVUZGTEVsQlFVc3NRMEZEWWl4TlFVRk5MRU5CUVVVc1EwRkJSU3hEUVVOV0xGVkJRVlVzUTBGQlJTeFhRVUZaTEVOQlEzcENMRUZCUlVRc1FVRkJRU3h2UTBGQmIwTXNRVUZCY0VNc1EwRkRSU3hSUVVGUkxFTkJRVVVzVVVGQlV5eERRVU51UWl4SFFVRkhMRU5CUVVVc1IwRkJTU3hEUVVOVUxFbEJRVWtzUTBGQlJTeEhRVUZKTEVOQlExWXNUMEZCVHl4RFFVRkZMRWxCUVVzc1EwRkRaQ3hQUVVGUExFTkJRVVVzUTBGQlJTeERRVU5ZTEdOQlFXTXNRMEZCUlN4SlFVRkxMRU5CZDBSMFFpeEJRVGxFUkN4QlFWRkZMRzlEUVZKclF5eERRVkZzUXl4bFFVRmxMRUZCUVVNc1EwRkRaQ3hMUVVGTExFTkJRVVVzU1VGQlN5eERRVU5hTEUxQlFVMHNRMEZCUlN4SlFVRkxMRU5CUTJJc1RVRkJUU3hCUVVGRExFTkJRVU1zUVVGRFRpeEhRVUZITEVOQlFVVXNTMEZCVFN4RFFVUmlMRTFCUVUwc1FVRkJReXhEUVVGRExFRkJSVTRzU1VGQlNTeERRVUZGTEV0QlFVMHNRMEZyUTJZc1FVRXZRMGdzUVVGblFra3NiME5CYUVKblF5eERRVkZzUXl4bFFVRmxMRU5CVVdJc2FVSkJRV2xDTEVOQmFFSnlRaXhCUVdkQ2RVSXNiME5CYUVKaExFTkJVV3hETEdWQlFXVXNRMEZSVFN4cFFrRkJhVUlzUTBGb1FuaERMRUZCWjBJd1F5eHZRMEZvUWs0c1EwRlJiRU1zWlVGQlpTeERRVkY1UWl4cFFrRkJhVUlzUTBGb1FqTkVMRUZCWjBJMlJDeHZRMEZvUW5wQ0xFTkJVV3hETEdWQlFXVXNRMEZSTkVNc2FVSkJRV2xDTEVOQmFFSTVSU3hCUVdkQ1owWXNiME5CYUVJMVF5eERRVkZzUXl4bFFVRmxMRU5CVVN0RUxHbENRVUZwUWl4QlFVRkRMRU5CUXpWR0xHbENRVUZwUWl4RFFVRkZMSFZEUVVFclFpeERRVUZoTEVWQlFVVXNRMEZCUXl4UlFVRlJMRU5CUVVNc1YwRkJWeXhEUVVOMFJpd3lRa0ZCTWtJc1EwRkJSU3hKUVVGTExFTkJRMnhETEZOQlFWTXNRMEZCUlN4MVEwRkJLMElzUTBGQllTeEZRVUZGTEVOQlFVTXNVVUZCVVN4RFFVRkRMRmRCUVZjc1EwRkRPVVVzYlVKQlFXMUNMRU5CUVVVc1NVRkJTeXhEUVVNelFpeEJRWEpDVEN4QlFYVkNTU3h2UTBGMlFtZERMRU5CVVd4RExHVkJRV1VzUTBGbFlpeHBRa0ZCYVVJc1FVRkJReXhEUVVOb1FpeDFRa0ZCZFVJc1EwRkJSU3hGUVVGSExFTkJRelZDTEdWQlFXVXNRMEZCUlN4RlFVRkhMRU5CUTNKQ0xFRkJNVUpNTEVGQk5FSkpMRzlEUVRWQ1owTXNRMEZSYkVNc1pVRkJaU3hEUVc5Q1lpeHBRa0ZCYVVJc1FVRkJReXhEUVVOb1FpeDFRa0ZCZFVJc1EwRkJSU3hIUVVGSkxFTkJRemRDTEdWQlFXVXNRMEZCUlN4SFFVRkpMRU5CUTNSQ0xFRkJMMEpNTEVGQmFVTkpMRzlEUVdwRFowTXNRMEZSYkVNc1pVRkJaU3hEUVhsQ1lpeHBRa0ZCYVVJc1FVRkJReXhEUVVOb1FpeDFRa0ZCZFVJc1EwRkJSU3hIUVVGSkxFTkJRemRDTEdWQlFXVXNRMEZCUlN4SFFVRkpMRU5CUTNSQ0xFRkJjRU5NTEVGQmMwTkpMRzlEUVhSRFowTXNRMEZSYkVNc1pVRkJaU3hEUVRoQ1lpeHBRa0ZCYVVJc1FVRkJReXhEUVVOb1FpeDFRa0ZCZFVJc1EwRkJSU3hIUVVGSkxFTkJRemRDTEdWQlFXVXNRMEZCUlN4SFFVRkpMRU5CUTNSQ0xFRkJla05NTEVGQk1rTkpMRzlEUVRORFowTXNRMEZSYkVNc1pVRkJaU3hEUVcxRFlpeHBRa0ZCYVVJc1FVRkJReXhEUVVOb1FpeDFRa0ZCZFVJc1EwRkJSU3hIUVVGSkxFTkJRemRDTEdWQlFXVXNRMEZCUlN4SFFVRkpMRU5CUTNSQ0xFRkJPVU5NTEVGQmFVUkZMRzlEUVdwRWEwTXNRMEZwUkd4RExHTkJRV01zUVVGQlF5eERRVU5pTEUxQlFVMHNRVUZCUXl4RFFVRkRMRUZCUTA0c1IwRkJSeXhEUVVGRkxFdEJRVTBzUTBGRVlpeE5RVUZOTEVGQlFVTXNRMEZCUXl4QlFVVk9MRWxCUVVrc1EwRkJSU3hMUVVGTkxFTkJSV1FzYVVKQlFXbENMRU5CUVVVc1owTkJRWGRDTEVOQlFVMHNSVUZCUlN4RFFVRkRMRkZCUVZFc1EwRkJReXhOUVVGTkxFTkJRMjVGTEZOQlFWTXNRMEZCUlN4blEwRkJkMElzUTBGQlRTeEZRVUZGTEVOQlFVTXNVVUZCVVN4RFFVRkRMRTFCUVUwc1EwRkROVVFzUVVGNFJFZ3NRVUV3UkVVc2IwTkJNVVJyUXl4RFFUQkViRU1zWlVGQlpTeEJRVUZETEVOQlEyUXNhVUpCUVdsQ0xFTkJRVVVzWjBOQlFYZENMRU5CUVUwc1VVRkJVU3hEUVVGRExFMUJRVTBzUTBGRGFFVXNVMEZCVXl4RFFVRkZMR2REUVVGM1FpeERRVUZOTEZGQlFWRXNRMEZCUXl4TlFVRk5MRU5CUTNwRUxFRkJSMGdzYTBKQlFXdENMRU5CUVd4Q0xIVkRRVUZyUWl4RFFVTm9RaXhCUVVGQkxFVkJRVVVzUTBGQlJTeEJRVUZCTEVkQlFVY3NRMEZCUlN4QlFVRkJMRWxCUVVrc1EwRkJSeXhQUVVGUExFTkJRVVVzUTBGQlJTeERRVU16UWl4QlFVRkJMRWRCUVVjc1EwRkJSeXhQUVVGUExFTkJRVVVzUTBGQlJ5eEZRVWR3UWl4VlFVRlZMRU5CUVZZc2RVTkJRVlVzUTBGRFVpeEJRVUZCTEVWQlFVVXNRMEZCUlN4QlFVRkJMRWRCUVVjc1EwRkJSU3hCUVVGQkxFbEJRVWtzUTBGQlJ5eFBRVUZQTEVOQlFVVXNRMEZCUlN4RFFVTXpRaXhCUVVGQkxFZEJRVWNzUTBGQlJ5eFBRVUZQTEVOQlFVVXNRMEZCUlN4RlFVZHVRaXhyUWtGQmEwSXNRMEZCYkVJc2EwTkJRV3RDTEVOQlEyaENMRUZCUVVFc1NVRkJTU3hEUVVGSExFOUJRVThzUTBGQlJTeERRVUZGTEVOQlEyeENMRUZCUVVFc1JVRkJSU3hEUVVGSExFOUJRVThzUTBGQlJTeERRVUZGTEVWQlIyeENMRlZCUVZVc1EwRkJWaXhyUTBGQlZTeERRVU5TTEVGQlFVRXNTVUZCU1N4RFFVRkhMRTlCUVU4c1EwRkJSU3hEUVVGRkxFTkJRMnhDTEVGQlFVRXNSVUZCUlN4RFFVRkhMRTlCUVU4c1EwRkJSU3hEUVVGRkxFVkJSMnhDTEd0Q1FVRnJRaXhEUVVGc1FpeG5RMEZCYTBJc1EwRkRhRUlzUVVGQlFTeEpRVUZKTEVOQlFVY3NhVUpCUVdsQ0xFTkJRVVVzV1VGQlRTeERRVU5vUXl4QlFVRkJMRVZCUVVVc1EwRkJSeXhwUWtGQmFVSXNRMEZCUlN4alFVRk5MRVZCUjJoRExGVkJRVlVzUTBGQlZpeG5RMEZCVlN4RFFVTlNMRUZCUVVFc1NVRkJTU3hEUVVGSExGTkJRVk1zUTBGQlJTeFpRVUZOTEVOQlEzaENMRUZCUVVFc1JVRkJSU3hEUVVGSExGTkJRVk1zUTBGQlJTeGpRVUZOSWl3S0NTSnVZVzFsY3lJNklGdGRDbjA9ICovJyk7OyIsIm1vZHVsZS5leHBvcnRzID0gJzEuMi4zJztcbiIsIi8qIVxuICogQm93c2VyIC0gYSBicm93c2VyIGRldGVjdG9yXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZGVkL2Jvd3NlclxuICogTUlUIExpY2Vuc2UgfCAoYykgRHVzdGluIERpYXogMjAxNVxuICovXG5cbiFmdW5jdGlvbiAocm9vdCwgbmFtZSwgZGVmaW5pdGlvbikge1xuICBpZiAodHlwZW9mIG1vZHVsZSAhPSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykgbW9kdWxlLmV4cG9ydHMgPSBkZWZpbml0aW9uKClcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIGRlZmluZShuYW1lLCBkZWZpbml0aW9uKVxuICBlbHNlIHJvb3RbbmFtZV0gPSBkZWZpbml0aW9uKClcbn0odGhpcywgJ2Jvd3NlcicsIGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAgKiBTZWUgdXNlcmFnZW50cy5qcyBmb3IgZXhhbXBsZXMgb2YgbmF2aWdhdG9yLnVzZXJBZ2VudFxuICAgICovXG5cbiAgdmFyIHQgPSB0cnVlXG5cbiAgZnVuY3Rpb24gZGV0ZWN0KHVhKSB7XG5cbiAgICBmdW5jdGlvbiBnZXRGaXJzdE1hdGNoKHJlZ2V4KSB7XG4gICAgICB2YXIgbWF0Y2ggPSB1YS5tYXRjaChyZWdleCk7XG4gICAgICByZXR1cm4gKG1hdGNoICYmIG1hdGNoLmxlbmd0aCA+IDEgJiYgbWF0Y2hbMV0pIHx8ICcnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNlY29uZE1hdGNoKHJlZ2V4KSB7XG4gICAgICB2YXIgbWF0Y2ggPSB1YS5tYXRjaChyZWdleCk7XG4gICAgICByZXR1cm4gKG1hdGNoICYmIG1hdGNoLmxlbmd0aCA+IDEgJiYgbWF0Y2hbMl0pIHx8ICcnO1xuICAgIH1cblxuICAgIHZhciBpb3NkZXZpY2UgPSBnZXRGaXJzdE1hdGNoKC8oaXBvZHxpcGhvbmV8aXBhZCkvaSkudG9Mb3dlckNhc2UoKVxuICAgICAgLCBsaWtlQW5kcm9pZCA9IC9saWtlIGFuZHJvaWQvaS50ZXN0KHVhKVxuICAgICAgLCBhbmRyb2lkID0gIWxpa2VBbmRyb2lkICYmIC9hbmRyb2lkL2kudGVzdCh1YSlcbiAgICAgICwgbmV4dXNNb2JpbGUgPSAvbmV4dXNcXHMqWzAtNl1cXHMqL2kudGVzdCh1YSlcbiAgICAgICwgbmV4dXNUYWJsZXQgPSAhbmV4dXNNb2JpbGUgJiYgL25leHVzXFxzKlswLTldKy9pLnRlc3QodWEpXG4gICAgICAsIGNocm9tZW9zID0gL0NyT1MvLnRlc3QodWEpXG4gICAgICAsIHNpbGsgPSAvc2lsay9pLnRlc3QodWEpXG4gICAgICAsIHNhaWxmaXNoID0gL3NhaWxmaXNoL2kudGVzdCh1YSlcbiAgICAgICwgdGl6ZW4gPSAvdGl6ZW4vaS50ZXN0KHVhKVxuICAgICAgLCB3ZWJvcyA9IC8od2VifGhwdykob3wwKXMvaS50ZXN0KHVhKVxuICAgICAgLCB3aW5kb3dzcGhvbmUgPSAvd2luZG93cyBwaG9uZS9pLnRlc3QodWEpXG4gICAgICAsIHNhbXN1bmdCcm93c2VyID0gL1NhbXN1bmdCcm93c2VyL2kudGVzdCh1YSlcbiAgICAgICwgd2luZG93cyA9ICF3aW5kb3dzcGhvbmUgJiYgL3dpbmRvd3MvaS50ZXN0KHVhKVxuICAgICAgLCBtYWMgPSAhaW9zZGV2aWNlICYmICFzaWxrICYmIC9tYWNpbnRvc2gvaS50ZXN0KHVhKVxuICAgICAgLCBsaW51eCA9ICFhbmRyb2lkICYmICFzYWlsZmlzaCAmJiAhdGl6ZW4gJiYgIXdlYm9zICYmIC9saW51eC9pLnRlc3QodWEpXG4gICAgICAsIGVkZ2VWZXJzaW9uID0gZ2V0U2Vjb25kTWF0Y2goL2VkZyhbZWFdfGlvcylcXC8oXFxkKyhcXC5cXGQrKT8pL2kpXG4gICAgICAsIHZlcnNpb25JZGVudGlmaWVyID0gZ2V0Rmlyc3RNYXRjaCgvdmVyc2lvblxcLyhcXGQrKFxcLlxcZCspPykvaSlcbiAgICAgICwgdGFibGV0ID0gL3RhYmxldC9pLnRlc3QodWEpICYmICEvdGFibGV0IHBjL2kudGVzdCh1YSlcbiAgICAgICwgbW9iaWxlID0gIXRhYmxldCAmJiAvW14tXW1vYmkvaS50ZXN0KHVhKVxuICAgICAgLCB4Ym94ID0gL3hib3gvaS50ZXN0KHVhKVxuICAgICAgLCByZXN1bHRcblxuICAgIGlmICgvb3BlcmEvaS50ZXN0KHVhKSkge1xuICAgICAgLy8gIGFuIG9sZCBPcGVyYVxuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnT3BlcmEnXG4gICAgICAsIG9wZXJhOiB0XG4gICAgICAsIHZlcnNpb246IHZlcnNpb25JZGVudGlmaWVyIHx8IGdldEZpcnN0TWF0Y2goLyg/Om9wZXJhfG9wcnxvcGlvcylbXFxzXFwvXShcXGQrKFxcLlxcZCspPykvaSlcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKC9vcHJcXC98b3Bpb3MvaS50ZXN0KHVhKSkge1xuICAgICAgLy8gYSBuZXcgT3BlcmFcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgbmFtZTogJ09wZXJhJ1xuICAgICAgICAsIG9wZXJhOiB0XG4gICAgICAgICwgdmVyc2lvbjogZ2V0Rmlyc3RNYXRjaCgvKD86b3ByfG9waW9zKVtcXHNcXC9dKFxcZCsoXFwuXFxkKyk/KS9pKSB8fCB2ZXJzaW9uSWRlbnRpZmllclxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICgvU2Ftc3VuZ0Jyb3dzZXIvaS50ZXN0KHVhKSkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnU2Ftc3VuZyBJbnRlcm5ldCBmb3IgQW5kcm9pZCdcbiAgICAgICAgLCBzYW1zdW5nQnJvd3NlcjogdFxuICAgICAgICAsIHZlcnNpb246IHZlcnNpb25JZGVudGlmaWVyIHx8IGdldEZpcnN0TWF0Y2goLyg/OlNhbXN1bmdCcm93c2VyKVtcXHNcXC9dKFxcZCsoXFwuXFxkKyk/KS9pKVxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICgvV2hhbGUvaS50ZXN0KHVhKSkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnTkFWRVIgV2hhbGUgYnJvd3NlcidcbiAgICAgICAgLCB3aGFsZTogdFxuICAgICAgICAsIHZlcnNpb246IGdldEZpcnN0TWF0Y2goLyg/OndoYWxlKVtcXHNcXC9dKFxcZCsoPzpcXC5cXGQrKSspL2kpXG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKC9NWkJyb3dzZXIvaS50ZXN0KHVhKSkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnTVogQnJvd3NlcidcbiAgICAgICAgLCBtemJyb3dzZXI6IHRcbiAgICAgICAgLCB2ZXJzaW9uOiBnZXRGaXJzdE1hdGNoKC8oPzpNWkJyb3dzZXIpW1xcc1xcL10oXFxkKyg/OlxcLlxcZCspKykvaSlcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoL2NvYXN0L2kudGVzdCh1YSkpIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgbmFtZTogJ09wZXJhIENvYXN0J1xuICAgICAgICAsIGNvYXN0OiB0XG4gICAgICAgICwgdmVyc2lvbjogdmVyc2lvbklkZW50aWZpZXIgfHwgZ2V0Rmlyc3RNYXRjaCgvKD86Y29hc3QpW1xcc1xcL10oXFxkKyhcXC5cXGQrKT8pL2kpXG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKC9mb2N1cy9pLnRlc3QodWEpKSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG5hbWU6ICdGb2N1cydcbiAgICAgICAgLCBmb2N1czogdFxuICAgICAgICAsIHZlcnNpb246IGdldEZpcnN0TWF0Y2goLyg/OmZvY3VzKVtcXHNcXC9dKFxcZCsoPzpcXC5cXGQrKSspL2kpXG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKC95YWJyb3dzZXIvaS50ZXN0KHVhKSkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnWWFuZGV4IEJyb3dzZXInXG4gICAgICAsIHlhbmRleGJyb3dzZXI6IHRcbiAgICAgICwgdmVyc2lvbjogdmVyc2lvbklkZW50aWZpZXIgfHwgZ2V0Rmlyc3RNYXRjaCgvKD86eWFicm93c2VyKVtcXHNcXC9dKFxcZCsoXFwuXFxkKyk/KS9pKVxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICgvdWNicm93c2VyL2kudGVzdCh1YSkpIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgICBuYW1lOiAnVUMgQnJvd3NlcidcbiAgICAgICAgLCB1Y2Jyb3dzZXI6IHRcbiAgICAgICAgLCB2ZXJzaW9uOiBnZXRGaXJzdE1hdGNoKC8oPzp1Y2Jyb3dzZXIpW1xcc1xcL10oXFxkKyg/OlxcLlxcZCspKykvaSlcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoL214aW9zL2kudGVzdCh1YSkpIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgbmFtZTogJ01heHRob24nXG4gICAgICAgICwgbWF4dGhvbjogdFxuICAgICAgICAsIHZlcnNpb246IGdldEZpcnN0TWF0Y2goLyg/Om14aW9zKVtcXHNcXC9dKFxcZCsoPzpcXC5cXGQrKSspL2kpXG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKC9lcGlwaGFueS9pLnRlc3QodWEpKSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG5hbWU6ICdFcGlwaGFueSdcbiAgICAgICAgLCBlcGlwaGFueTogdFxuICAgICAgICAsIHZlcnNpb246IGdldEZpcnN0TWF0Y2goLyg/OmVwaXBoYW55KVtcXHNcXC9dKFxcZCsoPzpcXC5cXGQrKSspL2kpXG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKC9wdWZmaW4vaS50ZXN0KHVhKSkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnUHVmZmluJ1xuICAgICAgICAsIHB1ZmZpbjogdFxuICAgICAgICAsIHZlcnNpb246IGdldEZpcnN0TWF0Y2goLyg/OnB1ZmZpbilbXFxzXFwvXShcXGQrKD86XFwuXFxkKyk/KS9pKVxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICgvc2xlaXBuaXIvaS50ZXN0KHVhKSkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnU2xlaXBuaXInXG4gICAgICAgICwgc2xlaXBuaXI6IHRcbiAgICAgICAgLCB2ZXJzaW9uOiBnZXRGaXJzdE1hdGNoKC8oPzpzbGVpcG5pcilbXFxzXFwvXShcXGQrKD86XFwuXFxkKykrKS9pKVxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICgvay1tZWxlb24vaS50ZXN0KHVhKSkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnSy1NZWxlb24nXG4gICAgICAgICwga01lbGVvbjogdFxuICAgICAgICAsIHZlcnNpb246IGdldEZpcnN0TWF0Y2goLyg/OmstbWVsZW9uKVtcXHNcXC9dKFxcZCsoPzpcXC5cXGQrKSspL2kpXG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHdpbmRvd3NwaG9uZSkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnV2luZG93cyBQaG9uZSdcbiAgICAgICwgb3NuYW1lOiAnV2luZG93cyBQaG9uZSdcbiAgICAgICwgd2luZG93c3Bob25lOiB0XG4gICAgICB9XG4gICAgICBpZiAoZWRnZVZlcnNpb24pIHtcbiAgICAgICAgcmVzdWx0Lm1zZWRnZSA9IHRcbiAgICAgICAgcmVzdWx0LnZlcnNpb24gPSBlZGdlVmVyc2lvblxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdC5tc2llID0gdFxuICAgICAgICByZXN1bHQudmVyc2lvbiA9IGdldEZpcnN0TWF0Y2goL2llbW9iaWxlXFwvKFxcZCsoXFwuXFxkKyk/KS9pKVxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICgvbXNpZXx0cmlkZW50L2kudGVzdCh1YSkpIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgbmFtZTogJ0ludGVybmV0IEV4cGxvcmVyJ1xuICAgICAgLCBtc2llOiB0XG4gICAgICAsIHZlcnNpb246IGdldEZpcnN0TWF0Y2goLyg/Om1zaWUgfHJ2OikoXFxkKyhcXC5cXGQrKT8pL2kpXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjaHJvbWVvcykge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnQ2hyb21lJ1xuICAgICAgLCBvc25hbWU6ICdDaHJvbWUgT1MnXG4gICAgICAsIGNocm9tZW9zOiB0XG4gICAgICAsIGNocm9tZUJvb2s6IHRcbiAgICAgICwgY2hyb21lOiB0XG4gICAgICAsIHZlcnNpb246IGdldEZpcnN0TWF0Y2goLyg/OmNocm9tZXxjcmlvc3xjcm1vKVxcLyhcXGQrKFxcLlxcZCspPykvaSlcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKC9lZGcoW2VhXXxpb3MpL2kudGVzdCh1YSkpIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgbmFtZTogJ01pY3Jvc29mdCBFZGdlJ1xuICAgICAgLCBtc2VkZ2U6IHRcbiAgICAgICwgdmVyc2lvbjogZWRnZVZlcnNpb25cbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoL3ZpdmFsZGkvaS50ZXN0KHVhKSkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnVml2YWxkaSdcbiAgICAgICAgLCB2aXZhbGRpOiB0XG4gICAgICAgICwgdmVyc2lvbjogZ2V0Rmlyc3RNYXRjaCgvdml2YWxkaVxcLyhcXGQrKFxcLlxcZCspPykvaSkgfHwgdmVyc2lvbklkZW50aWZpZXJcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoc2FpbGZpc2gpIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgbmFtZTogJ1NhaWxmaXNoJ1xuICAgICAgLCBvc25hbWU6ICdTYWlsZmlzaCBPUydcbiAgICAgICwgc2FpbGZpc2g6IHRcbiAgICAgICwgdmVyc2lvbjogZ2V0Rmlyc3RNYXRjaCgvc2FpbGZpc2hcXHM/YnJvd3NlclxcLyhcXGQrKFxcLlxcZCspPykvaSlcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoL3NlYW1vbmtleVxcLy9pLnRlc3QodWEpKSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG5hbWU6ICdTZWFNb25rZXknXG4gICAgICAsIHNlYW1vbmtleTogdFxuICAgICAgLCB2ZXJzaW9uOiBnZXRGaXJzdE1hdGNoKC9zZWFtb25rZXlcXC8oXFxkKyhcXC5cXGQrKT8pL2kpXG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKC9maXJlZm94fGljZXdlYXNlbHxmeGlvcy9pLnRlc3QodWEpKSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG5hbWU6ICdGaXJlZm94J1xuICAgICAgLCBmaXJlZm94OiB0XG4gICAgICAsIHZlcnNpb246IGdldEZpcnN0TWF0Y2goLyg/OmZpcmVmb3h8aWNld2Vhc2VsfGZ4aW9zKVsgXFwvXShcXGQrKFxcLlxcZCspPykvaSlcbiAgICAgIH1cbiAgICAgIGlmICgvXFwoKG1vYmlsZXx0YWJsZXQpO1teXFwpXSpydjpbXFxkXFwuXStcXCkvaS50ZXN0KHVhKSkge1xuICAgICAgICByZXN1bHQuZmlyZWZveG9zID0gdFxuICAgICAgICByZXN1bHQub3NuYW1lID0gJ0ZpcmVmb3ggT1MnXG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHNpbGspIHtcbiAgICAgIHJlc3VsdCA9ICB7XG4gICAgICAgIG5hbWU6ICdBbWF6b24gU2lsaydcbiAgICAgICwgc2lsazogdFxuICAgICAgLCB2ZXJzaW9uIDogZ2V0Rmlyc3RNYXRjaCgvc2lsa1xcLyhcXGQrKFxcLlxcZCspPykvaSlcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoL3BoYW50b20vaS50ZXN0KHVhKSkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnUGhhbnRvbUpTJ1xuICAgICAgLCBwaGFudG9tOiB0XG4gICAgICAsIHZlcnNpb246IGdldEZpcnN0TWF0Y2goL3BoYW50b21qc1xcLyhcXGQrKFxcLlxcZCspPykvaSlcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoL3NsaW1lcmpzL2kudGVzdCh1YSkpIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgbmFtZTogJ1NsaW1lckpTJ1xuICAgICAgICAsIHNsaW1lcjogdFxuICAgICAgICAsIHZlcnNpb246IGdldEZpcnN0TWF0Y2goL3NsaW1lcmpzXFwvKFxcZCsoXFwuXFxkKyk/KS9pKVxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICgvYmxhY2tiZXJyeXxcXGJiYlxcZCsvaS50ZXN0KHVhKSB8fCAvcmltXFxzdGFibGV0L2kudGVzdCh1YSkpIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgbmFtZTogJ0JsYWNrQmVycnknXG4gICAgICAsIG9zbmFtZTogJ0JsYWNrQmVycnkgT1MnXG4gICAgICAsIGJsYWNrYmVycnk6IHRcbiAgICAgICwgdmVyc2lvbjogdmVyc2lvbklkZW50aWZpZXIgfHwgZ2V0Rmlyc3RNYXRjaCgvYmxhY2tiZXJyeVtcXGRdK1xcLyhcXGQrKFxcLlxcZCspPykvaSlcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAod2Vib3MpIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgbmFtZTogJ1dlYk9TJ1xuICAgICAgLCBvc25hbWU6ICdXZWJPUydcbiAgICAgICwgd2Vib3M6IHRcbiAgICAgICwgdmVyc2lvbjogdmVyc2lvbklkZW50aWZpZXIgfHwgZ2V0Rmlyc3RNYXRjaCgvdyg/OmViKT9vc2Jyb3dzZXJcXC8oXFxkKyhcXC5cXGQrKT8pL2kpXG4gICAgICB9O1xuICAgICAgL3RvdWNocGFkXFwvL2kudGVzdCh1YSkgJiYgKHJlc3VsdC50b3VjaHBhZCA9IHQpXG4gICAgfVxuICAgIGVsc2UgaWYgKC9iYWRhL2kudGVzdCh1YSkpIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgbmFtZTogJ0JhZGEnXG4gICAgICAsIG9zbmFtZTogJ0JhZGEnXG4gICAgICAsIGJhZGE6IHRcbiAgICAgICwgdmVyc2lvbjogZ2V0Rmlyc3RNYXRjaCgvZG9sZmluXFwvKFxcZCsoXFwuXFxkKyk/KS9pKVxuICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAodGl6ZW4pIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgbmFtZTogJ1RpemVuJ1xuICAgICAgLCBvc25hbWU6ICdUaXplbidcbiAgICAgICwgdGl6ZW46IHRcbiAgICAgICwgdmVyc2lvbjogZ2V0Rmlyc3RNYXRjaCgvKD86dGl6ZW5cXHM/KT9icm93c2VyXFwvKFxcZCsoXFwuXFxkKyk/KS9pKSB8fCB2ZXJzaW9uSWRlbnRpZmllclxuICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoL3F1cHppbGxhL2kudGVzdCh1YSkpIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgbmFtZTogJ1F1cFppbGxhJ1xuICAgICAgICAsIHF1cHppbGxhOiB0XG4gICAgICAgICwgdmVyc2lvbjogZ2V0Rmlyc3RNYXRjaCgvKD86cXVwemlsbGEpW1xcc1xcL10oXFxkKyg/OlxcLlxcZCspKykvaSkgfHwgdmVyc2lvbklkZW50aWZpZXJcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoL2Nocm9taXVtL2kudGVzdCh1YSkpIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgbmFtZTogJ0Nocm9taXVtJ1xuICAgICAgICAsIGNocm9taXVtOiB0XG4gICAgICAgICwgdmVyc2lvbjogZ2V0Rmlyc3RNYXRjaCgvKD86Y2hyb21pdW0pW1xcc1xcL10oXFxkKyg/OlxcLlxcZCspPykvaSkgfHwgdmVyc2lvbklkZW50aWZpZXJcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoL2Nocm9tZXxjcmlvc3xjcm1vL2kudGVzdCh1YSkpIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgbmFtZTogJ0Nocm9tZSdcbiAgICAgICAgLCBjaHJvbWU6IHRcbiAgICAgICAgLCB2ZXJzaW9uOiBnZXRGaXJzdE1hdGNoKC8oPzpjaHJvbWV8Y3Jpb3N8Y3JtbylcXC8oXFxkKyhcXC5cXGQrKT8pL2kpXG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGFuZHJvaWQpIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgbmFtZTogJ0FuZHJvaWQnXG4gICAgICAgICwgdmVyc2lvbjogdmVyc2lvbklkZW50aWZpZXJcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoL3NhZmFyaXxhcHBsZXdlYmtpdC9pLnRlc3QodWEpKSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG5hbWU6ICdTYWZhcmknXG4gICAgICAsIHNhZmFyaTogdFxuICAgICAgfVxuICAgICAgaWYgKHZlcnNpb25JZGVudGlmaWVyKSB7XG4gICAgICAgIHJlc3VsdC52ZXJzaW9uID0gdmVyc2lvbklkZW50aWZpZXJcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoaW9zZGV2aWNlKSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG5hbWUgOiBpb3NkZXZpY2UgPT0gJ2lwaG9uZScgPyAnaVBob25lJyA6IGlvc2RldmljZSA9PSAnaXBhZCcgPyAnaVBhZCcgOiAnaVBvZCdcbiAgICAgIH1cbiAgICAgIC8vIFdURjogdmVyc2lvbiBpcyBub3QgcGFydCBvZiB1c2VyIGFnZW50IGluIHdlYiBhcHBzXG4gICAgICBpZiAodmVyc2lvbklkZW50aWZpZXIpIHtcbiAgICAgICAgcmVzdWx0LnZlcnNpb24gPSB2ZXJzaW9uSWRlbnRpZmllclxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmKC9nb29nbGVib3QvaS50ZXN0KHVhKSkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnR29vZ2xlYm90J1xuICAgICAgLCBnb29nbGVib3Q6IHRcbiAgICAgICwgdmVyc2lvbjogZ2V0Rmlyc3RNYXRjaCgvZ29vZ2xlYm90XFwvKFxcZCsoXFwuXFxkKykpL2kpIHx8IHZlcnNpb25JZGVudGlmaWVyXG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiBnZXRGaXJzdE1hdGNoKC9eKC4qKVxcLyguKikgLyksXG4gICAgICAgIHZlcnNpb246IGdldFNlY29uZE1hdGNoKC9eKC4qKVxcLyguKikgLylcbiAgICAgfTtcbiAgIH1cblxuICAgIC8vIHNldCB3ZWJraXQgb3IgZ2Vja28gZmxhZyBmb3IgYnJvd3NlcnMgYmFzZWQgb24gdGhlc2UgZW5naW5lc1xuICAgIGlmICghcmVzdWx0Lm1zZWRnZSAmJiAvKGFwcGxlKT93ZWJraXQvaS50ZXN0KHVhKSkge1xuICAgICAgaWYgKC8oYXBwbGUpP3dlYmtpdFxcLzUzN1xcLjM2L2kudGVzdCh1YSkpIHtcbiAgICAgICAgcmVzdWx0Lm5hbWUgPSByZXN1bHQubmFtZSB8fCBcIkJsaW5rXCJcbiAgICAgICAgcmVzdWx0LmJsaW5rID0gdFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0Lm5hbWUgPSByZXN1bHQubmFtZSB8fCBcIldlYmtpdFwiXG4gICAgICAgIHJlc3VsdC53ZWJraXQgPSB0XG4gICAgICB9XG4gICAgICBpZiAoIXJlc3VsdC52ZXJzaW9uICYmIHZlcnNpb25JZGVudGlmaWVyKSB7XG4gICAgICAgIHJlc3VsdC52ZXJzaW9uID0gdmVyc2lvbklkZW50aWZpZXJcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFyZXN1bHQub3BlcmEgJiYgL2dlY2tvXFwvL2kudGVzdCh1YSkpIHtcbiAgICAgIHJlc3VsdC5uYW1lID0gcmVzdWx0Lm5hbWUgfHwgXCJHZWNrb1wiXG4gICAgICByZXN1bHQuZ2Vja28gPSB0XG4gICAgICByZXN1bHQudmVyc2lvbiA9IHJlc3VsdC52ZXJzaW9uIHx8IGdldEZpcnN0TWF0Y2goL2dlY2tvXFwvKFxcZCsoXFwuXFxkKyk/KS9pKVxuICAgIH1cblxuICAgIC8vIHNldCBPUyBmbGFncyBmb3IgcGxhdGZvcm1zIHRoYXQgaGF2ZSBtdWx0aXBsZSBicm93c2Vyc1xuICAgIGlmICghcmVzdWx0LndpbmRvd3NwaG9uZSAmJiAoYW5kcm9pZCB8fCByZXN1bHQuc2lsaykpIHtcbiAgICAgIHJlc3VsdC5hbmRyb2lkID0gdFxuICAgICAgcmVzdWx0Lm9zbmFtZSA9ICdBbmRyb2lkJ1xuICAgIH0gZWxzZSBpZiAoIXJlc3VsdC53aW5kb3dzcGhvbmUgJiYgaW9zZGV2aWNlKSB7XG4gICAgICByZXN1bHRbaW9zZGV2aWNlXSA9IHRcbiAgICAgIHJlc3VsdC5pb3MgPSB0XG4gICAgICByZXN1bHQub3NuYW1lID0gJ2lPUydcbiAgICB9IGVsc2UgaWYgKG1hYykge1xuICAgICAgcmVzdWx0Lm1hYyA9IHRcbiAgICAgIHJlc3VsdC5vc25hbWUgPSAnbWFjT1MnXG4gICAgfSBlbHNlIGlmICh4Ym94KSB7XG4gICAgICByZXN1bHQueGJveCA9IHRcbiAgICAgIHJlc3VsdC5vc25hbWUgPSAnWGJveCdcbiAgICB9IGVsc2UgaWYgKHdpbmRvd3MpIHtcbiAgICAgIHJlc3VsdC53aW5kb3dzID0gdFxuICAgICAgcmVzdWx0Lm9zbmFtZSA9ICdXaW5kb3dzJ1xuICAgIH0gZWxzZSBpZiAobGludXgpIHtcbiAgICAgIHJlc3VsdC5saW51eCA9IHRcbiAgICAgIHJlc3VsdC5vc25hbWUgPSAnTGludXgnXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0V2luZG93c1ZlcnNpb24gKHMpIHtcbiAgICAgIHN3aXRjaCAocykge1xuICAgICAgICBjYXNlICdOVCc6IHJldHVybiAnTlQnXG4gICAgICAgIGNhc2UgJ1hQJzogcmV0dXJuICdYUCdcbiAgICAgICAgY2FzZSAnTlQgNS4wJzogcmV0dXJuICcyMDAwJ1xuICAgICAgICBjYXNlICdOVCA1LjEnOiByZXR1cm4gJ1hQJ1xuICAgICAgICBjYXNlICdOVCA1LjInOiByZXR1cm4gJzIwMDMnXG4gICAgICAgIGNhc2UgJ05UIDYuMCc6IHJldHVybiAnVmlzdGEnXG4gICAgICAgIGNhc2UgJ05UIDYuMSc6IHJldHVybiAnNydcbiAgICAgICAgY2FzZSAnTlQgNi4yJzogcmV0dXJuICc4J1xuICAgICAgICBjYXNlICdOVCA2LjMnOiByZXR1cm4gJzguMSdcbiAgICAgICAgY2FzZSAnTlQgMTAuMCc6IHJldHVybiAnMTAnXG4gICAgICAgIGRlZmF1bHQ6IHJldHVybiB1bmRlZmluZWRcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBPUyB2ZXJzaW9uIGV4dHJhY3Rpb25cbiAgICB2YXIgb3NWZXJzaW9uID0gJyc7XG4gICAgaWYgKHJlc3VsdC53aW5kb3dzKSB7XG4gICAgICBvc1ZlcnNpb24gPSBnZXRXaW5kb3dzVmVyc2lvbihnZXRGaXJzdE1hdGNoKC9XaW5kb3dzICgoTlR8WFApKCBcXGRcXGQ/LlxcZCk/KS9pKSlcbiAgICB9IGVsc2UgaWYgKHJlc3VsdC53aW5kb3dzcGhvbmUpIHtcbiAgICAgIG9zVmVyc2lvbiA9IGdldEZpcnN0TWF0Y2goL3dpbmRvd3MgcGhvbmUgKD86b3MpP1xccz8oXFxkKyhcXC5cXGQrKSopL2kpO1xuICAgIH0gZWxzZSBpZiAocmVzdWx0Lm1hYykge1xuICAgICAgb3NWZXJzaW9uID0gZ2V0Rmlyc3RNYXRjaCgvTWFjIE9TIFggKFxcZCsoW19cXC5cXHNdXFxkKykqKS9pKTtcbiAgICAgIG9zVmVyc2lvbiA9IG9zVmVyc2lvbi5yZXBsYWNlKC9bX1xcc10vZywgJy4nKTtcbiAgICB9IGVsc2UgaWYgKGlvc2RldmljZSkge1xuICAgICAgb3NWZXJzaW9uID0gZ2V0Rmlyc3RNYXRjaCgvb3MgKFxcZCsoW19cXHNdXFxkKykqKSBsaWtlIG1hYyBvcyB4L2kpO1xuICAgICAgb3NWZXJzaW9uID0gb3NWZXJzaW9uLnJlcGxhY2UoL1tfXFxzXS9nLCAnLicpO1xuICAgIH0gZWxzZSBpZiAoYW5kcm9pZCkge1xuICAgICAgb3NWZXJzaW9uID0gZ2V0Rmlyc3RNYXRjaCgvYW5kcm9pZFsgXFwvLV0oXFxkKyhcXC5cXGQrKSopL2kpO1xuICAgIH0gZWxzZSBpZiAocmVzdWx0LndlYm9zKSB7XG4gICAgICBvc1ZlcnNpb24gPSBnZXRGaXJzdE1hdGNoKC8oPzp3ZWJ8aHB3KW9zXFwvKFxcZCsoXFwuXFxkKykqKS9pKTtcbiAgICB9IGVsc2UgaWYgKHJlc3VsdC5ibGFja2JlcnJ5KSB7XG4gICAgICBvc1ZlcnNpb24gPSBnZXRGaXJzdE1hdGNoKC9yaW1cXHN0YWJsZXRcXHNvc1xccyhcXGQrKFxcLlxcZCspKikvaSk7XG4gICAgfSBlbHNlIGlmIChyZXN1bHQuYmFkYSkge1xuICAgICAgb3NWZXJzaW9uID0gZ2V0Rmlyc3RNYXRjaCgvYmFkYVxcLyhcXGQrKFxcLlxcZCspKikvaSk7XG4gICAgfSBlbHNlIGlmIChyZXN1bHQudGl6ZW4pIHtcbiAgICAgIG9zVmVyc2lvbiA9IGdldEZpcnN0TWF0Y2goL3RpemVuW1xcL1xcc10oXFxkKyhcXC5cXGQrKSopL2kpO1xuICAgIH1cbiAgICBpZiAob3NWZXJzaW9uKSB7XG4gICAgICByZXN1bHQub3N2ZXJzaW9uID0gb3NWZXJzaW9uO1xuICAgIH1cblxuICAgIC8vIGRldmljZSB0eXBlIGV4dHJhY3Rpb25cbiAgICB2YXIgb3NNYWpvclZlcnNpb24gPSAhcmVzdWx0LndpbmRvd3MgJiYgb3NWZXJzaW9uLnNwbGl0KCcuJylbMF07XG4gICAgaWYgKFxuICAgICAgICAgdGFibGV0XG4gICAgICB8fCBuZXh1c1RhYmxldFxuICAgICAgfHwgaW9zZGV2aWNlID09ICdpcGFkJ1xuICAgICAgfHwgKGFuZHJvaWQgJiYgKG9zTWFqb3JWZXJzaW9uID09IDMgfHwgKG9zTWFqb3JWZXJzaW9uID49IDQgJiYgIW1vYmlsZSkpKVxuICAgICAgfHwgcmVzdWx0LnNpbGtcbiAgICApIHtcbiAgICAgIHJlc3VsdC50YWJsZXQgPSB0XG4gICAgfSBlbHNlIGlmIChcbiAgICAgICAgIG1vYmlsZVxuICAgICAgfHwgaW9zZGV2aWNlID09ICdpcGhvbmUnXG4gICAgICB8fCBpb3NkZXZpY2UgPT0gJ2lwb2QnXG4gICAgICB8fCBhbmRyb2lkXG4gICAgICB8fCBuZXh1c01vYmlsZVxuICAgICAgfHwgcmVzdWx0LmJsYWNrYmVycnlcbiAgICAgIHx8IHJlc3VsdC53ZWJvc1xuICAgICAgfHwgcmVzdWx0LmJhZGFcbiAgICApIHtcbiAgICAgIHJlc3VsdC5tb2JpbGUgPSB0XG4gICAgfVxuXG4gICAgLy8gR3JhZGVkIEJyb3dzZXIgU3VwcG9ydFxuICAgIC8vIGh0dHA6Ly9kZXZlbG9wZXIueWFob28uY29tL3l1aS9hcnRpY2xlcy9nYnNcbiAgICBpZiAocmVzdWx0Lm1zZWRnZSB8fFxuICAgICAgICAocmVzdWx0Lm1zaWUgJiYgcmVzdWx0LnZlcnNpb24gPj0gMTApIHx8XG4gICAgICAgIChyZXN1bHQueWFuZGV4YnJvd3NlciAmJiByZXN1bHQudmVyc2lvbiA+PSAxNSkgfHxcblx0XHQgICAgKHJlc3VsdC52aXZhbGRpICYmIHJlc3VsdC52ZXJzaW9uID49IDEuMCkgfHxcbiAgICAgICAgKHJlc3VsdC5jaHJvbWUgJiYgcmVzdWx0LnZlcnNpb24gPj0gMjApIHx8XG4gICAgICAgIChyZXN1bHQuc2Ftc3VuZ0Jyb3dzZXIgJiYgcmVzdWx0LnZlcnNpb24gPj0gNCkgfHxcbiAgICAgICAgKHJlc3VsdC53aGFsZSAmJiBjb21wYXJlVmVyc2lvbnMoW3Jlc3VsdC52ZXJzaW9uLCAnMS4wJ10pID09PSAxKSB8fFxuICAgICAgICAocmVzdWx0Lm16YnJvd3NlciAmJiBjb21wYXJlVmVyc2lvbnMoW3Jlc3VsdC52ZXJzaW9uLCAnNi4wJ10pID09PSAxKSB8fFxuICAgICAgICAocmVzdWx0LmZvY3VzICYmIGNvbXBhcmVWZXJzaW9ucyhbcmVzdWx0LnZlcnNpb24sICcxLjAnXSkgPT09IDEpIHx8XG4gICAgICAgIChyZXN1bHQuZmlyZWZveCAmJiByZXN1bHQudmVyc2lvbiA+PSAyMC4wKSB8fFxuICAgICAgICAocmVzdWx0LnNhZmFyaSAmJiByZXN1bHQudmVyc2lvbiA+PSA2KSB8fFxuICAgICAgICAocmVzdWx0Lm9wZXJhICYmIHJlc3VsdC52ZXJzaW9uID49IDEwLjApIHx8XG4gICAgICAgIChyZXN1bHQuaW9zICYmIHJlc3VsdC5vc3ZlcnNpb24gJiYgcmVzdWx0Lm9zdmVyc2lvbi5zcGxpdChcIi5cIilbMF0gPj0gNikgfHxcbiAgICAgICAgKHJlc3VsdC5ibGFja2JlcnJ5ICYmIHJlc3VsdC52ZXJzaW9uID49IDEwLjEpXG4gICAgICAgIHx8IChyZXN1bHQuY2hyb21pdW0gJiYgcmVzdWx0LnZlcnNpb24gPj0gMjApXG4gICAgICAgICkge1xuICAgICAgcmVzdWx0LmEgPSB0O1xuICAgIH1cbiAgICBlbHNlIGlmICgocmVzdWx0Lm1zaWUgJiYgcmVzdWx0LnZlcnNpb24gPCAxMCkgfHxcbiAgICAgICAgKHJlc3VsdC5jaHJvbWUgJiYgcmVzdWx0LnZlcnNpb24gPCAyMCkgfHxcbiAgICAgICAgKHJlc3VsdC5maXJlZm94ICYmIHJlc3VsdC52ZXJzaW9uIDwgMjAuMCkgfHxcbiAgICAgICAgKHJlc3VsdC5zYWZhcmkgJiYgcmVzdWx0LnZlcnNpb24gPCA2KSB8fFxuICAgICAgICAocmVzdWx0Lm9wZXJhICYmIHJlc3VsdC52ZXJzaW9uIDwgMTAuMCkgfHxcbiAgICAgICAgKHJlc3VsdC5pb3MgJiYgcmVzdWx0Lm9zdmVyc2lvbiAmJiByZXN1bHQub3N2ZXJzaW9uLnNwbGl0KFwiLlwiKVswXSA8IDYpXG4gICAgICAgIHx8IChyZXN1bHQuY2hyb21pdW0gJiYgcmVzdWx0LnZlcnNpb24gPCAyMClcbiAgICAgICAgKSB7XG4gICAgICByZXN1bHQuYyA9IHRcbiAgICB9IGVsc2UgcmVzdWx0LnggPSB0XG5cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICB2YXIgYm93c2VyID0gZGV0ZWN0KHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnID8gbmF2aWdhdG9yLnVzZXJBZ2VudCB8fCAnJyA6ICcnKVxuXG4gIGJvd3Nlci50ZXN0ID0gZnVuY3Rpb24gKGJyb3dzZXJMaXN0KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBicm93c2VyTGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGJyb3dzZXJJdGVtID0gYnJvd3Nlckxpc3RbaV07XG4gICAgICBpZiAodHlwZW9mIGJyb3dzZXJJdGVtPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmIChicm93c2VySXRlbSBpbiBib3dzZXIpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHZlcnNpb24gcHJlY2lzaW9ucyBjb3VudFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAgIGdldFZlcnNpb25QcmVjaXNpb24oXCIxLjEwLjNcIikgLy8gM1xuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHZlcnNpb25cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0VmVyc2lvblByZWNpc2lvbih2ZXJzaW9uKSB7XG4gICAgcmV0dXJuIHZlcnNpb24uc3BsaXQoXCIuXCIpLmxlbmd0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBcnJheTo6bWFwIHBvbHlmaWxsXG4gICAqXG4gICAqIEBwYXJhbSAge0FycmF5fSBhcnJcbiAgICogQHBhcmFtICB7RnVuY3Rpb259IGl0ZXJhdG9yXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgZnVuY3Rpb24gbWFwKGFyciwgaXRlcmF0b3IpIHtcbiAgICB2YXIgcmVzdWx0ID0gW10sIGk7XG4gICAgaWYgKEFycmF5LnByb3RvdHlwZS5tYXApIHtcbiAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUubWFwLmNhbGwoYXJyLCBpdGVyYXRvcik7XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc3VsdC5wdXNoKGl0ZXJhdG9yKGFycltpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSBicm93c2VyIHZlcnNpb24gd2VpZ2h0XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqICAgY29tcGFyZVZlcnNpb25zKFsnMS4xMC4yLjEnLCAgJzEuOC4yLjEuOTAnXSkgICAgLy8gMVxuICAgKiAgIGNvbXBhcmVWZXJzaW9ucyhbJzEuMDEwLjIuMScsICcxLjA5LjIuMS45MCddKTsgIC8vIDFcbiAgICogICBjb21wYXJlVmVyc2lvbnMoWycxLjEwLjIuMScsICAnMS4xMC4yLjEnXSk7ICAgICAvLyAwXG4gICAqICAgY29tcGFyZVZlcnNpb25zKFsnMS4xMC4yLjEnLCAgJzEuMDgwMC4yJ10pOyAgICAgLy8gLTFcbiAgICpcbiAgICogQHBhcmFtICB7QXJyYXk8U3RyaW5nPn0gdmVyc2lvbnMgdmVyc2lvbnMgdG8gY29tcGFyZVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGNvbXBhcmlzb24gcmVzdWx0XG4gICAqL1xuICBmdW5jdGlvbiBjb21wYXJlVmVyc2lvbnModmVyc2lvbnMpIHtcbiAgICAvLyAxKSBnZXQgY29tbW9uIHByZWNpc2lvbiBmb3IgYm90aCB2ZXJzaW9ucywgZm9yIGV4YW1wbGUgZm9yIFwiMTAuMFwiIGFuZCBcIjlcIiBpdCBzaG91bGQgYmUgMlxuICAgIHZhciBwcmVjaXNpb24gPSBNYXRoLm1heChnZXRWZXJzaW9uUHJlY2lzaW9uKHZlcnNpb25zWzBdKSwgZ2V0VmVyc2lvblByZWNpc2lvbih2ZXJzaW9uc1sxXSkpO1xuICAgIHZhciBjaHVua3MgPSBtYXAodmVyc2lvbnMsIGZ1bmN0aW9uICh2ZXJzaW9uKSB7XG4gICAgICB2YXIgZGVsdGEgPSBwcmVjaXNpb24gLSBnZXRWZXJzaW9uUHJlY2lzaW9uKHZlcnNpb24pO1xuXG4gICAgICAvLyAyKSBcIjlcIiAtPiBcIjkuMFwiIChmb3IgcHJlY2lzaW9uID0gMilcbiAgICAgIHZlcnNpb24gPSB2ZXJzaW9uICsgbmV3IEFycmF5KGRlbHRhICsgMSkuam9pbihcIi4wXCIpO1xuXG4gICAgICAvLyAzKSBcIjkuMFwiIC0+IFtcIjAwMDAwMDAwMFwiXCIsIFwiMDAwMDAwMDA5XCJdXG4gICAgICByZXR1cm4gbWFwKHZlcnNpb24uc3BsaXQoXCIuXCIpLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBcnJheSgyMCAtIGNodW5rLmxlbmd0aCkuam9pbihcIjBcIikgKyBjaHVuaztcbiAgICAgIH0pLnJldmVyc2UoKTtcbiAgICB9KTtcblxuICAgIC8vIGl0ZXJhdGUgaW4gcmV2ZXJzZSBvcmRlciBieSByZXZlcnNlZCBjaHVua3MgYXJyYXlcbiAgICB3aGlsZSAoLS1wcmVjaXNpb24gPj0gMCkge1xuICAgICAgLy8gNCkgY29tcGFyZTogXCIwMDAwMDAwMDlcIiA+IFwiMDAwMDAwMDEwXCIgPSBmYWxzZSAoYnV0IFwiOVwiID4gXCIxMFwiID0gdHJ1ZSlcbiAgICAgIGlmIChjaHVua3NbMF1bcHJlY2lzaW9uXSA+IGNodW5rc1sxXVtwcmVjaXNpb25dKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoY2h1bmtzWzBdW3ByZWNpc2lvbl0gPT09IGNodW5rc1sxXVtwcmVjaXNpb25dKSB7XG4gICAgICAgIGlmIChwcmVjaXNpb24gPT09IDApIHtcbiAgICAgICAgICAvLyBhbGwgdmVyc2lvbiBjaHVua3MgYXJlIHNhbWVcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYnJvd3NlciBpcyB1bnN1cHBvcnRlZFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAgIGJvd3Nlci5pc1Vuc3VwcG9ydGVkQnJvd3Nlcih7XG4gICAqICAgICBtc2llOiBcIjEwXCIsXG4gICAqICAgICBmaXJlZm94OiBcIjIzXCIsXG4gICAqICAgICBjaHJvbWU6IFwiMjlcIixcbiAgICogICAgIHNhZmFyaTogXCI1LjFcIixcbiAgICogICAgIG9wZXJhOiBcIjE2XCIsXG4gICAqICAgICBwaGFudG9tOiBcIjUzNFwiXG4gICAqICAgfSk7XG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gIG1pblZlcnNpb25zIG1hcCBvZiBtaW5pbWFsIHZlcnNpb24gdG8gYnJvd3NlclxuICAgKiBAcGFyYW0gIHtCb29sZWFufSBbc3RyaWN0TW9kZSA9IGZhbHNlXSBmbGFnIHRvIHJldHVybiBmYWxzZSBpZiBicm93c2VyIHdhc24ndCBmb3VuZCBpbiBtYXBcbiAgICogQHBhcmFtICB7U3RyaW5nfSAgW3VhXSB1c2VyIGFnZW50IHN0cmluZ1xuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgZnVuY3Rpb24gaXNVbnN1cHBvcnRlZEJyb3dzZXIobWluVmVyc2lvbnMsIHN0cmljdE1vZGUsIHVhKSB7XG4gICAgdmFyIF9ib3dzZXIgPSBib3dzZXI7XG5cbiAgICAvLyBtYWtlIHN0cmljdE1vZGUgcGFyYW0gb3B0aW9uYWwgd2l0aCB1YSBwYXJhbSB1c2FnZVxuICAgIGlmICh0eXBlb2Ygc3RyaWN0TW9kZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHVhID0gc3RyaWN0TW9kZTtcbiAgICAgIHN0cmljdE1vZGUgPSB2b2lkKDApO1xuICAgIH1cblxuICAgIGlmIChzdHJpY3RNb2RlID09PSB2b2lkKDApKSB7XG4gICAgICBzdHJpY3RNb2RlID0gZmFsc2U7XG4gICAgfVxuICAgIGlmICh1YSkge1xuICAgICAgX2Jvd3NlciA9IGRldGVjdCh1YSk7XG4gICAgfVxuXG4gICAgdmFyIHZlcnNpb24gPSBcIlwiICsgX2Jvd3Nlci52ZXJzaW9uO1xuICAgIGZvciAodmFyIGJyb3dzZXIgaW4gbWluVmVyc2lvbnMpIHtcbiAgICAgIGlmIChtaW5WZXJzaW9ucy5oYXNPd25Qcm9wZXJ0eShicm93c2VyKSkge1xuICAgICAgICBpZiAoX2Jvd3Nlclticm93c2VyXSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgbWluVmVyc2lvbnNbYnJvd3Nlcl0gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Jyb3dzZXIgdmVyc2lvbiBpbiB0aGUgbWluVmVyc2lvbiBtYXAgc2hvdWxkIGJlIGEgc3RyaW5nOiAnICsgYnJvd3NlciArICc6ICcgKyBTdHJpbmcobWluVmVyc2lvbnMpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBicm93c2VyIHZlcnNpb24gYW5kIG1pbiBzdXBwb3J0ZWQgdmVyc2lvbi5cbiAgICAgICAgICByZXR1cm4gY29tcGFyZVZlcnNpb25zKFt2ZXJzaW9uLCBtaW5WZXJzaW9uc1ticm93c2VyXV0pIDwgMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdHJpY3RNb2RlOyAvLyBub3QgZm91bmRcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBicm93c2VyIGlzIHN1cHBvcnRlZFxuICAgKlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG1pblZlcnNpb25zIG1hcCBvZiBtaW5pbWFsIHZlcnNpb24gdG8gYnJvd3NlclxuICAgKiBAcGFyYW0gIHtCb29sZWFufSBbc3RyaWN0TW9kZSA9IGZhbHNlXSBmbGFnIHRvIHJldHVybiBmYWxzZSBpZiBicm93c2VyIHdhc24ndCBmb3VuZCBpbiBtYXBcbiAgICogQHBhcmFtICB7U3RyaW5nfSAgW3VhXSB1c2VyIGFnZW50IHN0cmluZ1xuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgZnVuY3Rpb24gY2hlY2sobWluVmVyc2lvbnMsIHN0cmljdE1vZGUsIHVhKSB7XG4gICAgcmV0dXJuICFpc1Vuc3VwcG9ydGVkQnJvd3NlcihtaW5WZXJzaW9ucywgc3RyaWN0TW9kZSwgdWEpO1xuICB9XG5cbiAgYm93c2VyLmlzVW5zdXBwb3J0ZWRCcm93c2VyID0gaXNVbnN1cHBvcnRlZEJyb3dzZXI7XG4gIGJvd3Nlci5jb21wYXJlVmVyc2lvbnMgPSBjb21wYXJlVmVyc2lvbnM7XG4gIGJvd3Nlci5jaGVjayA9IGNoZWNrO1xuXG4gIC8qXG4gICAqIFNldCBvdXIgZGV0ZWN0IG1ldGhvZCB0byB0aGUgbWFpbiBib3dzZXIgb2JqZWN0IHNvIHdlIGNhblxuICAgKiByZXVzZSBpdCB0byB0ZXN0IG90aGVyIHVzZXIgYWdlbnRzLlxuICAgKiBUaGlzIGlzIG5lZWRlZCB0byBpbXBsZW1lbnQgZnV0dXJlIHRlc3RzLlxuICAgKi9cbiAgYm93c2VyLl9kZXRlY3QgPSBkZXRlY3Q7XG5cbiAgLypcbiAgICogU2V0IG91ciBkZXRlY3QgcHVibGljIG1ldGhvZCB0byB0aGUgbWFpbiBib3dzZXIgb2JqZWN0XG4gICAqIFRoaXMgaXMgbmVlZGVkIHRvIGltcGxlbWVudCBib3dzZXIgaW4gc2VydmVyIHNpZGVcbiAgICovXG4gIGJvd3Nlci5kZXRlY3QgPSBkZXRlY3Q7XG4gIHJldHVybiBib3dzZXJcbn0pO1xuIiwidmFyIEhlbHBlcnMgPSByZXF1aXJlKCcuL2hlbHBlcnMnKVxudmFyIEFwcCA9IHJlcXVpcmUoJy4vYXBwJyk7XG52YXIgcG9seWZpbGxzID0gcmVxdWlyZSgnLi9wb2x5ZmlsbHMnKTtcblxucG9seWZpbGxzLmFwcGx5UG9seWZpbGxzKCk7XG5cbnZhciBpbnN0YW5jZTtcblxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBnZXRJbnN0YW5jZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFpbnN0YW5jZSkge1xuICAgICAgICAgICAgaW5zdGFuY2UgPSBuZXcgQXBwKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH07XG5cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihIZWxwZXJzLnppcE9iamVjdChbJ2luaXQnLCAnb3BlbicsICdvbicsICdvZmYnLCAnc2VuZE1lc3NhZ2UnLCAnb25NZXNzYWdlJ10ubWFwKGZ1bmN0aW9uIChtZXRob2ROYW1lKSB7XG4gICAgICAgIHZhciBhcHAgPSBnZXRJbnN0YW5jZSgpO1xuICAgICAgICByZXR1cm4gW21ldGhvZE5hbWUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBhcHBbbWV0aG9kTmFtZV0uYXBwbHkoYXBwLCBhcmd1bWVudHMpO1xuICAgICAgICB9XTtcbiAgICB9KSksIHtcbiAgICAgICAgZXZlbnRUeXBlczogQXBwLmV2ZW50VHlwZXMsXG4gICAgfSk7XG59KSgpO1xuIl19

// SawHammerEntity.js
var SawHammerEntity = pc.createScript('sawHammerEntity');

SawHammerEntity.attributes.add('curve', { type: 'curve' });

pc.extend(SawHammerEntity.prototype, {
    initialize: function() {
        this.currentZoom = 0;
    },

    update: function() {
        if (!GardenCamera.instance) {
            return;
        }
        const currentZoom = GardenCamera.instance.currentZoom;

        if (currentZoom !== this.currentZoom) {
            this.currentZoom = currentZoom;

            this.updateScale();
        }
    },

    updateScale: function() {   
        const value = this.curve.value(this.currentZoom / 10);

        this.entity.setLocalScale(value, value, value);
    },
});


// LifeInterface.js
var LifeInterface = pc.createScript('lifeInterface');

LifeInterface.attributes.add('amount', { type: 'entity' });
LifeInterface.attributes.add('timer', { type: 'entity' });
LifeInterface.attributes.add('plus', { type: 'entity' });

pc.extend(LifeInterface.prototype, {
    initialize: function() {
        this.timerText = '';

        this.entity.script.elementInput.on('click', this.onClick, this);

        this.on('enable', this.onEnable, this);
        this.on('disable', this.onDisable, this);
        LivesManager.instance.on('regenerated', this.onEnable, this);
    },

    postInitialize: function() {
        this.onEnable();    
    },

    onClick: function() {
        this.app.fire('UIManager:showUI', 'FloatingUI');
        this.app.fire('UIManager:showUI', 'NoMoreLivesScreen');
    },

    onDisable: function() {
        LivesManager.instance.off('regenerated', this.onEnable, this);
    },
    
    onEnable: function() {
        this.amount.element.text = LivesManager.instance.getLives();

        this.maxLives = LivesManager.instance.hasMaxLives();
        this.entity.element.useInput = !this.maxLives;
        this.plus.enabled = !this.maxLives;

        this.timer.element.key = this.maxLives ? 'LIVES_FULL' : this.getTimerText();
    },

    update: function() {
        if (this.maxLives) {
            return;
        }

        const timerText = this.getTimerText();

        if (timerText !== this.timerText) {
            this.timer.element.key = timerText;
        }
    },

    getTimerText: function() {
        return pc.utils.millisecondsToTimeFormat(LivesManager.instance.timeTillRegeneration * 1000);
    },
});


// FakeChapterInformationBar.js
var FakeChapterInformationBar = pc.createScript('fakeChapterInformationBar');

FakeChapterInformationBar.attributes.add('currentStarsTextEntity', { type: 'entity' });
FakeChapterInformationBar.attributes.add('totalStarsTextEntity', { type: 'entity' });
FakeChapterInformationBar.attributes.add('currentPartsTextEntity', { type: 'entity' });
FakeChapterInformationBar.attributes.add('totalPartsTextEntity', { type: 'entity' });
FakeChapterInformationBar.attributes.add('statsGroupEntity', { type: 'entity' });
FakeChapterInformationBar.attributes.add('partImageEntity', { type: 'entity' });
FakeChapterInformationBar.attributes.add('starImageEntity', { type: 'entity' });

pc.extend(FakeChapterInformationBar.prototype, {
    initialize: function () {
        this._coloredStarScript = this.starImageEntity.script.coloredStar;

        this.app.on('FakeChapterInformationBar:updateStats', this._updateStats, this);
        this.app.on('BookUI:switchPage', this._onPageSwitch, this);
    },

    _updateStats: function (currentStars, totalStars, currentParts, totalParts, worldID) {
        this.currentStarsTextEntity.element.text = currentStars;
        this.totalStarsTextEntity.element.text = totalStars;

        this.currentPartsTextEntity.element.text = currentParts;
        this.totalPartsTextEntity.element.text = totalParts;

        var partSprite = WorldManager.instance.getPartAssets(worldID).partSprite.id;
        this.partImageEntity.element.spriteAsset = partSprite;

        this._coloredStarScript.setStarBasedOnWorldIndex(worldID);
    },

    _onPageSwitch: function (pageIndex, totalPages, pageData) {
        this.statsGroupEntity.enabled = !isNaN(pageData.pageInfo.chapterID);
    }
});

// UniqueCharacterUI.js
var UniqueCharacterUi = pc.createScript('uniqueCharacterUi');

UniqueCharacterUi.attributes.add('id', { type: 'string', default: 'Lucy' });
UniqueCharacterUi.attributes.add('other', { type: 'entity', array: true });

pc.extend(UniqueCharacterUi.prototype, {
    initialize: function() {
        this._test = Math.random() * 39434
        this.onState(true);

        this.on('state', this.onState, this);
    },

    onState: function(enabled) {
        if (enabled) {
            if (this.ignoreEnable) {
                this.ignoreEnable = false;
                return;
            }
            UniqueCharacterManager.instance.addCharacter(this);
        } else {
            if (this.ignoreDisable) {
                this.ignoreDisable = false;
                return;
            }
            UniqueCharacterManager.instance.removeCharacter(this);
        }
    },

    enable: function() {
        this.ignoreEnable = true;
        this.enableEntity(this.entity);

        this.other.forEach(entity => this.enableEntity(entity));
    },

    disable: function() {
        this.ignoreDisable = true;
        this.disableEntity(this.entity);

        this.other.forEach(entity => this.disableEntity(entity));
    },

    enableEntity: function(entity) {
        entity.enabled = true;

        if (entity.script && entity.script.MoveUITween) {
            entity.script.MoveUITween.doOpenAnimation();
        }
    },

    disableEntity: function(entity) {
        if (entity.script && entity.script.MoveUITween) {
            entity.script.MoveUITween.doCloseAnimation().then(() => {
                entity.enabled = false;
            });
        } else {
            entity.enabled = false;
        }
    },
});


// UniqueCharacterManager.js
var UniqueCharacterManager = pc.createScript('uniqueCharacterManager');

pc.extend(UniqueCharacterManager.prototype, {
    initialize: function() {
        UniqueCharacterManager.instance = this;

        this.visibleCharacters = {};

        this.characters = {};
    },

    addCharacter: function(script) {
        const id = script.id;
        const entity = script.entity;

        if (!Array.isArray(this.characters[id])) {
            this.characters[id] = [];
        }

        const array = this.characters[id];

        if (!this.doesItExist(script)) {
            array.push(script);
        } else {
            console.warn("Already in the list");
            return;
        }

        const currentCharacter = this.visibleCharacters[id];

        if (currentCharacter) {
            currentCharacter.disable();
        }

        this.visibleCharacters[id] = script;
    },

    removeCharacter: function(script) {
        const id = script.id;

        if (!Array.isArray(this.characters[id])) {
            this.characters[id] = [];
        }

        const array = this.characters[id];

        if (!this.doesItExist(script)) {
            console.warn("Not in the list", array);
        } else {
            const index = array.indexOf(script);

            array.splice(index, 1); 
        }

        const previousCharacter = array[array.length - 1];

        if (previousCharacter) {
            previousCharacter.enable();
            this.visibleCharacters[id] = previousCharacter;
        } else {
            delete this.visibleCharacters[id];
        }

    },

    doesItExist: function(script) {
        return this.characters[script.id].includes(script);
    },
});


// BuyItem.js
var BuyItem = pc.createScript('buyItem');

BuyItem.TYPES = Object.freeze({
    BUNDLE: 'bundle',
    VIRTUAL_CURRENCY_PACKAGE: 'virtualCurrency',
});

BuyItem.TYPES_ENUM = Object.freeze([
    { BUNDLE: 'bundle' },
    { VIRTUAL_CURRENCY_PACKAGE: 'virtualCurrency' },
]);

BuyItem.attributes.add('key', { type: 'string' });
BuyItem.attributes.add('titleKey', { type: 'string' });
BuyItem.attributes.add('price', { type: 'number' });
BuyItem.attributes.add('button', { type: 'entity' });
BuyItem.attributes.add('titleEntity', { type: 'entity' });
BuyItem.attributes.add('priceText', { type: 'entity' });
BuyItem.attributes.add('coinsText', { type: 'entity' });
BuyItem.attributes.add('type', { type: 'string', enum: BuyItem.TYPES_ENUM, default: BuyItem.TYPES.BUNDLE });
BuyItem.attributes.add('rewardEntities', { type: 'entity', array: true });
BuyItem.attributes.add('coinTemplate', { type: 'asset', assetType: 'template' });
BuyItem.attributes.add('boosterTemplate', { type: 'asset', assetType: 'template' });

BuyItem.attributes.add('coinSpawn', { type: 'entity' });
BuyItem.attributes.add('coinAnimGroup', { type: 'entity' });
BuyItem.attributes.add('endPoint', { type: 'entity' });

BuyItem.attributes.add('rewardLayoutEntity', { type: 'entity' });

BuyItem.attributes.add('priceContainer', { type: 'entity' });
BuyItem.attributes.add('adContainer', { type: 'entity' });
BuyItem.attributes.add('adsRequired', { type: 'number', default: 1 });

BuyItem.attributes.add('adsStringEntity', { type: 'entity' })

BuyItem.attributes.add('coinsReward', {
    type: 'json', schema: [
        {
            name: 'key',
            type: 'string',
        },
        {
            name: 'quantity',
            type: 'number',
            default: 1
        },
    ]
});
BuyItem.attributes.add('boosterReward', {
    type: 'json', array: true, schema: [
        {
            name: 'key',
            type: 'string',
        },
        {
            name: 'quantity',
            type: 'number',
            default: 1
        },
    ]
});

pc.extend(BuyItem.prototype, {
    initialize: function () {
        this.isAd = !window.famobi.hasFeature('payment');

        if (this.isAd) {
            this.setupAdData();
        }

        this.priceContainer.enabled = !this.isAd;
        this.adContainer.enabled = this.isAd;

        // this.button.script.elementInput.on('click', this._onClick, this);
        this.button.element.on('click', this._onClick, this);
        this.setLayout();

        this.on('enable', this.setLayout, this);
    },

    setupAdData() {
        this.shopData = Wrapper.instance.getLocalStorageItem('shop');

        if (this.shopData[this.key]) {
            if (typeof this.shopData[this.key].adsWatched !== 'number') {
                this.shopData[this.key].adsWatched = 0;
            }
        } else {
            this.shopData[this.key] = {
                adsWatched: 0
            };
        }

        this.setAdsAmount();
    },

    _onClick: function (event, forced) {
        if (this.isAd) {
            this._onClickAd();
            return;
        }

        if (!firebaseClass.loggedIn() && Wrapper.instance.hasFeature('login') && !forced) {
            this.app.fire('UIManager:showUI', 'IAPWarning', this);
            return;
        }

        GameManager.instance.trackCustomEvent('shop', 'package_clicked', { sku: this.key });

        var promise = Xsolla.instance.buyItem(this.key);

        if (promise) {
            Xsolla.instance.once('bought', this.giveReward, this);

            promise.then((bought) => {
                if (bought) {
                    // this.showRewardAnimation();
                } else {
                    console.log("cancelled");
                }
            }).catch((e) => {
                this.onError(e);
            }).finally(() => {
                Xsolla.instance.busy = false;
                Xsolla.instance.off('bought', this.giveReward, this);
            });
        } else {
            this.onError();
        }
    },

    _onClickAd() {
        Wrapper.instance.rewardedAd(this.onAdReward, this);
    },

    setAdsAmount() {
        this.adsStringEntity.element.text = this.adsRequired - this.shopData[this.key].adsWatched;
    },

    onAdReward(result) {
        if (result.rewardGranted) {
            this.shopData[this.key].adsWatched += 1;

            Wrapper.instance.sendGAEvent(Wrapper.GA_EVENT_TYPE.DESIGN, {
                eventId: `packageProgress:${this.key}:attempt`,
                value: this.shopData[this.key].adsWatched,
            });

            if (this.shopData[this.key].adsWatched >= this.adsRequired) {
                Inventory.instance.addItem(this.coinsReward.key, this.coinsReward.quantity, 'reward', 'rewardedAd');
                this.boosterReward.forEach(reward => Inventory.instance.addItem(reward.key, reward.quantity, 'reward', 'rewardedAd'));
                this.shopData[this.key].adsWatched = 0;
                this.showRewardAnimation()
                Wrapper.instance.sendGAEvent(Wrapper.GA_EVENT_TYPE.DESIGN, {
                    eventId: `packageSold:${this.key}:rewardedAd`,
                });
            }

            this.setAdsAmount();
            Wrapper.instance.setLocalStorageItem('shop', this.shopData);
        }
    },

    giveReward: function (paymentInfo) {
        // TODO check paymentInfo
        const invoiceID = paymentInfo.paymentInfo.invoice;

        if (Inventory.instance.hasInvoice(paymentInfo.paymentInfo.invoice)) {
            console.log("already received");
            return;
        }

        firebaseClass.addInvoice();
        Inventory.instance.addInvoice({ id: invoiceID, sku: this.key });
        Inventory.instance.addItem(this.coinsReward.key, this.coinsReward.quantity, 'purchase', this.key);
        this.boosterReward.forEach(reward => Inventory.instance.addItem(reward.key, reward.quantity, 'purchase', this.key));

        this.app.fire('UIManager:showUI', 'IAPSuccess', this.createReward());

        UIManager.instance.getScreen('IAPSuccess').script.uiEntity.once('closed', this.showRewardAnimation, this);
    },

    createReward: function () {
        return { coinsReward: this.coinsReward, boosterReward: this.boosterReward };
    },

    showRewardAnimation: function () {
        this.createNewCoins(10, this.coinsReward.quantity / 10, 1);
    },

    createNewCoins(amount, coinPerXAmount, time) {
        this.endPosition = this.endPoint.getLocalPosition();

        let index = 0;

        for (; index < amount; index++) {
            var coin = this.coinTemplate.resource.instantiate();
            coin.enabled = true;
            coin.reparent(this.coinAnimGroup);
            coin.setPosition(this.coinSpawn.getPosition());
            coin.script.coinAnimation.playAnimation(this.endPosition, amount, coinPerXAmount, time, index);
        }

        this.boosterReward.forEach(reward => {
            var booster = this.boosterTemplate.resource.instantiate();
            booster.enabled = true;
            booster.reparent(this.coinAnimGroup);
            booster.setPosition(this.coinSpawn.getPosition());
            booster.script.boosterAnimation.setSprite(Inventory.instance.getItemSprite(reward.key));
            booster.script.boosterAnimation.playAnimation(this.endPosition, 1, 0, time, index);
            index++;
        });
    },

    setLayout: function () {
        this.coinsText.element.text = this.coinsReward.quantity;
        this.titleEntity.element.key = this.titleKey;

        const itemValue = Xsolla.instance.getItemValue(this.key, this.type);

        if (itemValue) {
            this.priceText.element.text = LocalizationManager.instance.priceToText(itemValue.price.amount, itemValue.price.currency);
        } else {
            // Default
            this.priceText.element.text = `${this.price}`;
        }

        this.rewardEntities.forEach((entity, i) => {
            const reward = this.boosterReward[i];

            if (!reward) {
                entity.enabled = false;
            } else {
                var stockItem = BoosterShopManager.instance._getStockByinventoryKey(reward.key);

                entity.children[0].element.spriteAsset = stockItem.image.id;
                entity.children[1].element.text = 'x' + reward.quantity;
            }
        });

        const rows = Math.ceil(this.boosterReward.length / 2);

        if (this.rewardLayoutEntity) {
            this.rewardLayoutEntity.layoutgroup.spacing = new pc.Vec2(5, 35 - rows * 10);

        }
    },

    onError: function (e) {
        if (!!e) {
            this.app.fire('UIManager:showUI', 'IAPFail');
        }
    }
});


// Vec4.js
pc.extend(pc.Vec4, {
    MINUS_ONE: Object.freeze(new pc.Vec4(-1, -1, -1, -1)),
});


// Vec2.js
pc.extend(pc.Vec2, {
    MINUS_ONE: Object.freeze(new pc.Vec2(-1, -1)),
});


// DynamicContent.js
var DynamicContent = pc.createScript('dynamicContent');

DynamicContent.BEHAVIOURS = Object.freeze({
    NONE: 'none',
    DEFAULT: 'default',
    CLAMP_WIDTH: 'clampWidth',
    CLAMP_HEIGHT: 'clampHeight',
    CLAMP_ALL: 'clampAll',
});

DynamicContent.BEHAVIOURS_ATTRIBUTES = [
    { NONE: 'none' },
    { DEFAULT: 'default' },
    { CLAMP_WIDTH: 'clampWidth' },
    { CLAMP_HEIGHT: 'clampHeight' },
    { CLAMP_ALL: 'clampAll' },
];

DynamicContent.attributes.add('portraitBehaviour', { type: 'string', enum: DynamicContent.BEHAVIOURS_ATTRIBUTES, default: 'none' });
DynamicContent.attributes.add('landscapeBehaviour', { type: 'string', enum: DynamicContent.BEHAVIOURS_ATTRIBUTES, default: 'none' });

DynamicContent.attributes.add('widthOffset', { type: 'number', default: 0 });

DynamicContent.attributes.add('useScale', { type: 'boolean', });


DynamicContent.attributes.add('defaultWidth', { type: 'number' });
DynamicContent.attributes.add('defaultHeight', { type: 'number' });
DynamicContent.attributes.add('debug', { type: 'boolean' });

pc.extend(DynamicContent.prototype, {
    initialize: function () {
        this._onResize(ViewportManager.instance.getOrientation(), ViewportManager.instance.width, ViewportManager.instance.height, ViewportManager.instance.getDevice());

        this.app.on('ViewportManager:onResize', this._onResize, this);
    },

    _onResize: function (orientation, width, height, device) {
        this.orientation = orientation;

        if (this.orientation === orientationEnum.LANDSCAPE) {
            this.setBehaviour(this.landscapeBehaviour, width, height);
        } else {
            this.setBehaviour(this.portraitBehaviour, width, height);
        }
    },

    setBehaviour: function (behaviour, width, height) {
        switch (behaviour) {
            case DynamicContent.BEHAVIOURS.NONE:
                break;

            case DynamicContent.BEHAVIOURS.DEFAULT:
                this.setDefaultWidth();
                this.setDefaultHeight();

                break;

            case DynamicContent.BEHAVIOURS.CLAMP_WIDTH:
                this.setClampWidth(width, height);
                this.setDefaultHeight();

                break;

            case DynamicContent.BEHAVIOURS.CLAMP_HEIGHT:
                this.setDefaultWidth();
                this.setClampHeight(width, height);

                break;

            case DynamicContent.BEHAVIOURS.CLAMP_ALL:
                this.setClampWidth(width, height);
                this.setClampHeight(width, height);

                break;
        }
    },

    setDefaultWidth: function () {
        this.entity.element.width = this.defaultWidth;
    },

    setDefaultHeight: function () {
        this.entity.element.height = this.defaultHeight;
    },

    setClampWidth: function (width, height) {
        const scale = this.useScale ? this.entity.getUIScale().x : 1;

        this.entity.element.width = (width * this.getScale(width, height) + this.widthOffset) / scale;
    },

    setClampHeight: function (width, height) {
        this.entity.element.height = height * this.getScale(width, height);
    },

    getScale: function (width, height) {
        return UIManager.instance.getReferenceResolution().y / height;
    },
});




// BoosterAnimation.js
class BoosterAnimation extends pc.ScriptType {
    static addAttributes() {
    }

    initialize() {
        this.on('disable', this._onDisable, this);
    }

    _onDisable() {
        //this._disabled = true;
        pc.timer.add(0.01, () => {
            this.entity.destroy();
        }, this);
    }

    setSprite(sprite) {
        this.entity.element.spriteAsset = sprite;
    }

    playAnimation(endPoint, amount, coins, time, index) {
        //amount is the amount of coins to spawn
        this._startNewAnimation(endPoint, amount, coins, time, index);
    }

    _startNewAnimation(endPoint, amount, coins, time, index) {
        this.coins = coins;

        var randomX = pc.math.random(-80, 80);
        var randomY = pc.math.random(-80, 80);
        var delay = index / 20;

        this.entity.setLocalScale(0, 0, 0);
        this.entity.tween(this.entity.getLocalScale()).to(CoinAnimation.FINAL_SCALE, 0.4, pc.SineOut, delay).start();

        var positionTween = this.entity.tween(this.entity.getLocalPosition())
            .to({ x: this.entity.getLocalPosition().x + randomX, y: this.entity.getLocalPosition().y + randomY, z: this.entity.getLocalPosition().z }, 0.4, pc.SineOut, delay)
            .start();

        if (delay === 0) {
            this.app.fire('Audio:sfx', 'coin_gain_single.mp3');
        } else {
            positionTween.on('delayDone', () => {
                this.app.fire('Audio:sfx', 'coin_gain_single.mp3');
            });
        }

        var timeToPlay;

        if (time) {
            timeToPlay = time;
        } else {
            timeToPlay = pc.math.random(0.3, 0.7);
        }

        var positionTween2 = this.entity.tween(this.entity.getLocalPosition()).to(endPoint, timeToPlay, pc.SineIn)
        positionTween2.on('complete', this.onComplete, this);
        positionTween.chain(positionTween2);
    }

    onComplete() {
        this.app.fire('Audio:sfx', 'coin_gain.mp3');
        // Inventory.instance.addItem('COINS', this.rewardPerCoin);
        this.app.fire('CoinInterface:addCoins', this.coins);
        this.entity.destroy();
    }
}
BoosterAnimation.FINAL_SCALE = { x: 0.5, y: 0.5, z: 0.5 };
pc.registerScript(BoosterAnimation, 'boosterAnimation');
BoosterAnimation.addAttributes();



// CenterScrollView.js
var CenterScrollView = pc.createScript('centerScrollView');

CenterScrollView.attributes.add('content', { type: 'entity' });

pc.extend(CenterScrollView.prototype, {
    initialize: function () {
        this._onResize(ViewportManager.instance.getOrientation(), ViewportManager.instance.width, ViewportManager.instance.height, ViewportManager.instance.getDevice());

        this.app.on('ViewportManager:onResize', this._onResize, this);
    },

    _onResize: function (orientation, width, height, device) {
        if (orientation === orientationEnum.LANDSCAPE) {
            pc.timer.add(0.01, () => {
                this.check(width, height);
            });
        }
    },

    check: function (width, height) {
        var scale = UIManager.instance.getReferenceResolution().y / height;

        const uiScale = this.entity.getUIScale();

        if (this.content.element.width < width * scale / uiScale.x) {
            const difference = width * scale / uiScale.x - this.content.element.width;

            const position = this.entity.getLocalPosition();

            this.entity.setLocalPosition(difference / 2, position.y, position.z);
        } else {
            const position = this.entity.getLocalPosition();

            this.entity.setLocalPosition(0, position.y, position.z);
        }
    }
});


// vconsole.js
// /*!
//  * vConsole v3.10.0 (https://github.com/Tencent/vConsole)
//  *
//  * Tencent is pleased to support the open source community by making vConsole available.
//  * Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.
//  * Licensed under the MIT License (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at
//  * http://opensource.org/licenses/MIT
//  * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
//  */
// !function(t,n){"object"==typeof exports&&"object"==typeof module?module.exports=n():"function"==typeof define&&define.amd?define("VConsole",[],n):"object"==typeof exports?exports.VConsole=n():t.VConsole=n()}(this||self,(function(){return function(){var __webpack_modules__={8406:function(t,n,e){"use strict";function o(t,n){for(var e=0;e<n.length;e++){var o=n[e];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(t,o.key,o)}}Object.defineProperty(n,"__esModule",{value:!0}),n.CookieStorage=void 0;var r=e(9390),i=e(4370),c=function(){function t(n){if(function(t,n){if(!(t instanceof n))throw new TypeError("Cannot call a class as a function")}(this,t),this._defaultOptions=Object.assign({domain:null,expires:null,path:null,secure:!1},n),"undefined"!=typeof Proxy)return new Proxy(this,a)}var n,e,c;return n=t,(e=[{key:"clear",value:function(){var t=this,n=i.parseCookies(this._getCookie());Object.keys(n).forEach((function(n){return t.removeItem(n)}))}},{key:"getItem",value:function(t){var n=i.parseCookies(this._getCookie());return Object.prototype.hasOwnProperty.call(n,t)?n[t]:null}},{key:"key",value:function(t){var n=i.parseCookies(this._getCookie()),e=Object.keys(n).sort();return t<e.length?e[t]:null}},{key:"removeItem",value:function(t,n){var e=Object.assign(Object.assign(Object.assign({},this._defaultOptions),n),{expires:new Date(0)}),o=r.formatCookie(t,"",e);this._setCookie(o)}},{key:"setItem",value:function(t,n,e){var o=Object.assign(Object.assign({},this._defaultOptions),e),i=r.formatCookie(t,n,o);this._setCookie(i)}},{key:"_getCookie",value:function(){return"undefined"==typeof document||void 0===document.cookie?"":document.cookie}},{key:"_setCookie",value:function(t){document.cookie=t}},{key:"length",get:function(){var t=i.parseCookies(this._getCookie());return Object.keys(t).length}}])&&o(n.prototype,e),c&&o(n,c),t}();n.CookieStorage=c;var a={defineProperty:function(t,n,e){return t.setItem(n.toString(),String(e.value)),!0},deleteProperty:function(t,n){return t.removeItem(n.toString()),!0},get:function(t,n,e){if("string"==typeof n&&n in t)return t[n];var o=t.getItem(n.toString());return null!==o?o:void 0},getOwnPropertyDescriptor:function(t,n){if(!(n in t))return{configurable:!0,enumerable:!0,value:t.getItem(n.toString()),writable:!0}},has:function(t,n){return"string"==typeof n&&n in t||null!==t.getItem(n.toString())},ownKeys:function(t){for(var n=[],e=0;e<t.length;e++){var o=t.key(e);null!==o&&n.push(o)}return n},preventExtensions:function(t){throw new TypeError("can't prevent extensions on this proxy object")},set:function(t,n,e,o){return t.setItem(n.toString(),String(e)),!0}}},9390:function(t,n){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.formatCookie=void 0;var e=function(t){var n=t.path,e=t.domain,o=t.expires,r=t.secure,i=function(t){var n=t.sameSite;return void 0===n?null:["none","lax","strict"].indexOf(n.toLowerCase())>=0?n:null}(t);return[null==n?"":";path="+n,null==e?"":";domain="+e,null==o?"":";expires="+o.toUTCString(),void 0===r||!1===r?"":";secure",null===i?"":";SameSite="+i].join("")};n.formatCookie=function(t,n,o){return[encodeURIComponent(t),"=",encodeURIComponent(n),e(o)].join("")}},6025:function(t,n,e){"use strict";var o=e(8406);Object.defineProperty(n,"eR",{enumerable:!0,get:function(){return o.CookieStorage}});var r=e(9390);var i=e(4370)},4370:function(t,n){"use strict";function e(t,n){return function(t){if(Array.isArray(t))return t}(t)||function(t,n){if("undefined"==typeof Symbol||!(Symbol.iterator in Object(t)))return;var e=[],o=!0,r=!1,i=void 0;try{for(var c,a=t[Symbol.iterator]();!(o=(c=a.next()).done)&&(e.push(c.value),!n||e.length!==n);o=!0);}catch(t){r=!0,i=t}finally{try{o||null==a.return||a.return()}finally{if(r)throw i}}return e}(t,n)||function(t,n){if(!t)return;if("string"==typeof t)return o(t,n);var e=Object.prototype.toString.call(t).slice(8,-1);"Object"===e&&t.constructor&&(e=t.constructor.name);if("Map"===e||"Set"===e)return Array.from(t);if("Arguments"===e||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e))return o(t,n)}(t,n)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function o(t,n){(null==n||n>t.length)&&(n=t.length);for(var e=0,o=new Array(n);e<n;e++)o[e]=t[e];return o}Object.defineProperty(n,"__esModule",{value:!0}),n.parseCookies=void 0;n.parseCookies=function(t){if(0===t.length)return{};var n={},o=new RegExp("\\s*;\\s*");return t.split(o).forEach((function(t){var o=e(t.split("="),2),r=o[0],i=o[1],c=decodeURIComponent(r),a=decodeURIComponent(i);n[c]=a})),n}},2582:function(t,n,e){e(1646),e(6394),e(2004),e(462),e(8407),e(2429),e(1172),e(8288),e(1274),e(8201),e(6626),e(3211),e(9952),e(15),e(9831),e(7521),e(2972),e(6956),e(5222),e(2257);var o=e(1287);t.exports=o.Symbol},6163:function(t){t.exports=function(t){if("function"!=typeof t)throw TypeError(String(t)+" is not a function");return t}},2569:function(t,n,e){var o=e(794);t.exports=function(t){if(!o(t))throw TypeError(String(t)+" is not an object");return t}},5766:function(t,n,e){var o=e(2977),r=e(97),i=e(6782),c=function(t){return function(n,e,c){var a,l=o(n),u=r(l.length),s=i(c,u);if(t&&e!=e){for(;u>s;)if((a=l[s++])!=a)return!0}else for(;u>s;s++)if((t||s in l)&&l[s]===e)return t||s||0;return!t&&-1}};t.exports={includes:c(!0),indexOf:c(!1)}},4805:function(t,n,e){var o=e(2938),r=e(5044),i=e(1324),c=e(97),a=e(4822),l=[].push,u=function(t){var n=1==t,e=2==t,u=3==t,s=4==t,f=6==t,d=7==t,v=5==t||f;return function(p,_,h,g){for(var m,b,y=i(p),E=r(y),w=o(_,h,3),O=c(E.length),L=0,C=g||a,T=n?C(p,O):e||d?C(p,0):void 0;O>L;L++)if((v||L in E)&&(b=w(m=E[L],L,y),t))if(n)T[L]=b;else if(b)switch(t){case 3:return!0;case 5:return m;case 6:return L;case 2:l.call(T,m)}else switch(t){case 4:return!1;case 7:l.call(T,m)}return f?-1:u||s?s:T}};t.exports={forEach:u(0),map:u(1),filter:u(2),some:u(3),every:u(4),find:u(5),findIndex:u(6),filterOut:u(7)}},9269:function(t,n,e){var o=e(6544),r=e(3649),i=e(4061),c=r("species");t.exports=function(t){return i>=51||!o((function(){var n=[];return(n.constructor={})[c]=function(){return{foo:1}},1!==n[t](Boolean).foo}))}},4822:function(t,n,e){var o=e(794),r=e(4521),i=e(3649)("species");t.exports=function(t,n){var e;return r(t)&&("function"!=typeof(e=t.constructor)||e!==Array&&!r(e.prototype)?o(e)&&null===(e=e[i])&&(e=void 0):e=void 0),new(void 0===e?Array:e)(0===n?0:n)}},9624:function(t){var n={}.toString;t.exports=function(t){return n.call(t).slice(8,-1)}},3058:function(t,n,e){var o=e(8191),r=e(9624),i=e(3649)("toStringTag"),c="Arguments"==r(function(){return arguments}());t.exports=o?r:function(t){var n,e,o;return void 0===t?"Undefined":null===t?"Null":"string"==typeof(e=function(t,n){try{return t[n]}catch(t){}}(n=Object(t),i))?e:c?r(n):"Object"==(o=r(n))&&"function"==typeof n.callee?"Arguments":o}},3478:function(t,n,e){var o=e(4402),r=e(929),i=e(6683),c=e(4615);t.exports=function(t,n){for(var e=r(n),a=c.f,l=i.f,u=0;u<e.length;u++){var s=e[u];o(t,s)||a(t,s,l(n,s))}}},57:function(t,n,e){var o=e(8494),r=e(4615),i=e(4677);t.exports=o?function(t,n,e){return r.f(t,n,i(1,e))}:function(t,n,e){return t[n]=e,t}},4677:function(t){t.exports=function(t,n){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:n}}},5999:function(t,n,e){"use strict";var o=e(2670),r=e(4615),i=e(4677);t.exports=function(t,n,e){var c=o(n);c in t?r.f(t,c,i(0,e)):t[c]=e}},2219:function(t,n,e){var o=e(1287),r=e(4402),i=e(491),c=e(4615).f;t.exports=function(t){var n=o.Symbol||(o.Symbol={});r(n,t)||c(n,t,{value:i.f(t)})}},8494:function(t,n,e){var o=e(6544);t.exports=!o((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]}))},6668:function(t,n,e){var o=e(7583),r=e(794),i=o.document,c=r(i)&&r(i.createElement);t.exports=function(t){return c?i.createElement(t):{}}},6918:function(t,n,e){var o=e(5897);t.exports=o("navigator","userAgent")||""},4061:function(t,n,e){var o,r,i=e(7583),c=e(6918),a=i.process,l=a&&a.versions,u=l&&l.v8;u?r=(o=u.split("."))[0]<4?1:o[0]+o[1]:c&&(!(o=c.match(/Edge\/(\d+)/))||o[1]>=74)&&(o=c.match(/Chrome\/(\d+)/))&&(r=o[1]),t.exports=r&&+r},5690:function(t){t.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},7263:function(t,n,e){var o=e(7583),r=e(6683).f,i=e(57),c=e(1270),a=e(460),l=e(3478),u=e(4451);t.exports=function(t,n){var e,s,f,d,v,p=t.target,_=t.global,h=t.stat;if(e=_?o:h?o[p]||a(p,{}):(o[p]||{}).prototype)for(s in n){if(d=n[s],f=t.noTargetGet?(v=r(e,s))&&v.value:e[s],!u(_?s:p+(h?".":"#")+s,t.forced)&&void 0!==f){if(typeof d==typeof f)continue;l(d,f)}(t.sham||f&&f.sham)&&i(d,"sham",!0),c(e,s,d,t)}}},6544:function(t){t.exports=function(t){try{return!!t()}catch(t){return!0}}},2938:function(t,n,e){var o=e(6163);t.exports=function(t,n,e){if(o(t),void 0===n)return t;switch(e){case 0:return function(){return t.call(n)};case 1:return function(e){return t.call(n,e)};case 2:return function(e,o){return t.call(n,e,o)};case 3:return function(e,o,r){return t.call(n,e,o,r)}}return function(){return t.apply(n,arguments)}}},5897:function(t,n,e){var o=e(1287),r=e(7583),i=function(t){return"function"==typeof t?t:void 0};t.exports=function(t,n){return arguments.length<2?i(o[t])||i(r[t]):o[t]&&o[t][n]||r[t]&&r[t][n]}},7583:function(t,n,e){var o=function(t){return t&&t.Math==Math&&t};t.exports=o("object"==typeof globalThis&&globalThis)||o("object"==typeof window&&window)||o("object"==typeof self&&self)||o("object"==typeof e.g&&e.g)||function(){return this}()||Function("return this")()},4402:function(t,n,e){var o=e(1324),r={}.hasOwnProperty;t.exports=Object.hasOwn||function(t,n){return r.call(o(t),n)}},4639:function(t){t.exports={}},482:function(t,n,e){var o=e(5897);t.exports=o("document","documentElement")},275:function(t,n,e){var o=e(8494),r=e(6544),i=e(6668);t.exports=!o&&!r((function(){return 7!=Object.defineProperty(i("div"),"a",{get:function(){return 7}}).a}))},5044:function(t,n,e){var o=e(6544),r=e(9624),i="".split;t.exports=o((function(){return!Object("z").propertyIsEnumerable(0)}))?function(t){return"String"==r(t)?i.call(t,""):Object(t)}:Object},9734:function(t,n,e){var o=e(1314),r=Function.toString;"function"!=typeof o.inspectSource&&(o.inspectSource=function(t){return r.call(t)}),t.exports=o.inspectSource},2743:function(t,n,e){var o,r,i,c=e(9491),a=e(7583),l=e(794),u=e(57),s=e(4402),f=e(1314),d=e(9137),v=e(4639),p="Object already initialized",_=a.WeakMap;if(c||f.state){var h=f.state||(f.state=new _),g=h.get,m=h.has,b=h.set;o=function(t,n){if(m.call(h,t))throw new TypeError(p);return n.facade=t,b.call(h,t,n),n},r=function(t){return g.call(h,t)||{}},i=function(t){return m.call(h,t)}}else{var y=d("state");v[y]=!0,o=function(t,n){if(s(t,y))throw new TypeError(p);return n.facade=t,u(t,y,n),n},r=function(t){return s(t,y)?t[y]:{}},i=function(t){return s(t,y)}}t.exports={set:o,get:r,has:i,enforce:function(t){return i(t)?r(t):o(t,{})},getterFor:function(t){return function(n){var e;if(!l(n)||(e=r(n)).type!==t)throw TypeError("Incompatible receiver, "+t+" required");return e}}}},4521:function(t,n,e){var o=e(9624);t.exports=Array.isArray||function(t){return"Array"==o(t)}},4451:function(t,n,e){var o=e(6544),r=/#|\.prototype\./,i=function(t,n){var e=a[c(t)];return e==u||e!=l&&("function"==typeof n?o(n):!!n)},c=i.normalize=function(t){return String(t).replace(r,".").toLowerCase()},a=i.data={},l=i.NATIVE="N",u=i.POLYFILL="P";t.exports=i},794:function(t){t.exports=function(t){return"object"==typeof t?null!==t:"function"==typeof t}},6268:function(t){t.exports=!1},8640:function(t,n,e){var o=e(4061),r=e(6544);t.exports=!!Object.getOwnPropertySymbols&&!r((function(){var t=Symbol();return!String(t)||!(Object(t)instanceof Symbol)||!Symbol.sham&&o&&o<41}))},9491:function(t,n,e){var o=e(7583),r=e(9734),i=o.WeakMap;t.exports="function"==typeof i&&/native code/.test(r(i))},3590:function(t,n,e){var o,r=e(2569),i=e(8728),c=e(5690),a=e(4639),l=e(482),u=e(6668),s=e(9137),f=s("IE_PROTO"),d=function(){},v=function(t){return"<script>"+t+"</"+"script>"},p=function(){try{o=document.domain&&new ActiveXObject("htmlfile")}catch(t){}var t,n;p=o?function(t){t.write(v("")),t.close();var n=t.parentWindow.Object;return t=null,n}(o):((n=u("iframe")).style.display="none",l.appendChild(n),n.src=String("javascript:"),(t=n.contentWindow.document).open(),t.write(v("document.F=Object")),t.close(),t.F);for(var e=c.length;e--;)delete p.prototype[c[e]];return p()};a[f]=!0,t.exports=Object.create||function(t,n){var e;return null!==t?(d.prototype=r(t),e=new d,d.prototype=null,e[f]=t):e=p(),void 0===n?e:i(e,n)}},8728:function(t,n,e){var o=e(8494),r=e(4615),i=e(2569),c=e(5432);t.exports=o?Object.defineProperties:function(t,n){i(t);for(var e,o=c(n),a=o.length,l=0;a>l;)r.f(t,e=o[l++],n[e]);return t}},4615:function(t,n,e){var o=e(8494),r=e(275),i=e(2569),c=e(2670),a=Object.defineProperty;n.f=o?a:function(t,n,e){if(i(t),n=c(n,!0),i(e),r)try{return a(t,n,e)}catch(t){}if("get"in e||"set"in e)throw TypeError("Accessors not supported");return"value"in e&&(t[n]=e.value),t}},6683:function(t,n,e){var o=e(8494),r=e(112),i=e(4677),c=e(2977),a=e(2670),l=e(4402),u=e(275),s=Object.getOwnPropertyDescriptor;n.f=o?s:function(t,n){if(t=c(t),n=a(n,!0),u)try{return s(t,n)}catch(t){}if(l(t,n))return i(!r.f.call(t,n),t[n])}},3130:function(t,n,e){var o=e(2977),r=e(9275).f,i={}.toString,c="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[];t.exports.f=function(t){return c&&"[object Window]"==i.call(t)?function(t){try{return r(t)}catch(t){return c.slice()}}(t):r(o(t))}},9275:function(t,n,e){var o=e(8356),r=e(5690).concat("length","prototype");n.f=Object.getOwnPropertyNames||function(t){return o(t,r)}},4012:function(t,n){n.f=Object.getOwnPropertySymbols},8356:function(t,n,e){var o=e(4402),r=e(2977),i=e(5766).indexOf,c=e(4639);t.exports=function(t,n){var e,a=r(t),l=0,u=[];for(e in a)!o(c,e)&&o(a,e)&&u.push(e);for(;n.length>l;)o(a,e=n[l++])&&(~i(u,e)||u.push(e));return u}},5432:function(t,n,e){var o=e(8356),r=e(5690);t.exports=Object.keys||function(t){return o(t,r)}},112:function(t,n){"use strict";var e={}.propertyIsEnumerable,o=Object.getOwnPropertyDescriptor,r=o&&!e.call({1:2},1);n.f=r?function(t){var n=o(this,t);return!!n&&n.enumerable}:e},3060:function(t,n,e){"use strict";var o=e(8191),r=e(3058);t.exports=o?{}.toString:function(){return"[object "+r(this)+"]"}},929:function(t,n,e){var o=e(5897),r=e(9275),i=e(4012),c=e(2569);t.exports=o("Reflect","ownKeys")||function(t){var n=r.f(c(t)),e=i.f;return e?n.concat(e(t)):n}},1287:function(t,n,e){var o=e(7583);t.exports=o},1270:function(t,n,e){var o=e(7583),r=e(57),i=e(4402),c=e(460),a=e(9734),l=e(2743),u=l.get,s=l.enforce,f=String(String).split("String");(t.exports=function(t,n,e,a){var l,u=!!a&&!!a.unsafe,d=!!a&&!!a.enumerable,v=!!a&&!!a.noTargetGet;"function"==typeof e&&("string"!=typeof n||i(e,"name")||r(e,"name",n),(l=s(e)).source||(l.source=f.join("string"==typeof n?n:""))),t!==o?(u?!v&&t[n]&&(d=!0):delete t[n],d?t[n]=e:r(t,n,e)):d?t[n]=e:c(n,e)})(Function.prototype,"toString",(function(){return"function"==typeof this&&u(this).source||a(this)}))},3955:function(t){t.exports=function(t){if(null==t)throw TypeError("Can't call method on "+t);return t}},460:function(t,n,e){var o=e(7583),r=e(57);t.exports=function(t,n){try{r(o,t,n)}catch(e){o[t]=n}return n}},8821:function(t,n,e){var o=e(4615).f,r=e(4402),i=e(3649)("toStringTag");t.exports=function(t,n,e){t&&!r(t=e?t:t.prototype,i)&&o(t,i,{configurable:!0,value:n})}},9137:function(t,n,e){var o=e(7836),r=e(8284),i=o("keys");t.exports=function(t){return i[t]||(i[t]=r(t))}},1314:function(t,n,e){var o=e(7583),r=e(460),i="__core-js_shared__",c=o[i]||r(i,{});t.exports=c},7836:function(t,n,e){var o=e(6268),r=e(1314);(t.exports=function(t,n){return r[t]||(r[t]=void 0!==n?n:{})})("versions",[]).push({version:"3.15.2",mode:o?"pure":"global",copyright:" 2021 Denis Pushkarev (zloirock.ru)"})},6782:function(t,n,e){var o=e(5089),r=Math.max,i=Math.min;t.exports=function(t,n){var e=o(t);return e<0?r(e+n,0):i(e,n)}},2977:function(t,n,e){var o=e(5044),r=e(3955);t.exports=function(t){return o(r(t))}},5089:function(t){var n=Math.ceil,e=Math.floor;t.exports=function(t){return isNaN(t=+t)?0:(t>0?e:n)(t)}},97:function(t,n,e){var o=e(5089),r=Math.min;t.exports=function(t){return t>0?r(o(t),9007199254740991):0}},1324:function(t,n,e){var o=e(3955);t.exports=function(t){return Object(o(t))}},2670:function(t,n,e){var o=e(794);t.exports=function(t,n){if(!o(t))return t;var e,r;if(n&&"function"==typeof(e=t.toString)&&!o(r=e.call(t)))return r;if("function"==typeof(e=t.valueOf)&&!o(r=e.call(t)))return r;if(!n&&"function"==typeof(e=t.toString)&&!o(r=e.call(t)))return r;throw TypeError("Can't convert object to primitive value")}},8191:function(t,n,e){var o={};o[e(3649)("toStringTag")]="z",t.exports="[object z]"===String(o)},8284:function(t){var n=0,e=Math.random();t.exports=function(t){return"Symbol("+String(void 0===t?"":t)+")_"+(++n+e).toString(36)}},7786:function(t,n,e){var o=e(8640);t.exports=o&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},491:function(t,n,e){var o=e(3649);n.f=o},3649:function(t,n,e){var o=e(7583),r=e(7836),i=e(4402),c=e(8284),a=e(8640),l=e(7786),u=r("wks"),s=o.Symbol,f=l?s:s&&s.withoutSetter||c;t.exports=function(t){return i(u,t)&&(a||"string"==typeof u[t])||(a&&i(s,t)?u[t]=s[t]:u[t]=f("Symbol."+t)),u[t]}},1646:function(t,n,e){"use strict";var o=e(7263),r=e(6544),i=e(4521),c=e(794),a=e(1324),l=e(97),u=e(5999),s=e(4822),f=e(9269),d=e(3649),v=e(4061),p=d("isConcatSpreadable"),_=9007199254740991,h="Maximum allowed index exceeded",g=v>=51||!r((function(){var t=[];return t[p]=!1,t.concat()[0]!==t})),m=f("concat"),b=function(t){if(!c(t))return!1;var n=t[p];return void 0!==n?!!n:i(t)};o({target:"Array",proto:!0,forced:!g||!m},{concat:function(t){var n,e,o,r,i,c=a(this),f=s(c,0),d=0;for(n=-1,o=arguments.length;n<o;n++)if(b(i=-1===n?c:arguments[n])){if(d+(r=l(i.length))>_)throw TypeError(h);for(e=0;e<r;e++,d++)e in i&&u(f,d,i[e])}else{if(d>=_)throw TypeError(h);u(f,d++,i)}return f.length=d,f}})},6956:function(t,n,e){var o=e(7583);e(8821)(o.JSON,"JSON",!0)},5222:function(t,n,e){e(8821)(Math,"Math",!0)},6394:function(t,n,e){var o=e(8191),r=e(1270),i=e(3060);o||r(Object.prototype,"toString",i,{unsafe:!0})},2257:function(t,n,e){var o=e(7263),r=e(7583),i=e(8821);o({global:!0},{Reflect:{}}),i(r.Reflect,"Reflect",!0)},462:function(t,n,e){e(2219)("asyncIterator")},8407:function(t,n,e){"use strict";var o=e(7263),r=e(8494),i=e(7583),c=e(4402),a=e(794),l=e(4615).f,u=e(3478),s=i.Symbol;if(r&&"function"==typeof s&&(!("description"in s.prototype)||void 0!==s().description)){var f={},d=function(){var t=arguments.length<1||void 0===arguments[0]?void 0:String(arguments[0]),n=this instanceof d?new s(t):void 0===t?s():s(t);return""===t&&(f[n]=!0),n};u(d,s);var v=d.prototype=s.prototype;v.constructor=d;var p=v.toString,_="Symbol(test)"==String(s("test")),h=/^Symbol\((.*)\)[^)]+$/;l(v,"description",{configurable:!0,get:function(){var t=a(this)?this.valueOf():this,n=p.call(t);if(c(f,t))return"";var e=_?n.slice(7,-1):n.replace(h,"$1");return""===e?void 0:e}}),o({global:!0,forced:!0},{Symbol:d})}},2429:function(t,n,e){e(2219)("hasInstance")},1172:function(t,n,e){e(2219)("isConcatSpreadable")},8288:function(t,n,e){e(2219)("iterator")},2004:function(t,n,e){"use strict";var o=e(7263),r=e(7583),i=e(5897),c=e(6268),a=e(8494),l=e(8640),u=e(7786),s=e(6544),f=e(4402),d=e(4521),v=e(794),p=e(2569),_=e(1324),h=e(2977),g=e(2670),m=e(4677),b=e(3590),y=e(5432),E=e(9275),w=e(3130),O=e(4012),L=e(6683),C=e(4615),T=e(112),D=e(57),R=e(1270),x=e(7836),P=e(9137),$=e(4639),k=e(8284),M=e(3649),j=e(491),I=e(2219),S=e(8821),U=e(2743),A=e(4805).forEach,V=P("hidden"),B="Symbol",N=M("toPrimitive"),G=U.set,K=U.getterFor(B),W=Object.prototype,H=r.Symbol,F=i("JSON","stringify"),q=L.f,z=C.f,Z=w.f,Y=T.f,X=x("symbols"),J=x("op-symbols"),Q=x("string-to-symbol-registry"),tt=x("symbol-to-string-registry"),nt=x("wks"),et=r.QObject,ot=!et||!et.prototype||!et.prototype.findChild,rt=a&&s((function(){return 7!=b(z({},"a",{get:function(){return z(this,"a",{value:7}).a}})).a}))?function(t,n,e){var o=q(W,n);o&&delete W[n],z(t,n,e),o&&t!==W&&z(W,n,o)}:z,it=function(t,n){var e=X[t]=b(H.prototype);return G(e,{type:B,tag:t,description:n}),a||(e.description=n),e},ct=u?function(t){return"symbol"==typeof t}:function(t){return Object(t)instanceof H},at=function(t,n,e){t===W&&at(J,n,e),p(t);var o=g(n,!0);return p(e),f(X,o)?(e.enumerable?(f(t,V)&&t[V][o]&&(t[V][o]=!1),e=b(e,{enumerable:m(0,!1)})):(f(t,V)||z(t,V,m(1,{})),t[V][o]=!0),rt(t,o,e)):z(t,o,e)},lt=function(t,n){p(t);var e=h(n),o=y(e).concat(dt(e));return A(o,(function(n){a&&!ut.call(e,n)||at(t,n,e[n])})),t},ut=function(t){var n=g(t,!0),e=Y.call(this,n);return!(this===W&&f(X,n)&&!f(J,n))&&(!(e||!f(this,n)||!f(X,n)||f(this,V)&&this[V][n])||e)},st=function(t,n){var e=h(t),o=g(n,!0);if(e!==W||!f(X,o)||f(J,o)){var r=q(e,o);return!r||!f(X,o)||f(e,V)&&e[V][o]||(r.enumerable=!0),r}},ft=function(t){var n=Z(h(t)),e=[];return A(n,(function(t){f(X,t)||f($,t)||e.push(t)})),e},dt=function(t){var n=t===W,e=Z(n?J:h(t)),o=[];return A(e,(function(t){!f(X,t)||n&&!f(W,t)||o.push(X[t])})),o};(l||(R((H=function(){if(this instanceof H)throw TypeError("Symbol is not a constructor");var t=arguments.length&&void 0!==arguments[0]?String(arguments[0]):void 0,n=k(t),e=function t(e){this===W&&t.call(J,e),f(this,V)&&f(this[V],n)&&(this[V][n]=!1),rt(this,n,m(1,e))};return a&&ot&&rt(W,n,{configurable:!0,set:e}),it(n,t)}).prototype,"toString",(function(){return K(this).tag})),R(H,"withoutSetter",(function(t){return it(k(t),t)})),T.f=ut,C.f=at,L.f=st,E.f=w.f=ft,O.f=dt,j.f=function(t){return it(M(t),t)},a&&(z(H.prototype,"description",{configurable:!0,get:function(){return K(this).description}}),c||R(W,"propertyIsEnumerable",ut,{unsafe:!0}))),o({global:!0,wrap:!0,forced:!l,sham:!l},{Symbol:H}),A(y(nt),(function(t){I(t)})),o({target:B,stat:!0,forced:!l},{for:function(t){var n=String(t);if(f(Q,n))return Q[n];var e=H(n);return Q[n]=e,tt[e]=n,e},keyFor:function(t){if(!ct(t))throw TypeError(t+" is not a symbol");if(f(tt,t))return tt[t]},useSetter:function(){ot=!0},useSimple:function(){ot=!1}}),o({target:"Object",stat:!0,forced:!l,sham:!a},{create:function(t,n){return void 0===n?b(t):lt(b(t),n)},defineProperty:at,defineProperties:lt,getOwnPropertyDescriptor:st}),o({target:"Object",stat:!0,forced:!l},{getOwnPropertyNames:ft,getOwnPropertySymbols:dt}),o({target:"Object",stat:!0,forced:s((function(){O.f(1)}))},{getOwnPropertySymbols:function(t){return O.f(_(t))}}),F)&&o({target:"JSON",stat:!0,forced:!l||s((function(){var t=H();return"[null]"!=F([t])||"{}"!=F({a:t})||"{}"!=F(Object(t))}))},{stringify:function(t,n,e){for(var o,r=[t],i=1;arguments.length>i;)r.push(arguments[i++]);if(o=n,(v(n)||void 0!==t)&&!ct(t))return d(n)||(n=function(t,n){if("function"==typeof o&&(n=o.call(this,t,n)),!ct(n))return n}),r[1]=n,F.apply(null,r)}});H.prototype[N]||D(H.prototype,N,H.prototype.valueOf),S(H,B),$[V]=!0},8201:function(t,n,e){e(2219)("matchAll")},1274:function(t,n,e){e(2219)("match")},6626:function(t,n,e){e(2219)("replace")},3211:function(t,n,e){e(2219)("search")},9952:function(t,n,e){e(2219)("species")},15:function(t,n,e){e(2219)("split")},9831:function(t,n,e){e(2219)("toPrimitive")},7521:function(t,n,e){e(2219)("toStringTag")},2972:function(t,n,e){e(2219)("unscopables")},5441:function(t,n,e){var o=e(2582);t.exports=o},7705:function(t){"use strict";t.exports=function(t){var n=[];return n.toString=function(){return this.map((function(n){var e=t(n);return n[2]?"@media ".concat(n[2]," {").concat(e,"}"):e})).join("")},n.i=function(t,e,o){"string"==typeof t&&(t=[[null,t,""]]);var r={};if(o)for(var i=0;i<this.length;i++){var c=this[i][0];null!=c&&(r[c]=!0)}for(var a=0;a<t.length;a++){var l=[].concat(t[a]);o&&r[l[0]]||(e&&(l[2]?l[2]="".concat(e," and ").concat(l[2]):l[2]=e),n.push(l))}},n}},8679:function(t){var n=window.MutationObserver||window.WebKitMutationObserver||window.MozMutationObserver,e=window.WeakMap;if(void 0===e){var o=Object.defineProperty,r=Date.now()%1e9;(e=function(){this.name="__st"+(1e9*Math.random()>>>0)+r+++"__"}).prototype={set:function(t,n){var e=t[this.name];return e&&e[0]===t?e[1]=n:o(t,this.name,{value:[t,n],writable:!0}),this},get:function(t){var n;return(n=t[this.name])&&n[0]===t?n[1]:void 0},delete:function(t){var n=t[this.name];if(!n)return!1;var e=n[0]===t;return n[0]=n[1]=void 0,e},has:function(t){var n=t[this.name];return!!n&&n[0]===t}}}var i=new e,c=window.msSetImmediate;if(!c){var a=[],l=String(Math.random());window.addEventListener("message",(function(t){if(t.data===l){var n=a;a=[],n.forEach((function(t){t()}))}})),c=function(t){a.push(t),window.postMessage(l,"*")}}var u=!1,s=[];function f(){u=!1;var t=s;s=[],t.sort((function(t,n){return t.uid_-n.uid_}));var n=!1;t.forEach((function(t){var e=t.takeRecords();!function(t){t.nodes_.forEach((function(n){var e=i.get(n);e&&e.forEach((function(n){n.observer===t&&n.removeTransientObservers()}))}))}(t),e.length&&(t.callback_(e,t),n=!0)})),n&&f()}function d(t,n){for(var e=t;e;e=e.parentNode){var o=i.get(e);if(o)for(var r=0;r<o.length;r++){var c=o[r],a=c.options;if(e===t||a.subtree){var l=n(a);l&&c.enqueue(l)}}}}var v,p,_=0;function h(t){this.callback_=t,this.nodes_=[],this.records_=[],this.uid_=++_}function g(t,n){this.type=t,this.target=n,this.addedNodes=[],this.removedNodes=[],this.previousSibling=null,this.nextSibling=null,this.attributeName=null,this.attributeNamespace=null,this.oldValue=null}function m(t,n){return v=new g(t,n)}function b(t){return p||((e=new g((n=v).type,n.target)).addedNodes=n.addedNodes.slice(),e.removedNodes=n.removedNodes.slice(),e.previousSibling=n.previousSibling,e.nextSibling=n.nextSibling,e.attributeName=n.attributeName,e.attributeNamespace=n.attributeNamespace,e.oldValue=n.oldValue,(p=e).oldValue=t,p);var n,e}function y(t,n){return t===n?t:p&&((e=t)===p||e===v)?p:null;var e}function E(t,n,e){this.observer=t,this.target=n,this.options=e,this.transientObservedNodes=[]}h.prototype={observe:function(t,n){var e;if(e=t,t=window.ShadowDOMPolyfill&&window.ShadowDOMPolyfill.wrapIfNeeded(e)||e,!n.childList&&!n.attributes&&!n.characterData||n.attributeOldValue&&!n.attributes||n.attributeFilter&&n.attributeFilter.length&&!n.attributes||n.characterDataOldValue&&!n.characterData)throw new SyntaxError;var o,r=i.get(t);r||i.set(t,r=[]);for(var c=0;c<r.length;c++)if(r[c].observer===this){(o=r[c]).removeListeners(),o.options=n;break}o||(o=new E(this,t,n),r.push(o),this.nodes_.push(t)),o.addListeners()},disconnect:function(){this.nodes_.forEach((function(t){for(var n=i.get(t),e=0;e<n.length;e++){var o=n[e];if(o.observer===this){o.removeListeners(),n.splice(e,1);break}}}),this),this.records_=[]},takeRecords:function(){var t=this.records_;return this.records_=[],t}},E.prototype={enqueue:function(t){var n,e=this.observer.records_,o=e.length;if(e.length>0){var r=y(e[o-1],t);if(r)return void(e[o-1]=r)}else n=this.observer,s.push(n),u||(u=!0,c(f));e[o]=t},addListeners:function(){this.addListeners_(this.target)},addListeners_:function(t){var n=this.options;n.attributes&&t.addEventListener("DOMAttrModified",this,!0),n.characterData&&t.addEventListener("DOMCharacterDataModified",this,!0),n.childList&&t.addEventListener("DOMNodeInserted",this,!0),(n.childList||n.subtree)&&t.addEventListener("DOMNodeRemoved",this,!0)},removeListeners:function(){this.removeListeners_(this.target)},removeListeners_:function(t){var n=this.options;n.attributes&&t.removeEventListener("DOMAttrModified",this,!0),n.characterData&&t.removeEventListener("DOMCharacterDataModified",this,!0),n.childList&&t.removeEventListener("DOMNodeInserted",this,!0),(n.childList||n.subtree)&&t.removeEventListener("DOMNodeRemoved",this,!0)},addTransientObserver:function(t){if(t!==this.target){this.addListeners_(t),this.transientObservedNodes.push(t);var n=i.get(t);n||i.set(t,n=[]),n.push(this)}},removeTransientObservers:function(){var t=this.transientObservedNodes;this.transientObservedNodes=[],t.forEach((function(t){this.removeListeners_(t);for(var n=i.get(t),e=0;e<n.length;e++)if(n[e]===this){n.splice(e,1);break}}),this)},handleEvent:function(t){switch(t.stopImmediatePropagation(),t.type){case"DOMAttrModified":var n=t.attrName,e=t.relatedNode.namespaceURI,o=t.target;(i=new m("attributes",o)).attributeName=n,i.attributeNamespace=e;var r=null;"undefined"!=typeof MutationEvent&&t.attrChange===MutationEvent.ADDITION||(r=t.prevValue),d(o,(function(t){if(t.attributes&&(!t.attributeFilter||!t.attributeFilter.length||-1!==t.attributeFilter.indexOf(n)||-1!==t.attributeFilter.indexOf(e)))return t.attributeOldValue?b(r):i}));break;case"DOMCharacterDataModified":var i=m("characterData",o=t.target);r=t.prevValue;d(o,(function(t){if(t.characterData)return t.characterDataOldValue?b(r):i}));break;case"DOMNodeRemoved":this.addTransientObserver(t.target);case"DOMNodeInserted":o=t.relatedNode;var c,a,l=t.target;"DOMNodeInserted"===t.type?(c=[l],a=[]):(c=[],a=[l]);var u=l.previousSibling,s=l.nextSibling;(i=m("childList",o)).addedNodes=c,i.removedNodes=a,i.previousSibling=u,i.nextSibling=s,d(o,(function(t){if(t.childList)return i}))}v=p=void 0}},n||(n=h),t.exports=n},6958:function(t,n,e){"use strict";e.d(n,{Z:function(){return L}});var o,r=e(8826),i=e(7003),c=e(3379),a=e.n(c),l=e(9746),u=0,s={injectType:"lazyStyleTag",insert:"head",singleton:!1},f={};f.locals=l.Z.locals||{},f.use=function(){return u++||(o=a()(l.Z,s)),f},f.unuse=function(){u>0&&!--u&&(o(),o=null)};var d=f;function v(t,n){for(var e=0;e<n.length;e++){var o=n[e];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(t,o.key,o)}}function p(t,n){return(p=Object.setPrototypeOf||function(t,n){return t.__proto__=n,t})(t,n)}function _(t){var n,e;return{c:function(){n=(0,r.bi)("svg"),e=(0,r.bi)("path"),(0,r.Lj)(e,"d","M599.99999 832.000004h47.999999a24 24 0 0 0 23.999999-24V376.000013a24 24 0 0 0-23.999999-24h-47.999999a24 24 0 0 0-24 24v431.999991a24 24 0 0 0 24 24zM927.999983 160.000017h-164.819997l-67.999998-113.399998A95.999998 95.999998 0 0 0 612.819989 0.00002H411.179993a95.999998 95.999998 0 0 0-82.319998 46.599999L260.819996 160.000017H95.999999A31.999999 31.999999 0 0 0 64 192.000016v32a31.999999 31.999999 0 0 0 31.999999 31.999999h32v671.999987a95.999998 95.999998 0 0 0 95.999998 95.999998h575.999989a95.999998 95.999998 0 0 0 95.999998-95.999998V256.000015h31.999999a31.999999 31.999999 0 0 0 32-31.999999V192.000016a31.999999 31.999999 0 0 0-32-31.999999zM407.679993 101.820018A12 12 0 0 1 417.999993 96.000018h187.999996a12 12 0 0 1 10.3 5.82L651.219989 160.000017H372.779994zM799.999986 928.000002H223.999997V256.000015h575.999989z m-423.999992-95.999998h47.999999a24 24 0 0 0 24-24V376.000013a24 24 0 0 0-24-24h-47.999999a24 24 0 0 0-24 24v431.999991a24 24 0 0 0 24 24z"),(0,r.Lj)(n,"class","vc-icon-delete"),(0,r.Lj)(n,"viewBox","0 0 1024 1024"),(0,r.Lj)(n,"width","200"),(0,r.Lj)(n,"height","200")},m:function(t,o){(0,r.$T)(t,n,o),(0,r.R3)(n,e)},d:function(t){t&&(0,r.og)(n)}}}function h(t){var n,e,o;return{c:function(){n=(0,r.bi)("svg"),e=(0,r.bi)("path"),o=(0,r.bi)("path"),(0,r.Lj)(e,"d","M874.154197 150.116875A511.970373 511.970373 0 1 0 1023.993986 511.991687a511.927744 511.927744 0 0 0-149.839789-361.874812z m-75.324866 648.382129A405.398688 405.398688 0 1 1 917.422301 511.991687a405.313431 405.313431 0 0 1-118.59297 286.507317z"),(0,r.Lj)(o,"d","M725.039096 299.274605a54.351559 54.351559 0 0 0-76.731613 0l-135.431297 135.431297L377.274375 299.274605a54.436817 54.436817 0 0 0-76.944756 76.987385l135.388668 135.431297-135.388668 135.473925a54.436817 54.436817 0 0 0 76.944756 76.987385l135.388668-135.431297 135.431297 135.473926a54.436817 54.436817 0 0 0 76.731613-76.987385l-135.388668-135.473926 135.388668-135.431296a54.479445 54.479445 0 0 0 0.213143-77.030014z"),(0,r.Lj)(n,"viewBox","0 0 1024 1024"),(0,r.Lj)(n,"width","200"),(0,r.Lj)(n,"height","200")},m:function(t,i){(0,r.$T)(t,n,i),(0,r.R3)(n,e),(0,r.R3)(n,o)},d:function(t){t&&(0,r.og)(n)}}}function g(t){var n,e;return{c:function(){n=(0,r.bi)("svg"),e=(0,r.bi)("path"),(0,r.Lj)(e,"fill-rule","evenodd"),(0,r.Lj)(e,"d","M5.75 1a.75.75 0 00-.75.75v3c0 .414.336.75.75.75h4.5a.75.75 0 00.75-.75v-3a.75.75 0 00-.75-.75h-4.5zm.75 3V2.5h3V4h-3zm-2.874-.467a.75.75 0 00-.752-1.298A1.75 1.75 0 002 3.75v9.5c0 .966.784 1.75 1.75 1.75h8.5A1.75 1.75 0 0014 13.25v-9.5a1.75 1.75 0 00-.874-1.515.75.75 0 10-.752 1.298.25.25 0 01.126.217v9.5a.25.25 0 01-.25.25h-8.5a.25.25 0 01-.25-.25v-9.5a.25.25 0 01.126-.217z"),(0,r.Lj)(n,"class","vc-icon-copy"),(0,r.Lj)(n,"viewBox","0 0 16 16")},m:function(t,o){(0,r.$T)(t,n,o),(0,r.R3)(n,e)},d:function(t){t&&(0,r.og)(n)}}}function m(t){var n,e;return{c:function(){n=(0,r.bi)("svg"),e=(0,r.bi)("path"),(0,r.Lj)(e,"fill-rule","evenodd"),(0,r.Lj)(e,"d","M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"),(0,r.Lj)(n,"class","vc-icon-suc"),(0,r.Lj)(n,"viewBox","0 0 16 16")},m:function(t,o){(0,r.$T)(t,n,o),(0,r.R3)(n,e)},d:function(t){t&&(0,r.og)(n)}}}function b(t){var n,e,o;return{c:function(){n=(0,r.bi)("svg"),e=(0,r.bi)("path"),o=(0,r.bi)("path"),(0,r.Lj)(e,"d","M776.533333 1024 162.133333 1024C72.533333 1024 0 951.466667 0 861.866667L0 247.466667C0 157.866667 72.533333 85.333333 162.133333 85.333333L469.333333 85.333333c25.6 0 42.666667 17.066667 42.666667 42.666667s-17.066667 42.666667-42.666667 42.666667L162.133333 170.666667C119.466667 170.666667 85.333333 204.8 85.333333 247.466667l0 610.133333c0 42.666667 34.133333 76.8 76.8 76.8l610.133333 0c42.666667 0 76.8-34.133333 76.8-76.8L849.066667 554.666667c0-25.6 17.066667-42.666667 42.666667-42.666667s42.666667 17.066667 42.666667 42.666667l0 307.2C938.666667 951.466667 866.133333 1024 776.533333 1024z"),(0,r.Lj)(o,"d","M256 810.666667c-12.8 0-21.333333-4.266667-29.866667-12.8C217.6 789.333333 213.333333 772.266667 213.333333 759.466667l42.666667-213.333333c0-8.533333 4.266667-17.066667 12.8-21.333333l512-512c17.066667-17.066667 42.666667-17.066667 59.733333 0l170.666667 170.666667c17.066667 17.066667 17.066667 42.666667 0 59.733333l-512 512c-4.266667 4.266667-12.8 8.533333-21.333333 12.8l-213.333333 42.666667C260.266667 810.666667 260.266667 810.666667 256 810.666667zM337.066667 576l-25.6 136.533333 136.533333-25.6L921.6 213.333333 810.666667 102.4 337.066667 576z"),(0,r.Lj)(n,"class","vc-icon-edit"),(0,r.Lj)(n,"viewBox","0 0 1024 1024"),(0,r.Lj)(n,"width","200"),(0,r.Lj)(n,"height","200")},m:function(t,i){(0,r.$T)(t,n,i),(0,r.R3)(n,e),(0,r.R3)(n,o)},d:function(t){t&&(0,r.og)(n)}}}function y(t){var n,e;return{c:function(){n=(0,r.bi)("svg"),e=(0,r.bi)("path"),(0,r.Lj)(e,"d","M581.338005 987.646578c-2.867097 4.095853-4.573702 8.669555-8.191705 12.287558a83.214071 83.214071 0 0 1-60.959939 24.029001 83.214071 83.214071 0 0 1-61.028203-24.029001c-3.618003-3.618003-5.324608-8.191705-8.123441-12.15103L24.370323 569.050448a83.418864 83.418864 0 0 1 117.892289-117.89229l369.923749 369.92375L1308.829682 24.438587A83.418864 83.418864 0 0 1 1426.721971 142.194348L581.338005 987.646578z"),(0,r.Lj)(n,"class","vc-icon-don"),(0,r.Lj)(n,"viewBox","0 0 1501 1024"),(0,r.Lj)(n,"width","200"),(0,r.Lj)(n,"height","200")},m:function(t,o){(0,r.$T)(t,n,o),(0,r.R3)(n,e)},d:function(t){t&&(0,r.og)(n)}}}function E(t){var n,e;return{c:function(){n=(0,r.bi)("svg"),e=(0,r.bi)("path"),(0,r.Lj)(e,"d","M894.976 574.464q0 78.848-29.696 148.48t-81.408 123.392-121.856 88.064-151.04 41.472q-5.12 1.024-9.216 1.536t-9.216 0.512l-177.152 0q-17.408 0-34.304-6.144t-30.208-16.896-22.016-25.088-8.704-29.696 8.192-29.696 21.504-24.576 29.696-16.384 33.792-6.144l158.72 1.024q54.272 0 102.4-19.968t83.968-53.76 56.32-79.36 20.48-97.792q0-49.152-18.432-92.16t-50.688-76.8-75.264-54.784-93.184-26.112q-2.048 0-2.56 0.512t-2.56 0.512l-162.816 0 0 80.896q0 17.408-13.824 25.6t-44.544-10.24q-8.192-5.12-26.112-17.92t-41.984-30.208-50.688-36.864l-51.2-38.912q-15.36-12.288-26.624-22.016t-11.264-24.064q0-12.288 12.8-25.6t29.184-26.624q18.432-15.36 44.032-35.84t50.688-39.936 45.056-35.328 28.16-22.016q24.576-17.408 39.936-7.168t16.384 30.72l0 81.92 162.816 0q5.12 0 10.752 1.024t10.752 2.048q79.872 8.192 149.504 41.984t121.344 87.552 80.896 123.392 29.184 147.456z"),(0,r.Lj)(n,"class","vc-icon-cancel"),(0,r.Lj)(n,"viewBox","0 0 1024 1024"),(0,r.Lj)(n,"width","200"),(0,r.Lj)(n,"height","200")},m:function(t,o){(0,r.$T)(t,n,o),(0,r.R3)(n,e)},d:function(t){t&&(0,r.og)(n)}}}function w(t){var n,e,o,i,c,a,l,u,s,f="delete"===t[0]&&_(),d="clear"===t[0]&&h(),v="copy"===t[0]&&g(),p="success"===t[0]&&m(),w="edit"===t[0]&&b(),O="done"===t[0]&&y(),L="cancel"===t[0]&&E();return{c:function(){n=(0,r.bG)("i"),f&&f.c(),e=(0,r.Dh)(),d&&d.c(),o=(0,r.Dh)(),v&&v.c(),i=(0,r.Dh)(),p&&p.c(),c=(0,r.Dh)(),w&&w.c(),a=(0,r.Dh)(),O&&O.c(),l=(0,r.Dh)(),L&&L.c(),(0,r.Lj)(n,"class","vc-icon")},m:function(_,h){(0,r.$T)(_,n,h),f&&f.m(n,null),(0,r.R3)(n,e),d&&d.m(n,null),(0,r.R3)(n,o),v&&v.m(n,null),(0,r.R3)(n,i),p&&p.m(n,null),(0,r.R3)(n,c),w&&w.m(n,null),(0,r.R3)(n,a),O&&O.m(n,null),(0,r.R3)(n,l),L&&L.m(n,null),u||(s=(0,r.oL)(n,"click",t[1]),u=!0)},p:function(t,r){r[0];"delete"===t[0]?f||((f=_()).c(),f.m(n,e)):f&&(f.d(1),f=null),"clear"===t[0]?d||((d=h()).c(),d.m(n,o)):d&&(d.d(1),d=null),"copy"===t[0]?v||((v=g()).c(),v.m(n,i)):v&&(v.d(1),v=null),"success"===t[0]?p||((p=m()).c(),p.m(n,c)):p&&(p.d(1),p=null),"edit"===t[0]?w||((w=b()).c(),w.m(n,a)):w&&(w.d(1),w=null),"done"===t[0]?O||((O=y()).c(),O.m(n,l)):O&&(O.d(1),O=null),"cancel"===t[0]?L||((L=E()).c(),L.m(n,null)):L&&(L.d(1),L=null)},i:r.ZT,o:r.ZT,d:function(t){t&&(0,r.og)(n),f&&f.d(),d&&d.d(),v&&v.d(),p&&p.d(),w&&w.d(),O&&O.d(),L&&L.d(),u=!1,s()}}}function O(t,n,e){var o=n.name;return(0,i.H3)((function(){d.use()})),(0,i.ev)((function(){d.unuse()})),t.$$set=function(t){"name"in t&&e(0,o=t.name)},[o,function(n){r.cK.call(this,t,n)}]}var L=function(t){var n,e,o,i,c;function a(n){var e;return e=t.call(this)||this,(0,r.S1)(function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(e),n,O,w,r.N8,{name:0}),e}return e=t,(n=a).prototype=Object.create(e.prototype),n.prototype.constructor=n,p(n,e),o=a,(i=[{key:"name",get:function(){return this.$$.ctx[0]},set:function(t){this.$set({name:t}),(0,r.yl)()}}])&&v(o.prototype,i),c&&v(o,c),a}(r.f_)},3903:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";var svelte_internal__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(8826),svelte__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(7003),_component_icon_svelte__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__(6958),_logTool__WEBPACK_IMPORTED_MODULE_5__=__webpack_require__(8665),_log_model__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__(5629),_logCommand_less__WEBPACK_IMPORTED_MODULE_4__=__webpack_require__(3411);function _assertThisInitialized(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}function _inheritsLoose(t,n){t.prototype=Object.create(n.prototype),t.prototype.constructor=t,_setPrototypeOf(t,n)}function _setPrototypeOf(t,n){return(_setPrototypeOf=Object.setPrototypeOf||function(t,n){return t.__proto__=n,t})(t,n)}function get_each_context(t,n,e){var o=t.slice();return o[27]=n[e],o}function create_if_block_2(t){var n,e,o;return{c:function(){(n=(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.bG)("li")).textContent="Close",(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.Lj)(n,"class","vc-cmd-prompted-hide")},m:function(r,i){(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.$T)(r,n,i),e||(o=(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.oL)(n,"click",t[5]),e=!0)},p:svelte_internal__WEBPACK_IMPORTED_MODULE_0__.ZT,d:function(t){t&&(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.og)(n),e=!1,o()}}}function create_else_block(t){var n;return{c:function(){(n=(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.bG)("li")).textContent="No Prompted"},m:function(t,e){(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.$T)(t,n,e)},d:function(t){t&&(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.og)(n)}}}function create_each_block(t){var n,e,o,r,i=t[27].text+"";function c(){return t[13](t[27])}return{c:function(){n=(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.bG)("li"),e=(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.fL)(i)},m:function(t,i){(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.$T)(t,n,i),(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.R3)(n,e),o||(r=(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.oL)(n,"click",c),o=!0)},p:function(n,o){t=n,8&o&&i!==(i=t[27].text+"")&&(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.rT)(e,i)},d:function(t){t&&(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.og)(n),o=!1,r()}}}function create_if_block_1(t){var n,e,o,r,i;return e=new _component_icon_svelte__WEBPACK_IMPORTED_MODULE_2__.Z({props:{name:"clear"}}),{c:function(){n=(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.bG)("div"),(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.YC)(e.$$.fragment),(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.Lj)(n,"class","vc-cmd-clear-btn")},m:function(c,a){(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.$T)(c,n,a),(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.ye)(e,n,null),o=!0,r||(i=(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.oL)(n,"click",(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.AT)(t[14])),r=!0)},p:svelte_internal__WEBPACK_IMPORTED_MODULE_0__.ZT,i:function(t){o||((0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.Ui)(e.$$.fragment,t),o=!0)},o:function(t){(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.et)(e.$$.fragment,t),o=!1},d:function(t){t&&(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.og)(n),(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.vp)(e),r=!1,i()}}}function create_if_block(t){var n,e,o,r,i;return e=new _component_icon_svelte__WEBPACK_IMPORTED_MODULE_2__.Z({props:{name:"clear"}}),{c:function(){n=(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.bG)("div"),(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.YC)(e.$$.fragment),(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.Lj)(n,"class","vc-cmd-clear-btn")},m:function(c,a){(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.$T)(c,n,a),(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.ye)(e,n,null),o=!0,r||(i=(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.oL)(n,"click",(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.AT)(t[17])),r=!0)},p:svelte_internal__WEBPACK_IMPORTED_MODULE_0__.ZT,i:function(t){o||((0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.Ui)(e.$$.fragment,t),o=!0)},o:function(t){(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.et)(e.$$.fragment,t),o=!1},d:function(t){t&&(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.og)(n),(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.vp)(e),r=!1,i()}}}function create_fragment(t){for(var n,e,o,r,i,c,a,l,u,s,f,d,v,p,_,h,g,m,b,y,E,w=t[3].length>0&&create_if_block_2(t),O=t[3],L=[],C=0;C<O.length;C+=1)L[C]=create_each_block(get_each_context(t,O,C));var T=null;O.length||(T=create_else_block(t));var D=t[1].length>0&&create_if_block_1(t),R=t[4].length>0&&create_if_block(t);return{c:function(){n=(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.bG)("form"),(e=(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.bG)("button")).textContent="OK",o=(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.Dh)(),r=(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.bG)("ul"),w&&w.c(),i=(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.Dh)();for(var b=0;b<L.length;b+=1)L[b].c();T&&T.c(),c=(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.Dh)(),a=(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.bG)("div"),D&&D.c(),l=(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.Dh)(),u=(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.bG)("textarea"),s=(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.Dh)(),f=(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.bG)("form"),(d=(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.bG)("button")).textContent="Filter",v=(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.Dh)(),p=(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.bG)("ul"),_=(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.Dh)(),h=(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.bG)("div"),R&&R.c(),g=(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.Dh)(),m=(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.bG)("textarea"),(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.Lj)(e,"class","vc-cmd-btn"),(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.Lj)(e,"type","submit"),(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.Lj)(r,"class","vc-cmd-prompted"),(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.Lj)(r,"style",t[2]),(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.Lj)(u,"class","vc-cmd-input"),(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.Lj)(u,"placeholder","command..."),(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.Lj)(a,"class","vc-cmd-input-wrap"),(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.Lj)(n,"class","vc-cmd"),(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.Lj)(d,"class","vc-cmd-btn"),(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.Lj)(d,"type","submit"),(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.Lj)(p,"class","vc-cmd-prompted"),(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.Lj)(m,"class","vc-cmd-input"),(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.Lj)(m,"placeholder","filter..."),(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.Lj)(h,"class","vc-cmd-input-wrap"),(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.Lj)(f,"class","vc-cmd vc-filter")},m:function(O,C){(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.$T)(O,n,C),(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.R3)(n,e),(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.R3)(n,o),(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.R3)(n,r),w&&w.m(r,null),(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.R3)(r,i);for(var x=0;x<L.length;x+=1)L[x].m(r,null);T&&T.m(r,null),(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.R3)(n,c),(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.R3)(n,a),D&&D.m(a,null),(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.R3)(a,l),(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.R3)(a,u),(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.Bm)(u,t[1]),t[16](u),(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.$T)(O,s,C),(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.$T)(O,f,C),(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.R3)(f,d),(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.R3)(f,v),(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.R3)(f,p),(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.R3)(f,_),(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.R3)(f,h),R&&R.m(h,null),(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.R3)(h,g),(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.R3)(h,m),(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.Bm)(m,t[4]),b=!0,y||(E=[(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.oL)(u,"input",t[15]),(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.oL)(u,"keyup",t[10]),(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.oL)(u,"focus",t[8]),(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.oL)(u,"blur",t[9]),(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.oL)(n,"submit",(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.AT)(t[11])),(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.oL)(m,"input",t[18]),(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.oL)(f,"submit",(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.AT)(t[12]))],y=!0)},p:function(t,n){var e=n[0];if(t[3].length>0?w?w.p(t,e):((w=create_if_block_2(t)).c(),w.m(r,i)):w&&(w.d(1),w=null),136&e){var o;for(O=t[3],o=0;o<O.length;o+=1){var c=get_each_context(t,O,o);L[o]?L[o].p(c,e):(L[o]=create_each_block(c),L[o].c(),L[o].m(r,null))}for(;o<L.length;o+=1)L[o].d(1);L.length=O.length,O.length?T&&(T.d(1),T=null):T||((T=create_else_block(t)).c(),T.m(r,null))}(!b||4&e)&&(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.Lj)(r,"style",t[2]),t[1].length>0?D?(D.p(t,e),2&e&&(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.Ui)(D,1)):((D=create_if_block_1(t)).c(),(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.Ui)(D,1),D.m(a,l)):D&&((0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dv)(),(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.et)(D,1,1,(function(){D=null})),(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.gb)()),2&e&&(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.Bm)(u,t[1]),t[4].length>0?R?(R.p(t,e),16&e&&(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.Ui)(R,1)):((R=create_if_block(t)).c(),(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.Ui)(R,1),R.m(h,g)):R&&((0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dv)(),(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.et)(R,1,1,(function(){R=null})),(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.gb)()),16&e&&(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.Bm)(m,t[4])},i:function(t){b||((0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.Ui)(D),(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.Ui)(R),b=!0)},o:function(t){(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.et)(D),(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.et)(R),b=!1},d:function(e){e&&(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.og)(n),w&&w.d(),(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.RM)(L,e),T&&T.d(),D&&D.d(),t[16](null),e&&(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.og)(s),e&&(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.og)(f),R&&R.d(),y=!1,(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.j7)(E)}}}function instance($$self,$$props,$$invalidate){var module=_log_model__WEBPACK_IMPORTED_MODULE_3__.W.getSingleton(_log_model__WEBPACK_IMPORTED_MODULE_3__.W,"VConsoleLogModel"),cachedObjKeys={},dispatch=(0,svelte__WEBPACK_IMPORTED_MODULE_1__.x)(),cmdElement,cmdValue="",promptedStyle="",promptedList=[],filterValue="";(0,svelte__WEBPACK_IMPORTED_MODULE_1__.H3)((function(){_logCommand_less__WEBPACK_IMPORTED_MODULE_4__.Z.use()})),(0,svelte__WEBPACK_IMPORTED_MODULE_1__.ev)((function(){_logCommand_less__WEBPACK_IMPORTED_MODULE_4__.Z.unuse()}));var evalCommand=function(t){module.evalCommand(t)},moveCursorToPos=function(t,n){t.setSelectionRange&&setTimeout((function(){t.setSelectionRange(n,n)}),1)},clearPromptedList=function(){$$invalidate(2,promptedStyle="display: none;"),$$invalidate(3,promptedList=[])},updatePromptedList=function updatePromptedList(identifier){if(""!==cmdValue){identifier||(identifier=(0,_logTool__WEBPACK_IMPORTED_MODULE_5__.oj)(cmdValue));var objName="window",keyName=cmdValue;if("."!==identifier.front.text&&"["!==identifier.front.text||(objName=identifier.front.before,keyName=""!==identifier.back.text?identifier.back.before:identifier.front.after),keyName=keyName.replace(/(^['"]+)|(['"']+$)/g,""),!cachedObjKeys[objName])try{cachedObjKeys[objName]=Object.getOwnPropertyNames(eval("("+objName+")")).sort()}catch(t){}try{if(cachedObjKeys[objName])for(var i=0;i<cachedObjKeys[objName].length&&!(promptedList.length>=100);i++){var key=String(cachedObjKeys[objName][i]),keyPattern=new RegExp("^"+keyName,"i");if(keyPattern.test(key)){var completeCmd=objName;"."===identifier.front.text||""===identifier.front.text?completeCmd+="."+key:"["===identifier.front.text&&(completeCmd+="['"+key+"']"),promptedList.push({text:key,value:completeCmd})}}}catch(t){}if(promptedList.length>0){var m=Math.min(200,31*(promptedList.length+1));$$invalidate(2,promptedStyle="display: block; height: "+m+"px; margin-top: "+(-m-2)+"px;"),$$invalidate(3,promptedList)}else clearPromptedList()}else clearPromptedList()},autoCompleteBrackets=function(t,n){if(!(8===n||46===n)&&""===t.front.after)switch(t.front.text){case"[":return $$invalidate(1,cmdValue+="]"),void moveCursorToPos(cmdElement,cmdValue.length-1);case"(":return $$invalidate(1,cmdValue+=")"),void moveCursorToPos(cmdElement,cmdValue.length-1);case"{":return $$invalidate(1,cmdValue+="}"),void moveCursorToPos(cmdElement,cmdValue.length-1)}},dispatchFilterEvent=function(){dispatch("filterText",{filterText:filterValue})},onTapClearText=function(t){"cmd"===t?($$invalidate(1,cmdValue=""),clearPromptedList()):"filter"===t&&($$invalidate(4,filterValue=""),dispatchFilterEvent())},onTapPromptedItem=function onTapPromptedItem(item){var type="";try{type=eval("typeof "+item.value)}catch(t){}$$invalidate(1,cmdValue=item.value+("function"===type?"()":"")),clearPromptedList()},onCmdFocus=function(){updatePromptedList()},onCmdBlur=function(){},onCmdKeyUp=function(t){$$invalidate(3,promptedList=[]);var n=(0,_logTool__WEBPACK_IMPORTED_MODULE_5__.oj)(t.target.value);autoCompleteBrackets(n,t.keyCode),updatePromptedList(n)},onCmdSubmit=function(t){""!==cmdValue&&evalCommand(cmdValue),clearPromptedList()},onFilterSubmit=function(t){dispatchFilterEvent()},click_handler=function(t){return onTapPromptedItem(t)},click_handler_1=function(){return onTapClearText("cmd")};function textarea0_input_handler(){cmdValue=this.value,$$invalidate(1,cmdValue)}function textarea0_binding(t){svelte_internal__WEBPACK_IMPORTED_MODULE_0__.Vn[t?"unshift":"push"]((function(){$$invalidate(0,cmdElement=t)}))}var click_handler_2=function(){return onTapClearText("filter")};function textarea1_input_handler(){filterValue=this.value,$$invalidate(4,filterValue)}return[cmdElement,cmdValue,promptedStyle,promptedList,filterValue,clearPromptedList,onTapClearText,onTapPromptedItem,onCmdFocus,onCmdBlur,onCmdKeyUp,onCmdSubmit,onFilterSubmit,click_handler,click_handler_1,textarea0_input_handler,textarea0_binding,click_handler_2,textarea1_input_handler]}var LogCommand=function(t){function n(n){var e;return e=t.call(this)||this,(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.S1)(_assertThisInitialized(e),n,instance,create_fragment,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.N8,{}),e}return _inheritsLoose(n,t),n}(svelte_internal__WEBPACK_IMPORTED_MODULE_0__.f_);__webpack_exports__.Z=LogCommand},4687:function(t,n,e){"use strict";e.d(n,{x:function(){return r}});var o=e(4683),r=function(){var t=(0,o.fZ)({updateTime:0}),n=t.subscribe,e=t.set,r=t.update;return{subscribe:n,set:e,update:r,updateTime:function(){r((function(t){return t.updateTime=Date.now(),t}))}}}()},643:function(t,n,e){"use strict";e.d(n,{N:function(){return o}});var o=function(){function t(){this._onDataUpdateCallbacks=[]}return t.getSingleton=function(n,e){return e||(e=n.toString()),t.singleton[e]||(t.singleton[e]=new n),t.singleton[e]},t}();o.singleton={}},5103:function(t,n,e){"use strict";function o(t){return"[object Number]"===Object.prototype.toString.call(t)}function r(t){return"bigint"==typeof t}function i(t){return"string"==typeof t}function c(t){return"[object Array]"===Object.prototype.toString.call(t)}function a(t){return"boolean"==typeof t}function l(t){return void 0===t}function u(t){return null===t}function s(t){return"symbol"==typeof t}function f(t){return!("[object Object]"!==Object.prototype.toString.call(t)&&(o(t)||r(t)||i(t)||a(t)||c(t)||u(t)||d(t)||l(t)||s(t)))}function d(t){return"function"==typeof t}function v(t){return"object"==typeof HTMLElement?t instanceof HTMLElement:t&&"object"==typeof t&&null!==t&&1===t.nodeType&&"string"==typeof t.nodeName}function p(t){var n=Object.prototype.toString.call(t);return"[object Window]"===n||"[object DOMWindow]"===n||"[object global]"===n}function _(t){return Object.prototype.toString.call(t).replace(/\[object (.*)\]/,"$1")}e.d(n,{hj:function(){return o},C4:function(){return r},HD:function(){return i},kJ:function(){return c},jn:function(){return a},o8:function(){return l},Ft:function(){return u},yk:function(){return s},Kn:function(){return f},mf:function(){return d},kK:function(){return v},FJ:function(){return p},zl:function(){return _},DV:function(){return g},PO:function(){return m},Ak:function(){return E},rE:function(){return L},hZ:function(){return D},wz:function(){return R},KL:function(){return x},Kt:function(){return $},qr:function(){return M},MH:function(){return j},QK:function(){return I},_D:function(){return S},po:function(){return U},cF:function(){return A},QI:function(){return V}});var h=/(function|class) ([^ \{\()}]{1,})[\(| ]/;function g(t){var n;if(null==t)return"";var e=h.exec((null==t||null==(n=t.constructor)?void 0:n.toString())||"");return e&&e.length>1?e[2]:""}function m(t){var n,e=Object.prototype.hasOwnProperty;if(!t||"object"!=typeof t||t.nodeType||p(t))return!1;try{if(t.constructor&&!e.call(t,"constructor")&&!e.call(t.constructor.prototype,"isPrototypeOf"))return!1}catch(t){return!1}for(n in t);return void 0===n||e.call(t,n)}var b=/[<>&" ]/g,y=function(t){return{"<":"&lt;",">":"&gt;","&":"&amp;",'"':"&quot;"," ":"&nbsp;"}[t]};function E(t){return"string"!=typeof t&&"number"!=typeof t?t:String(t).replace(b,y)}var w=/[\n\t]/g,O=function(t){return{"\n":"\\n","\t":"\\t"}[t]};function L(t){return"string"!=typeof t?t:String(t).replace(w,O)}var C=function(t,n){void 0===n&&(n=0);var e="";if(i(t)){var o=t.length;n>0&&o>n&&(t=$(t,n)+"...("+x(R(t))+")"),e+='"'+L(t)+'"'}else s(t)?e+=String(t).replace(/^Symbol\((.*)\)$/i,'Symbol("$1")'):d(t)?e+=(t.name||"function")+"()":r(t)?e+=String(t)+"n":e+=String(t);return e},T=function t(n,e,o){if(void 0===o&&(o=0),f(n)||c(n))if(e.circularFinder(n)){if(c(n))e.ret+="(Circular Array)";else if(f){var r;e.ret+="(Circular "+((null==(r=n.constructor)?void 0:r.name)||"Object")+")"}}else{var i="{",a="}";c(n)&&(i="[",a="]"),e.ret+=i;for(var l=j(n),u=0;u<l.length;u++){var d=l[u];try{c(n)||(f(d)||c(d)||s(d)?e.ret+=Object.prototype.toString.call(d):e.ret+=d,e.ret+=": ")}catch(t){continue}try{var v=n[d];if(c(v))e.maxDepth>-1&&o>=e.maxDepth?e.ret+="Array("+v.length+")":t(v,e,o+1);else if(f(v)){var p;if(e.maxDepth>-1&&o>=e.maxDepth)e.ret+=((null==(p=v.constructor)?void 0:p.name)||"Object")+" {}";else t(v,e,o+1)}else e.ret+=C(v,e.keyMaxLen)}catch(t){e.ret+="(...)"}if(e.keyMaxLen>0&&e.ret.length>=10*e.keyMaxLen){e.ret+=", (...)";break}u<l.length-1&&(e.ret+=", ")}e.ret+=a}else e.ret+=C(n,e.keyMaxLen)};function D(t,n,e){void 0===n&&(n=-1),void 0===e&&(e=-1);var o,r={ret:"",maxDepth:n,keyMaxLen:e,circularFinder:(o=new WeakSet,function(t){if("object"==typeof t&&null!==t){if(o.has(t))return!0;o.add(t)}return!1})};return T(t,r),r.ret}function R(t){try{return encodeURI(t).split(/%(?:u[0-9A-F]{2})?[0-9A-F]{2}|./).length-1}catch(t){return 0}}function x(t){return t<=0?"":t>=1048576?(t/1024/1024).toFixed(1)+" MB":t>=1024?(t/1024).toFixed(1)+" KB":t+" B"}var P=/[^\x00-\xff]/g;function $(t,n){if(t.replace(P,"**").length>n)for(var e=Math.floor(n/2),o=t.length;e<o;e++){var r=t.substring(0,e);if(r.replace(P,"**").length>=n)return r}return t}var k=function(t,n){return String(t).localeCompare(String(n),void 0,{numeric:!0,sensitivity:"base"})};function M(t){return t.sort(k)}function j(t){return f(t)||c(t)?Object.keys(t):[]}function I(t){var n=j(t);return function(t){return f(t)||c(t)?Object.getOwnPropertyNames(t):[]}(t).filter((function(t){return-1===n.indexOf(t)}))}function S(t){return f(t)||c(t)?Object.getOwnPropertySymbols(t):[]}function U(t,n){window.localStorage&&(t="vConsole_"+t,localStorage.setItem(t,n))}function A(t){if(window.localStorage)return t="vConsole_"+t,localStorage.getItem(t)}function V(t){return void 0===t&&(t=""),"__vc_"+t+Math.random().toString(36).substring(2,8)}},5629:function(t,n,e){"use strict";e.d(n,{W:function(){return u}});var o=e(5103),r=e(643),i=e(4687),c=e(8665),a=e(9923);function l(t,n){return(l=Object.setPrototypeOf||function(t,n){return t.__proto__=n,t})(t,n)}var u=function(t){var n,e;function r(){for(var n,e=arguments.length,o=new Array(e),r=0;r<e;r++)o[r]=arguments[r];return(n=t.call.apply(t,[this].concat(o))||this).LOG_METHODS=["log","info","warn","debug","error"],n.ADDED_LOG_PLUGIN_ID=[],n.maxLogNumber=1e3,n.logCounter=0,n.pluginPattern=void 0,n.origConsole={},n}e=t,(n=r).prototype=Object.create(e.prototype),n.prototype.constructor=n,l(n,e);var u=r.prototype;return u.bindPlugin=function(t){return!(this.ADDED_LOG_PLUGIN_ID.indexOf(t)>-1)&&(0===this.ADDED_LOG_PLUGIN_ID.length&&this.mockConsole(),a.O.create(t),this.ADDED_LOG_PLUGIN_ID.push(t),this.pluginPattern=new RegExp("^\\[("+this.ADDED_LOG_PLUGIN_ID.join("|")+")\\]$","i"),!0)},u.unbindPlugin=function(t){var n=this.ADDED_LOG_PLUGIN_ID.indexOf(t);return-1!==n&&(this.ADDED_LOG_PLUGIN_ID.splice(n,1),a.O.delete(t),0===this.ADDED_LOG_PLUGIN_ID.length&&this.unmockConsole(),!0)},u.mockConsole=function(){var t=this;if("function"!=typeof this.origConsole.log){var n=this.LOG_METHODS;window.console?(n.map((function(n){t.origConsole[n]=window.console[n]})),this.origConsole.time=window.console.time,this.origConsole.timeEnd=window.console.timeEnd,this.origConsole.clear=window.console.clear):window.console={},n.map((function(n){window.console[n]=function(){for(var e=arguments.length,o=new Array(e),r=0;r<e;r++)o[r]=arguments[r];t.addLog({type:n,origData:o||[]})}.bind(window.console)}));var e={};window.console.time=function(t){void 0===t&&(t=""),e[t]=Date.now()}.bind(window.console),window.console.timeEnd=function(t){void 0===t&&(t="");var n=e[t];n?(console.log(t+":",Date.now()-n+"ms"),delete e[t]):console.log(t+": 0ms")}.bind(window.console),window.console.clear=function(){t.clearLog();for(var n=arguments.length,e=new Array(n),o=0;o<n;o++)e[o]=arguments[o];t.callOriginalConsole.apply(t,["clear"].concat(e))}.bind(window.console),window._vcOrigConsole=this.origConsole}},u.unmockConsole=function(){for(var t in this.origConsole)window.console[t]=this.origConsole[t];window._vcOrigConsole&&delete window._vcOrigConsole},u.callOriginalConsole=function(t){if("function"==typeof this.origConsole[t]){for(var n=arguments.length,e=new Array(n>1?n-1:0),o=1;o<n;o++)e[o-1]=arguments[o];this.origConsole[t].apply(window.console,e)}},u.clearLog=function(){var t=a.O.getAll();for(var n in t)t[n].update((function(t){return t.logList=[],t}))},u.clearPluginLog=function(t){a.O.get(t).update((function(t){return t.logList=[],t}))},u.addLog=function(t,n){void 0===t&&(t={type:"log",origData:[]});var e={_id:o.QI(),type:t.type,cmdType:null==n?void 0:n.cmdType,date:Date.now(),data:(0,c.b1)(t.origData||[])},r=this._extractPluginIdByLog(e);this._isRepeatedLog(r,e)?this._updateLastLogRepeated(r):(this._pushLogList(r,e),this._limitLogListLength()),null!=n&&n.noOrig||this.callOriginalConsole.apply(this,[t.type].concat(t.origData))},u.evalCommand=function(t){this.addLog({type:"log",origData:[t]},{cmdType:"input"});var n=void 0;try{n=eval.call(window,"("+t+")")}catch(e){try{n=eval.call(window,t)}catch(t){}}this.addLog({type:"log",origData:[n]},{cmdType:"output"})},u._extractPluginIdByLog=function(t){var n,e="default",r=null==(n=t.data[0])?void 0:n.origData;if(o.HD(r)){var i=r.match(this.pluginPattern);if(null!==i&&i.length>1){var c=i[1].toLowerCase();this.ADDED_LOG_PLUGIN_ID.indexOf(c)>-1&&(e=c,t.data.shift())}}return e},u._isRepeatedLog=function(t,n){var e=a.O.getRaw(t),o=e.logList[e.logList.length-1];if(!o)return!1;var r=!1;if(n.type===o.type&&n.cmdType===o.cmdType&&n.data.length===o.data.length){r=!0;for(var i=0;i<n.data.length;i++)if(n.data[i].origData!==o.data[i].origData){r=!1;break}}return r},u._updateLastLogRepeated=function(t){a.O.get(t).update((function(t){var n=t.logList,e=n[n.length-1];return e.repeated=e.repeated?e.repeated+1:2,t}))},u._pushLogList=function(t,n){a.O.get(t).update((function(t){return t.logList.push(n),t})),i.x.updateTime()},u._limitLogListLength=function(){var t=this;if(this.logCounter++,this.logCounter%10==0){this.logCounter=0;var n=a.O.getAll();for(var e in n)n[e].update((function(n){return n.logList.length>t.maxLogNumber&&n.logList.splice(0,n.logList.length-t.maxLogNumber+10),n}))}},r}(r.N)},9923:function(t,n,e){"use strict";e.d(n,{O:function(){return r}});var o=e(4683),r=function(){function t(){}return t.create=function(t){return this.storeMap[t]||(this.storeMap[t]=(0,o.fZ)({logList:[]})),this.storeMap[t]},t.delete=function(t){this.storeMap[t]&&delete this.storeMap[t]},t.get=function(t){return this.storeMap[t]},t.getRaw=function(t){return(0,o.U2)(this.storeMap[t])},t.getAll=function(){return this.storeMap},t}();r.storeMap={}},8665:function(t,n,e){"use strict";e.d(n,{LH:function(){return i},oj:function(){return u},HX:function(){return s},b1:function(){return d},Tg:function(){return v}});var o=e(5103),r=function(t){var n=o.hZ(t,0),e=n.substr(0,36),r=o.DV(t);return n.length>36&&(e+="..."),r=o.rE(r+" "+e)},i=function(t,n){void 0===n&&(n=!0);var e="undefined",i=t;return t instanceof v?(e="uninvocatable",i="(...)"):o.kJ(t)?(e="array",i=r(t)):o.Kn(t)?(e="object",i=r(t)):o.HD(t)?(e="string",i=o.rE(t),n&&(i='"'+i+'"')):o.hj(t)?(e="number",i=String(t)):o.C4(t)?(e="bigint",i=String(t)+"n"):o.jn(t)?(e="boolean",i=String(t)):o.Ft(t)?(e="null",i="null"):o.o8(t)?(e="undefined",i="undefined"):o.mf(t)?(e="function",i=(t.name||"function")+"()"):o.yk(t)&&(e="symbol",i=String(t)),{text:i,valueType:e}},c=[".","[","(","{","}"],a=["]",")","}"],l=function(t,n,e){void 0===e&&(e=0);for(var o={text:"",pos:-1,before:"",after:""},r=t.length-1;r>=e;r--){var i=n.indexOf(t[r]);if(i>-1){o.text=n[i],o.pos=r,o.before=t.substring(e,r),o.after=t.substring(r+1,t.length);break}}return o},u=function(t){var n=l(t,c,0);return{front:n,back:l(t,a,n.pos+1)}},s=function(t,n){if(""===n)return!0;for(var e=0;e<t.data.length;e++){if("string"===typeof t.data[e].origData&&t.data[e].origData.indexOf(n)>-1)return!0}return!1},f=/(\%[csdo] )|( \%[csdo])/g,d=function(t){if(f.lastIndex=0,o.HD(t[0])&&f.test(t[0])){for(var n,e=[].concat(t),r=e.shift().split(f).filter((function(t){return void 0!==t&&""!==t})),i=e,c=[],a=!1,l="";r.length>0;){var u=r.shift();if(/ ?\%c ?/.test(u)?i.length>0?"string"!=typeof(l=i.shift())&&(l=""):(n=u,l="",a=!0):/ ?\%[sd] ?/.test(u)?(n=i.length>0?o.Kn(i[0])?o.DV(i.shift()):String(i.shift()):u,a=!0):/ ?\%o ?/.test(u)?(n=i.length>0?i.shift():u,a=!0):(n=u,a=!0),a){var s={origData:n};l&&(s.style=l),c.push(s),a=!1,n=void 0,l=""}}for(var d=0;d<i.length;d++)c.push({origData:i[d]});return c}for(var v=[],p=0;p<t.length;p++)v.push({origData:t[p]});return v},v=function(){}},9746:function(t,n,e){"use strict";var o=e(7705),r=e.n(o)()((function(t){return t[1]}));r.push([t.id,".vc-icon {\n  word-break: normal;\n  white-space: normal;\n  overflow: visible;\n}\n.vc-icon svg {\n  fill: var(--VC-FG-2);\n  height: 1em;\n  width: 1em;\n  vertical-align: -0.11em;\n}\n.vc-icon .vc-icon-delete {\n  vertical-align: -0.11em;\n}\n.vc-icon .vc-icon-copy {\n  height: 1.1em;\n  width: 1.1em;\n  vertical-align: -0.16em;\n}\n.vc-icon .vc-icon-suc {\n  fill: var(--VC-TEXTGREEN);\n  height: 1.1em;\n  width: 1.1em;\n  vertical-align: -0.16em;\n}\n",""]),n.Z=r},3283:function(t,n,e){"use strict";var o=e(7705),r=e.n(o)()((function(t){return t[1]}));r.push([t.id,'#__vconsole {\n  --VC-BG-0: #ededed;\n  --VC-BG-1: #f7f7f7;\n  --VC-BG-2: #fff;\n  --VC-BG-3: #f7f7f7;\n  --VC-BG-4: #4c4c4c;\n  --VC-BG-5: #fff;\n  --VC-BG-6: rgba(0, 0, 0, 0.1);\n  --VC-FG-0: rgba(0, 0, 0, 0.9);\n  --VC-FG-HALF: rgba(0, 0, 0, 0.9);\n  --VC-FG-1: rgba(0, 0, 0, 0.5);\n  --VC-FG-2: rgba(0, 0, 0, 0.3);\n  --VC-FG-3: rgba(0, 0, 0, 0.1);\n  --VC-RED: #fa5151;\n  --VC-ORANGE: #fa9d3b;\n  --VC-YELLOW: #ffc300;\n  --VC-GREEN: #91d300;\n  --VC-LIGHTGREEN: #95ec69;\n  --VC-BRAND: #07c160;\n  --VC-BLUE: #10aeff;\n  --VC-INDIGO: #1485ee;\n  --VC-PURPLE: #6467f0;\n  --VC-LINK: #576b95;\n  --VC-TEXTGREEN: #06ae56;\n  --VC-FG: black;\n  --VC-BG: white;\n  --VC-BG-COLOR-ACTIVE: #ececec;\n  --VC-WARN-BG: #fff3cc;\n  --VC-WARN-BORDER: #ffe799;\n  --VC-ERROR-BG: #fedcdc;\n  --VC-ERROR-BORDER: #fdb9b9;\n  --VC-DOM-TAG-NAME-COLOR: #881280;\n  --VC-DOM-ATTRIBUTE-NAME-COLOR: #994500;\n  --VC-DOM-ATTRIBUTE-VALUE-COLOR: #1a1aa6;\n  --VC-CODE-KEY-FG: #881391;\n  --VC-CODE-PRIVATE-KEY-FG: #cfa1d3;\n  --VC-CODE-FUNC-FG: #0d22aa;\n  --VC-CODE-NUMBER-FG: #1c00cf;\n  --VC-CODE-STR-FG: #c41a16;\n  --VC-CODE-NULL-FG: #808080;\n  color: var(--VC-FG-0);\n  font-size: 13px;\n  font-family: Helvetica Neue, Helvetica, Arial, sans-serif;\n  -webkit-user-select: auto;\n  /* global */\n}\n#__vconsole .vc-max-height {\n  max-height: 19.23076923em;\n}\n#__vconsole .vc-max-height-line {\n  max-height: 3.38461538em;\n}\n#__vconsole .vc-min-height {\n  min-height: 3.07692308em;\n}\n#__vconsole dd,\n#__vconsole dl,\n#__vconsole pre {\n  margin: 0;\n}\n#__vconsole i {\n  font-style: normal;\n}\n.vc-table .vc-table-row {\n  line-height: 1.5;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -moz-box;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-orient: horizontal;\n  -webkit-box-direction: normal;\n  -webkit-flex-direction: row;\n  -moz-box-orient: horizontal;\n  -moz-box-direction: normal;\n  -ms-flex-direction: row;\n  flex-direction: row;\n  -webkit-flex-wrap: wrap;\n  -ms-flex-wrap: wrap;\n  flex-wrap: wrap;\n  overflow: hidden;\n  border-bottom: 1px solid var(--VC-FG-3);\n}\n.vc-table .vc-table-row.vc-left-border {\n  border-left: 1px solid var(--VC-FG-3);\n}\n.vc-table .vc-table-row-icon {\n  margin-left: 4px;\n}\n.vc-table .vc-table-col {\n  -webkit-box-flex: 1;\n  -webkit-flex: 1;\n  -moz-box-flex: 1;\n  -ms-flex: 1;\n  flex: 1;\n  padding: 0.23076923em 0.30769231em;\n  border-left: 1px solid var(--VC-FG-3);\n  overflow: auto;\n}\n.vc-table .vc-table-col:first-child {\n  border: none;\n}\n.vc-table .vc-table-col-value {\n  white-space: pre-wrap;\n  word-break: break-word;\n  /*white-space: nowrap;\n    text-overflow: ellipsis;*/\n  -webkit-overflow-scrolling: touch;\n}\n.vc-table .vc-small .vc-table-col {\n  padding: 0 0.30769231em;\n  font-size: 0.92307692em;\n}\n.vc-table .vc-table-col-2 {\n  -webkit-box-flex: 2;\n  -webkit-flex: 2;\n  -moz-box-flex: 2;\n  -ms-flex: 2;\n  flex: 2;\n}\n.vc-table .vc-table-col-3 {\n  -webkit-box-flex: 3;\n  -webkit-flex: 3;\n  -moz-box-flex: 3;\n  -ms-flex: 3;\n  flex: 3;\n}\n.vc-table .vc-table-col-4 {\n  -webkit-box-flex: 4;\n  -webkit-flex: 4;\n  -moz-box-flex: 4;\n  -ms-flex: 4;\n  flex: 4;\n}\n.vc-table .vc-table-col-5 {\n  -webkit-box-flex: 5;\n  -webkit-flex: 5;\n  -moz-box-flex: 5;\n  -ms-flex: 5;\n  flex: 5;\n}\n.vc-table .vc-table-col-6 {\n  -webkit-box-flex: 6;\n  -webkit-flex: 6;\n  -moz-box-flex: 6;\n  -ms-flex: 6;\n  flex: 6;\n}\n.vc-table .vc-table-row-error {\n  border-color: var(--VC-ERROR-BORDER);\n  background-color: var(--VC-ERROR-BG);\n}\n.vc-table .vc-table-row-error .vc-table-col {\n  color: var(--VC-RED);\n  border-color: var(--VC-ERROR-BORDER);\n}\n.vc-table .vc-table-col-title {\n  font-weight: bold;\n}\n.vc-table .vc-table-action {\n  display: flex;\n  justify-content: space-evenly;\n}\n.vc-table .vc-table-action .vc-icon {\n  flex: 1;\n  text-align: center;\n  display: block;\n}\n.vc-table .vc-table-action .vc-icon:hover {\n  background: var(--VC-BG-3);\n}\n.vc-table .vc-table-action .vc-icon:active {\n  background: var(--VC-BG-1);\n}\n.vc-table .vc-table-input {\n  width: 100%;\n  border: none;\n  color: var(--VC-FG-0);\n  background-color: var(--VC-BG-6);\n  height: 3.53846154em;\n}\n.vc-table .vc-table-input:focus {\n  background-color: var(--VC-FG-2);\n}\n@media (prefers-color-scheme: dark) {\n  #__vconsole:not([data-theme="light"]) {\n    --VC-BG-0: #191919;\n    --VC-BG-1: #1f1f1f;\n    --VC-BG-2: #232323;\n    --VC-BG-3: #2f2f2f;\n    --VC-BG-4: #606060;\n    --VC-BG-5: #2c2c2c;\n    --VC-BG-6: rgba(255, 255, 255, 0.2);\n    --VC-FG-0: rgba(255, 255, 255, 0.8);\n    --VC-FG-HALF: rgba(255, 255, 255, 0.6);\n    --VC-FG-1: rgba(255, 255, 255, 0.5);\n    --VC-FG-2: rgba(255, 255, 255, 0.3);\n    --VC-FG-3: rgba(255, 255, 255, 0.05);\n    --VC-RED: #fa5151;\n    --VC-ORANGE: #c87d2f;\n    --VC-YELLOW: #cc9c00;\n    --VC-GREEN: #74a800;\n    --VC-LIGHTGREEN: #28b561;\n    --VC-BRAND: #07c160;\n    --VC-BLUE: #10aeff;\n    --VC-INDIGO: #1196ff;\n    --VC-PURPLE: #8183ff;\n    --VC-LINK: #7d90a9;\n    --VC-TEXTGREEN: #259c5c;\n    --VC-FG: white;\n    --VC-BG: black;\n    --VC-BG-COLOR-ACTIVE: #282828;\n    --VC-WARN-BG: #332700;\n    --VC-WARN-BORDER: #664e00;\n    --VC-ERROR-BG: #321010;\n    --VC-ERROR-BORDER: #642020;\n    --VC-DOM-TAG-NAME-COLOR: #5DB0D7;\n    --VC-DOM-ATTRIBUTE-NAME-COLOR: #9BBBDC;\n    --VC-DOM-ATTRIBUTE-VALUE-COLOR: #f29766;\n    --VC-CODE-KEY-FG: #e36eec;\n    --VC-CODE-PRIVATE-KEY-FG: #f4c5f7;\n    --VC-CODE-FUNC-FG: #556af2;\n    --VC-CODE-NUMBER-FG: #9980ff;\n    --VC-CODE-STR-FG: #e93f3b;\n    --VC-CODE-NULL-FG: #808080;\n  }\n}\n#__vconsole[data-theme="dark"] {\n  --VC-BG-0: #191919;\n  --VC-BG-1: #1f1f1f;\n  --VC-BG-2: #232323;\n  --VC-BG-3: #2f2f2f;\n  --VC-BG-4: #606060;\n  --VC-BG-5: #2c2c2c;\n  --VC-BG-6: rgba(255, 255, 255, 0.2);\n  --VC-FG-0: rgba(255, 255, 255, 0.8);\n  --VC-FG-HALF: rgba(255, 255, 255, 0.6);\n  --VC-FG-1: rgba(255, 255, 255, 0.5);\n  --VC-FG-2: rgba(255, 255, 255, 0.3);\n  --VC-FG-3: rgba(255, 255, 255, 0.05);\n  --VC-RED: #fa5151;\n  --VC-ORANGE: #c87d2f;\n  --VC-YELLOW: #cc9c00;\n  --VC-GREEN: #74a800;\n  --VC-LIGHTGREEN: #28b561;\n  --VC-BRAND: #07c160;\n  --VC-BLUE: #10aeff;\n  --VC-INDIGO: #1196ff;\n  --VC-PURPLE: #8183ff;\n  --VC-LINK: #7d90a9;\n  --VC-TEXTGREEN: #259c5c;\n  --VC-FG: white;\n  --VC-BG: black;\n  --VC-BG-COLOR-ACTIVE: #282828;\n  --VC-WARN-BG: #332700;\n  --VC-WARN-BORDER: #664e00;\n  --VC-ERROR-BG: #321010;\n  --VC-ERROR-BORDER: #642020;\n  --VC-DOM-TAG-NAME-COLOR: #5DB0D7;\n  --VC-DOM-ATTRIBUTE-NAME-COLOR: #9BBBDC;\n  --VC-DOM-ATTRIBUTE-VALUE-COLOR: #f29766;\n  --VC-CODE-KEY-FG: #e36eec;\n  --VC-CODE-PRIVATE-KEY-FG: #f4c5f7;\n  --VC-CODE-FUNC-FG: #556af2;\n  --VC-CODE-NUMBER-FG: #9980ff;\n  --VC-CODE-STR-FG: #e93f3b;\n  --VC-CODE-NULL-FG: #808080;\n}\n.vc-mask {\n  display: none;\n  position: fixed;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  background: rgba(0, 0, 0, 0);\n  z-index: 10001;\n  -webkit-transition: background 0.3s;\n  transition: background 0.3s;\n  -webkit-tap-highlight-color: transparent;\n  overflow-y: scroll;\n}\n.vc-panel {\n  display: none;\n  position: fixed;\n  min-height: 85%;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  z-index: 10002;\n  background-color: var(--VC-BG-0);\n  -webkit-transition: -webkit-transform 0.3s;\n  transition: -webkit-transform 0.3s;\n  transition: transform 0.3s;\n  transition: transform 0.3s, -webkit-transform 0.3s;\n  -webkit-transform: translate(0, 100%);\n  transform: translate(0, 100%);\n}\n.vc-toggle .vc-switch {\n  display: none;\n}\n.vc-toggle .vc-mask {\n  background: rgba(0, 0, 0, 0.6);\n  display: block;\n}\n.vc-toggle .vc-panel {\n  -webkit-transform: translate(0, 0);\n  transform: translate(0, 0);\n}\n.vc-content {\n  background-color: var(--VC-BG-2);\n  overflow-x: hidden;\n  overflow-y: auto;\n  position: absolute;\n  top: 3.07692308em;\n  left: 0;\n  right: 0;\n  bottom: 3.07692308em;\n  -webkit-overflow-scrolling: touch;\n  margin-bottom: constant(safe-area-inset-bottom);\n  margin-bottom: env(safe-area-inset-bottom);\n}\n.vc-content.vc-has-topbar {\n  top: 5.46153846em;\n}\n.vc-plugin-box {\n  display: none;\n  position: relative;\n  min-height: 100%;\n}\n.vc-plugin-box.vc-actived {\n  display: block;\n}\n.vc-plugin-content {\n  padding-bottom: 6em;\n  -webkit-tap-highlight-color: transparent;\n}\n.vc-plugin-empty:before,\n.vc-plugin-content:empty:before {\n  content: "Empty";\n  color: var(--VC-FG-1);\n  position: absolute;\n  top: 45%;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  font-size: 1.15384615em;\n  text-align: center;\n}\n@supports (bottom: constant(safe-area-inset-bottom)) or (bottom: env(safe-area-inset-bottom)) {\n  .vc-toolbar,\n  .vc-switch {\n    bottom: constant(safe-area-inset-bottom);\n    bottom: env(safe-area-inset-bottom);\n  }\n}\n.vc-tabbar {\n  border-bottom: 1px solid var(--VC-FG-3);\n  overflow-x: auto;\n  height: 3em;\n  width: auto;\n  white-space: nowrap;\n}\n.vc-tabbar .vc-tab {\n  display: inline-block;\n  line-height: 3em;\n  padding: 0 1.15384615em;\n  border-right: 1px solid var(--VC-FG-3);\n  text-decoration: none;\n  color: var(--VC-FG-0);\n  -webkit-tap-highlight-color: transparent;\n  -webkit-touch-callout: none;\n}\n.vc-tabbar .vc-tab:active {\n  background-color: rgba(0, 0, 0, 0.15);\n}\n.vc-tabbar .vc-tab.vc-actived {\n  background-color: var(--VC-BG-1);\n}\n.vc-toolbar {\n  border-top: 1px solid var(--VC-FG-3);\n  line-height: 3em;\n  position: absolute;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -moz-box;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-orient: horizontal;\n  -webkit-box-direction: normal;\n  -webkit-flex-direction: row;\n  -moz-box-orient: horizontal;\n  -moz-box-direction: normal;\n  -ms-flex-direction: row;\n  flex-direction: row;\n}\n.vc-toolbar .vc-tool {\n  display: none;\n  font-style: normal;\n  text-decoration: none;\n  color: var(--VC-FG-0);\n  width: 50%;\n  -webkit-box-flex: 1;\n  -webkit-flex: 1;\n  -moz-box-flex: 1;\n  -ms-flex: 1;\n  flex: 1;\n  text-align: center;\n  position: relative;\n  -webkit-touch-callout: none;\n}\n.vc-toolbar .vc-tool.vc-toggle,\n.vc-toolbar .vc-tool.vc-global-tool {\n  display: block;\n}\n.vc-toolbar .vc-tool:active {\n  background-color: rgba(0, 0, 0, 0.15);\n}\n.vc-toolbar .vc-tool:after {\n  content: " ";\n  position: absolute;\n  top: 0.53846154em;\n  bottom: 0.53846154em;\n  right: 0;\n  border-left: 1px solid var(--VC-FG-3);\n}\n.vc-toolbar .vc-tool-last:after {\n  border: none;\n}\n.vc-topbar {\n  background-color: var(--VC-BG-1);\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -moz-box;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-orient: horizontal;\n  -webkit-box-direction: normal;\n  -webkit-flex-direction: row;\n  -moz-box-orient: horizontal;\n  -moz-box-direction: normal;\n  -ms-flex-direction: row;\n  flex-direction: row;\n  -webkit-flex-wrap: wrap;\n  -ms-flex-wrap: wrap;\n  flex-wrap: wrap;\n  width: 100%;\n}\n.vc-topbar .vc-toptab {\n  display: none;\n  -webkit-box-flex: 1;\n  -webkit-flex: 1;\n  -moz-box-flex: 1;\n  -ms-flex: 1;\n  flex: 1;\n  line-height: 2.30769231em;\n  padding: 0 1.15384615em;\n  border-bottom: 1px solid var(--VC-FG-3);\n  text-decoration: none;\n  text-align: center;\n  color: var(--VC-FG-0);\n  -webkit-tap-highlight-color: transparent;\n  -webkit-touch-callout: none;\n}\n.vc-topbar .vc-toptab.vc-toggle {\n  display: block;\n}\n.vc-topbar .vc-toptab:active {\n  background-color: rgba(0, 0, 0, 0.15);\n}\n.vc-topbar .vc-toptab.vc-actived {\n  border-bottom: 1px solid var(--VC-INDIGO);\n}\n',""]),n.Z=r},7558:function(t,n,e){"use strict";var o=e(7705),r=e.n(o)()((function(t){return t[1]}));r.push([t.id,".vc-switch {\n  display: block;\n  position: fixed;\n  right: 0.76923077em;\n  bottom: 0.76923077em;\n  color: #FFF;\n  background-color: var(--VC-BRAND);\n  line-height: 1;\n  font-size: 1.07692308em;\n  padding: 0.61538462em 1.23076923em;\n  z-index: 10000;\n  border-radius: 0.30769231em;\n  box-shadow: 0 0 0.61538462em rgba(0, 0, 0, 0.4);\n}\n",""]),n.Z=r},5670:function(t,n,e){"use strict";var o=e(7705),r=e.n(o)()((function(t){return t[1]}));r.push([t.id,'/* color */\n.vcelm-node {\n  color: var(--VC-DOM-TAG-NAME-COLOR);\n}\n.vcelm-k {\n  color: var(--VC-DOM-ATTRIBUTE-NAME-COLOR);\n}\n.vcelm-v {\n  color: var(--VC-DOM-ATTRIBUTE-VALUE-COLOR);\n}\n.vcelm-l.vc-actived > .vcelm-node {\n  background-color: var(--VC-FG-3);\n}\n/* layout */\n.vcelm-l {\n  padding-left: 8px;\n  position: relative;\n  word-wrap: break-word;\n  line-height: 1.2;\n}\n/*.vcelm-l.vcelm-noc {\n  padding-left: 0;\n}*/\n.vcelm-l .vcelm-node:active {\n  background-color: var(--VC-BG-COLOR-ACTIVE);\n}\n.vcelm-l.vcelm-noc .vcelm-node:active {\n  background-color: transparent;\n}\n.vcelm-t {\n  white-space: pre-wrap;\n  word-wrap: break-word;\n}\n/* level */\n/* arrow */\n.vcelm-l:before {\n  content: "";\n  display: block;\n  position: absolute;\n  top: 6px;\n  left: 3px;\n  width: 0;\n  height: 0;\n  border: transparent solid 3px;\n  border-left-color: var(--VC-FG-1);\n}\n.vcelm-l.vc-toggle:before {\n  display: block;\n  top: 6px;\n  left: 0;\n  border-top-color: var(--VC-FG-1);\n  border-left-color: transparent;\n}\n.vcelm-l.vcelm-noc:before {\n  display: none;\n}\n',""]),n.Z=r},3327:function(t,n,e){"use strict";var o=e(7705),r=e.n(o)()((function(t){return t[1]}));r.push([t.id,".vc-logs-has-cmd {\n  padding-bottom: 6.15384615em;\n}\n",""]),n.Z=r},1130:function(t,n,e){"use strict";var o=e(7705),r=e.n(o)()((function(t){return t[1]}));r.push([t.id,".vc-cmd {\n  position: absolute;\n  height: 3.07692308em;\n  left: 0;\n  right: 0;\n  bottom: 3.07692308em;\n  border-top: 1px solid var(--VC-FG-3);\n  display: block !important;\n}\n.vc-cmd.vc-filter {\n  bottom: 0;\n}\n.vc-cmd-input-wrap {\n  display: block;\n  position: relative;\n  height: 2.15384615em;\n  margin-right: 3.07692308em;\n  padding: 0.46153846em 0.61538462em;\n}\n.vc-cmd-input {\n  width: 100%;\n  border: none;\n  resize: none;\n  outline: none;\n  padding: 0;\n  font-size: 0.92307692em;\n  background-color: transparent;\n  color: var(--VC-FG-0);\n}\n.vc-cmd-input::-webkit-input-placeholder {\n  line-height: 2.15384615em;\n}\n.vc-cmd-btn {\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  width: 3.07692308em;\n  border: none;\n  background-color: var(--VC-BG-0);\n  color: var(--VC-FG-0);\n  outline: none;\n  -webkit-touch-callout: none;\n  font-size: 1em;\n}\n.vc-cmd-clear-btn {\n  position: absolute;\n  text-align: center;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  width: 3.07692308em;\n  line-height: 3.07692308em;\n}\n.vc-cmd-btn:active,\n.vc-cmd-clear-btn:active {\n  background-color: var(--VC-BG-COLOR-ACTIVE);\n}\n.vc-cmd-prompted {\n  position: absolute;\n  left: 0.46153846em;\n  right: 0.46153846em;\n  background-color: var(--VC-BG-3);\n  border: 1px solid var(--VC-FG-3);\n  overflow-x: scroll;\n  display: none;\n}\n.vc-cmd-prompted li {\n  list-style: none;\n  line-height: 30px;\n  padding: 0 0.46153846em;\n  border-bottom: 1px solid var(--VC-FG-3);\n}\n.vc-cmd-prompted li:active {\n  background-color: var(--VC-BG-COLOR-ACTIVE);\n}\n.vc-cmd-prompted-hide {\n  text-align: center;\n}\n",""]),n.Z=r},7147:function(t,n,e){"use strict";var o=e(7705),r=e.n(o)()((function(t){return t[1]}));r.push([t.id,'.vc-log-row {\n  margin: 0;\n  padding: 0.46153846em 0.61538462em;\n  overflow: hidden;\n  line-height: 1.3;\n  border-bottom: 1px solid var(--VC-FG-3);\n  word-break: break-word;\n  position: relative;\n}\n.vc-log-info {\n  color: var(--VC-PURPLE);\n}\n.vc-log-debug {\n  color: var(--VC-YELLOW);\n}\n.vc-log-warn {\n  color: var(--VC-ORANGE);\n  border-color: var(--VC-WARN-BORDER);\n  background-color: var(--VC-WARN-BG);\n}\n.vc-log-error {\n  color: var(--VC-RED);\n  border-color: var(--VC-ERROR-BORDER);\n  background-color: var(--VC-ERROR-BG);\n}\n.vc-logrow-icon {\n  float: right;\n}\n.vc-log-repeat {\n  float: left;\n  margin-right: 0.30769231em;\n  padding: 0 6.5px;\n  color: #D7E0EF;\n  background-color: #42597F;\n  border-radius: 8.66666667px;\n}\n.vc-log-error .vc-log-repeat {\n  color: #901818;\n  background-color: var(--VC-RED);\n}\n.vc-log-warn .vc-log-repeat {\n  color: #987D20;\n  background-color: #F4BD02;\n}\n.vc-log-input,\n.vc-log-output {\n  padding-left: 0.92307692em;\n}\n.vc-log-input:before,\n.vc-log-output:before {\n  content: "";\n  position: absolute;\n  top: 0.15384615em;\n  left: 0;\n  font-size: 1.23076923em;\n  color: #6A5ACD;\n}\n.vc-log-output:before {\n  content: "";\n}\n',""]),n.Z=r},1237:function(t,n,e){"use strict";var o=e(7705),r=e.n(o)()((function(t){return t[1]}));r.push([t.id,'.vc-log-tree {\n  display: block;\n  overflow: auto;\n  position: relative;\n  -webkit-overflow-scrolling: touch;\n}\n.vc-log-tree-node {\n  display: block;\n  font-style: italic;\n  padding-left: 0.76923077em;\n  position: relative;\n}\n.vc-log-tree.vc-is-tree > .vc-log-tree-node:active {\n  background-color: var(--VC-BG-COLOR-ACTIVE);\n}\n.vc-log-tree.vc-is-tree > .vc-log-tree-node::before {\n  content: "";\n  position: absolute;\n  top: 0.30769231em;\n  left: 0.15384615em;\n  width: 0;\n  height: 0;\n  border: transparent solid 0.30769231em;\n  border-left-color: var(--VC-FG-1);\n}\n.vc-log-tree.vc-is-tree.vc-toggle > .vc-log-tree-node::before {\n  top: 0.46153846em;\n  left: 0;\n  border-top-color: var(--VC-FG-1);\n  border-left-color: transparent;\n}\n.vc-log-tree-child {\n  margin-left: 0.76923077em;\n}\n.vc-log-tree-loadmore {\n  text-decoration: underline;\n  padding-left: 1.84615385em;\n  position: relative;\n  color: var(--VC-CODE-FUNC-FG);\n}\n.vc-log-tree-loadmore::before {\n  content: "";\n  position: absolute;\n  top: -0.15384615em;\n  left: 0.76923077em;\n  font-size: 1.23076923em;\n  color: var(--VC-CODE-FUNC-FG);\n}\n.vc-log-tree-loadmore:active {\n  background-color: var(--VC-BG-COLOR-ACTIVE);\n}\n',""]),n.Z=r},845:function(t,n,e){"use strict";var o=e(7705),r=e.n(o)()((function(t){return t[1]}));r.push([t.id,".vc-log-key {\n  color: var(--VC-CODE-KEY-FG);\n}\n.vc-log-key-private {\n  color: var(--VC-CODE-PRIVATE-KEY-FG);\n}\n.vc-log-val {\n  white-space: pre-line;\n}\n.vc-log-val-function {\n  color: var(--VC-CODE-FUNC-FG);\n  font-style: italic !important;\n}\n.vc-log-val-bigint {\n  color: var(--VC-CODE-FUNC-FG);\n}\n.vc-log-val-number,\n.vc-log-val-boolean {\n  color: var(--VC-CODE-NUMBER-FG);\n}\n.vc-log-val-string.vc-log-val-haskey {\n  color: var(--VC-CODE-STR-FG);\n  white-space: normal;\n}\n.vc-log-val-null,\n.vc-log-val-undefined,\n.vc-log-val-uninvocatable {\n  color: var(--VC-CODE-NULL-FG);\n}\n.vc-log-val-symbol {\n  color: var(--VC-CODE-STR-FG);\n}\n",""]),n.Z=r},8747:function(t,n,e){"use strict";var o=e(7705),r=e.n(o)()((function(t){return t[1]}));r.push([t.id,".vc-group .vc-group-preview {\n  -webkit-touch-callout: none;\n}\n.vc-group .vc-group-preview:active {\n  background-color: var(--VC-BG-COLOR-ACTIVE);\n}\n.vc-group .vc-group-detail {\n  display: none;\n  padding: 0 0 0.76923077em 1.53846154em;\n  border-bottom: 1px solid var(--VC-FG-3);\n}\n.vc-group.vc-actived .vc-group-detail {\n  display: block;\n  background-color: var(--VC-BG-1);\n}\n.vc-group.vc-actived .vc-table-row {\n  background-color: var(--VC-BG-2);\n}\n.vc-group.vc-actived .vc-group-preview {\n  background-color: var(--VC-BG-1);\n}\n",""]),n.Z=r},3411:function(t,n,e){"use strict";var o,r=e(3379),i=e.n(r),c=e(1130),a=0,l={injectType:"lazyStyleTag",insert:"head",singleton:!1},u={};u.locals=c.Z.locals||{},u.use=function(){return a++||(o=i()(c.Z,l)),u},u.unuse=function(){a>0&&!--a&&(o(),o=null)},n.Z=u},3379:function(t,n,e){"use strict";var o,r=function(){return void 0===o&&(o=Boolean(window&&document&&document.all&&!window.atob)),o},i=function(){var t={};return function(n){if(void 0===t[n]){var e=document.querySelector(n);if(window.HTMLIFrameElement&&e instanceof window.HTMLIFrameElement)try{e=e.contentDocument.head}catch(t){e=null}t[n]=e}return t[n]}}(),c=[];function a(t){for(var n=-1,e=0;e<c.length;e++)if(c[e].identifier===t){n=e;break}return n}function l(t,n){for(var e={},o=[],r=0;r<t.length;r++){var i=t[r],l=n.base?i[0]+n.base:i[0],u=e[l]||0,s="".concat(l," ").concat(u);e[l]=u+1;var f=a(s),d={css:i[1],media:i[2],sourceMap:i[3]};-1!==f?(c[f].references++,c[f].updater(d)):c.push({identifier:s,updater:h(d,n),references:1}),o.push(s)}return o}function u(t){var n=document.createElement("style"),o=t.attributes||{};if(void 0===o.nonce){var r=e.nc;r&&(o.nonce=r)}if(Object.keys(o).forEach((function(t){n.setAttribute(t,o[t])})),"function"==typeof t.insert)t.insert(n);else{var c=i(t.insert||"head");if(!c)throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");c.appendChild(n)}return n}var s,f=(s=[],function(t,n){return s[t]=n,s.filter(Boolean).join("\n")});function d(t,n,e,o){var r=e?"":o.media?"@media ".concat(o.media," {").concat(o.css,"}"):o.css;if(t.styleSheet)t.styleSheet.cssText=f(n,r);else{var i=document.createTextNode(r),c=t.childNodes;c[n]&&t.removeChild(c[n]),c.length?t.insertBefore(i,c[n]):t.appendChild(i)}}function v(t,n,e){var o=e.css,r=e.media,i=e.sourceMap;if(r?t.setAttribute("media",r):t.removeAttribute("media"),i&&"undefined"!=typeof btoa&&(o+="\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(i))))," */")),t.styleSheet)t.styleSheet.cssText=o;else{for(;t.firstChild;)t.removeChild(t.firstChild);t.appendChild(document.createTextNode(o))}}var p=null,_=0;function h(t,n){var e,o,r;if(n.singleton){var i=_++;e=p||(p=u(n)),o=d.bind(null,e,i,!1),r=d.bind(null,e,i,!0)}else e=u(n),o=v.bind(null,e,n),r=function(){!function(t){if(null===t.parentNode)return!1;t.parentNode.removeChild(t)}(e)};return o(t),function(n){if(n){if(n.css===t.css&&n.media===t.media&&n.sourceMap===t.sourceMap)return;o(t=n)}else r()}}t.exports=function(t,n){(n=n||{}).singleton||"boolean"==typeof n.singleton||(n.singleton=r());var e=l(t=t||[],n);return function(t){if(t=t||[],"[object Array]"===Object.prototype.toString.call(t)){for(var o=0;o<e.length;o++){var r=a(e[o]);c[r].references--}for(var i=l(t,n),u=0;u<e.length;u++){var s=a(e[u]);0===c[s].references&&(c[s].updater(),c.splice(s,1))}e=i}}}},7003:function(t,n,e){"use strict";e.d(n,{x:function(){return o.x},ev:function(){return o.ev},H3:function(){return o.H3}});var o=e(8826)},8826:function(t,n,e){"use strict";function o(t,n){t.prototype=Object.create(n.prototype),t.prototype.constructor=t,a(t,n)}function r(t){var n="function"==typeof Map?new Map:void 0;return(r=function(t){if(null===t||(e=t,-1===Function.toString.call(e).indexOf("[native code]")))return t;var e;if("function"!=typeof t)throw new TypeError("Super expression must either be null or a function");if(void 0!==n){if(n.has(t))return n.get(t);n.set(t,o)}function o(){return i(t,arguments,l(this).constructor)}return o.prototype=Object.create(t.prototype,{constructor:{value:o,enumerable:!1,writable:!0,configurable:!0}}),a(o,t)})(t)}function i(t,n,e){return(i=c()?Reflect.construct:function(t,n,e){var o=[null];o.push.apply(o,n);var r=new(Function.bind.apply(t,o));return e&&a(r,e.prototype),r}).apply(null,arguments)}function c(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}function a(t,n){return(a=Object.setPrototypeOf||function(t,n){return t.__proto__=n,t})(t,n)}function l(t){return(l=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}function u(){}e.d(n,{FW:function(){return V},f_:function(){return yt},hj:function(){return nt},R3:function(){return w},Lj:function(){return M},ak:function(){return pt},Vn:function(){return z},cK:function(){return F},gb:function(){return ut},FI:function(){return m},x:function(){return H},YC:function(){return _t},vp:function(){return gt},RM:function(){return C},og:function(){return L},bG:function(){return T},cS:function(){return P},yl:function(){return rt},$X:function(){return g},dv:function(){return lt},S1:function(){return bt},$T:function(){return O},oL:function(){return $},ye:function(){return ht},ZT:function(){return u},ev:function(){return W},H3:function(){return K},cl:function(){return dt},AT:function(){return k},j7:function(){return d},N8:function(){return p},rT:function(){return j},Bm:function(){return I},fx:function(){return b},cz:function(){return S},Dh:function(){return x},Ld:function(){return h},bi:function(){return D},fL:function(){return R},VH:function(){return U},Ui:function(){return st},et:function(){return ft},GQ:function(){return vt}});function s(t){return t()}function f(){return Object.create(null)}function d(t){t.forEach(s)}function v(t){return"function"==typeof t}function p(t,n){return t!=t?n==n:t!==n||t&&"object"==typeof t||"function"==typeof t}function _(t){return 0===Object.keys(t).length}function h(t){if(null==t)return u;for(var n=arguments.length,e=new Array(n>1?n-1:0),o=1;o<n;o++)e[o-1]=arguments[o];var r=t.subscribe.apply(t,e);return r.unsubscribe?function(){return r.unsubscribe()}:r}function g(t){var n;return h(t,(function(t){return n=t}))(),n}function m(t,n,e){t.$$.on_destroy.push(h(n,e))}function b(t,n,e){return void 0===e&&(e=n),t.set(e),n}new Set;var y=!1;function E(t,n,e,o){for(;t<n;){var r=t+(n-t>>1);e(r)<=o?t=r+1:n=r}return t}function w(t,n){y?(!function(t){if(!t.hydrate_init){t.hydrate_init=!0;var n=t.childNodes,e=new Int32Array(n.length+1),o=new Int32Array(n.length);e[0]=-1;for(var r=0,i=0;i<n.length;i++){var c=E(1,r+1,(function(t){return n[e[t]].claim_order}),n[i].claim_order)-1;o[i]=e[c]+1;var a=c+1;e[a]=i,r=Math.max(a,r)}for(var l=[],u=[],s=n.length-1,f=e[r]+1;0!=f;f=o[f-1]){for(l.push(n[f-1]);s>=f;s--)u.push(n[s]);s--}for(;s>=0;s--)u.push(n[s]);l.reverse(),u.sort((function(t,n){return t.claim_order-n.claim_order}));for(var d=0,v=0;d<u.length;d++){for(;v<l.length&&u[d].claim_order>=l[v].claim_order;)v++;var p=v<l.length?l[v]:null;t.insertBefore(u[d],p)}}}(t),(void 0===t.actual_end_child||null!==t.actual_end_child&&t.actual_end_child.parentElement!==t)&&(t.actual_end_child=t.firstChild),n!==t.actual_end_child?t.insertBefore(n,t.actual_end_child):t.actual_end_child=n.nextSibling):n.parentNode!==t&&t.appendChild(n)}function O(t,n,e){y&&!e?w(t,n):(n.parentNode!==t||e&&n.nextSibling!==e)&&t.insertBefore(n,e||null)}function L(t){t.parentNode.removeChild(t)}function C(t,n){for(var e=0;e<t.length;e+=1)t[e]&&t[e].d(n)}function T(t){return document.createElement(t)}function D(t){return document.createElementNS("http://www.w3.org/2000/svg",t)}function R(t){return document.createTextNode(t)}function x(){return R(" ")}function P(){return R("")}function $(t,n,e,o){return t.addEventListener(n,e,o),function(){return t.removeEventListener(n,e,o)}}function k(t){return function(n){return n.preventDefault(),t.call(this,n)}}function M(t,n,e){null==e?t.removeAttribute(n):t.getAttribute(n)!==e&&t.setAttribute(n,e)}function j(t,n){n=""+n,t.wholeText!==n&&(t.data=n)}function I(t,n){t.value=null==n?"":n}function S(t,n,e,o){t.style.setProperty(n,e,o?"important":"")}function U(t,n,e){t.classList[e?"add":"remove"](n)}function A(t,n){var e=document.createEvent("CustomEvent");return e.initCustomEvent(t,!1,!1,n),e}var V=function(){function t(t){this.e=this.n=null,this.l=t}var n=t.prototype;return n.m=function(t,n,e){void 0===e&&(e=null),this.e||(this.e=T(n.nodeName),this.t=n,this.l?this.n=this.l:this.h(t)),this.i(e)},n.h=function(t){this.e.innerHTML=t,this.n=Array.from(this.e.childNodes)},n.i=function(t){for(var n=0;n<this.n.length;n+=1)O(this.t,this.n[n],t)},n.p=function(t){this.d(),this.h(t),this.i(this.a)},n.d=function(){this.n.forEach(L)},t}();var B;new Set;function N(t){B=t}function G(){if(!B)throw new Error("Function called outside component initialization");return B}function K(t){G().$$.on_mount.push(t)}function W(t){G().$$.on_destroy.push(t)}function H(){var t=G();return function(n,e){var o=t.$$.callbacks[n];if(o){var r=A(n,e);o.slice().forEach((function(n){n.call(t,r)}))}}}function F(t,n){var e=this,o=t.$$.callbacks[n.type];o&&o.slice().forEach((function(t){return t.call(e,n)}))}var q=[],z=[],Z=[],Y=[],X=Promise.resolve(),J=!1;function Q(){J||(J=!0,X.then(rt))}function tt(t){Z.push(t)}function nt(t){Y.push(t)}var et=!1,ot=new Set;function rt(){if(!et){et=!0;do{for(var t=0;t<q.length;t+=1){var n=q[t];N(n),it(n.$$)}for(N(null),q.length=0;z.length;)z.pop()();for(var e=0;e<Z.length;e+=1){var o=Z[e];ot.has(o)||(ot.add(o),o())}Z.length=0}while(q.length);for(;Y.length;)Y.pop()();J=!1,et=!1,ot.clear()}}function it(t){if(null!==t.fragment){t.update(),d(t.before_update);var n=t.dirty;t.dirty=[-1],t.fragment&&t.fragment.p(t.ctx,n),t.after_update.forEach(tt)}}var ct,at=new Set;function lt(){ct={r:0,c:[],p:ct}}function ut(){ct.r||d(ct.c),ct=ct.p}function st(t,n){t&&t.i&&(at.delete(t),t.i(n))}function ft(t,n,e,o){if(t&&t.o){if(at.has(t))return;at.add(t),ct.c.push((function(){at.delete(t),o&&(e&&t.d(1),o())})),t.o(n)}}"undefined"!=typeof window?window:"undefined"!=typeof globalThis?globalThis:global;function dt(t,n){ft(t,1,1,(function(){n.delete(t.key)}))}function vt(t,n,e,o,r,i,c,a,l,u,s,f){for(var d=t.length,v=i.length,p=d,_={};p--;)_[t[p].key]=p;var h=[],g=new Map,m=new Map;for(p=v;p--;){var b=f(r,i,p),y=e(b),E=c.get(y);E?o&&E.p(b,n):(E=u(y,b)).c(),g.set(y,h[p]=E),y in _&&m.set(y,Math.abs(p-_[y]))}var w=new Set,O=new Set;function L(t){st(t,1),t.m(a,s),c.set(t.key,t),s=t.first,v--}for(;d&&v;){var C=h[v-1],T=t[d-1],D=C.key,R=T.key;C===T?(s=C.first,d--,v--):g.has(R)?!c.has(D)||w.has(D)?L(C):O.has(R)?d--:m.get(D)>m.get(R)?(O.add(D),L(C)):(w.add(R),d--):(l(T,c),d--)}for(;d--;){var x=t[d];g.has(x.key)||l(x,c)}for(;v;)L(h[v-1]);return h}new Set(["allowfullscreen","allowpaymentrequest","async","autofocus","autoplay","checked","controls","default","defer","disabled","formnovalidate","hidden","ismap","loop","multiple","muted","nomodule","novalidate","open","playsinline","readonly","required","reversed","selected"]);function pt(t,n,e){var o=t.$$.props[n];void 0!==o&&(t.$$.bound[o]=e,e(t.$$.ctx[o]))}function _t(t){t&&t.c()}function ht(t,n,e,o){var r=t.$$,i=r.fragment,c=r.on_mount,a=r.on_destroy,l=r.after_update;i&&i.m(n,e),o||tt((function(){var n=c.map(s).filter(v);a?a.push.apply(a,n):d(n),t.$$.on_mount=[]})),l.forEach(tt)}function gt(t,n){var e=t.$$;null!==e.fragment&&(d(e.on_destroy),e.fragment&&e.fragment.d(n),e.on_destroy=e.fragment=null,e.ctx=[])}function mt(t,n){-1===t.$$.dirty[0]&&(q.push(t),Q(),t.$$.dirty.fill(0)),t.$$.dirty[n/31|0]|=1<<n%31}function bt(t,n,e,o,r,i,c){void 0===c&&(c=[-1]);var a=B;N(t);var l=t.$$={fragment:null,ctx:null,props:i,update:u,not_equal:r,bound:f(),on_mount:[],on_destroy:[],on_disconnect:[],before_update:[],after_update:[],context:new Map(a?a.$$.context:n.context||[]),callbacks:f(),dirty:c,skip_bound:!1},s=!1;if(l.ctx=e?e(t,n.props||{},(function(n,e){var o=!(arguments.length<=2)&&arguments.length-2?arguments.length<=2?void 0:arguments[2]:e;return l.ctx&&r(l.ctx[n],l.ctx[n]=o)&&(!l.skip_bound&&l.bound[n]&&l.bound[n](o),s&&mt(t,n)),e})):[],l.update(),s=!0,d(l.before_update),l.fragment=!!o&&o(l.ctx),n.target){if(n.hydrate){y=!0;var v=function(t){return Array.from(t.childNodes)}(n.target);l.fragment&&l.fragment.l(v),v.forEach(L)}else l.fragment&&l.fragment.c();n.intro&&st(t.$$.fragment),ht(t,n.target,n.anchor,n.customElement),y=!1,rt()}N(a)}"function"==typeof HTMLElement&&HTMLElement;var yt=function(){function t(){}var n=t.prototype;return n.$destroy=function(){gt(this,1),this.$destroy=u},n.$on=function(t,n){var e=this.$$.callbacks[t]||(this.$$.callbacks[t]=[]);return e.push(n),function(){var t=e.indexOf(n);-1!==t&&e.splice(t,1)}},n.$set=function(t){this.$$set&&!_(t)&&(this.$$.skip_bound=!0,this.$$set(t),this.$$.skip_bound=!1)},t}()},4683:function(t,n,e){"use strict";e.d(n,{U2:function(){return o.$X},fZ:function(){return i}});var o=e(8826),r=[];function i(t,n){var e;void 0===n&&(n=o.ZT);var i=[];function c(n){if((0,o.N8)(t,n)&&(t=n,e)){for(var c=!r.length,a=0;a<i.length;a+=1){var l=i[a];l[1](),r.push(l,t)}if(c){for(var u=0;u<r.length;u+=2)r[u][0](r[u+1]);r.length=0}}}return{set:c,update:function(n){c(n(t))},subscribe:function(r,a){void 0===a&&(a=o.ZT);var l=[r,a];return i.push(l),1===i.length&&(e=n(c)||o.ZT),r(t),function(){var t=i.indexOf(l);-1!==t&&i.splice(t,1),0===i.length&&(e(),e=null)}}}}}},__webpack_module_cache__={};function __webpack_require__(t){var n=__webpack_module_cache__[t];if(void 0!==n)return n.exports;var e=__webpack_module_cache__[t]={id:t,exports:{}};return __webpack_modules__[t](e,e.exports,__webpack_require__),e.exports}__webpack_require__.n=function(t){var n=t&&t.__esModule?function(){return t.default}:function(){return t};return __webpack_require__.d(n,{a:n}),n},__webpack_require__.d=function(t,n){for(var e in n)__webpack_require__.o(n,e)&&!__webpack_require__.o(t,e)&&Object.defineProperty(t,e,{enumerable:!0,get:n[e]})},__webpack_require__.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(t){if("object"==typeof window)return window}}(),__webpack_require__.o=function(t,n){return Object.prototype.hasOwnProperty.call(t,n)};var __webpack_exports__={};return function(){"use strict";__webpack_require__.d(__webpack_exports__,{default:function(){return bo}});__webpack_require__(5441);var t,n=__webpack_require__(5103),e={one:function(t,n){void 0===n&&(n=document);try{return n.querySelector(t)||void 0}catch(t){return}},all:function(t,n){void 0===n&&(n=document);try{var e=n.querySelectorAll(t);return[].slice.call(e)}catch(t){return[]}},addClass:function(t,e){if(t)for(var o=(0,n.kJ)(t)?t:[t],r=0;r<o.length;r++){var i=(o[r].className||"").split(" ");i.indexOf(e)>-1||(i.push(e),o[r].className=i.join(" "))}},removeClass:function(t,e){if(t)for(var o=(0,n.kJ)(t)?t:[t],r=0;r<o.length;r++){for(var i=o[r].className.split(" "),c=0;c<i.length;c++)i[c]==e&&(i[c]="");o[r].className=i.join(" ").trim()}},hasClass:function(t,n){return!(!t||!t.classList)&&t.classList.contains(n)},bind:function(t,e,o,r){(void 0===r&&(r=!1),t)&&((0,n.kJ)(t)?t:[t]).forEach((function(t){t.addEventListener(e,o,!!r)}))},delegate:function(t,n,o,r){t&&t.addEventListener(n,(function(n){var i=e.all(o,t);if(i)t:for(var c=0;c<i.length;c++)for(var a=n.target;a;){if(a==i[c]){r.call(a,n,a);break t}if((a=a.parentNode)==t)break}}),!1)},removeChildren:function(t){for(;t.firstChild;)t.removeChild(t.lastChild);return t}},o=e,r=__webpack_require__(8826),i=__webpack_require__(7003),c=__webpack_require__(3379),a=__webpack_require__.n(c),l=__webpack_require__(7558),u=0,s={injectType:"lazyStyleTag",insert:"head",singleton:!1},f={};f.locals=l.Z.locals||{},f.use=function(){return u++||(t=a()(l.Z,s)),f},f.unuse=function(){u>0&&!--u&&(t(),t=null)};var d=f;function v(t,n){for(var e=0;e<n.length;e++){var o=n[e];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(t,o.key,o)}}function p(t,n){return(p=Object.setPrototypeOf||function(t,n){return t.__proto__=n,t})(t,n)}function _(t){var n,e,o,i;return{c:function(){n=(0,r.bG)("div"),e=(0,r.fL)("vConsole"),(0,r.Lj)(n,"class","vc-switch"),(0,r.cz)(n,"right",t[2].x+"px"),(0,r.cz)(n,"bottom",t[2].y+"px"),(0,r.cz)(n,"display",t[0]?"block":"none")},m:function(c,a){(0,r.$T)(c,n,a),(0,r.R3)(n,e),t[8](n),o||(i=[(0,r.oL)(n,"touchstart",t[3]),(0,r.oL)(n,"touchend",t[4]),(0,r.oL)(n,"touchmove",t[5]),(0,r.oL)(n,"click",t[7])],o=!0)},p:function(t,e){var o=e[0];4&o&&(0,r.cz)(n,"right",t[2].x+"px"),4&o&&(0,r.cz)(n,"bottom",t[2].y+"px"),1&o&&(0,r.cz)(n,"display",t[0]?"block":"none")},i:r.ZT,o:r.ZT,d:function(e){e&&(0,r.og)(n),t[8](null),o=!1,(0,r.j7)(i)}}}function h(t,e,o){var c,a=e.show,l=void 0===a||a,u=e.position,s=void 0===u?{x:0,y:0}:u,f={hasMoved:!1,x:0,y:0,startX:0,startY:0,endX:0,endY:0},v={x:0,y:0};(0,i.H3)((function(){d.use()})),(0,i.ev)((function(){d.unuse()}));var p=function(t,e){var r=_(t,e);t=r[0],e=r[1],f.x=t,f.y=e,o(2,v.x=t,v),o(2,v.y=e,v),n.po("switch_x",t+""),n.po("switch_y",e+"")},_=function(t,n){var e=Math.max(document.documentElement.offsetWidth,window.innerWidth),o=Math.max(document.documentElement.offsetHeight,window.innerHeight);return t+c.offsetWidth>e&&(t=e-c.offsetWidth),n+c.offsetHeight>o&&(n=o-c.offsetHeight),t<0&&(t=0),n<20&&(n=20),[t,n]};return t.$$set=function(t){"show"in t&&o(0,l=t.show),"position"in t&&o(6,s=t.position)},t.$$.update=function(){66&t.$$.dirty&&c&&p(s.x,s.y)},[l,c,v,function(t){f.startX=t.touches[0].pageX,f.startY=t.touches[0].pageY,f.hasMoved=!1},function(t){f.hasMoved&&(f.startX=0,f.startY=0,f.hasMoved=!1,p(f.endX,f.endY))},function(t){if(!(t.touches.length<=0)){var n=t.touches[0].pageX-f.startX,e=t.touches[0].pageY-f.startY,r=Math.floor(f.x-n),i=Math.floor(f.y-e),c=_(r,i);r=c[0],i=c[1],o(2,v.x=r,v),o(2,v.y=i,v),f.endX=r,f.endY=i,f.hasMoved=!0,t.preventDefault()}},s,function(n){r.cK.call(this,t,n)},function(t){r.Vn[t?"unshift":"push"]((function(){o(1,c=t)}))}]}var g,m=function(t){var n,e,o,i,c;function a(n){var e;return e=t.call(this)||this,(0,r.S1)(function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(e),n,h,_,r.N8,{show:0,position:6}),e}return e=t,(n=a).prototype=Object.create(e.prototype),n.prototype.constructor=n,p(n,e),o=a,(i=[{key:"show",get:function(){return this.$$.ctx[0]},set:function(t){this.$set({show:t}),(0,r.yl)()}},{key:"position",get:function(){return this.$$.ctx[6]},set:function(t){this.$set({position:t}),(0,r.yl)()}}])&&v(o.prototype,i),c&&v(o,c),a}(r.f_),b=__webpack_require__(4687),y=__webpack_require__(3283),E=0,w={injectType:"lazyStyleTag",insert:"head",singleton:!1},O={};O.locals=y.Z.locals||{},O.use=function(){return E++||(g=a()(y.Z,w)),O},O.unuse=function(){E>0&&!--E&&(g(),g=null)};var L=O;function C(t,n){for(var e=0;e<n.length;e++){var o=n[e];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(t,o.key,o)}}function T(t,n){return(T=Object.setPrototypeOf||function(t,n){return t.__proto__=n,t})(t,n)}function D(t,n,e){var o=t.slice();return o[36]=n[e][0],o[37]=n[e][1],o}function R(t,n,e){var o=t.slice();return o[40]=n[e],o[42]=e,o}function x(t,n,e){var o=t.slice();return o[36]=n[e][0],o[37]=n[e][1],o}function P(t,n,e){var o=t.slice();return o[36]=n[e][0],o[37]=n[e][1],o}function $(t,n,e){var o=t.slice();return o[40]=n[e],o[42]=e,o}function k(t,n,e){var o=t.slice();return o[36]=n[e][0],o[37]=n[e][1],o}function M(t){var n,e,o,i,c,a=t[37].name+"";function l(){return t[24](t[37])}return{c:function(){n=(0,r.bG)("a"),e=(0,r.fL)(a),(0,r.Lj)(n,"class","vc-tab"),(0,r.Lj)(n,"id",o="__vc_tab_"+t[37].id),(0,r.VH)(n,"vc-actived",t[37].id===t[2])},m:function(t,o){(0,r.$T)(t,n,o),(0,r.R3)(n,e),i||(c=(0,r.oL)(n,"touchend",l,{passive:!0}),i=!0)},p:function(i,c){t=i,8&c[0]&&a!==(a=t[37].name+"")&&(0,r.rT)(e,a),8&c[0]&&o!==(o="__vc_tab_"+t[37].id)&&(0,r.Lj)(n,"id",o),12&c[0]&&(0,r.VH)(n,"vc-actived",t[37].id===t[2])},d:function(t){t&&(0,r.og)(n),i=!1,c()}}}function j(t){var n,e=t[37].hasTabPanel&&M(t);return{c:function(){e&&e.c(),n=(0,r.cS)()},m:function(t,o){e&&e.m(t,o),(0,r.$T)(t,n,o)},p:function(t,o){t[37].hasTabPanel?e?e.p(t,o):((e=M(t)).c(),e.m(n.parentNode,n)):e&&(e.d(1),e=null)},d:function(t){e&&e.d(t),t&&(0,r.og)(n)}}}function I(t){var n,e,o,i,c,a=t[40].name+"";function l(){for(var n,e=arguments.length,o=new Array(e),r=0;r<e;r++)o[r]=arguments[r];return(n=t)[25].apply(n,[t[37],t[42]].concat(o))}return{c:function(){n=(0,r.bG)("i"),e=(0,r.fL)(a),(0,r.Lj)(n,"class",o="vc-toptab vc-topbar-"+t[37].id+" "+t[40].className),(0,r.VH)(n,"vc-toggle",t[37].id===t[2]),(0,r.VH)(n,"vc-actived",t[40].actived)},m:function(t,o){(0,r.$T)(t,n,o),(0,r.R3)(n,e),i||(c=(0,r.oL)(n,"touchend",l),i=!0)},p:function(i,c){t=i,8&c[0]&&a!==(a=t[40].name+"")&&(0,r.rT)(e,a),8&c[0]&&o!==(o="vc-toptab vc-topbar-"+t[37].id+" "+t[40].className)&&(0,r.Lj)(n,"class",o),12&c[0]&&(0,r.VH)(n,"vc-toggle",t[37].id===t[2]),8&c[0]&&(0,r.VH)(n,"vc-actived",t[40].actived)},d:function(t){t&&(0,r.og)(n),i=!1,c()}}}function S(t){for(var n,e=t[37].topbarList,o=[],i=0;i<e.length;i+=1)o[i]=I($(t,e,i));return{c:function(){for(var t=0;t<o.length;t+=1)o[t].c();n=(0,r.cS)()},m:function(t,e){for(var i=0;i<o.length;i+=1)o[i].m(t,e);(0,r.$T)(t,n,e)},p:function(t,r){if(16396&r[0]){var i;for(e=t[37].topbarList,i=0;i<e.length;i+=1){var c=$(t,e,i);o[i]?o[i].p(c,r):(o[i]=I(c),o[i].c(),o[i].m(n.parentNode,n))}for(;i<o.length;i+=1)o[i].d(1);o.length=e.length}},d:function(t){(0,r.RM)(o,t),t&&(0,r.og)(n)}}}function U(t){var n,e;return{c:function(){n=(0,r.bG)("div"),(0,r.Lj)(n,"id",e="__vc_plug_"+t[37].id),(0,r.Lj)(n,"class","vc-plugin-box"),(0,r.VH)(n,"vc-actived",t[37].id===t[2])},m:function(e,o){(0,r.$T)(e,n,o),t[26](n)},p:function(t,o){8&o[0]&&e!==(e="__vc_plug_"+t[37].id)&&(0,r.Lj)(n,"id",e),12&o[0]&&(0,r.VH)(n,"vc-actived",t[37].id===t[2])},d:function(e){e&&(0,r.og)(n),t[26](null)}}}function A(t){var n,e,o,i,c,a=t[40].name+"";function l(){for(var n,e=arguments.length,o=new Array(e),r=0;r<e;r++)o[r]=arguments[r];return(n=t)[28].apply(n,[t[37],t[42]].concat(o))}return{c:function(){n=(0,r.bG)("i"),e=(0,r.fL)(a),(0,r.Lj)(n,"class",o="vc-tool vc-tool-"+t[37].id),(0,r.VH)(n,"vc-global-tool",t[40].global),(0,r.VH)(n,"vc-toggle",t[37].id===t[2])},m:function(t,o){(0,r.$T)(t,n,o),(0,r.R3)(n,e),i||(c=(0,r.oL)(n,"touchend",l),i=!0)},p:function(i,c){t=i,8&c[0]&&a!==(a=t[40].name+"")&&(0,r.rT)(e,a),8&c[0]&&o!==(o="vc-tool vc-tool-"+t[37].id)&&(0,r.Lj)(n,"class",o),8&c[0]&&(0,r.VH)(n,"vc-global-tool",t[40].global),12&c[0]&&(0,r.VH)(n,"vc-toggle",t[37].id===t[2])},d:function(t){t&&(0,r.og)(n),i=!1,c()}}}function V(t){for(var n,e=t[37].toolbarList,o=[],i=0;i<e.length;i+=1)o[i]=A(R(t,e,i));return{c:function(){for(var t=0;t<o.length;t+=1)o[t].c();n=(0,r.cS)()},m:function(t,e){for(var i=0;i<o.length;i+=1)o[i].m(t,e);(0,r.$T)(t,n,e)},p:function(t,r){if(32780&r[0]){var i;for(e=t[37].toolbarList,i=0;i<e.length;i+=1){var c=R(t,e,i);o[i]?o[i].p(c,r):(o[i]=A(c),o[i].c(),o[i].m(n.parentNode,n))}for(;i<o.length;i+=1)o[i].d(1);o.length=e.length}},d:function(t){(0,r.RM)(o,t),t&&(0,r.og)(n)}}}function B(t){var n,e,o,i,c,a,l,u,s,f,d,v,p,_,h,g,b,y,E,w,O;function L(n){t[22](n)}function C(n){t[23](n)}var T={};void 0!==t[0]&&(T.show=t[0]),void 0!==t[1]&&(T.position=t[1]),e=new m({props:T}),r.Vn.push((function(){return(0,r.ak)(e,"show",L)})),r.Vn.push((function(){return(0,r.ak)(e,"position",C)})),e.$on("click",t[11]);for(var R=Object.entries(t[3]),$=[],M=0;M<R.length;M+=1)$[M]=j(k(t,R,M));for(var I=Object.entries(t[3]),A=[],B=0;B<I.length;B+=1)A[B]=S(P(t,I,B));for(var N=Object.entries(t[3]),G=[],K=0;K<N.length;K+=1)G[K]=U(x(t,N,K));for(var W=Object.entries(t[3]),H=[],F=0;F<W.length;F+=1)H[F]=V(D(t,W,F));return{c:function(){var o,i;n=(0,r.bG)("div"),(0,r.YC)(e.$$.fragment),c=(0,r.Dh)(),a=(0,r.bG)("div"),l=(0,r.Dh)(),u=(0,r.bG)("div"),s=(0,r.bG)("div");for(var m=0;m<$.length;m+=1)$[m].c();f=(0,r.Dh)(),d=(0,r.bG)("div");for(var E=0;E<A.length;E+=1)A[E].c();v=(0,r.Dh)(),p=(0,r.bG)("div");for(var w=0;w<G.length;w+=1)G[w].c();_=(0,r.Dh)(),h=(0,r.bG)("div");for(var O=0;O<H.length;O+=1)H[O].c();g=(0,r.Dh)(),(b=(0,r.bG)("i")).textContent="Hide",(0,r.Lj)(a,"class","vc-mask"),(0,r.cz)(a,"display",t[10]?"block":"none"),(0,r.Lj)(s,"class","vc-tabbar"),(0,r.Lj)(d,"class","vc-topbar"),(0,r.Lj)(p,"class","vc-content"),(0,r.VH)(p,"vc-has-topbar",(null==(o=t[3][t[2]])||null==(i=o.topbarList)?void 0:i.length)>0),(0,r.Lj)(b,"class","vc-tool vc-global-tool vc-tool-last vc-hide"),(0,r.Lj)(h,"class","vc-toolbar"),(0,r.Lj)(u,"class","vc-panel"),(0,r.cz)(u,"display",t[9]?"block":"none"),(0,r.Lj)(n,"id","__vconsole"),(0,r.Lj)(n,"style",y=t[7]?"font-size:"+t[7]+";":""),(0,r.Lj)(n,"data-theme",t[5]),(0,r.VH)(n,"vc-toggle",t[8])},m:function(o,i){(0,r.$T)(o,n,i),(0,r.ye)(e,n,null),(0,r.R3)(n,c),(0,r.R3)(n,a),(0,r.R3)(n,l),(0,r.R3)(n,u),(0,r.R3)(u,s);for(var m=0;m<$.length;m+=1)$[m].m(s,null);(0,r.R3)(u,f),(0,r.R3)(u,d);for(var y=0;y<A.length;y+=1)A[y].m(d,null);(0,r.R3)(u,v),(0,r.R3)(u,p);for(var L=0;L<G.length;L+=1)G[L].m(p,null);t[27](p),(0,r.R3)(u,_),(0,r.R3)(u,h);for(var C=0;C<H.length;C+=1)H[C].m(h,null);(0,r.R3)(h,g),(0,r.R3)(h,b),E=!0,w||(O=[(0,r.oL)(a,"click",t[12]),(0,r.oL)(p,"touchstart",t[16]),(0,r.oL)(p,"touchmove",t[17]),(0,r.oL)(p,"touchend",t[18]),(0,r.oL)(p,"scroll",t[19]),(0,r.oL)(b,"click",t[12])],w=!0)},p:function(t,c){var l,f,v={};if(!o&&1&c[0]&&(o=!0,v.show=t[0],(0,r.hj)((function(){return o=!1}))),!i&&2&c[0]&&(i=!0,v.position=t[1],(0,r.hj)((function(){return i=!1}))),e.$set(v),(!E||1024&c[0])&&(0,r.cz)(a,"display",t[10]?"block":"none"),8204&c[0]){var _;for(R=Object.entries(t[3]),_=0;_<R.length;_+=1){var m=k(t,R,_);$[_]?$[_].p(m,c):($[_]=j(m),$[_].c(),$[_].m(s,null))}for(;_<$.length;_+=1)$[_].d(1);$.length=R.length}if(16396&c[0]){var b;for(I=Object.entries(t[3]),b=0;b<I.length;b+=1){var w=P(t,I,b);A[b]?A[b].p(w,c):(A[b]=S(w),A[b].c(),A[b].m(d,null))}for(;b<A.length;b+=1)A[b].d(1);A.length=I.length}if(28&c[0]){var O;for(N=Object.entries(t[3]),O=0;O<N.length;O+=1){var L=x(t,N,O);G[O]?G[O].p(L,c):(G[O]=U(L),G[O].c(),G[O].m(p,null))}for(;O<G.length;O+=1)G[O].d(1);G.length=N.length}12&c[0]&&(0,r.VH)(p,"vc-has-topbar",(null==(l=t[3][t[2]])||null==(f=l.topbarList)?void 0:f.length)>0);if(32780&c[0]){var C;for(W=Object.entries(t[3]),C=0;C<W.length;C+=1){var T=D(t,W,C);H[C]?H[C].p(T,c):(H[C]=V(T),H[C].c(),H[C].m(h,g))}for(;C<H.length;C+=1)H[C].d(1);H.length=W.length}(!E||512&c[0])&&(0,r.cz)(u,"display",t[9]?"block":"none"),(!E||128&c[0]&&y!==(y=t[7]?"font-size:"+t[7]+";":""))&&(0,r.Lj)(n,"style",y),(!E||32&c[0])&&(0,r.Lj)(n,"data-theme",t[5]),256&c[0]&&(0,r.VH)(n,"vc-toggle",t[8])},i:function(t){E||((0,r.Ui)(e.$$.fragment,t),E=!0)},o:function(t){(0,r.et)(e.$$.fragment,t),E=!1},d:function(o){o&&(0,r.og)(n),(0,r.vp)(e),(0,r.RM)($,o),(0,r.RM)(A,o),(0,r.RM)(G,o),t[27](null),(0,r.RM)(H,o),w=!1,(0,r.j7)(O)}}}function N(t,e,o){var c,a,l=e.theme,u=void 0===l?"":l,s=e.disableScrolling,f=void 0!==s&&s,d=e.show,v=void 0!==d&&d,p=e.showSwitchButton,_=void 0===p||p,h=e.switchButtonPosition,g=void 0===h?{x:0,y:0}:h,m=e.activedPluginId,y=void 0===m?"":m,E=e.pluginList,w=void 0===E?{}:E,O=e.divContentInner,C=void 0===O?void 0:O,T=(0,i.x)(),D=!1,R="",x=!1,P=!1,$=!1,k=!0,M=0;(0,i.H3)((function(){var t=window.devicePixelRatio||1,n=document.querySelector('[name="viewport"]');if(n){var e=(n.getAttribute("content")||"").match(/initial\-scale\=\d+(\.\d+)?/);(e?parseFloat(e[0].split("=")[1]):1)<1&&o(7,R=13*t+"px")}L.use&&L.use(),a=b.x.subscribe((function(t){v&&M!==t.updateTime&&(M=t.updateTime,j())}))})),(0,i.ev)((function(){L.unuse&&L.unuse(),a&&a()}));var j=function(){!f&&k&&c&&o(6,c.scrollTop=c.scrollHeight-c.offsetHeight,c)},I=function(t){t!==y&&(o(2,y=t),T("changePanel",{pluginId:t}))},S=function(t,e,r){var i=w[e].topbarList[r],c=!0;if(n.mf(i.onClick)&&(c=i.onClick.call(t.target,t,i.data)),!1===c);else{for(var a=0;a<w[e].topbarList.length;a++)o(3,w[e].topbarList[a].actived=r===a,w);o(3,w)}},U=function(t,e,o){var r=w[e].toolbarList[o];n.mf(r.onClick)&&r.onClick.call(t.target,t,r.data)};return t.$$set=function(t){"theme"in t&&o(5,u=t.theme),"disableScrolling"in t&&o(20,f=t.disableScrolling),"show"in t&&o(21,v=t.show),"showSwitchButton"in t&&o(0,_=t.showSwitchButton),"switchButtonPosition"in t&&o(1,g=t.switchButtonPosition),"activedPluginId"in t&&o(2,y=t.activedPluginId),"pluginList"in t&&o(3,w=t.pluginList),"divContentInner"in t&&o(4,C=t.divContentInner)},t.$$.update=function(){2097152&t.$$.dirty[0]&&(!0===v?(o(9,P=!0),o(10,$=!0),setTimeout((function(){o(8,x=!0),j()}),10)):(o(8,x=!1),setTimeout((function(){o(9,P=!1),o(10,$=!1)}),330)))},[_,g,y,w,C,u,c,R,x,P,$,function(t){T("show",{show:!0})},function(t){T("show",{show:!1})},I,S,U,function(t){var n=c.scrollTop,e=c.scrollHeight,r=n+c.offsetHeight;0===n?(o(6,c.scrollTop=1,c),0===c.scrollTop&&t.target.classList&&!t.target.classList.contains("vc-cmd-input")&&(D=!0)):r===e&&(o(6,c.scrollTop=n-1,c),c.scrollTop===n&&t.target.classList&&!t.target.classList.contains("vc-cmd-input")&&(D=!0))},function(t){D&&t.preventDefault()},function(t){D=!1},function(t){v&&(k=c.scrollTop+c.offsetHeight>=c.scrollHeight-50)},f,v,function(t){o(0,_=t)},function(t){o(1,g=t)},function(t){return I(t.id)},function(t,n,e){return S(e,t.id,n)},function(t){r.Vn[t?"unshift":"push"]((function(){o(4,C=t)}))},function(t){r.Vn[t?"unshift":"push"]((function(){o(6,c=t)}))},function(t,n,e){return U(e,t.id,n)}]}var G=function(t){var n,e,o,i,c;function a(n){var e;return e=t.call(this)||this,(0,r.S1)(function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(e),n,N,B,r.N8,{theme:5,disableScrolling:20,show:21,showSwitchButton:0,switchButtonPosition:1,activedPluginId:2,pluginList:3,divContentInner:4},[-1,-1]),e}return e=t,(n=a).prototype=Object.create(e.prototype),n.prototype.constructor=n,T(n,e),o=a,(i=[{key:"theme",get:function(){return this.$$.ctx[5]},set:function(t){this.$set({theme:t}),(0,r.yl)()}},{key:"disableScrolling",get:function(){return this.$$.ctx[20]},set:function(t){this.$set({disableScrolling:t}),(0,r.yl)()}},{key:"show",get:function(){return this.$$.ctx[21]},set:function(t){this.$set({show:t}),(0,r.yl)()}},{key:"showSwitchButton",get:function(){return this.$$.ctx[0]},set:function(t){this.$set({showSwitchButton:t}),(0,r.yl)()}},{key:"switchButtonPosition",get:function(){return this.$$.ctx[1]},set:function(t){this.$set({switchButtonPosition:t}),(0,r.yl)()}},{key:"activedPluginId",get:function(){return this.$$.ctx[2]},set:function(t){this.$set({activedPluginId:t}),(0,r.yl)()}},{key:"pluginList",get:function(){return this.$$.ctx[3]},set:function(t){this.$set({pluginList:t}),(0,r.yl)()}},{key:"divContentInner",get:function(){return this.$$.ctx[4]},set:function(t){this.$set({divContentInner:t}),(0,r.yl)()}}])&&C(o.prototype,i),c&&C(o,c),a}(r.f_);function K(t,n){for(var e=0;e<n.length;e++){var o=n[e];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(t,o.key,o)}}var W=function(){function t(t,n){void 0===n&&(n="newPlugin"),this.isReady=!1,this.eventList=void 0,this._id=void 0,this._name=void 0,this._vConsole=void 0,this.id=t,this.name=n,this.isReady=!1,this.eventList={}}var e,o,r,i=t.prototype;return i.on=function(t,n){return this.eventList[t]=n,this},i.trigger=function(t,n){if("function"==typeof this.eventList[t])this.eventList[t].call(this,n);else{var e="on"+t.charAt(0).toUpperCase()+t.slice(1);"function"==typeof this[e]&&this[e].call(this,n)}return this},i.getUniqueID=function(t){return void 0===t&&(t=""),(0,n.QI)(t)},e=t,(o=[{key:"id",get:function(){return this._id},set:function(t){if(!t)throw"Plugin ID cannot be empty";this._id=t.toLowerCase()}},{key:"name",get:function(){return this._name},set:function(t){if(!t)throw"Plugin name cannot be empty";this._name=t}},{key:"vConsole",get:function(){return this._vConsole||void 0},set:function(t){if(!t)throw"vConsole cannot be empty";this._vConsole=t}}])&&K(e.prototype,o),r&&K(e,r),t}();function H(t,n){return(H=Object.setPrototypeOf||function(t,n){return t.__proto__=n,t})(t,n)}var F=function(t){var n,e;function o(n,e,o,r){var i;return(i=t.call(this,n,e)||this).CompClass=void 0,i.compInstance=void 0,i.initialProps=void 0,i.CompClass=o,i.initialProps=r,i}e=t,(n=o).prototype=Object.create(e.prototype),n.prototype.constructor=n,H(n,e);var r=o.prototype;return r.onReady=function(){this.isReady=!0},r.onRenderTab=function(t){var n=document.createElement("div");this.compInstance=new this.CompClass({target:n,props:this.initialProps}),t(n.firstElementChild)},r.onRemove=function(){this.compInstance&&this.compInstance.$destroy()},o}(W),q=__webpack_require__(8665),z=__webpack_require__(9923);var Z=__webpack_require__(6958);function Y(t,n){for(var e=0;e<n.length;e++){var o=n[e];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(t,o.key,o)}}function X(t,n){return(X=Object.setPrototypeOf||function(t,n){return t.__proto__=n,t})(t,n)}function J(t){var n,e;return(n=new Z.Z({props:{name:t[0]?"success":"copy"}})).$on("click",t[1]),{c:function(){(0,r.YC)(n.$$.fragment)},m:function(t,o){(0,r.ye)(n,t,o),e=!0},p:function(t,e){var o={};1&e[0]&&(o.name=t[0]?"success":"copy"),n.$set(o)},i:function(t){e||((0,r.Ui)(n.$$.fragment,t),e=!0)},o:function(t){(0,r.et)(n.$$.fragment,t),e=!1},d:function(t){(0,r.vp)(n,t)}}}function Q(t,e,o){var r=e.content,i=void 0===r?"":r,c=e.handler,a=void 0===c?void 0:c,l={target:document.documentElement},u=!1;return t.$$set=function(t){"content"in t&&o(2,i=t.content),"handler"in t&&o(3,a=t.handler)},[u,function(t){(function(t,n){var e=(void 0===n?{}:n).target,o=void 0===e?document.body:e,r=document.createElement("textarea"),i=document.activeElement;r.value=t,r.setAttribute("readonly",""),r.style.contain="strict",r.style.position="absolute",r.style.left="-9999px",r.style.fontSize="12pt";var c=document.getSelection(),a=!1;c.rangeCount>0&&(a=c.getRangeAt(0)),o.append(r),r.select(),r.selectionStart=0,r.selectionEnd=t.length;var l=!1;try{l=document.execCommand("copy")}catch(t){}r.remove(),a&&(c.removeAllRanges(),c.addRange(a)),i&&i.focus()})(n.mf(a)?a(i)||"":n.Kn(i)||n.kJ(i)?n.hZ(i):i,l),o(0,u=!0),setTimeout((function(){o(0,u=!1)}),600)},i,a]}var tt,nt=function(t){var n,e,o,i,c;function a(n){var e;return e=t.call(this)||this,(0,r.S1)(function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(e),n,Q,J,r.N8,{content:2,handler:3}),e}return e=t,(n=a).prototype=Object.create(e.prototype),n.prototype.constructor=n,X(n,e),o=a,(i=[{key:"content",get:function(){return this.$$.ctx[2]},set:function(t){this.$set({content:t}),(0,r.yl)()}},{key:"handler",get:function(){return this.$$.ctx[3]},set:function(t){this.$set({handler:t}),(0,r.yl)()}}])&&Y(o.prototype,i),c&&Y(o,c),a}(r.f_),et=__webpack_require__(845),ot=0,rt={injectType:"lazyStyleTag",insert:"head",singleton:!1},it={};it.locals=et.Z.locals||{},it.use=function(){return ot++||(tt=a()(et.Z,rt)),it},it.unuse=function(){ot>0&&!--ot&&(tt(),tt=null)};var ct=it;function at(t,n){for(var e=0;e<n.length;e++){var o=n[e];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(t,o.key,o)}}function lt(t,n){return(lt=Object.setPrototypeOf||function(t,n){return t.__proto__=n,t})(t,n)}function ut(t){var e,o,i,c=n.rE(t[1])+"";return{c:function(){e=(0,r.bG)("i"),o=(0,r.fL)(c),i=(0,r.fL)(":"),(0,r.Lj)(e,"class","vc-log-key"),(0,r.VH)(e,"vc-log-key-symbol","symbol"===t[2]),(0,r.VH)(e,"vc-log-key-private","private"===t[2])},m:function(t,n){(0,r.$T)(t,e,n),(0,r.R3)(e,o),(0,r.$T)(t,i,n)},p:function(t,i){2&i&&c!==(c=n.rE(t[1])+"")&&(0,r.rT)(o,c),4&i&&(0,r.VH)(e,"vc-log-key-symbol","symbol"===t[2]),4&i&&(0,r.VH)(e,"vc-log-key-private","private"===t[2])},d:function(t){t&&(0,r.og)(e),t&&(0,r.og)(i)}}}function st(t){var n;return{c:function(){n=(0,r.fL)(t[3])},m:function(t,e){(0,r.$T)(t,n,e)},p:function(t,e){8&e&&(0,r.rT)(n,t[3])},d:function(t){t&&(0,r.og)(n)}}}function ft(t){var n,e;return{c:function(){n=new r.FW,e=(0,r.cS)(),n.a=e},m:function(o,i){n.m(t[3],o,i),(0,r.$T)(o,e,i)},p:function(t,e){8&e&&n.p(t[3])},d:function(t){t&&(0,r.og)(e),t&&n.d()}}}function dt(t){var n,e,o,i=void 0!==t[1]&&ut(t);function c(t,n){return t[5]||"string"!==t[4]?st:ft}var a=c(t),l=a(t);return{c:function(){i&&i.c(),n=(0,r.Dh)(),e=(0,r.bG)("i"),l.c(),(0,r.Lj)(e,"class",o="vc-log-val vc-log-val-"+t[4]),(0,r.Lj)(e,"style",t[0]),(0,r.VH)(e,"vc-log-val-haskey",void 0!==t[1])},m:function(t,o){i&&i.m(t,o),(0,r.$T)(t,n,o),(0,r.$T)(t,e,o),l.m(e,null)},p:function(t,u){var s=u[0];void 0!==t[1]?i?i.p(t,s):((i=ut(t)).c(),i.m(n.parentNode,n)):i&&(i.d(1),i=null),a===(a=c(t))&&l?l.p(t,s):(l.d(1),(l=a(t))&&(l.c(),l.m(e,null))),16&s&&o!==(o="vc-log-val vc-log-val-"+t[4])&&(0,r.Lj)(e,"class",o),1&s&&(0,r.Lj)(e,"style",t[0]),18&s&&(0,r.VH)(e,"vc-log-val-haskey",void 0!==t[1])},i:r.ZT,o:r.ZT,d:function(t){i&&i.d(t),t&&(0,r.og)(n),t&&(0,r.og)(e),l.d()}}}function vt(t,e,o){var r=e.origData,c=e.style,a=void 0===c?"":c,l=e.dataKey,u=void 0===l?void 0:l,s=e.keyType,f=void 0===s?"":s,d="",v="",p=!1,_=!1;return(0,i.H3)((function(){ct.use()})),(0,i.ev)((function(){ct.unuse()})),t.$$set=function(t){"origData"in t&&o(6,r=t.origData),"style"in t&&o(0,a=t.style),"dataKey"in t&&o(1,u=t.dataKey),"keyType"in t&&o(2,f=t.keyType)},t.$$.update=function(){if(250&t.$$.dirty&&!p){o(5,_=void 0!==u);var e=(0,q.LH)(r,_);o(4,v=e.valueType),o(3,d=e.text),_||"string"!==v||o(3,d=n.Ak(d.replace("\\n","\n").replace("\\t","\t"))),o(7,p=!0)}},[a,u,f,d,v,_,r,p]}var pt,_t=function(t){var n,e,o,i,c;function a(n){var e;return e=t.call(this)||this,(0,r.S1)(function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(e),n,vt,dt,r.N8,{origData:6,style:0,dataKey:1,keyType:2}),e}return e=t,(n=a).prototype=Object.create(e.prototype),n.prototype.constructor=n,lt(n,e),o=a,(i=[{key:"origData",get:function(){return this.$$.ctx[6]},set:function(t){this.$set({origData:t}),(0,r.yl)()}},{key:"style",get:function(){return this.$$.ctx[0]},set:function(t){this.$set({style:t}),(0,r.yl)()}},{key:"dataKey",get:function(){return this.$$.ctx[1]},set:function(t){this.$set({dataKey:t}),(0,r.yl)()}},{key:"keyType",get:function(){return this.$$.ctx[2]},set:function(t){this.$set({keyType:t}),(0,r.yl)()}}])&&at(o.prototype,i),c&&at(o,c),a}(r.f_),ht=__webpack_require__(1237),gt=0,mt={injectType:"lazyStyleTag",insert:"head",singleton:!1},bt={};bt.locals=ht.Z.locals||{},bt.use=function(){return gt++||(pt=a()(ht.Z,mt)),bt},bt.unuse=function(){gt>0&&!--gt&&(pt(),pt=null)};var yt=bt;function Et(t,n){for(var e=0;e<n.length;e++){var o=n[e];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(t,o.key,o)}}function wt(t,n){return(wt=Object.setPrototypeOf||function(t,n){return t.__proto__=n,t})(t,n)}function Ot(t,n,e){var o=t.slice();return o[18]=n[e],o[20]=e,o}function Lt(t,n,e){var o=t.slice();return o[18]=n[e],o}function Ct(t,n,e){var o=t.slice();return o[18]=n[e],o[20]=e,o}function Tt(t){for(var n,e,o,i,c,a,l,u=[],s=new Map,f=[],d=new Map,v=[],p=new Map,_=t[5],h=function(t){return t[18]},g=0;g<_.length;g+=1){var m=Ct(t,_,g),b=h(m);s.set(b,u[g]=Rt(b,m))}for(var y=t[9]<t[5].length&&xt(t),E=t[7],w=function(t){return t[18]},O=0;O<E.length;O+=1){var L=Lt(t,E,O),C=w(L);d.set(C,f[O]=Pt(C,L))}for(var T=t[6],D=function(t){return t[18]},R=0;R<T.length;R+=1){var x=Ot(t,T,R),P=D(x);p.set(P,v[R]=kt(P,x))}var $=t[10]<t[6].length&&Mt(t),k=t[8]&&jt(t);return{c:function(){n=(0,r.bG)("div");for(var t=0;t<u.length;t+=1)u[t].c();e=(0,r.Dh)(),y&&y.c(),o=(0,r.Dh)();for(var l=0;l<f.length;l+=1)f[l].c();i=(0,r.Dh)();for(var s=0;s<v.length;s+=1)v[s].c();c=(0,r.Dh)(),$&&$.c(),a=(0,r.Dh)(),k&&k.c(),(0,r.Lj)(n,"class","vc-log-tree-child")},m:function(t,s){(0,r.$T)(t,n,s);for(var d=0;d<u.length;d+=1)u[d].m(n,null);(0,r.R3)(n,e),y&&y.m(n,null),(0,r.R3)(n,o);for(var p=0;p<f.length;p+=1)f[p].m(n,null);(0,r.R3)(n,i);for(var _=0;_<v.length;_+=1)v[_].m(n,null);(0,r.R3)(n,c),$&&$.m(n,null),(0,r.R3)(n,a),k&&k.m(n,null),l=!0},p:function(t,l){16928&l&&(_=t[5],(0,r.dv)(),u=(0,r.GQ)(u,l,h,1,t,_,s,n,r.cl,Rt,e,Ct),(0,r.gb)()),t[9]<t[5].length?y?y.p(t,l):((y=xt(t)).c(),y.m(n,o)):y&&(y.d(1),y=null),16512&l&&(E=t[7],(0,r.dv)(),f=(0,r.GQ)(f,l,w,1,t,E,d,n,r.cl,Pt,i,Lt),(0,r.gb)()),17472&l&&(T=t[6],(0,r.dv)(),v=(0,r.GQ)(v,l,D,1,t,T,p,n,r.cl,kt,c,Ot),(0,r.gb)()),t[10]<t[6].length?$?$.p(t,l):(($=Mt(t)).c(),$.m(n,a)):$&&($.d(1),$=null),t[8]?k?(k.p(t,l),256&l&&(0,r.Ui)(k,1)):((k=jt(t)).c(),(0,r.Ui)(k,1),k.m(n,null)):k&&((0,r.dv)(),(0,r.et)(k,1,1,(function(){k=null})),(0,r.gb)())},i:function(t){if(!l){for(var n=0;n<_.length;n+=1)(0,r.Ui)(u[n]);for(var e=0;e<E.length;e+=1)(0,r.Ui)(f[e]);for(var o=0;o<T.length;o+=1)(0,r.Ui)(v[o]);(0,r.Ui)(k),l=!0}},o:function(t){for(var n=0;n<u.length;n+=1)(0,r.et)(u[n]);for(var e=0;e<f.length;e+=1)(0,r.et)(f[e]);for(var o=0;o<v.length;o+=1)(0,r.et)(v[o]);(0,r.et)(k),l=!1},d:function(t){t&&(0,r.og)(n);for(var e=0;e<u.length;e+=1)u[e].d();y&&y.d();for(var o=0;o<f.length;o+=1)f[o].d();for(var i=0;i<v.length;i+=1)v[i].d();$&&$.d(),k&&k.d()}}}function Dt(t){var n,e;return n=new At({props:{origData:t[14](t[18]),dataKey:t[18]}}),{c:function(){(0,r.YC)(n.$$.fragment)},m:function(t,o){(0,r.ye)(n,t,o),e=!0},p:function(t,e){var o={};32&e&&(o.origData=t[14](t[18])),32&e&&(o.dataKey=t[18]),n.$set(o)},i:function(t){e||((0,r.Ui)(n.$$.fragment,t),e=!0)},o:function(t){(0,r.et)(n.$$.fragment,t),e=!1},d:function(t){(0,r.vp)(n,t)}}}function Rt(t,n){var e,o,i,c=n[20]<n[9]&&Dt(n);return{key:t,first:null,c:function(){e=(0,r.cS)(),c&&c.c(),o=(0,r.cS)(),this.first=e},m:function(t,n){(0,r.$T)(t,e,n),c&&c.m(t,n),(0,r.$T)(t,o,n),i=!0},p:function(t,e){(n=t)[20]<n[9]?c?(c.p(n,e),544&e&&(0,r.Ui)(c,1)):((c=Dt(n)).c(),(0,r.Ui)(c,1),c.m(o.parentNode,o)):c&&((0,r.dv)(),(0,r.et)(c,1,1,(function(){c=null})),(0,r.gb)())},i:function(t){i||((0,r.Ui)(c),i=!0)},o:function(t){(0,r.et)(c),i=!1},d:function(t){t&&(0,r.og)(e),c&&c.d(t),t&&(0,r.og)(o)}}}function xt(t){var n,e,o,i,c=t[12](t[5].length-t[9])+"";return{c:function(){n=(0,r.bG)("div"),e=(0,r.fL)(c),(0,r.Lj)(n,"class","vc-log-tree-loadmore")},m:function(c,a){(0,r.$T)(c,n,a),(0,r.R3)(n,e),o||(i=(0,r.oL)(n,"click",t[16]),o=!0)},p:function(t,n){544&n&&c!==(c=t[12](t[5].length-t[9])+"")&&(0,r.rT)(e,c)},d:function(t){t&&(0,r.og)(n),o=!1,i()}}}function Pt(t,n){var e,o,i;return o=new At({props:{origData:n[14](n[18]),dataKey:String(n[18]),keyType:"symbol"}}),{key:t,first:null,c:function(){e=(0,r.cS)(),(0,r.YC)(o.$$.fragment),this.first=e},m:function(t,n){(0,r.$T)(t,e,n),(0,r.ye)(o,t,n),i=!0},p:function(t,e){n=t;var r={};128&e&&(r.origData=n[14](n[18])),128&e&&(r.dataKey=String(n[18])),o.$set(r)},i:function(t){i||((0,r.Ui)(o.$$.fragment,t),i=!0)},o:function(t){(0,r.et)(o.$$.fragment,t),i=!1},d:function(t){t&&(0,r.og)(e),(0,r.vp)(o,t)}}}function $t(t){var n,e;return n=new At({props:{origData:t[14](t[18]),dataKey:t[18],keyType:"private"}}),{c:function(){(0,r.YC)(n.$$.fragment)},m:function(t,o){(0,r.ye)(n,t,o),e=!0},p:function(t,e){var o={};64&e&&(o.origData=t[14](t[18])),64&e&&(o.dataKey=t[18]),n.$set(o)},i:function(t){e||((0,r.Ui)(n.$$.fragment,t),e=!0)},o:function(t){(0,r.et)(n.$$.fragment,t),e=!1},d:function(t){(0,r.vp)(n,t)}}}function kt(t,n){var e,o,i,c=n[20]<n[10]&&$t(n);return{key:t,first:null,c:function(){e=(0,r.cS)(),c&&c.c(),o=(0,r.cS)(),this.first=e},m:function(t,n){(0,r.$T)(t,e,n),c&&c.m(t,n),(0,r.$T)(t,o,n),i=!0},p:function(t,e){(n=t)[20]<n[10]?c?(c.p(n,e),1088&e&&(0,r.Ui)(c,1)):((c=$t(n)).c(),(0,r.Ui)(c,1),c.m(o.parentNode,o)):c&&((0,r.dv)(),(0,r.et)(c,1,1,(function(){c=null})),(0,r.gb)())},i:function(t){i||((0,r.Ui)(c),i=!0)},o:function(t){(0,r.et)(c),i=!1},d:function(t){t&&(0,r.og)(e),c&&c.d(t),t&&(0,r.og)(o)}}}function Mt(t){var n,e,o,i,c=t[12](t[6].length-t[10])+"";return{c:function(){n=(0,r.bG)("div"),e=(0,r.fL)(c),(0,r.Lj)(n,"class","vc-log-tree-loadmore")},m:function(c,a){(0,r.$T)(c,n,a),(0,r.R3)(n,e),o||(i=(0,r.oL)(n,"click",t[17]),o=!0)},p:function(t,n){1088&n&&c!==(c=t[12](t[6].length-t[10])+"")&&(0,r.rT)(e,c)},d:function(t){t&&(0,r.og)(n),o=!1,i()}}}function jt(t){var n,e;return n=new At({props:{origData:t[14]("__proto__"),dataKey:"__proto__",keyType:"private"}}),{c:function(){(0,r.YC)(n.$$.fragment)},m:function(t,o){(0,r.ye)(n,t,o),e=!0},p:r.ZT,i:function(t){e||((0,r.Ui)(n.$$.fragment,t),e=!0)},o:function(t){(0,r.et)(n.$$.fragment,t),e=!1},d:function(t){(0,r.vp)(n,t)}}}function It(t){var n,e,o,i,c,a,l;o=new _t({props:{origData:t[0],dataKey:t[1],keyType:t[2]}});var u=t[4]&&t[3]&&Tt(t);return{c:function(){n=(0,r.bG)("div"),e=(0,r.bG)("div"),(0,r.YC)(o.$$.fragment),i=(0,r.Dh)(),u&&u.c(),(0,r.Lj)(e,"class","vc-log-tree-node"),(0,r.Lj)(n,"class","vc-log-tree"),(0,r.VH)(n,"vc-toggle",t[3]),(0,r.VH)(n,"vc-is-tree",t[4])},m:function(s,f){(0,r.$T)(s,n,f),(0,r.R3)(n,e),(0,r.ye)(o,e,null),(0,r.R3)(n,i),u&&u.m(n,null),c=!0,a||(l=(0,r.oL)(e,"click",t[13]),a=!0)},p:function(t,e){var i=e[0],c={};1&i&&(c.origData=t[0]),2&i&&(c.dataKey=t[1]),4&i&&(c.keyType=t[2]),o.$set(c),t[4]&&t[3]?u?(u.p(t,i),24&i&&(0,r.Ui)(u,1)):((u=Tt(t)).c(),(0,r.Ui)(u,1),u.m(n,null)):u&&((0,r.dv)(),(0,r.et)(u,1,1,(function(){u=null})),(0,r.gb)()),8&i&&(0,r.VH)(n,"vc-toggle",t[3]),16&i&&(0,r.VH)(n,"vc-is-tree",t[4])},i:function(t){c||((0,r.Ui)(o.$$.fragment,t),(0,r.Ui)(u),c=!0)},o:function(t){(0,r.et)(o.$$.fragment,t),(0,r.et)(u),c=!1},d:function(t){t&&(0,r.og)(n),(0,r.vp)(o),u&&u.d(),a=!1,l()}}}function St(t,e,o){var r,c,a,l=e.origData,u=e.dataKey,s=void 0===u?void 0:u,f=e.keyType,d=void 0===f?"":f,v=!1,p=!1,_=!1,h=!1,g=50,m=50;(0,i.H3)((function(){yt.use()})),(0,i.ev)((function(){yt.unuse()}));var b=function(t){"enum"===t?o(9,g+=50):"nonEnum"===t&&o(10,m+=50)};return t.$$set=function(t){"origData"in t&&o(0,l=t.origData),"dataKey"in t&&o(1,s=t.dataKey),"keyType"in t&&o(2,d=t.keyType)},t.$$.update=function(){33017&t.$$.dirty&&(v||(o(4,_=!(l instanceof q.Tg)&&(n.kJ(l)||n.Kn(l))),o(15,v=!0)),_&&p&&(o(5,r=r||n.qr(n.MH(l))),o(6,c=c||n.qr(n.QK(l))),o(7,a=a||n._D(l)),o(8,h=n.Kn(l)&&-1===c.indexOf("__proto__"))))},[l,s,d,p,_,r,c,a,h,g,m,b,function(t){return"(..."+t+" Key"+(t>1?"s":"")+" Left)"},function(){o(3,p=!p)},function(t){try{return l[t]}catch(t){return new q.Tg}},v,function(){return b("enum")},function(){return b("nonEnum")}]}var Ut,At=function(t){var n,e,o,i,c;function a(n){var e;return e=t.call(this)||this,(0,r.S1)(function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(e),n,St,It,r.N8,{origData:0,dataKey:1,keyType:2}),e}return e=t,(n=a).prototype=Object.create(e.prototype),n.prototype.constructor=n,wt(n,e),o=a,(i=[{key:"origData",get:function(){return this.$$.ctx[0]},set:function(t){this.$set({origData:t}),(0,r.yl)()}},{key:"dataKey",get:function(){return this.$$.ctx[1]},set:function(t){this.$set({dataKey:t}),(0,r.yl)()}},{key:"keyType",get:function(){return this.$$.ctx[2]},set:function(t){this.$set({keyType:t}),(0,r.yl)()}}])&&Et(o.prototype,i),c&&Et(o,c),a}(r.f_),Vt=At,Bt=__webpack_require__(7147),Nt=0,Gt={injectType:"lazyStyleTag",insert:"head",singleton:!1},Kt={};Kt.locals=Bt.Z.locals||{},Kt.use=function(){return Nt++||(Ut=a()(Bt.Z,Gt)),Kt},Kt.unuse=function(){Nt>0&&!--Nt&&(Ut(),Ut=null)};var Wt=Kt;function Ht(t,n){for(var e=0;e<n.length;e++){var o=n[e];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(t,o.key,o)}}function Ft(t,n){return(Ft=Object.setPrototypeOf||function(t,n){return t.__proto__=n,t})(t,n)}function qt(t,n,e){var o=t.slice();return o[3]=n[e],o[5]=e,o}function zt(t){var n,e,o,i,c,a,l,u,s=[],f=new Map;o=new nt({props:{handler:t[2]}});for(var d=t[0].repeated&&Zt(t),v=t[0].data,p=function(t){return t[5]},_=0;_<v.length;_+=1){var h=qt(t,v,_),g=p(h);f.set(g,s[_]=Jt(g,h))}return{c:function(){n=(0,r.bG)("div"),e=(0,r.bG)("div"),(0,r.YC)(o.$$.fragment),i=(0,r.Dh)(),d&&d.c(),c=(0,r.Dh)(),a=(0,r.bG)("div");for(var u=0;u<s.length;u+=1)s[u].c();(0,r.Lj)(e,"class","vc-logrow-icon"),(0,r.Lj)(a,"class","vc-log-content"),(0,r.Lj)(n,"class",l="vc-log-row vc-log-"+t[0].type),(0,r.VH)(n,"vc-log-input","input"===t[0].cmdType),(0,r.VH)(n,"vc-log-output","output"===t[0].cmdType)},m:function(t,l){(0,r.$T)(t,n,l),(0,r.R3)(n,e),(0,r.ye)(o,e,null),(0,r.R3)(n,i),d&&d.m(n,null),(0,r.R3)(n,c),(0,r.R3)(n,a);for(var f=0;f<s.length;f+=1)s[f].m(a,null);u=!0},p:function(t,e){t[0].repeated?d?d.p(t,e):((d=Zt(t)).c(),d.m(n,c)):d&&(d.d(1),d=null),3&e&&(v=t[0].data,(0,r.dv)(),s=(0,r.GQ)(s,e,p,1,t,v,f,a,r.cl,Jt,null,qt),(0,r.gb)()),(!u||1&e&&l!==(l="vc-log-row vc-log-"+t[0].type))&&(0,r.Lj)(n,"class",l),1&e&&(0,r.VH)(n,"vc-log-input","input"===t[0].cmdType),1&e&&(0,r.VH)(n,"vc-log-output","output"===t[0].cmdType)},i:function(t){if(!u){(0,r.Ui)(o.$$.fragment,t);for(var n=0;n<v.length;n+=1)(0,r.Ui)(s[n]);u=!0}},o:function(t){(0,r.et)(o.$$.fragment,t);for(var n=0;n<s.length;n+=1)(0,r.et)(s[n]);u=!1},d:function(t){t&&(0,r.og)(n),(0,r.vp)(o),d&&d.d();for(var e=0;e<s.length;e+=1)s[e].d()}}}function Zt(t){var n,e,o=t[0].repeated+"";return{c:function(){n=(0,r.bG)("div"),e=(0,r.fL)(o),(0,r.Lj)(n,"class","vc-log-repeat")},m:function(t,o){(0,r.$T)(t,n,o),(0,r.R3)(n,e)},p:function(t,n){1&n&&o!==(o=t[0].repeated+"")&&(0,r.rT)(e,o)},d:function(t){t&&(0,r.og)(n)}}}function Yt(t){var n,e;return n=new _t({props:{origData:t[3].origData,style:t[3].style}}),{c:function(){(0,r.YC)(n.$$.fragment)},m:function(t,o){(0,r.ye)(n,t,o),e=!0},p:function(t,e){var o={};1&e&&(o.origData=t[3].origData),1&e&&(o.style=t[3].style),n.$set(o)},i:function(t){e||((0,r.Ui)(n.$$.fragment,t),e=!0)},o:function(t){(0,r.et)(n.$$.fragment,t),e=!1},d:function(t){(0,r.vp)(n,t)}}}function Xt(t){var n,e;return n=new Vt({props:{origData:t[3].origData}}),{c:function(){(0,r.YC)(n.$$.fragment)},m:function(t,o){(0,r.ye)(n,t,o),e=!0},p:function(t,e){var o={};1&e&&(o.origData=t[3].origData),n.$set(o)},i:function(t){e||((0,r.Ui)(n.$$.fragment,t),e=!0)},o:function(t){(0,r.et)(n.$$.fragment,t),e=!1},d:function(t){(0,r.vp)(n,t)}}}function Jt(t,n){var e,o,i,c,a,l,u=[Xt,Yt],s=[];function f(t,n){return 1&n&&(o=!!t[1](t[3].origData)),o?0:1}return i=f(n,-1),c=s[i]=u[i](n),{key:t,first:null,c:function(){e=(0,r.cS)(),c.c(),a=(0,r.cS)(),this.first=e},m:function(t,n){(0,r.$T)(t,e,n),s[i].m(t,n),(0,r.$T)(t,a,n),l=!0},p:function(t,e){var o=i;(i=f(n=t,e))===o?s[i].p(n,e):((0,r.dv)(),(0,r.et)(s[o],1,1,(function(){s[o]=null})),(0,r.gb)(),(c=s[i])?c.p(n,e):(c=s[i]=u[i](n)).c(),(0,r.Ui)(c,1),c.m(a.parentNode,a))},i:function(t){l||((0,r.Ui)(c),l=!0)},o:function(t){(0,r.et)(c),l=!1},d:function(t){t&&(0,r.og)(e),s[i].d(t),t&&(0,r.og)(a)}}}function Qt(t){var n,e,o=t[0]&&zt(t);return{c:function(){o&&o.c(),n=(0,r.cS)()},m:function(t,i){o&&o.m(t,i),(0,r.$T)(t,n,i),e=!0},p:function(t,e){var i=e[0];t[0]?o?(o.p(t,i),1&i&&(0,r.Ui)(o,1)):((o=zt(t)).c(),(0,r.Ui)(o,1),o.m(n.parentNode,n)):o&&((0,r.dv)(),(0,r.et)(o,1,1,(function(){o=null})),(0,r.gb)())},i:function(t){e||((0,r.Ui)(o),e=!0)},o:function(t){(0,r.et)(o),e=!1},d:function(t){o&&o.d(t),t&&(0,r.og)(n)}}}function tn(t,e,o){var r=e.log;(0,i.H3)((function(){Wt.use()})),(0,i.ev)((function(){Wt.unuse()}));return t.$$set=function(t){"log"in t&&o(0,r=t.log)},[r,function(t){return!(t instanceof q.Tg)&&(n.kJ(t)||n.Kn(t))},function(){var t=[];try{for(var e=0;e<r.data.length;e++)t.push(n.hZ(r.data[e].origData,10,1e4))}catch(t){}return t.join(" ")}]}var nn,en=function(t){var n,e,o,i,c;function a(n){var e;return e=t.call(this)||this,(0,r.S1)(function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(e),n,tn,Qt,r.N8,{log:0}),e}return e=t,(n=a).prototype=Object.create(e.prototype),n.prototype.constructor=n,Ft(n,e),o=a,(i=[{key:"log",get:function(){return this.$$.ctx[0]},set:function(t){this.$set({log:t}),(0,r.yl)()}}])&&Ht(o.prototype,i),c&&Ht(o,c),a}(r.f_),on=__webpack_require__(3903),rn=__webpack_require__(3327),cn=0,an={injectType:"lazyStyleTag",insert:"head",singleton:!1},ln={};ln.locals=rn.Z.locals||{},ln.use=function(){return cn++||(nn=a()(rn.Z,an)),ln},ln.unuse=function(){cn>0&&!--cn&&(nn(),nn=null)};var un=ln;function sn(t,n){for(var e=0;e<n.length;e++){var o=n[e];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(t,o.key,o)}}function fn(t,n){return(fn=Object.setPrototypeOf||function(t,n){return t.__proto__=n,t})(t,n)}function dn(t,n,e){var o=t.slice();return o[8]=n[e],o}function vn(t){var n;return{c:function(){n=(0,r.bG)("div"),(0,r.Lj)(n,"class","vc-plugin-empty")},m:function(t,e){(0,r.$T)(t,n,e)},p:r.ZT,i:r.ZT,o:r.ZT,d:function(t){t&&(0,r.og)(n)}}}function pn(t){for(var n,e,o=[],i=new Map,c=t[4].logList,a=function(t){return t[8]._id},l=0;l<c.length;l+=1){var u=dn(t,c,l),s=a(u);i.set(s,o[l]=hn(s,u))}return{c:function(){for(var t=0;t<o.length;t+=1)o[t].c();n=(0,r.cS)()},m:function(t,i){for(var c=0;c<o.length;c+=1)o[c].m(t,i);(0,r.$T)(t,n,i),e=!0},p:function(t,e){22&e&&(c=t[4].logList,(0,r.dv)(),o=(0,r.GQ)(o,e,a,1,t,c,i,n.parentNode,r.cl,hn,n,dn),(0,r.gb)())},i:function(t){if(!e){for(var n=0;n<c.length;n+=1)(0,r.Ui)(o[n]);e=!0}},o:function(t){for(var n=0;n<o.length;n+=1)(0,r.et)(o[n]);e=!1},d:function(t){for(var e=0;e<o.length;e+=1)o[e].d(t);t&&(0,r.og)(n)}}}function _n(t){var n,e;return n=new en({props:{log:t[8]}}),{c:function(){(0,r.YC)(n.$$.fragment)},m:function(t,o){(0,r.ye)(n,t,o),e=!0},p:function(t,e){var o={};16&e&&(o.log=t[8]),n.$set(o)},i:function(t){e||((0,r.Ui)(n.$$.fragment,t),e=!0)},o:function(t){(0,r.et)(n.$$.fragment,t),e=!1},d:function(t){(0,r.vp)(n,t)}}}function hn(t,n){var e,o,i,c=("all"===n[1]||n[1]===n[8].type)&&(""===n[2]||(0,q.HX)(n[8],n[2])),a=c&&_n(n);return{key:t,first:null,c:function(){e=(0,r.cS)(),a&&a.c(),o=(0,r.cS)(),this.first=e},m:function(t,n){(0,r.$T)(t,e,n),a&&a.m(t,n),(0,r.$T)(t,o,n),i=!0},p:function(t,e){n=t,22&e&&(c=("all"===n[1]||n[1]===n[8].type)&&(""===n[2]||(0,q.HX)(n[8],n[2]))),c?a?(a.p(n,e),22&e&&(0,r.Ui)(a,1)):((a=_n(n)).c(),(0,r.Ui)(a,1),a.m(o.parentNode,o)):a&&((0,r.dv)(),(0,r.et)(a,1,1,(function(){a=null})),(0,r.gb)())},i:function(t){i||((0,r.Ui)(a),i=!0)},o:function(t){(0,r.et)(a),i=!1},d:function(t){t&&(0,r.og)(e),a&&a.d(t),t&&(0,r.og)(o)}}}function gn(t){var n,e;return(n=new on.Z({})).$on("filterText",t[5]),{c:function(){(0,r.YC)(n.$$.fragment)},m:function(t,o){(0,r.ye)(n,t,o),e=!0},p:r.ZT,i:function(t){e||((0,r.Ui)(n.$$.fragment,t),e=!0)},o:function(t){(0,r.et)(n.$$.fragment,t),e=!1},d:function(t){(0,r.vp)(n,t)}}}function mn(t){var n,e,o,i,c,a=[pn,vn],l=[];function u(t,n){return t[4]&&t[4].logList.length>0?0:1}e=u(t),o=l[e]=a[e](t);var s=t[0]&&gn(t);return{c:function(){n=(0,r.bG)("div"),o.c(),i=(0,r.Dh)(),s&&s.c(),(0,r.Lj)(n,"class","vc-plugin-content"),(0,r.VH)(n,"vc-logs-has-cmd",t[0])},m:function(t,o){(0,r.$T)(t,n,o),l[e].m(n,null),(0,r.R3)(n,i),s&&s.m(n,null),c=!0},p:function(t,c){var f=c[0],d=e;(e=u(t))===d?l[e].p(t,f):((0,r.dv)(),(0,r.et)(l[d],1,1,(function(){l[d]=null})),(0,r.gb)(),(o=l[e])?o.p(t,f):(o=l[e]=a[e](t)).c(),(0,r.Ui)(o,1),o.m(n,i)),t[0]?s?(s.p(t,f),1&f&&(0,r.Ui)(s,1)):((s=gn(t)).c(),(0,r.Ui)(s,1),s.m(n,null)):s&&((0,r.dv)(),(0,r.et)(s,1,1,(function(){s=null})),(0,r.gb)()),1&f&&(0,r.VH)(n,"vc-logs-has-cmd",t[0])},i:function(t){c||((0,r.Ui)(o),(0,r.Ui)(s),c=!0)},o:function(t){(0,r.et)(o),(0,r.et)(s),c=!1},d:function(t){t&&(0,r.og)(n),l[e].d(),s&&s.d()}}}function bn(t,n,e){var o,c=r.ZT;t.$$.on_destroy.push((function(){return c()}));var a,l=n.pluginId,u=void 0===l?"default":l,s=n.showCmd,f=void 0!==s&&s,d=n.filterType,v=void 0===d?"all":d,p=!1,_="";(0,i.H3)((function(){un.use()})),(0,i.ev)((function(){un.unuse()}));return t.$$set=function(t){"pluginId"in t&&e(6,u=t.pluginId),"showCmd"in t&&e(0,f=t.showCmd),"filterType"in t&&e(1,v=t.filterType)},t.$$.update=function(){192&t.$$.dirty&&(p||(e(3,a=z.O.get(u)),c(),c=(0,r.Ld)(a,(function(t){return e(4,o=t)})),e(7,p=!0)))},[f,v,_,a,o,function(t){e(2,_=t.detail.filterText||"")},u,p]}var yn=function(t){var n,e,o,i,c;function a(n){var e;return e=t.call(this)||this,(0,r.S1)(function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(e),n,bn,mn,r.N8,{pluginId:6,showCmd:0,filterType:1}),e}return e=t,(n=a).prototype=Object.create(e.prototype),n.prototype.constructor=n,fn(n,e),o=a,(i=[{key:"pluginId",get:function(){return this.$$.ctx[6]},set:function(t){this.$set({pluginId:t}),(0,r.yl)()}},{key:"showCmd",get:function(){return this.$$.ctx[0]},set:function(t){this.$set({showCmd:t}),(0,r.yl)()}},{key:"filterType",get:function(){return this.$$.ctx[1]},set:function(t){this.$set({filterType:t}),(0,r.yl)()}}])&&sn(o.prototype,i),c&&sn(o,c),a}(r.f_),En=__webpack_require__(5629);function wn(t,n){return(wn=Object.setPrototypeOf||function(t,n){return t.__proto__=n,t})(t,n)}var On=function(t){var n,e;function o(n,e){var o;return(o=t.call(this,n,e,yn,{pluginId:n,filterType:"all"})||this).module=En.W.getSingleton(En.W,"VConsoleLogModel"),o.isReady=!1,o.isShow=!1,o.isInBottom=!0,o.module.bindPlugin(n),o}e=t,(n=o).prototype=Object.create(e.prototype),n.prototype.constructor=n,wn(n,e);var r=o.prototype;return r.onReady=function(){t.prototype.onReady.call(this),this.module.maxLogNumber=Number(this.vConsole.option.maxLogNumber)||1e3},r.onRemove=function(){t.prototype.onRemove.call(this),this.module.unbindPlugin(this.id)},r.onAddTopBar=function(t){for(var n=this,e=["All","Log","Info","Warn","Error"],o=[],r=0;r<e.length;r++)o.push({name:e[r],data:{type:e[r].toLowerCase()},actived:0===r,className:"",onClick:function(t,e){if(e.type===n.compInstance.filterType)return!1;n.compInstance.filterType=e.type}});o[0].className="vc-actived",t(o)},r.onAddTool=function(t){var n=this;t([{name:"Clear",global:!1,onClick:function(t){n.module.clearPluginLog(n.id),n.vConsole.triggerEvent("clearLog")}}])},r.onUpdateOption=function(){this.vConsole.option.maxLogNumber!==this.module.maxLogNumber&&(this.module.maxLogNumber=Number(this.vConsole.option.maxLogNumber)||1e3)},o}(F);function Ln(t,n){return(Ln=Object.setPrototypeOf||function(t,n){return t.__proto__=n,t})(t,n)}var Cn=function(t){var e,o;function r(){for(var n,e=arguments.length,o=new Array(e),r=0;r<e;r++)o[r]=arguments[r];return(n=t.call.apply(t,[this].concat(o))||this).onErrorHandler=void 0,n.resourceErrorHandler=void 0,n.rejectionHandler=void 0,n}o=t,(e=r).prototype=Object.create(o.prototype),e.prototype.constructor=e,Ln(e,o);var i=r.prototype;return i.onReady=function(){t.prototype.onReady.call(this),this.bindErrors(),this.compInstance.showCmd=!0},i.onRemove=function(){t.prototype.onRemove.call(this),this.unbindErrors()},i.bindErrors=function(){n.FJ(window)&&n.mf(window.addEventListener)&&(this.catchWindowOnError(),this.catchResourceError(),this.catchUnhandledRejection())},i.unbindErrors=function(){n.FJ(window)&&n.mf(window.addEventListener)&&(window.removeEventListener("error",this.onErrorHandler),window.removeEventListener("error",this.resourceErrorHandler),window.removeEventListener("unhandledrejection",this.rejectionHandler))},i.catchWindowOnError=function(){var t=this;this.onErrorHandler=this.onErrorHandler?this.onErrorHandler:function(n){var e=n.message;n.filename&&(e+="\n"+n.filename.replace(location.origin,"")),(n.lineno||n.colno)&&(e+=":"+n.lineno+":"+n.colno);var o=!!n.error&&!!n.error.stack&&n.error.stack.toString()||"";t.module.addLog({type:"error",origData:[e,o]},{noOrig:!0})},window.removeEventListener("error",this.onErrorHandler),window.addEventListener("error",this.onErrorHandler)},i.catchResourceError=function(){var t=this;this.resourceErrorHandler=this.resourceErrorHandler?this.resourceErrorHandler:function(n){var e=n.target;if(["link","video","script","img","audio"].indexOf(e.localName)>-1){var o=e.href||e.src||e.currentSrc;t.module.addLog({type:"error",origData:["GET <"+e.localName+"> error: "+o]},{noOrig:!0})}},window.removeEventListener("error",this.resourceErrorHandler),window.addEventListener("error",this.resourceErrorHandler,!0)},i.catchUnhandledRejection=function(){var t=this;this.rejectionHandler=this.rejectionHandler?this.rejectionHandler:function(n){var e=n&&n.reason,o="Uncaught (in promise) ",r=[o,e];e instanceof Error&&(r=[o,{name:e.name,message:e.message,stack:e.stack}]),t.module.addLog({type:"error",origData:r},{noOrig:!0})},window.removeEventListener("unhandledrejection",this.rejectionHandler),window.addEventListener("unhandledrejection",this.rejectionHandler)},r}(On);function Tn(t,n){return(Tn=Object.setPrototypeOf||function(t,n){return t.__proto__=n,t})(t,n)}var Dn=function(t){var n,e;function o(){return t.apply(this,arguments)||this}e=t,(n=o).prototype=Object.create(e.prototype),n.prototype.constructor=n,Tn(n,e);var r=o.prototype;return r.onReady=function(){t.prototype.onReady.call(this),this.printSystemInfo()},r.printSystemInfo=function(){var t=navigator.userAgent,n=[],e=t.match(/MicroMessenger\/([\d\.]+)/i),o=e&&e[1]?e[1]:null;"servicewechat.com"===location.host||console.info("[system]","Location:",location.href);var r=t.match(/(ipod).*\s([\d_]+)/i),i=t.match(/(ipad).*\s([\d_]+)/i),c=t.match(/(iphone)\sos\s([\d_]+)/i),a=t.match(/(android)\s([\d\.]+)/i),l=t.match(/(Mac OS X)\s([\d_]+)/i);n=[],a?n.push("Android "+a[2]):c?n.push("iPhone, iOS "+c[2].replace(/_/g,".")):i?n.push("iPad, iOS "+i[2].replace(/_/g,".")):r?n.push("iPod, iOS "+r[2].replace(/_/g,".")):l&&n.push("Mac, MacOS "+l[2].replace(/_/g,".")),o&&n.push("WeChat "+o),console.info("[system]","Client:",n.length?n.join(", "):"Unknown");var u=t.toLowerCase().match(/ nettype\/([^ ]+)/g);u&&u[0]&&(n=[(u=u[0].split("/"))[1]],console.info("[system]","Network:",n.length?n.join(", "):"Unknown")),console.info("[system]","UA:",t),setTimeout((function(){var t=window.performance||window.msPerformance||window.webkitPerformance;if(t&&t.timing){var n=t.timing;n.navigationStart&&console.info("[system]","navigationStart:",n.navigationStart),n.navigationStart&&n.domainLookupStart&&console.info("[system]","navigation:",n.domainLookupStart-n.navigationStart+"ms"),n.domainLookupEnd&&n.domainLookupStart&&console.info("[system]","dns:",n.domainLookupEnd-n.domainLookupStart+"ms"),n.connectEnd&&n.connectStart&&(n.connectEnd&&n.secureConnectionStart?console.info("[system]","tcp (ssl):",n.connectEnd-n.connectStart+"ms ("+(n.connectEnd-n.secureConnectionStart)+"ms)"):console.info("[system]","tcp:",n.connectEnd-n.connectStart+"ms")),n.responseStart&&n.requestStart&&console.info("[system]","request:",n.responseStart-n.requestStart+"ms"),n.responseEnd&&n.responseStart&&console.info("[system]","response:",n.responseEnd-n.responseStart+"ms"),n.domComplete&&n.domLoading&&(n.domContentLoadedEventStart&&n.domLoading?console.info("[system]","domComplete (domLoaded):",n.domComplete-n.domLoading+"ms ("+(n.domContentLoadedEventStart-n.domLoading)+"ms)"):console.info("[system]","domComplete:",n.domComplete-n.domLoading+"ms")),n.loadEventEnd&&n.loadEventStart&&console.info("[system]","loadEvent:",n.loadEventEnd-n.loadEventStart+"ms"),n.navigationStart&&n.loadEventEnd&&console.info("[system]","total (DOM):",n.loadEventEnd-n.navigationStart+"ms ("+(n.domComplete-n.navigationStart)+"ms)")}}),0)},o}(On),Rn=__webpack_require__(4683),xn=__webpack_require__(643);function Pn(t,n){var e="undefined"!=typeof Symbol&&t[Symbol.iterator]||t["@@iterator"];if(e)return(e=e.call(t)).next.bind(e);if(Array.isArray(t)||(e=function(t,n){if(!t)return;if("string"==typeof t)return $n(t,n);var e=Object.prototype.toString.call(t).slice(8,-1);"Object"===e&&t.constructor&&(e=t.constructor.name);if("Map"===e||"Set"===e)return Array.from(t);if("Arguments"===e||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e))return $n(t,n)}(t))||n&&t&&"number"==typeof t.length){e&&(t=e);var o=0;return function(){return o>=t.length?{done:!0}:{done:!1,value:t[o++]}}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}function $n(t,n){(null==n||n>t.length)&&(n=t.length);for(var e=0,o=new Array(n);e<n;e++)o[e]=t[e];return o}function kn(t,n){return(kn=Object.setPrototypeOf||function(t,n){return t.__proto__=n,t})(t,n)}var Mn,jn=function(t){this.id="",this.name="",this.method="",this.url="",this.status=0,this.statusText="",this.readyState=0,this.header=null,this.responseType=void 0,this.requestType=void 0,this.requestHeader=null,this.response=void 0,this.startTime=0,this.endTime=0,this.costTime=0,this.getData=null,this.postData=null,this.actived=!1,this.id=t},In=(0,Rn.fZ)({}),Sn=function(t){var e,o;function r(){var n;return(n=t.call(this)||this)._xhrOpen=void 0,n._xhrSend=void 0,n._xhrSetRequestHeader=void 0,n._fetch=void 0,n._sendBeacon=void 0,n.mockXHR(),n.mockFetch(),n.mockSendBeacon(),n}o=t,(e=r).prototype=Object.create(o.prototype),e.prototype.constructor=e,kn(e,o);var i=r.prototype;return i.unMock=function(){window.XMLHttpRequest&&(window.XMLHttpRequest.prototype.open=this._xhrOpen,window.XMLHttpRequest.prototype.send=this._xhrSend,window.XMLHttpRequest.prototype.setRequestHeader=this._xhrSetRequestHeader,this._xhrOpen=void 0,this._xhrSend=void 0,this._xhrSetRequestHeader=void 0),window.fetch&&(window.fetch=this._fetch,this._fetch=void 0),window.navigator.sendBeacon&&(window.navigator.sendBeacon=this._sendBeacon,this._sendBeacon=void 0)},i.clearLog=function(){In.set({})},i.updateRequest=function(t,n){var e=(0,Rn.U2)(In),o=!!e[t],r=o?e[t]:new jn(t);for(var i in n)r[i]=n[i];In.update((function(n){return n[t]=r,n})),o||b.x.updateTime()},i.mockXHR=function(){if(window.XMLHttpRequest){var t=this,e=window.XMLHttpRequest.prototype.open,o=window.XMLHttpRequest.prototype.send,r=window.XMLHttpRequest.prototype.setRequestHeader;t._xhrOpen=e,t._xhrSend=o,t._xhrSetRequestHeader=r,window.XMLHttpRequest.prototype.open=function(){var o=this,r=[].slice.call(arguments),i=r[0],c=r[1],a=n.QI(),l=null;o._requestID=a,o._method=i,o._url=c;var u=o.onreadystatechange||function(){},s=function(){var e=(0,Rn.U2)(In),r=e[a]||new jn(a);switch(r.readyState=o.readyState,r.responseType=o.responseType,r.requestType="xhr",o.readyState){case 0:case 1:r.status=0,r.statusText="Pending",r.startTime||(r.startTime=+new Date);break;case 2:r.status=o.status,r.statusText="Loading",r.header={};for(var i=o.getAllResponseHeaders()||"",c=i.split("\n"),s=0;s<c.length;s++){var f=c[s];if(f){var d=f.split(": "),v=d[0],p=d.slice(1).join(": ");r.header[v]=p}}break;case 3:r.status=o.status,r.statusText="Loading";break;case 4:clearInterval(l),r.status=o.status,r.statusText=String(o.status),r.endTime=+new Date,r.costTime=r.endTime-(r.startTime||r.endTime),r.response=o.response;break;default:clearInterval(l),r.status=o.status,r.statusText="Unknown"}switch(o.responseType){case"":case"text":if(n.HD(o.response))try{r.response=JSON.parse(o.response),r.response=n.hZ(r.response,10,5e5)}catch(t){r.response=o.response}else void 0!==o.response&&(r.response=Object.prototype.toString.call(o.response));break;case"json":void 0!==o.response&&(r.response=n.hZ(o.response,10,5e5));break;case"blob":case"document":case"arraybuffer":default:void 0!==o.response&&(r.response=Object.prototype.toString.call(o.response))}return o._noVConsole||t.updateRequest(a,r),u.apply(o,arguments)};o.onreadystatechange=s;var f=-1;return l=setInterval((function(){f!=o.readyState&&(f=o.readyState,s.call(o))}),10),e.apply(o,r)},window.XMLHttpRequest.prototype.setRequestHeader=function(){var t=this,n=[].slice.call(arguments),e=(0,Rn.U2)(In),o=e[t._requestID];return o&&(o.requestHeader||(o.requestHeader={}),o.requestHeader[n[0]]=n[1]),r.apply(t,n)},window.XMLHttpRequest.prototype.send=function(){var e=this,r=[].slice.call(arguments),i=r[0],c=e,a=c._requestID,l=void 0===a?n.QI():a,u=c._url,s=c._method,f=(0,Rn.U2)(In),d=f[l]||new jn(l);d.method=s?s.toUpperCase():"GET";var v=u?u.split("?"):[];if(d.url=u||"",d.name=v.shift()||"",d.name=d.name.replace(new RegExp("[/]*$"),"").split("/").pop()||"",v.length>0){d.name+="?"+v,d.getData={};for(var p,_=Pn(v=(v=v.join("?")).split("&"));!(p=_()).done;){var h=p.value;h=h.split("=");try{d.getData[h[0]]=decodeURIComponent(h[1])}catch(t){d.getData[h[0]]=h[1]}}}if("POST"==d.method)if(n.HD(i))try{d.postData=JSON.parse(i)}catch(t){var g=i.split("&");d.postData={};for(var m,b=Pn(g);!(m=b()).done;){var y=m.value;y=y.split("="),d.postData[y[0]]=y[1]}}else n.PO(i)?d.postData=i:d.postData="[object Object]";return e._noVConsole||t.updateRequest(l,d),o.apply(e,r)}}},i.mockFetch=function(){var t=window.fetch;if(t){var e=this;this._fetch=t,window.fetch=function(o,r){var i=n.QI(),c=new jn(i);In.update((function(t){return t[i]=c,t}));var a,l,u="GET",s=null;if(n.HD(o)?(u=(null==r?void 0:r.method)||"GET",a=e.getURL(o),s=(null==r?void 0:r.headers)||null):(u=o.method||"GET",a=e.getURL(o.url),s=o.headers),c.id=i,c.method=u,c.requestType="fetch",c.requestHeader=s,c.url=a.toString(),c.name=(a.pathname.split("/").pop()||"")+a.search,c.status=0,c.statusText="Pending",c.startTime||(c.startTime=+new Date),"[object Headers]"===Object.prototype.toString.call(s)){c.requestHeader={};for(var f,d=Pn(s);!(f=d()).done;){var v=f.value,p=v[0],_=v[1];c.requestHeader[p]=_}}else c.requestHeader=s;if(a.search&&a.searchParams){c.getData={};for(var h,g=Pn(a.searchParams);!(h=g()).done;){var m=h.value,b=m[0],y=m[1];c.getData[b]=y}}"POST"===c.method&&(n.HD(o)?c.postData=e.getFormattedBody(r.body):c.postData="[object Object]");var E=n.HD(o)?a.toString():o;return t(E,r).then((function(t){var n=t.clone();l=n.clone(),c.endTime=+new Date,c.costTime=c.endTime-(c.startTime||c.endTime),c.status=n.status,c.statusText=String(n.status),c.header={};for(var e,o=Pn(n.headers);!(e=o()).done;){var r=e.value,i=r[0],a=r[1];c.header[i]=a}c.readyState=4;var u=n.headers.get("content-type");return u&&u.includes("application/json")?(c.responseType="json",n.clone().text()):u&&(u.includes("text/html")||u.includes("text/plain"))?(c.responseType="text",n.clone().text()):(c.responseType="","[object Object]")})).then((function(t){switch(c.responseType){case"json":try{c.response=JSON.parse(t),c.response=n.hZ(c.response,10,5e5)}catch(n){c.response=t,c.responseType="text"}break;case"text":default:c.response=t}return e.updateRequest(i,c),l})).catch((function(t){throw e.updateRequest(i,c),t}))}}},i.mockSendBeacon=function(){var t=window.navigator.sendBeacon;if(t){var e=this;this._sendBeacon=t;var o=function(t){return t instanceof Blob?t.type:t instanceof FormData?"multipart/form-data":t instanceof URLSearchParams?"application/x-www-form-urlencoded;charset=UTF-8":"text/plain;charset=UTF-8"};window.navigator.sendBeacon=function(r,i){var c=n.QI(),a=new jn(c);In.update((function(t){return t[c]=a,t}));var l=e.getURL(r);if(a.id=c,a.method="POST",a.url=r,a.name=(l.pathname.split("/").pop()||"")+l.search,a.requestType="ping",a.requestHeader={"Content-Type":o(i)},a.status=0,a.statusText="Pending",l.search&&l.searchParams){a.getData={};for(var u,s=Pn(l.searchParams);!(u=s()).done;){var f=u.value,d=f[0],v=f[1];a.getData[d]=v}}a.postData=e.getFormattedBody(i),a.startTime||(a.startTime=+new Date);var p=t.call(window.navigator,r,i);return p?(a.endTime=+new Date,a.costTime=a.endTime-(a.startTime||a.endTime),a.status=0,a.statusText="Sent",a.readyState=4):(a.status=500,a.statusText="Unknown"),e.updateRequest(c,a),p}}},i.getFormattedBody=function(t){if(!t)return null;var e=null,o=n.zl(t);switch(o){case"String":try{e=JSON.parse(t)}catch(n){e=t}break;case"URLSearchParams":e={};for(var r,i=Pn(t);!(r=i()).done;){var c=r.value,a=c[0],l=c[1];e[a]=l}break;default:e="[object "+o+"]"}return e},i.getURL=function(t){(void 0===t&&(t=""),t.startsWith("//"))&&(t=""+new URL(window.location.href).protocol+t);return t.startsWith("http")?new URL(t):new URL(t,window.location.href)},r}(xn.N),Un=__webpack_require__(8747),An=0,Vn={injectType:"lazyStyleTag",insert:"head",singleton:!1},Bn={};Bn.locals=Un.Z.locals||{},Bn.use=function(){return An++||(Mn=a()(Un.Z,Vn)),Bn},Bn.unuse=function(){An>0&&!--An&&(Mn(),Mn=null)};var Nn=Bn;function Gn(t,n){return(Gn=Object.setPrototypeOf||function(t,n){return t.__proto__=n,t})(t,n)}function Kn(t,n,e){var o=t.slice();return o[6]=n[e][0],o[7]=n[e][1],o}function Wn(t,n,e){var o=t.slice();return o[10]=n[e][0],o[11]=n[e][1],o}function Hn(t,n,e){var o=t.slice();return o[10]=n[e][0],o[11]=n[e][1],o}function Fn(t,n,e){var o=t.slice();return o[10]=n[e][0],o[11]=n[e][1],o}function qn(t,n,e){var o=t.slice();return o[10]=n[e][0],o[11]=n[e][1],o}function zn(t){var n,e,o;return{c:function(){n=(0,r.fL)("("),e=(0,r.fL)(t[0]),o=(0,r.fL)(")")},m:function(t,i){(0,r.$T)(t,n,i),(0,r.$T)(t,e,i),(0,r.$T)(t,o,i)},p:function(t,n){1&n&&(0,r.rT)(e,t[0])},d:function(t){t&&(0,r.og)(n),t&&(0,r.og)(e),t&&(0,r.og)(o)}}}function Zn(t){var n,e,o,i,c,a,l,u;a=new nt({props:{content:t[7].header}});for(var s=Object.entries(t[7].header),f=[],d=0;d<s.length;d+=1)f[d]=Yn(qn(t,s,d));return{c:function(){n=(0,r.bG)("div"),e=(0,r.bG)("dl"),o=(0,r.bG)("dt"),i=(0,r.fL)("Response Headers\n                "),c=(0,r.bG)("i"),(0,r.YC)(a.$$.fragment),l=(0,r.Dh)();for(var t=0;t<f.length;t+=1)f[t].c();(0,r.Lj)(c,"class","vc-table-row-icon"),(0,r.Lj)(o,"class","vc-table-col vc-table-col-title"),(0,r.Lj)(e,"class","vc-table-row vc-left-border")},m:function(t,s){(0,r.$T)(t,n,s),(0,r.R3)(n,e),(0,r.R3)(e,o),(0,r.R3)(o,i),(0,r.R3)(o,c),(0,r.ye)(a,c,null),(0,r.R3)(n,l);for(var d=0;d<f.length;d+=1)f[d].m(n,null);u=!0},p:function(t,e){var o={};if(2&e&&(o.content=t[7].header),a.$set(o),2&e){var r;for(s=Object.entries(t[7].header),r=0;r<s.length;r+=1){var i=qn(t,s,r);f[r]?f[r].p(i,e):(f[r]=Yn(i),f[r].c(),f[r].m(n,null))}for(;r<f.length;r+=1)f[r].d(1);f.length=s.length}},i:function(t){u||((0,r.Ui)(a.$$.fragment,t),u=!0)},o:function(t){(0,r.et)(a.$$.fragment,t),u=!1},d:function(t){t&&(0,r.og)(n),(0,r.vp)(a),(0,r.RM)(f,t)}}}function Yn(t){var n,e,o,i,c,a,l,u=t[10]+"",s=t[11]+"";return{c:function(){n=(0,r.bG)("div"),e=(0,r.bG)("div"),o=(0,r.fL)(u),i=(0,r.Dh)(),c=(0,r.bG)("div"),a=(0,r.fL)(s),l=(0,r.Dh)(),(0,r.Lj)(e,"class","vc-table-col vc-table-col-2"),(0,r.Lj)(c,"class","vc-table-col vc-table-col-4 vc-table-col-value vc-max-height-line"),(0,r.Lj)(n,"class","vc-table-row vc-left-border vc-small")},m:function(t,u){(0,r.$T)(t,n,u),(0,r.R3)(n,e),(0,r.R3)(e,o),(0,r.R3)(n,i),(0,r.R3)(n,c),(0,r.R3)(c,a),(0,r.R3)(n,l)},p:function(t,n){2&n&&u!==(u=t[10]+"")&&(0,r.rT)(o,u),2&n&&s!==(s=t[11]+"")&&(0,r.rT)(a,s)},d:function(t){t&&(0,r.og)(n)}}}function Xn(t){var n,e,o,i,c,a,l,u;a=new nt({props:{content:t[7].requestHeader}});for(var s=Object.entries(t[7].requestHeader),f=[],d=0;d<s.length;d+=1)f[d]=Jn(Fn(t,s,d));return{c:function(){n=(0,r.bG)("div"),e=(0,r.bG)("dl"),o=(0,r.bG)("dt"),i=(0,r.fL)("Request Headers\n                "),c=(0,r.bG)("i"),(0,r.YC)(a.$$.fragment),l=(0,r.Dh)();for(var t=0;t<f.length;t+=1)f[t].c();(0,r.Lj)(c,"class","vc-table-row-icon"),(0,r.Lj)(o,"class","vc-table-col vc-table-col-title"),(0,r.Lj)(e,"class","vc-table-row vc-left-border")},m:function(t,s){(0,r.$T)(t,n,s),(0,r.R3)(n,e),(0,r.R3)(e,o),(0,r.R3)(o,i),(0,r.R3)(o,c),(0,r.ye)(a,c,null),(0,r.R3)(n,l);for(var d=0;d<f.length;d+=1)f[d].m(n,null);u=!0},p:function(t,e){var o={};if(2&e&&(o.content=t[7].requestHeader),a.$set(o),2&e){var r;for(s=Object.entries(t[7].requestHeader),r=0;r<s.length;r+=1){var i=Fn(t,s,r);f[r]?f[r].p(i,e):(f[r]=Jn(i),f[r].c(),f[r].m(n,null))}for(;r<f.length;r+=1)f[r].d(1);f.length=s.length}},i:function(t){u||((0,r.Ui)(a.$$.fragment,t),u=!0)},o:function(t){(0,r.et)(a.$$.fragment,t),u=!1},d:function(t){t&&(0,r.og)(n),(0,r.vp)(a),(0,r.RM)(f,t)}}}function Jn(t){var n,e,o,i,c,a,l,u=t[10]+"",s=t[11]+"";return{c:function(){n=(0,r.bG)("div"),e=(0,r.bG)("div"),o=(0,r.fL)(u),i=(0,r.Dh)(),c=(0,r.bG)("div"),a=(0,r.fL)(s),l=(0,r.Dh)(),(0,r.Lj)(e,"class","vc-table-col vc-table-col-2"),(0,r.Lj)(c,"class","vc-table-col vc-table-col-4 vc-table-col-value vc-max-height-line"),(0,r.Lj)(n,"class","vc-table-row vc-left-border vc-small")},m:function(t,u){(0,r.$T)(t,n,u),(0,r.R3)(n,e),(0,r.R3)(e,o),(0,r.R3)(n,i),(0,r.R3)(n,c),(0,r.R3)(c,a),(0,r.R3)(n,l)},p:function(t,n){2&n&&u!==(u=t[10]+"")&&(0,r.rT)(o,u),2&n&&s!==(s=t[11]+"")&&(0,r.rT)(a,s)},d:function(t){t&&(0,r.og)(n)}}}function Qn(t){var n,e,o,i,c,a,l,u;a=new nt({props:{content:t[7].getData}});for(var s=Object.entries(t[7].getData),f=[],d=0;d<s.length;d+=1)f[d]=te(Hn(t,s,d));return{c:function(){n=(0,r.bG)("div"),e=(0,r.bG)("dl"),o=(0,r.bG)("dt"),i=(0,r.fL)("Query String Parameters\n                "),c=(0,r.bG)("i"),(0,r.YC)(a.$$.fragment),l=(0,r.Dh)();for(var t=0;t<f.length;t+=1)f[t].c();(0,r.Lj)(c,"class","vc-table-row-icon"),(0,r.Lj)(o,"class","vc-table-col vc-table-col-title"),(0,r.Lj)(e,"class","vc-table-row vc-left-border")},m:function(t,s){(0,r.$T)(t,n,s),(0,r.R3)(n,e),(0,r.R3)(e,o),(0,r.R3)(o,i),(0,r.R3)(o,c),(0,r.ye)(a,c,null),(0,r.R3)(n,l);for(var d=0;d<f.length;d+=1)f[d].m(n,null);u=!0},p:function(t,e){var o={};if(2&e&&(o.content=t[7].getData),a.$set(o),2&e){var r;for(s=Object.entries(t[7].getData),r=0;r<s.length;r+=1){var i=Hn(t,s,r);f[r]?f[r].p(i,e):(f[r]=te(i),f[r].c(),f[r].m(n,null))}for(;r<f.length;r+=1)f[r].d(1);f.length=s.length}},i:function(t){u||((0,r.Ui)(a.$$.fragment,t),u=!0)},o:function(t){(0,r.et)(a.$$.fragment,t),u=!1},d:function(t){t&&(0,r.og)(n),(0,r.vp)(a),(0,r.RM)(f,t)}}}function te(t){var n,e,o,i,c,a,l,u=t[10]+"",s=t[11]+"";return{c:function(){n=(0,r.bG)("div"),e=(0,r.bG)("div"),o=(0,r.fL)(u),i=(0,r.Dh)(),c=(0,r.bG)("div"),a=(0,r.fL)(s),l=(0,r.Dh)(),(0,r.Lj)(e,"class","vc-table-col vc-table-col-2"),(0,r.Lj)(c,"class","vc-table-col vc-table-col-4 vc-table-col-value vc-max-height-line"),(0,r.Lj)(n,"class","vc-table-row vc-left-border vc-small")},m:function(t,u){(0,r.$T)(t,n,u),(0,r.R3)(n,e),(0,r.R3)(e,o),(0,r.R3)(n,i),(0,r.R3)(n,c),(0,r.R3)(c,a),(0,r.R3)(n,l)},p:function(t,n){2&n&&u!==(u=t[10]+"")&&(0,r.rT)(o,u),2&n&&s!==(s=t[11]+"")&&(0,r.rT)(a,s)},d:function(t){t&&(0,r.og)(n)}}}function ne(t){var n,e,o,i,c,a,l,u;function s(t,n){return"string"==typeof t[7].postData?oe:ee}a=new nt({props:{content:t[7].postData}});var f=s(t),d=f(t);return{c:function(){n=(0,r.bG)("div"),e=(0,r.bG)("dl"),o=(0,r.bG)("dt"),i=(0,r.fL)("Request Payload\n                "),c=(0,r.bG)("i"),(0,r.YC)(a.$$.fragment),l=(0,r.Dh)(),d.c(),(0,r.Lj)(c,"class","vc-table-row-icon"),(0,r.Lj)(o,"class","vc-table-col vc-table-col-title"),(0,r.Lj)(e,"class","vc-table-row vc-left-border")},m:function(t,s){(0,r.$T)(t,n,s),(0,r.R3)(n,e),(0,r.R3)(e,o),(0,r.R3)(o,i),(0,r.R3)(o,c),(0,r.ye)(a,c,null),(0,r.R3)(n,l),d.m(n,null),u=!0},p:function(t,e){var o={};2&e&&(o.content=t[7].postData),a.$set(o),f===(f=s(t))&&d?d.p(t,e):(d.d(1),(d=f(t))&&(d.c(),d.m(n,null)))},i:function(t){u||((0,r.Ui)(a.$$.fragment,t),u=!0)},o:function(t){(0,r.et)(a.$$.fragment,t),u=!1},d:function(t){t&&(0,r.og)(n),(0,r.vp)(a),d.d()}}}function ee(t){for(var n,e=Object.entries(t[7].postData),o=[],i=0;i<e.length;i+=1)o[i]=re(Wn(t,e,i));return{c:function(){for(var t=0;t<o.length;t+=1)o[t].c();n=(0,r.cS)()},m:function(t,e){for(var i=0;i<o.length;i+=1)o[i].m(t,e);(0,r.$T)(t,n,e)},p:function(t,r){if(2&r){var i;for(e=Object.entries(t[7].postData),i=0;i<e.length;i+=1){var c=Wn(t,e,i);o[i]?o[i].p(c,r):(o[i]=re(c),o[i].c(),o[i].m(n.parentNode,n))}for(;i<o.length;i+=1)o[i].d(1);o.length=e.length}},d:function(t){(0,r.RM)(o,t),t&&(0,r.og)(n)}}}function oe(t){var n,e,o,i=t[7].postData+"";return{c:function(){n=(0,r.bG)("div"),e=(0,r.bG)("pre"),o=(0,r.fL)(i),(0,r.Lj)(e,"class","vc-table-col vc-table-col-value vc-max-height-line"),(0,r.Lj)(n,"class","vc-table-row vc-left-border vc-small")},m:function(t,i){(0,r.$T)(t,n,i),(0,r.R3)(n,e),(0,r.R3)(e,o)},p:function(t,n){2&n&&i!==(i=t[7].postData+"")&&(0,r.rT)(o,i)},d:function(t){t&&(0,r.og)(n)}}}function re(t){var n,e,o,i,c,a,l,u=t[10]+"",s=t[11]+"";return{c:function(){n=(0,r.bG)("div"),e=(0,r.bG)("div"),o=(0,r.fL)(u),i=(0,r.Dh)(),c=(0,r.bG)("div"),a=(0,r.fL)(s),l=(0,r.Dh)(),(0,r.Lj)(e,"class","vc-table-col vc-table-col-2"),(0,r.Lj)(c,"class","vc-table-col vc-table-col-4 vc-table-col-value vc-max-height-line"),(0,r.Lj)(n,"class","vc-table-row vc-left-border vc-small")},m:function(t,u){(0,r.$T)(t,n,u),(0,r.R3)(n,e),(0,r.R3)(e,o),(0,r.R3)(n,i),(0,r.R3)(n,c),(0,r.R3)(c,a),(0,r.R3)(n,l)},p:function(t,n){2&n&&u!==(u=t[10]+"")&&(0,r.rT)(o,u),2&n&&s!==(s=t[11]+"")&&(0,r.rT)(a,s)},d:function(t){t&&(0,r.og)(n)}}}function ie(t){var n,e,o,i,c,a,l,u,s,f,d,v,p,_,h,g,m,b,y,E,w,O,L,C,T,D,R,x,P,$,k,M,j,I,S,U,A,V,B,N,G,K,W,H,F,q,z,Z,Y,X,J,Q,tt,et,ot,rt,it=t[7].name+"",ct=t[7].method+"",at=t[7].statusText+"",lt=t[7].costTime+"",ut=t[7].url+"",st=t[7].method+"",ft=t[7].requestType+"",dt=(t[7].response||"")+"";function vt(){return t[3](t[7])}b=new nt({props:{content:t[7].url}});var pt=null!==t[7].header&&Zn(t),_t=null!==t[7].requestHeader&&Xn(t),ht=null!==t[7].getData&&Qn(t),gt=null!==t[7].postData&&ne(t);return z=new nt({props:{content:t[7].response}}),{c:function(){n=(0,r.bG)("div"),e=(0,r.bG)("dl"),o=(0,r.bG)("dd"),i=(0,r.fL)(it),c=(0,r.bG)("dd"),a=(0,r.fL)(ct),l=(0,r.bG)("dd"),u=(0,r.fL)(at),s=(0,r.bG)("dd"),f=(0,r.fL)(lt),d=(0,r.Dh)(),v=(0,r.bG)("div"),p=(0,r.bG)("div"),_=(0,r.bG)("dl"),h=(0,r.bG)("dt"),g=(0,r.fL)("General\n                "),m=(0,r.bG)("i"),(0,r.YC)(b.$$.fragment),y=(0,r.Dh)(),E=(0,r.bG)("div"),(w=(0,r.bG)("div")).textContent="URL",O=(0,r.Dh)(),L=(0,r.bG)("div"),C=(0,r.fL)(ut),T=(0,r.Dh)(),D=(0,r.bG)("div"),(R=(0,r.bG)("div")).textContent="Method",x=(0,r.Dh)(),P=(0,r.bG)("div"),$=(0,r.fL)(st),k=(0,r.Dh)(),M=(0,r.bG)("div"),(j=(0,r.bG)("div")).textContent="Type",I=(0,r.Dh)(),S=(0,r.bG)("div"),U=(0,r.fL)(ft),A=(0,r.Dh)(),pt&&pt.c(),V=(0,r.Dh)(),_t&&_t.c(),B=(0,r.Dh)(),ht&&ht.c(),N=(0,r.Dh)(),gt&&gt.c(),G=(0,r.Dh)(),K=(0,r.bG)("div"),W=(0,r.bG)("dl"),H=(0,r.bG)("dt"),F=(0,r.fL)("Response\n                "),q=(0,r.bG)("i"),(0,r.YC)(z.$$.fragment),Z=(0,r.Dh)(),Y=(0,r.bG)("div"),X=(0,r.bG)("pre"),J=(0,r.fL)(dt),Q=(0,r.Dh)(),(0,r.Lj)(o,"class","vc-table-col vc-table-col-4"),(0,r.Lj)(c,"class","vc-table-col"),(0,r.Lj)(l,"class","vc-table-col"),(0,r.Lj)(s,"class","vc-table-col"),(0,r.Lj)(e,"class","vc-table-row vc-group-preview"),(0,r.VH)(e,"vc-table-row-error",t[7].status>=400),(0,r.Lj)(m,"class","vc-table-row-icon"),(0,r.Lj)(h,"class","vc-table-col vc-table-col-title"),(0,r.Lj)(_,"class","vc-table-row vc-left-border"),(0,r.Lj)(w,"class","vc-table-col vc-table-col-2"),(0,r.Lj)(L,"class","vc-table-col vc-table-col-4 vc-table-col-value vc-max-height-line"),(0,r.Lj)(E,"class","vc-table-row vc-left-border vc-small"),(0,r.Lj)(R,"class","vc-table-col vc-table-col-2"),(0,r.Lj)(P,"class","vc-table-col vc-table-col-4 vc-table-col-value vc-max-height-line"),(0,r.Lj)(D,"class","vc-table-row vc-left-border vc-small"),(0,r.Lj)(j,"class","vc-table-col vc-table-col-2"),(0,r.Lj)(S,"class","vc-table-col vc-table-col-4 vc-table-col-value vc-max-height-line"),(0,r.Lj)(M,"class","vc-table-row vc-left-border vc-small"),(0,r.Lj)(q,"class","vc-table-row-icon"),(0,r.Lj)(H,"class","vc-table-col vc-table-col-title"),(0,r.Lj)(W,"class","vc-table-row vc-left-border"),(0,r.Lj)(X,"class","vc-table-col vc-max-height vc-min-height"),(0,r.Lj)(Y,"class","vc-table-row vc-left-border vc-small"),(0,r.Lj)(v,"class","vc-group-detail"),(0,r.Lj)(n,"class","vc-group"),(0,r.Lj)(n,"id",tt=t[7].id),(0,r.VH)(n,"vc-actived",t[7].actived)},m:function(t,tt){(0,r.$T)(t,n,tt),(0,r.R3)(n,e),(0,r.R3)(e,o),(0,r.R3)(o,i),(0,r.R3)(e,c),(0,r.R3)(c,a),(0,r.R3)(e,l),(0,r.R3)(l,u),(0,r.R3)(e,s),(0,r.R3)(s,f),(0,r.R3)(n,d),(0,r.R3)(n,v),(0,r.R3)(v,p),(0,r.R3)(p,_),(0,r.R3)(_,h),(0,r.R3)(h,g),(0,r.R3)(h,m),(0,r.ye)(b,m,null),(0,r.R3)(p,y),(0,r.R3)(p,E),(0,r.R3)(E,w),(0,r.R3)(E,O),(0,r.R3)(E,L),(0,r.R3)(L,C),(0,r.R3)(p,T),(0,r.R3)(p,D),(0,r.R3)(D,R),(0,r.R3)(D,x),(0,r.R3)(D,P),(0,r.R3)(P,$),(0,r.R3)(p,k),(0,r.R3)(p,M),(0,r.R3)(M,j),(0,r.R3)(M,I),(0,r.R3)(M,S),(0,r.R3)(S,U),(0,r.R3)(v,A),pt&&pt.m(v,null),(0,r.R3)(v,V),_t&&_t.m(v,null),(0,r.R3)(v,B),ht&&ht.m(v,null),(0,r.R3)(v,N),gt&&gt.m(v,null),(0,r.R3)(v,G),(0,r.R3)(v,K),(0,r.R3)(K,W),(0,r.R3)(W,H),(0,r.R3)(H,F),(0,r.R3)(H,q),(0,r.ye)(z,q,null),(0,r.R3)(K,Z),(0,r.R3)(K,Y),(0,r.R3)(Y,X),(0,r.R3)(X,J),(0,r.R3)(n,Q),et=!0,ot||(rt=(0,r.oL)(e,"click",vt),ot=!0)},p:function(o,c){t=o,(!et||2&c)&&it!==(it=t[7].name+"")&&(0,r.rT)(i,it),(!et||2&c)&&ct!==(ct=t[7].method+"")&&(0,r.rT)(a,ct),(!et||2&c)&&at!==(at=t[7].statusText+"")&&(0,r.rT)(u,at),(!et||2&c)&&lt!==(lt=t[7].costTime+"")&&(0,r.rT)(f,lt),2&c&&(0,r.VH)(e,"vc-table-row-error",t[7].status>=400);var l={};2&c&&(l.content=t[7].url),b.$set(l),(!et||2&c)&&ut!==(ut=t[7].url+"")&&(0,r.rT)(C,ut),(!et||2&c)&&st!==(st=t[7].method+"")&&(0,r.rT)($,st),(!et||2&c)&&ft!==(ft=t[7].requestType+"")&&(0,r.rT)(U,ft),null!==t[7].header?pt?(pt.p(t,c),2&c&&(0,r.Ui)(pt,1)):((pt=Zn(t)).c(),(0,r.Ui)(pt,1),pt.m(v,V)):pt&&((0,r.dv)(),(0,r.et)(pt,1,1,(function(){pt=null})),(0,r.gb)()),null!==t[7].requestHeader?_t?(_t.p(t,c),2&c&&(0,r.Ui)(_t,1)):((_t=Xn(t)).c(),(0,r.Ui)(_t,1),_t.m(v,B)):_t&&((0,r.dv)(),(0,r.et)(_t,1,1,(function(){_t=null})),(0,r.gb)()),null!==t[7].getData?ht?(ht.p(t,c),2&c&&(0,r.Ui)(ht,1)):((ht=Qn(t)).c(),(0,r.Ui)(ht,1),ht.m(v,N)):ht&&((0,r.dv)(),(0,r.et)(ht,1,1,(function(){ht=null})),(0,r.gb)()),null!==t[7].postData?gt?(gt.p(t,c),2&c&&(0,r.Ui)(gt,1)):((gt=ne(t)).c(),(0,r.Ui)(gt,1),gt.m(v,G)):gt&&((0,r.dv)(),(0,r.et)(gt,1,1,(function(){gt=null})),(0,r.gb)());var s={};2&c&&(s.content=t[7].response),z.$set(s),(!et||2&c)&&dt!==(dt=(t[7].response||"")+"")&&(0,r.rT)(J,dt),(!et||2&c&&tt!==(tt=t[7].id))&&(0,r.Lj)(n,"id",tt),2&c&&(0,r.VH)(n,"vc-actived",t[7].actived)},i:function(t){et||((0,r.Ui)(b.$$.fragment,t),(0,r.Ui)(pt),(0,r.Ui)(_t),(0,r.Ui)(ht),(0,r.Ui)(gt),(0,r.Ui)(z.$$.fragment,t),et=!0)},o:function(t){(0,r.et)(b.$$.fragment,t),(0,r.et)(pt),(0,r.et)(_t),(0,r.et)(ht),(0,r.et)(gt),(0,r.et)(z.$$.fragment,t),et=!1},d:function(t){t&&(0,r.og)(n),(0,r.vp)(b),pt&&pt.d(),_t&&_t.d(),ht&&ht.d(),gt&&gt.d(),(0,r.vp)(z),ot=!1,rt()}}}function ce(t){for(var n,e,o,i,c,a,l,u,s,f,d=t[0]>0&&zn(t),v=Object.entries(t[1]),p=[],_=0;_<v.length;_+=1)p[_]=ie(Kn(t,v,_));var h=function(t){return(0,r.et)(p[t],1,1,(function(){p[t]=null}))};return{c:function(){n=(0,r.bG)("div"),e=(0,r.bG)("dl"),o=(0,r.bG)("dd"),i=(0,r.fL)("Name "),d&&d.c(),(c=(0,r.bG)("dd")).textContent="Method",(a=(0,r.bG)("dd")).textContent="Status",(l=(0,r.bG)("dd")).textContent="Time",u=(0,r.Dh)(),s=(0,r.bG)("div");for(var t=0;t<p.length;t+=1)p[t].c();(0,r.Lj)(o,"class","vc-table-col vc-table-col-4"),(0,r.Lj)(c,"class","vc-table-col"),(0,r.Lj)(a,"class","vc-table-col"),(0,r.Lj)(l,"class","vc-table-col"),(0,r.Lj)(e,"class","vc-table-row"),(0,r.Lj)(s,"class","vc-plugin-content"),(0,r.Lj)(n,"class","vc-table")},m:function(t,v){(0,r.$T)(t,n,v),(0,r.R3)(n,e),(0,r.R3)(e,o),(0,r.R3)(o,i),d&&d.m(o,null),(0,r.R3)(e,c),(0,r.R3)(e,a),(0,r.R3)(e,l),(0,r.R3)(n,u),(0,r.R3)(n,s);for(var _=0;_<p.length;_+=1)p[_].m(s,null);f=!0},p:function(t,n){var e=n[0];if(t[0]>0?d?d.p(t,e):((d=zn(t)).c(),d.m(o,null)):d&&(d.d(1),d=null),6&e){var i;for(v=Object.entries(t[1]),i=0;i<v.length;i+=1){var c=Kn(t,v,i);p[i]?(p[i].p(c,e),(0,r.Ui)(p[i],1)):(p[i]=ie(c),p[i].c(),(0,r.Ui)(p[i],1),p[i].m(s,null))}for((0,r.dv)(),i=v.length;i<p.length;i+=1)h(i);(0,r.gb)()}},i:function(t){if(!f){for(var n=0;n<v.length;n+=1)(0,r.Ui)(p[n]);f=!0}},o:function(t){p=p.filter(Boolean);for(var n=0;n<p.length;n+=1)(0,r.et)(p[n]);f=!1},d:function(t){t&&(0,r.og)(n),d&&d.d(),(0,r.RM)(p,t)}}}function ae(t,n,e){var o;(0,r.FI)(t,In,(function(t){return e(1,o=t)}));var c=0,a=function(t){e(0,c=Object.keys(t).length)},l=In.subscribe(a);a(o);var u=function(t){(0,r.fx)(In,o[t].actived=!o[t].actived,o)};(0,i.H3)((function(){Nn.use()})),(0,i.ev)((function(){l(),Nn.unuse()}));return[c,o,u,function(t){return u(t.id)}]}var le=function(t){var n,e;function o(n){var e;return e=t.call(this)||this,(0,r.S1)(function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(e),n,ae,ce,r.N8,{}),e}return e=t,(n=o).prototype=Object.create(e.prototype),n.prototype.constructor=n,Gn(n,e),o}(r.f_);function ue(t,n){return(ue=Object.setPrototypeOf||function(t,n){return t.__proto__=n,t})(t,n)}var se,fe=function(t){var n,e;function o(n,e,o){var r;return void 0===o&&(o={}),(r=t.call(this,n,e,le,o)||this).module=Sn.getSingleton(Sn,"VConsoleNetworkModel"),r}e=t,(n=o).prototype=Object.create(e.prototype),n.prototype.constructor=n,ue(n,e);var r=o.prototype;return r.onAddTool=function(t){var n=this;t([{name:"Clear",global:!1,onClick:function(t){n.module.clearLog()}}])},r.onRemove=function(){t.prototype.onRemove.call(this),this.module&&this.module.unMock()},o}(F),de=__webpack_require__(8679),ve=__webpack_require__.n(de),pe=(0,Rn.fZ)(),_e=(0,Rn.fZ)(),he=__webpack_require__(5670),ge=0,me={injectType:"lazyStyleTag",insert:"head",singleton:!1},be={};be.locals=he.Z.locals||{},be.use=function(){return ge++||(se=a()(he.Z,me)),be},be.unuse=function(){ge>0&&!--ge&&(se(),se=null)};var ye=be;function Ee(t,n){for(var e=0;e<n.length;e++){var o=n[e];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(t,o.key,o)}}function we(t,n){return(we=Object.setPrototypeOf||function(t,n){return t.__proto__=n,t})(t,n)}function Oe(t,n,e){var o=t.slice();return o[8]=n[e],o}function Le(t,n,e){var o=t.slice();return o[11]=n[e],o}function Ce(t){var n,e,o,i=t[0].nodeType===Node.ELEMENT_NODE&&Te(t),c=t[0].nodeType===Node.TEXT_NODE&&Ue(t);return{c:function(){n=(0,r.bG)("div"),i&&i.c(),e=(0,r.Dh)(),c&&c.c(),(0,r.Lj)(n,"class","vcelm-l"),(0,r.VH)(n,"vc-actived",t[0]._isActived),(0,r.VH)(n,"vc-toggle",t[0]._isExpand),(0,r.VH)(n,"vcelm-noc",t[0]._isSingleLine)},m:function(t,a){(0,r.$T)(t,n,a),i&&i.m(n,null),(0,r.R3)(n,e),c&&c.m(n,null),o=!0},p:function(t,o){t[0].nodeType===Node.ELEMENT_NODE?i?(i.p(t,o),1&o&&(0,r.Ui)(i,1)):((i=Te(t)).c(),(0,r.Ui)(i,1),i.m(n,e)):i&&((0,r.dv)(),(0,r.et)(i,1,1,(function(){i=null})),(0,r.gb)()),t[0].nodeType===Node.TEXT_NODE?c?c.p(t,o):((c=Ue(t)).c(),c.m(n,null)):c&&(c.d(1),c=null),1&o&&(0,r.VH)(n,"vc-actived",t[0]._isActived),1&o&&(0,r.VH)(n,"vc-toggle",t[0]._isExpand),1&o&&(0,r.VH)(n,"vcelm-noc",t[0]._isSingleLine)},i:function(t){o||((0,r.Ui)(i),o=!0)},o:function(t){(0,r.et)(i),o=!1},d:function(t){t&&(0,r.og)(n),i&&i.d(),c&&c.d()}}}function Te(t){var n,e,o,i,c,a,l,u,s,f,d=t[0].nodeName+"",v=(t[0].className||t[0].attributes.length)&&De(t),p=t[0]._isNullEndTag&&$e(t),_=t[0].childNodes.length>0&&ke(t),h=!t[0]._isNullEndTag&&Se(t);return{c:function(){n=(0,r.bG)("span"),e=(0,r.fL)("<"),o=(0,r.fL)(d),v&&v.c(),i=(0,r.cS)(),p&&p.c(),c=(0,r.fL)(">"),_&&_.c(),a=(0,r.cS)(),h&&h.c(),l=(0,r.cS)(),(0,r.Lj)(n,"class","vcelm-node")},m:function(d,g){(0,r.$T)(d,n,g),(0,r.R3)(n,e),(0,r.R3)(n,o),v&&v.m(n,null),(0,r.R3)(n,i),p&&p.m(n,null),(0,r.R3)(n,c),_&&_.m(d,g),(0,r.$T)(d,a,g),h&&h.m(d,g),(0,r.$T)(d,l,g),u=!0,s||(f=(0,r.oL)(n,"click",t[2]),s=!0)},p:function(t,e){(!u||1&e)&&d!==(d=t[0].nodeName+"")&&(0,r.rT)(o,d),t[0].className||t[0].attributes.length?v?v.p(t,e):((v=De(t)).c(),v.m(n,i)):v&&(v.d(1),v=null),t[0]._isNullEndTag?p||((p=$e(t)).c(),p.m(n,c)):p&&(p.d(1),p=null),t[0].childNodes.length>0?_?(_.p(t,e),1&e&&(0,r.Ui)(_,1)):((_=ke(t)).c(),(0,r.Ui)(_,1),_.m(a.parentNode,a)):_&&((0,r.dv)(),(0,r.et)(_,1,1,(function(){_=null})),(0,r.gb)()),t[0]._isNullEndTag?h&&(h.d(1),h=null):h?h.p(t,e):((h=Se(t)).c(),h.m(l.parentNode,l))},i:function(t){u||((0,r.Ui)(_),u=!0)},o:function(t){(0,r.et)(_),u=!1},d:function(t){t&&(0,r.og)(n),v&&v.d(),p&&p.d(),_&&_.d(t),t&&(0,r.og)(a),h&&h.d(t),t&&(0,r.og)(l),s=!1,f()}}}function De(t){for(var n,e=t[0].attributes,o=[],i=0;i<e.length;i+=1)o[i]=Pe(Le(t,e,i));return{c:function(){n=(0,r.bG)("i");for(var t=0;t<o.length;t+=1)o[t].c();(0,r.Lj)(n,"class","vcelm-k")},m:function(t,e){(0,r.$T)(t,n,e);for(var i=0;i<o.length;i+=1)o[i].m(n,null)},p:function(t,r){if(1&r){var i;for(e=t[0].attributes,i=0;i<e.length;i+=1){var c=Le(t,e,i);o[i]?o[i].p(c,r):(o[i]=Pe(c),o[i].c(),o[i].m(n,null))}for(;i<o.length;i+=1)o[i].d(1);o.length=e.length}},d:function(t){t&&(0,r.og)(n),(0,r.RM)(o,t)}}}function Re(t){var n,e=t[11].name+"";return{c:function(){n=(0,r.fL)(e)},m:function(t,e){(0,r.$T)(t,n,e)},p:function(t,o){1&o&&e!==(e=t[11].name+"")&&(0,r.rT)(n,e)},d:function(t){t&&(0,r.og)(n)}}}function xe(t){var n,e,o,i,c,a=t[11].name+"",l=t[11].value+"";return{c:function(){n=(0,r.fL)(a),e=(0,r.fL)('="'),o=(0,r.bG)("i"),i=(0,r.fL)(l),c=(0,r.fL)('"'),(0,r.Lj)(o,"class","vcelm-v")},m:function(t,a){(0,r.$T)(t,n,a),(0,r.$T)(t,e,a),(0,r.$T)(t,o,a),(0,r.R3)(o,i),(0,r.$T)(t,c,a)},p:function(t,e){1&e&&a!==(a=t[11].name+"")&&(0,r.rT)(n,a),1&e&&l!==(l=t[11].value+"")&&(0,r.rT)(i,l)},d:function(t){t&&(0,r.og)(n),t&&(0,r.og)(e),t&&(0,r.og)(o),t&&(0,r.og)(c)}}}function Pe(t){var n,e;function o(t,n){return""!==t[11].value?xe:Re}var i=o(t),c=i(t);return{c:function(){n=(0,r.fL)(" \n            "),c.c(),e=(0,r.cS)()},m:function(t,o){(0,r.$T)(t,n,o),c.m(t,o),(0,r.$T)(t,e,o)},p:function(t,n){i===(i=o(t))&&c?c.p(t,n):(c.d(1),(c=i(t))&&(c.c(),c.m(e.parentNode,e)))},d:function(t){t&&(0,r.og)(n),c.d(t),t&&(0,r.og)(e)}}}function $e(t){var n;return{c:function(){n=(0,r.fL)("/")},m:function(t,e){(0,r.$T)(t,n,e)},d:function(t){t&&(0,r.og)(n)}}}function ke(t){var n,e,o,i,c=[je,Me],a=[];function l(t,n){return t[0]._isExpand?1:0}return n=l(t),e=a[n]=c[n](t),{c:function(){e.c(),o=(0,r.cS)()},m:function(t,e){a[n].m(t,e),(0,r.$T)(t,o,e),i=!0},p:function(t,i){var u=n;(n=l(t))===u?a[n].p(t,i):((0,r.dv)(),(0,r.et)(a[u],1,1,(function(){a[u]=null})),(0,r.gb)(),(e=a[n])?e.p(t,i):(e=a[n]=c[n](t)).c(),(0,r.Ui)(e,1),e.m(o.parentNode,o))},i:function(t){i||((0,r.Ui)(e),i=!0)},o:function(t){(0,r.et)(e),i=!1},d:function(t){a[n].d(t),t&&(0,r.og)(o)}}}function Me(t){for(var n,e,o=t[0].childNodes,i=[],c=0;c<o.length;c+=1)i[c]=Ie(Oe(t,o,c));var a=function(t){return(0,r.et)(i[t],1,1,(function(){i[t]=null}))};return{c:function(){for(var t=0;t<i.length;t+=1)i[t].c();n=(0,r.cS)()},m:function(t,o){for(var c=0;c<i.length;c+=1)i[c].m(t,o);(0,r.$T)(t,n,o),e=!0},p:function(t,e){if(1&e){var c;for(o=t[0].childNodes,c=0;c<o.length;c+=1){var l=Oe(t,o,c);i[c]?(i[c].p(l,e),(0,r.Ui)(i[c],1)):(i[c]=Ie(l),i[c].c(),(0,r.Ui)(i[c],1),i[c].m(n.parentNode,n))}for((0,r.dv)(),c=o.length;c<i.length;c+=1)a(c);(0,r.gb)()}},i:function(t){if(!e){for(var n=0;n<o.length;n+=1)(0,r.Ui)(i[n]);e=!0}},o:function(t){i=i.filter(Boolean);for(var n=0;n<i.length;n+=1)(0,r.et)(i[n]);e=!1},d:function(t){(0,r.RM)(i,t),t&&(0,r.og)(n)}}}function je(t){var n;return{c:function(){n=(0,r.fL)("...")},m:function(t,e){(0,r.$T)(t,n,e)},p:r.ZT,i:r.ZT,o:r.ZT,d:function(t){t&&(0,r.og)(n)}}}function Ie(t){var n,e,o;return(n=new Be({props:{node:t[8]}})).$on("toggleNode",t[4]),{c:function(){(0,r.YC)(n.$$.fragment),e=(0,r.Dh)()},m:function(t,i){(0,r.ye)(n,t,i),(0,r.$T)(t,e,i),o=!0},p:function(t,e){var o={};1&e&&(o.node=t[8]),n.$set(o)},i:function(t){o||((0,r.Ui)(n.$$.fragment,t),o=!0)},o:function(t){(0,r.et)(n.$$.fragment,t),o=!1},d:function(t){(0,r.vp)(n,t),t&&(0,r.og)(e)}}}function Se(t){var n,e,o,i,c=t[0].nodeName+"";return{c:function(){n=(0,r.bG)("span"),e=(0,r.fL)("</"),o=(0,r.fL)(c),i=(0,r.fL)(">"),(0,r.Lj)(n,"class","vcelm-node")},m:function(t,c){(0,r.$T)(t,n,c),(0,r.R3)(n,e),(0,r.R3)(n,o),(0,r.R3)(n,i)},p:function(t,n){1&n&&c!==(c=t[0].nodeName+"")&&(0,r.rT)(o,c)},d:function(t){t&&(0,r.og)(n)}}}function Ue(t){var n,e,o=t[1](t[0].textContent)+"";return{c:function(){n=(0,r.bG)("span"),e=(0,r.fL)(o),(0,r.Lj)(n,"class","vcelm-t vcelm-noc")},m:function(t,o){(0,r.$T)(t,n,o),(0,r.R3)(n,e)},p:function(t,n){1&n&&o!==(o=t[1](t[0].textContent)+"")&&(0,r.rT)(e,o)},d:function(t){t&&(0,r.og)(n)}}}function Ae(t){var n,e,o=t[0]&&Ce(t);return{c:function(){o&&o.c(),n=(0,r.cS)()},m:function(t,i){o&&o.m(t,i),(0,r.$T)(t,n,i),e=!0},p:function(t,e){var i=e[0];t[0]?o?(o.p(t,i),1&i&&(0,r.Ui)(o,1)):((o=Ce(t)).c(),(0,r.Ui)(o,1),o.m(n.parentNode,n)):o&&((0,r.dv)(),(0,r.et)(o,1,1,(function(){o=null})),(0,r.gb)())},i:function(t){e||((0,r.Ui)(o),e=!0)},o:function(t){(0,r.et)(o),e=!1},d:function(t){o&&o.d(t),t&&(0,r.og)(n)}}}function Ve(t,n,e){var o;(0,r.FI)(t,_e,(function(t){return e(3,o=t)}));var c=n.node,a=(0,i.x)(),l=["br","hr","img","input","link","meta"];(0,i.H3)((function(){ye.use()})),(0,i.ev)((function(){ye.unuse()}));return t.$$set=function(t){"node"in t&&e(0,c=t.node)},t.$$.update=function(){9&t.$$.dirty&&c&&(e(0,c._isActived=c===o,c),e(0,c._isNullEndTag=function(t){return l.indexOf(t.nodeName)>-1}(c),c),e(0,c._isSingleLine=0===c.childNodes.length||c._isNullEndTag,c))},[c,function(t){return t.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,"")},function(){c._isNullEndTag||(e(0,c._isExpand=!c._isExpand,c),a("toggleNode",{node:c}))},o,function(n){r.cK.call(this,t,n)}]}var Be=function(t){var n,e,o,i,c;function a(n){var e;return e=t.call(this)||this,(0,r.S1)(function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(e),n,Ve,Ae,r.N8,{node:0}),e}return e=t,(n=a).prototype=Object.create(e.prototype),n.prototype.constructor=n,we(n,e),o=a,(i=[{key:"node",get:function(){return this.$$.ctx[0]},set:function(t){this.$set({node:t}),(0,r.yl)()}}])&&Ee(o.prototype,i),c&&Ee(o,c),a}(r.f_),Ne=Be;function Ge(t,n){return(Ge=Object.setPrototypeOf||function(t,n){return t.__proto__=n,t})(t,n)}function Ke(t){var n,e,o;return(e=new Ne({props:{node:t[0]}})).$on("toggleNode",t[1]),{c:function(){n=(0,r.bG)("div"),(0,r.YC)(e.$$.fragment),(0,r.Lj)(n,"class","vc-plugin-content")},m:function(t,i){(0,r.$T)(t,n,i),(0,r.ye)(e,n,null),o=!0},p:function(t,n){var o={};1&n[0]&&(o.node=t[0]),e.$set(o)},i:function(t){o||((0,r.Ui)(e.$$.fragment,t),o=!0)},o:function(t){(0,r.et)(e.$$.fragment,t),o=!1},d:function(t){t&&(0,r.og)(n),(0,r.vp)(e)}}}function We(t,n,e){var o;return(0,r.FI)(t,pe,(function(t){return e(0,o=t)})),[o,function(n){r.cK.call(this,t,n)}]}var He=function(t){var n,e;function o(n){var e;return e=t.call(this)||this,(0,r.S1)(function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(e),n,We,Ke,r.N8,{}),e}return e=t,(n=o).prototype=Object.create(e.prototype),n.prototype.constructor=n,Ge(n,e),o}(r.f_);function Fe(t,n){return(Fe=Object.setPrototypeOf||function(t,n){return t.__proto__=n,t})(t,n)}var qe=function(t){var n,e;function o(n,e,o){var r;return void 0===o&&(o={}),(r=t.call(this,n,e,He,o)||this).isInited=!1,r.observer=void 0,r.nodeMap=void 0,r}e=t,(n=o).prototype=Object.create(e.prototype),n.prototype.constructor=n,Fe(n,e);var r=o.prototype;return r.onShow=function(){this.isInited||this._init()},r.onRemove=function(){t.prototype.onRemove.call(this),this.isInited&&(this.observer.disconnect(),this.isInited=!1,this.nodeMap=void 0,pe.set(void 0))},r.onAddTool=function(t){var n=this;t([{name:"Expand",global:!1,onClick:function(t){n._expandActivedNode()}},{name:"Collapse",global:!1,onClick:function(t){n._collapseActivedNode()}}])},r._init=function(){var t=this;this.isInited=!0,this.nodeMap=new WeakMap;var n=this._generateVNode(document.documentElement);n._isExpand=!0,_e.set(n),pe.set(n),this.compInstance.$on("toggleNode",(function(t){_e.set(t.detail.node)})),this.observer=new(ve())((function(n){for(var e=0;e<n.length;e++){var o=n[e];t._isInVConsole(o.target)||t._handleMutation(o)}})),this.observer.observe(document.documentElement,{attributes:!0,childList:!0,characterData:!0,subtree:!0})},r._handleMutation=function(t){switch(t.type){case"childList":t.removedNodes.length>0&&this._onChildRemove(t),t.addedNodes.length>0&&this._onChildAdd(t);break;case"attributes":this._onAttributesChange(t);break;case"characterData":this._onCharacterDataChange(t)}},r._onChildRemove=function(t){var n=this.nodeMap.get(t.target);if(n){for(var e=0;e<t.removedNodes.length;e++){var o=this.nodeMap.get(t.removedNodes[e]);if(o){for(var r=0;r<n.childNodes.length;r++)if(n.childNodes[r]===o){n.childNodes.splice(r,1);break}this.nodeMap.delete(t.removedNodes[e])}}this._refreshStore()}},r._onChildAdd=function(t){var n=this.nodeMap.get(t.target);if(n){for(var e=0;e<t.addedNodes.length;e++){var o=t.addedNodes[e],r=this._generateVNode(o),i=void 0;do{if(null===o.nextSibling)break;o.nodeType===Node.ELEMENT_NODE&&(i=this.nodeMap.get(o.nextSibling)||void 0)}while(void 0===i);if(void 0===i)n.childNodes.push(r);else for(var c=0;c<n.childNodes.length;c++)if(n.childNodes[c]===i){n.childNodes.splice(c,0,r);break}}this._refreshStore()}},r._onAttributesChange=function(t){this._updateVNodeAttributes(t.target),this._refreshStore()},r._onCharacterDataChange=function(t){this.nodeMap.get(t.target).textContent=t.target.textContent,this._refreshStore()},r._generateVNode=function(t){if(!this._isIgnoredNode(t)){var n={nodeType:t.nodeType,nodeName:t.nodeName.toLowerCase(),textContent:"",id:"",className:"",attributes:[],childNodes:[]};if(this.nodeMap.set(t,n),n.nodeType!=t.TEXT_NODE&&n.nodeType!=t.DOCUMENT_TYPE_NODE||(n.textContent=t.textContent),t.childNodes.length>0){n.childNodes=[];for(var e=0;e<t.childNodes.length;e++){var o=this._generateVNode(t.childNodes[e]);o&&n.childNodes.push(o)}}return this._updateVNodeAttributes(t),n}},r._updateVNodeAttributes=function(t){var n=this.nodeMap.get(t);if(t instanceof Element&&(n.id=t.id||"",n.className=t.className||"",t.hasAttributes&&t.hasAttributes())){n.attributes=[];for(var e=0;e<t.attributes.length;e++)n.attributes.push({name:t.attributes[e].name,value:t.attributes[e].value||""})}},r._expandActivedNode=function(){var t=(0,Rn.U2)(_e);if(t._isExpand)for(var n=0;n<t.childNodes.length;n++)t.childNodes[n]._isExpand=!0;else t._isExpand=!0;this._refreshStore()},r._collapseActivedNode=function(){var t=(0,Rn.U2)(_e);if(t._isExpand){for(var n=!1,e=0;e<t.childNodes.length;e++)t.childNodes[e]._isExpand&&(n=!0,t.childNodes[e]._isExpand=!1);n||(t._isExpand=!1),this._refreshStore()}},r._isIgnoredNode=function(t){return t.nodeType==t.TEXT_NODE&&""==t.textContent.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$|\n+/g,"")},r._isInVConsole=function(t){for(var n=t;void 0!==n;){if("__vconsole"==n.id)return!0;n=n.parentElement||void 0}return!1},r._refreshStore=function(){pe.update((function(t){return t}))},o}(F),ze=__webpack_require__(6025);function Ze(t,n){return(Ze=Object.setPrototypeOf||function(t,n){return t.__proto__=n,t})(t,n)}var Ye=function(t){var n,e;function o(){for(var n,e=arguments.length,o=new Array(e),r=0;r<e;r++)o[r]=arguments[r];return(n=t.call.apply(t,[this].concat(o))||this).cookiesStorage=new ze.eR,n.storages=void 0,n}return e=t,(n=o).prototype=Object.create(e.prototype),n.prototype.constructor=n,Ze(n,e),o.prototype.getAllStorages=function(){return this.storages||(this.storages=[],void 0!==document.cookie&&this.storages.push({name:"cookies",storage:this.cookiesStorage}),window.localStorage&&this.storages.push({name:"localStorage",storage:localStorage}),window.sessionStorage&&this.storages.push({name:"sessionStorage",storage:sessionStorage})),this.storages},o}(xn.N);function Xe(t,n){for(var e=0;e<n.length;e++){var o=n[e];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(t,o.key,o)}}function Je(t,n){return(Je=Object.setPrototypeOf||function(t,n){return t.__proto__=n,t})(t,n)}function Qe(t,n,e){var o=t.slice();return o[15]=n[e].name,o[16]=n[e].storage,o}function to(t,n,e){var o=t.slice();return o[19]=n[e][0],o[20]=n[e][1],o[22]=e,o}function no(t){for(var n,e,o=Object.entries(t[16]),i=[],c=0;c<o.length;c+=1)i[c]=ao(to(t,o,c));var a=function(t){return(0,r.et)(i[t],1,1,(function(){i[t]=null}))},l=null;return o.length||(l=eo(t)),{c:function(){for(var t=0;t<i.length;t+=1)i[t].c();n=(0,r.cS)(),l&&l.c()},m:function(t,o){for(var c=0;c<i.length;c+=1)i[c].m(t,o);(0,r.$T)(t,n,o),l&&l.m(t,o),e=!0},p:function(t,e){if(509&e){var c;for(o=Object.entries(t[16]),c=0;c<o.length;c+=1){var u=to(t,o,c);i[c]?(i[c].p(u,e),(0,r.Ui)(i[c],1)):(i[c]=ao(u),i[c].c(),(0,r.Ui)(i[c],1),i[c].m(n.parentNode,n))}for((0,r.dv)(),c=o.length;c<i.length;c+=1)a(c);(0,r.gb)(),o.length?l&&(l.d(1),l=null):l||((l=eo(t)).c(),l.m(n.parentNode,n))}},i:function(t){if(!e){for(var n=0;n<o.length;n+=1)(0,r.Ui)(i[n]);e=!0}},o:function(t){i=i.filter(Boolean);for(var n=0;n<i.length;n+=1)(0,r.et)(i[n]);e=!1},d:function(t){(0,r.RM)(i,t),t&&(0,r.og)(n),l&&l.d(t)}}}function eo(t){var n;return{c:function(){n=(0,r.bG)("div"),(0,r.Lj)(n,"class","vc-plugin-empty")},m:function(t,e){(0,r.$T)(t,n,e)},d:function(t){t&&(0,r.og)(n)}}}function oo(t){var n,e,o,i,c,a=t[19]+"",l=t[8](t[20])+"";return{c:function(){n=(0,r.bG)("div"),e=(0,r.fL)(a),o=(0,r.Dh)(),i=(0,r.bG)("div"),c=(0,r.fL)(l),(0,r.Lj)(n,"class","vc-table-col"),(0,r.Lj)(i,"class","vc-table-col vc-table-col-2")},m:function(t,a){(0,r.$T)(t,n,a),(0,r.R3)(n,e),(0,r.$T)(t,o,a),(0,r.$T)(t,i,a),(0,r.R3)(i,c)},p:function(t,n){1&n&&a!==(a=t[19]+"")&&(0,r.rT)(e,a),1&n&&l!==(l=t[8](t[20])+"")&&(0,r.rT)(c,l)},d:function(t){t&&(0,r.og)(n),t&&(0,r.og)(o),t&&(0,r.og)(i)}}}function ro(t){var n,e,o,i,c,a,l;return{c:function(){n=(0,r.bG)("div"),e=(0,r.bG)("textarea"),o=(0,r.Dh)(),i=(0,r.bG)("div"),c=(0,r.bG)("textarea"),(0,r.Lj)(e,"class","vc-table-input"),(0,r.Lj)(n,"class","vc-table-col"),(0,r.Lj)(c,"class","vc-table-input"),(0,r.Lj)(i,"class","vc-table-col vc-table-col-2")},m:function(u,s){(0,r.$T)(u,n,s),(0,r.R3)(n,e),(0,r.Bm)(e,t[3]),(0,r.$T)(u,o,s),(0,r.$T)(u,i,s),(0,r.R3)(i,c),(0,r.Bm)(c,t[4]),a||(l=[(0,r.oL)(e,"input",t[9]),(0,r.oL)(c,"input",t[10])],a=!0)},p:function(t,n){8&n&&(0,r.Bm)(e,t[3]),16&n&&(0,r.Bm)(c,t[4])},d:function(t){t&&(0,r.og)(n),t&&(0,r.og)(o),t&&(0,r.og)(i),a=!1,(0,r.j7)(l)}}}function io(t){var n,e,o,i,c,a;return(n=new Z.Z({props:{name:"delete"}})).$on("click",(function(){return t[12](t[16],t[22])})),o=new nt({props:{content:[t[19],t[20]].join("=")}}),(c=new Z.Z({props:{name:"edit"}})).$on("click",(function(){return t[13](t[16],t[19],t[20],t[22])})),{c:function(){(0,r.YC)(n.$$.fragment),e=(0,r.Dh)(),(0,r.YC)(o.$$.fragment),i=(0,r.Dh)(),(0,r.YC)(c.$$.fragment)},m:function(t,l){(0,r.ye)(n,t,l),(0,r.$T)(t,e,l),(0,r.ye)(o,t,l),(0,r.$T)(t,i,l),(0,r.ye)(c,t,l),a=!0},p:function(n,e){t=n;var r={};1&e&&(r.content=[t[19],t[20]].join("=")),o.$set(r)},i:function(t){a||((0,r.Ui)(n.$$.fragment,t),(0,r.Ui)(o.$$.fragment,t),(0,r.Ui)(c.$$.fragment,t),a=!0)},o:function(t){(0,r.et)(n.$$.fragment,t),(0,r.et)(o.$$.fragment,t),(0,r.et)(c.$$.fragment,t),a=!1},d:function(t){(0,r.vp)(n,t),t&&(0,r.og)(e),(0,r.vp)(o,t),t&&(0,r.og)(i),(0,r.vp)(c,t)}}}function co(t){var n,e,o,i;return(n=new Z.Z({props:{name:"cancel"}})).$on("click",t[7]),(o=new Z.Z({props:{name:"done"}})).$on("click",(function(){return t[11](t[16],t[19],t[20],t[22])})),{c:function(){(0,r.YC)(n.$$.fragment),e=(0,r.Dh)(),(0,r.YC)(o.$$.fragment)},m:function(t,c){(0,r.ye)(n,t,c),(0,r.$T)(t,e,c),(0,r.ye)(o,t,c),i=!0},p:function(n,e){t=n},i:function(t){i||((0,r.Ui)(n.$$.fragment,t),(0,r.Ui)(o.$$.fragment,t),i=!0)},o:function(t){(0,r.et)(n.$$.fragment,t),(0,r.et)(o.$$.fragment,t),i=!1},d:function(t){(0,r.vp)(n,t),t&&(0,r.og)(e),(0,r.vp)(o,t)}}}function ao(t){var n,e,o,i,c,a,l;function u(t,n){return t[2]===t[22]?ro:oo}var s=u(t),f=s(t),d=[co,io],v=[];function p(t,n){return t[2]===t[22]?0:1}return i=p(t),c=v[i]=d[i](t),{c:function(){n=(0,r.bG)("div"),f.c(),e=(0,r.Dh)(),o=(0,r.bG)("div"),c.c(),a=(0,r.Dh)(),(0,r.Lj)(o,"class","vc-table-col vc-table-col-1 vc-table-action"),(0,r.Lj)(n,"class","vc-table-row")},m:function(t,c){(0,r.$T)(t,n,c),f.m(n,null),(0,r.R3)(n,e),(0,r.R3)(n,o),v[i].m(o,null),(0,r.R3)(n,a),l=!0},p:function(t,a){s===(s=u(t))&&f?f.p(t,a):(f.d(1),(f=s(t))&&(f.c(),f.m(n,e)));var l=i;(i=p(t))===l?v[i].p(t,a):((0,r.dv)(),(0,r.et)(v[l],1,1,(function(){v[l]=null})),(0,r.gb)(),(c=v[i])?c.p(t,a):(c=v[i]=d[i](t)).c(),(0,r.Ui)(c,1),c.m(o,null))},i:function(t){l||((0,r.Ui)(c),l=!0)},o:function(t){(0,r.et)(c),l=!1},d:function(t){t&&(0,r.og)(n),f.d(),v[i].d()}}}function lo(t){var n,e,o=t[15]===t[1]&&no(t);return{c:function(){o&&o.c(),n=(0,r.cS)()},m:function(t,i){o&&o.m(t,i),(0,r.$T)(t,n,i),e=!0},p:function(t,e){t[15]===t[1]?o?(o.p(t,e),3&e&&(0,r.Ui)(o,1)):((o=no(t)).c(),(0,r.Ui)(o,1),o.m(n.parentNode,n)):o&&((0,r.dv)(),(0,r.et)(o,1,1,(function(){o=null})),(0,r.gb)())},i:function(t){e||((0,r.Ui)(o),e=!0)},o:function(t){(0,r.et)(o),e=!1},d:function(t){o&&o.d(t),t&&(0,r.og)(n)}}}function uo(t){for(var n,e,o,i,c=t[0],a=[],l=0;l<c.length;l+=1)a[l]=lo(Qe(t,c,l));var u=function(t){return(0,r.et)(a[t],1,1,(function(){a[t]=null}))};return{c:function(){n=(0,r.bG)("div"),(e=(0,r.bG)("div")).innerHTML='<div class="vc-table-col">Key</div> \n    <div class="vc-table-col vc-table-col-2">Value</div> \n    <div class="vc-table-col vc-table-col-1 vc-table-action"></div>',o=(0,r.Dh)();for(var t=0;t<a.length;t+=1)a[t].c();(0,r.Lj)(e,"class","vc-table-row"),(0,r.Lj)(n,"class","vc-table")},m:function(t,c){(0,r.$T)(t,n,c),(0,r.R3)(n,e),(0,r.R3)(n,o);for(var l=0;l<a.length;l+=1)a[l].m(n,null);i=!0},p:function(t,e){var o=e[0];if(511&o){var i;for(c=t[0],i=0;i<c.length;i+=1){var l=Qe(t,c,i);a[i]?(a[i].p(l,o),(0,r.Ui)(a[i],1)):(a[i]=lo(l),a[i].c(),(0,r.Ui)(a[i],1),a[i].m(n,null))}for((0,r.dv)(),i=c.length;i<a.length;i+=1)u(i);(0,r.gb)()}},i:function(t){if(!i){for(var n=0;n<c.length;n+=1)(0,r.Ui)(a[n]);i=!0}},o:function(t){a=a.filter(Boolean);for(var n=0;n<a.length;n+=1)(0,r.et)(a[n]);i=!1},d:function(t){t&&(0,r.og)(n),(0,r.RM)(a,t)}}}function so(t,e,o){var r=e.storages,i=void 0===r?[]:r,c=e.activedName,a=void 0===c?"":c,l=-1,u="",s="",f=function(){o(0,i),o(2,l=-1)},d=function(t,n){var e;t.removeItem(null!==(e=t.key(n))&&void 0!==e?e:""),f()},v=function(t,n,e,r){l===r?(u!==n&&t.removeItem(n),t.setItem(u,s),o(2,l=-1),f()):(o(3,u=n),o(4,s=e),o(2,l=r))};return t.$$set=function(t){"storages"in t&&o(0,i=t.storages),"activedName"in t&&o(1,a=t.activedName)},[i,a,l,u,s,d,v,function(){o(2,l=-1)},function(t){var e=(0,n.wz)(t);return e>1024?(0,n.Kt)(t,1024)+" ("+(0,n.KL)(e)+")":t},function(){u=this.value,o(3,u)},function(){s=this.value,o(4,s)},function(t,n,e,o){return v(t,n,e,o)},function(t,n){return d(t,n)},function(t,n,e,o){return v(t,n,e,o)}]}var fo=function(t){var n,e,o,i,c;function a(n){var e;return e=t.call(this)||this,(0,r.S1)(function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(e),n,so,uo,r.N8,{storages:0,activedName:1}),e}return e=t,(n=a).prototype=Object.create(e.prototype),n.prototype.constructor=n,Je(n,e),o=a,(i=[{key:"storages",get:function(){return this.$$.ctx[0]},set:function(t){this.$set({storages:t}),(0,r.yl)()}},{key:"activedName",get:function(){return this.$$.ctx[1]},set:function(t){this.$set({activedName:t}),(0,r.yl)()}}])&&Xe(o.prototype,i),c&&Xe(o,c),a}(r.f_);function vo(t,n){var e="undefined"!=typeof Symbol&&t[Symbol.iterator]||t["@@iterator"];if(e)return(e=e.call(t)).next.bind(e);if(Array.isArray(t)||(e=function(t,n){if(!t)return;if("string"==typeof t)return po(t,n);var e=Object.prototype.toString.call(t).slice(8,-1);"Object"===e&&t.constructor&&(e=t.constructor.name);if("Map"===e||"Set"===e)return Array.from(t);if("Arguments"===e||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e))return po(t,n)}(t))||n&&t&&"number"==typeof t.length){e&&(t=e);var o=0;return function(){return o>=t.length?{done:!0}:{done:!1,value:t[o++]}}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}function po(t,n){(null==n||n>t.length)&&(n=t.length);for(var e=0,o=new Array(n);e<n;e++)o[e]=t[e];return o}function _o(t,n){return(_o=Object.setPrototypeOf||function(t,n){return t.__proto__=n,t})(t,n)}var ho=function(t){var n,e;function o(n,e,o){var r;return void 0===o&&(o={}),(r=t.call(this,n,e,fo,o)||this).model=Ye.getSingleton(Ye,"VConsoleStorageModel"),r}e=t,(n=o).prototype=Object.create(e.prototype),n.prototype.constructor=n,_o(n,e);var r=o.prototype;return r.onShow=function(){this.compInstance.storages=this.model.getAllStorages(),this.compInstance.activedName||(this.compInstance.activedName=this.compInstance.storages[0].name)},r.onAddTopBar=function(t){for(var n=this,e=this.model.getAllStorages(),o=[],r=0;r<e.length;r++){var i=e[r].name;o.push({name:i[0].toUpperCase()+i.substring(1),data:{name:i},actived:0===r,onClick:function(t,e){if(e.name===n.compInstance.activedName)return!1;n.compInstance.activedName=e.name}})}o[0].className="vc-actived",t(o)},r.onAddTool=function(t){var n=this;t([{name:"Add",global:!1,onClick:function(){for(var t,e=vo(n.model.getAllStorages());!(t=e()).done;){var o=t.value;if(o.name===n.compInstance.activedName){o.storage.setItem("new_"+Date.now(),"new_value"),n.compInstance.storages=n.compInstance.storages;break}}}},{name:"Refresh",global:!1,onClick:function(){n.compInstance.storages=n.model.getAllStorages()}}])},o}(F),go="#__vconsole",mo=function(){function t(t){var e=this;if(this.version="3.10.0",this.isInited=void 0,this.option={},this.compInstance=void 0,this.pluginList={},o.one(go))console.debug("vConsole is already exists.");else{if(this.isInited=!1,this.option={defaultPlugins:["system","network","element","storage"]},n.Kn(t))for(var r in t)this.option[r]=t[r];this._addBuiltInPlugins();var i=function(){e.isInited||(e._initComponent(),e._autoRun())};if(void 0!==document)"loading"===document.readyState?o.bind(window,"DOMContentLoaded",i):i();else{var c;c=setTimeout((function t(){document&&"complete"==document.readyState?(c&&clearTimeout(c),i()):c=setTimeout(t,1)}),1)}}}var e=t.prototype;return e._addBuiltInPlugins=function(){this.addPlugin(new Cn("default","Log"));var t=this.option.defaultPlugins,e={system:{proto:Dn,name:"System"},network:{proto:fe,name:"Network"},element:{proto:qe,name:"Element"},storage:{proto:ho,name:"Storage"}};if(t&&n.kJ(t))for(var o=0;o<t.length;o++){var r=e[t[o]];r?this.addPlugin(new r.proto(t[o],r.name)):console.debug("Unrecognized default plugin ID:",t[o])}},e._initComponent=function(){var t=this;if(!o.one(go)){var e=1*n.cF("switch_x"),r=1*n.cF("switch_y");this.compInstance=new G({target:document.documentElement,props:{switchButtonPosition:{x:e,y:r}}}),this.compInstance.$on("show",(function(n){n.detail.show?t.show():t.hide()})),this.compInstance.$on("changePanel",(function(n){var e=n.detail.pluginId;t.showPlugin(e)}))}this._updateComponentByOptions()},e._updateComponentByOptions=function(){if(this.compInstance){if(this.compInstance.theme!==this.option.theme){var t=this.option.theme;t="light"!==t&&"dark"!==t?"":t,this.compInstance.theme=t}this.compInstance.disableScrolling!==this.option.disableLogScrolling&&(this.compInstance.disableScrolling=!!this.option.disableLogScrolling)}},e.setSwitchPosition=function(t,n){this.compInstance.switchButtonPosition={x:t,y:n}},e._autoRun=function(){for(var t in this.isInited=!0,this.pluginList)this._initPlugin(this.pluginList[t]);this._showFirstPluginWhenEmpty(),this.triggerEvent("ready")},e._showFirstPluginWhenEmpty=function(){var t=Object.keys(this.pluginList);""===this.compInstance.activedPluginId&&t.length>0&&this.showPlugin(t[0])},e.triggerEvent=function(t,e){t="on"+t.charAt(0).toUpperCase()+t.slice(1),n.mf(this.option[t])&&this.option[t].apply(this,e)},e._initPlugin=function(t){var e=this;t.vConsole=this,this.compInstance.pluginList[t.id]={id:t.id,name:t.name,hasTabPanel:!1,topbarList:[],toolbarList:[]},this.compInstance.pluginList=this.compInstance.pluginList,t.trigger("init"),t.trigger("renderTab",(function(o){e.compInstance.pluginList[t.id].hasTabPanel=!0,o&&(n.HD(o)?e.compInstance.divContentInner.innerHTML+=o:n.mf(o.appendTo)?o.appendTo(e.compInstance.divContentInner):n.kK(o)&&e.compInstance.divContentInner.insertAdjacentElement("beforeend",o))})),t.trigger("addTopBar",(function(n){if(n)for(var o=0;o<n.length;o++){var r=n[o];e.compInstance.pluginList[t.id].topbarList.push({name:r.name||"Undefined",className:r.className||"",actived:!!r.actived,data:r.data,onClick:r.onClick})}})),t.trigger("addTool",(function(n){if(n)for(var o=0;o<n.length;o++){var r=n[o];e.compInstance.pluginList[t.id].toolbarList.push({name:r.name||"Undefined",global:!!r.global,data:r.data,onClick:r.onClick})}})),t.isReady=!0,t.trigger("ready")},e._triggerPluginsEvent=function(t){for(var n in this.pluginList)this.pluginList[n].isReady&&this.pluginList[n].trigger(t)},e._triggerPluginEvent=function(t,n){var e=this.pluginList[t];e&&e.isReady&&e.trigger(n)},e.addPlugin=function(t){return void 0!==this.pluginList[t.id]?(console.debug("Plugin `"+t.id+"` has already been added."),!1):(this.pluginList[t.id]=t,this.isInited&&(this._initPlugin(t),this._showFirstPluginWhenEmpty()),!0)},e.removePlugin=function(t){t=(t+"").toLowerCase();var n=this.pluginList[t];if(void 0===n)return console.debug("Plugin `"+t+"` does not exist."),!1;n.trigger("remove");try{delete this.pluginList[t],delete this.compInstance.pluginList[t]}catch(n){this.pluginList[t]=void 0,this.compInstance.pluginList[t]=void 0}return this.compInstance.pluginList=this.compInstance.pluginList,this.compInstance.activedPluginId==t&&(this.compInstance.activedPluginId="",this._showFirstPluginWhenEmpty()),!0},e.show=function(){this.isInited&&(this.compInstance.show=!0,this._triggerPluginsEvent("showConsole"))},e.hide=function(){this.isInited&&(this.compInstance.show=!1,this._triggerPluginsEvent("hideConsole"))},e.showSwitch=function(){this.isInited&&(this.compInstance.showSwitchButton=!0)},e.hideSwitch=function(){this.isInited&&(this.compInstance.showSwitchButton=!1)},e.showPlugin=function(t){this.isInited&&(this.compInstance.activedPluginId&&this._triggerPluginEvent(this.compInstance.activedPluginId,"hide"),this.compInstance.activedPluginId=t,this._triggerPluginEvent(this.compInstance.activedPluginId,"show"))},e.setOption=function(t,e){if(n.HD(t))this.option[t]=e,this._triggerPluginsEvent("updateOption"),this._updateComponentByOptions();else if(n.Kn(t)){for(var o in t)this.option[o]=t[o];this._triggerPluginsEvent("updateOption"),this._updateComponentByOptions()}else console.debug("The first parameter of vConsole.setOption() must be a string or an object.")},e.destroy=function(){if(this.isInited){for(var t=Object.keys(this.pluginList),n=t.length-1;n>=0;n--)this.removePlugin(t[n]);this.compInstance.$destroy(),this.isInited=!1}},t}();mo.VConsolePlugin=W,mo.VConsoleLogPlugin=On,mo.VConsoleDefaultPlugin=Cn,mo.VConsoleSystemPlugin=Dn,mo.VConsoleNetworkPlugin=fe,mo.VConsoleElementPlugin=qe,mo.VConsoleStoragePlugin=ho;var bo=mo}(),__webpack_exports__=__webpack_exports__.default,__webpack_exports__}()}));

// var vConsole = new window.VConsole();

// ScrollViewMask.js
var ScrollViewMask = pc.createScript('scrollViewMask');

ScrollViewMask.attributes.add('landscapeMask', { type: 'boolean', default: true });
ScrollViewMask.attributes.add('portraitMask', { type: 'boolean', default: true });

pc.extend(ScrollViewMask.prototype, {
    initialize: function() {
        this._onResize(ViewportManager.instance.getOrientation(), ViewportManager.instance.width, ViewportManager.instance.height, ViewportManager.instance.getDevice());

        this.orientation = ''

        this.app.on('ViewportManager:onResize', this._onResize, this);
    },

    _onResize: function (orientation, width, height, device) {
        if (this.orientation === orientation) {
            return;
        }

        this.orientation = orientation;

        if (orientation === orientationEnum.LANDSCAPE) {
            this.entity.element.opacity = this.landscapeMask ? 1: 0;
            this.entity.element.mask = this.landscapeMask;
        } else {
            this.entity.element.opacity = this.portraitMask ? 1: 0;
            this.entity.element.mask = this.portraitMask;
        }
    },
});
    

// IAPSuccessScreen.js
var IapsuccessScreen = pc.createScript('iapsuccessScreen');

IapsuccessScreen.attributes.add('coinText', { type: 'entity' });
IapsuccessScreen.attributes.add('rewardEntities', { type: 'entity', array: true });

pc.extend(IapsuccessScreen.prototype, {
    initialize: function() {

    },

    onUIEntityOpen: function(args) {
        console.log(args);

        this.coinText.element.text = args.coinsReward.quantity;

        this.rewardEntities.forEach((entity, i) => {
            const reward = args.boosterReward[i];

            if (!reward) {
                entity.enabled = false;
            } else {
                var stockItem = BoosterShopManager.instance._getStockByinventoryKey(reward.key);

                entity.children[0].element.spriteAsset = stockItem.image.id;
                entity.children[1].element.text = 'x' + reward.quantity;
            }
        });
    },
});


// IAPWarning.js
var Iapwarning = pc.createScript('iapwarning');

Iapwarning.attributes.add('confirmButton', { type: 'entity' });
Iapwarning.attributes.add('closeButton', { type: 'entity' });


pc.extend(Iapwarning.prototype, {
    initialize: function () {
        this.confirmButton.script.elementInput.on('click', this.confirm, this);
        this.closeButton.script.elementInput.on('click', this.onClose, this);
    },

    onUIEntityOpen: function (script) {
        GameManager.instance.trackCustomEvent('shop', 'authorization_warning_opened');

        this.script = script;
    },

    onClose: function () {
        GameManager.instance.trackCustomEvent('shop', 'authorization_warning_closed');
    },

    confirm: function () {
        try {
            GameManager.instance.trackCustomEvent('shop', 'authorization_warning_continued');

            this.script._onClick(null, true);
            delete this.script;
        } catch (e) {

        }
    },
});


// Sentry.js
class SentryClass {
    initialize() {
        SentryClass.instance = this;
        this.createFakeSentry();
        //  this.load();
    }

    load() {
        if (!window.famobi) {
            this.createFakeSentry();
            return;
        }

        if (window.famobi.hasFeature('standalone')) {
            this.createFakeSentry();
            return;
        }

        var s1 = document.createElement("script");
        s1.type = "text/javascript";
        s1.src = "https://js.sentry-cdn.com/50e4d9c90c214c76901f30825c870000.min.js";
        document.head.append(s1);

        s1.onload = this.onLoaded.bind(this);
    }

    onLoaded() {
        Sentry.forceLoad();
        Sentry.onLoad(this.sentryLoaded.bind(this));

    }

    sentryLoaded() {
        Sentry.init({
            debug: true,
            dsn: 'https://50e4d9c90c214c76901f30825c870000@o1067566.ingest.sentry.io/6141625',
            release: '1.0.4',
            tracesSampleRate: 0.01, // Lower for live version
        });
    }

    createFakeSentry() {
        window.Sentry = {
            captureException: function (...e) {
                console.log(...e)
            },
            captureMessage: function (...e) {
                console.log(...e)
            }
        }
    }
}

var sentryClass = new SentryClass();
sentryClass.initialize();

// BackToTitleScreenButton.js
var BackTotitleScreenButton = pc.createScript('backTotitleScreenButton');

pc.extend(BackTotitleScreenButton.prototype, {
    initialize: function () {
        this.entity.script.elementInput.on('click', this.onClick, this);
    },

    onClick: function () {
        const loadSceneController = LoadSceneController.load('World', false);

        loadSceneController.once('finish', this.onFinish, this);

        GameManager.instance.trackCustomEvent('shop', 'authorization_warning_log_in');

        AssetManager.instance.setWorld(AssetManager.WORLDS.MENU, null, null, true);
    },

    onFinish: function () {
        UIManager.instance.getScreen('LoadingScreen').script.loadingScreen.setCurrentProgress(1, 1);
        this.app.fire('UIManager:hideAll');
        this.app.fire('UIManager:hideUI', 'LoadingScreen');
        this.app.fire('UIManager:showUI', 'Menu');
        this.app.fire('UIManager:showUI', 'Login');
    },

});


// Enabler.js
var Enabler = pc.createScript('enabler');

Enabler.attributes.add('entities', { type: 'entity', array: true });

pc.extend(Enabler.prototype, {
    initialize: function() {
        this.entities.forEach(entity => entity.enabled = true);
    }
});



// EventHandler.js
pc.extend(pc.EventHandler.prototype, {
    off: function (name, callback, scope) {
        if (name) {
            // if we are removing a callback from the list that is executing right now
            // ensure we preserve initial list before modifications
            if (this._callbackActive.has(name) && this._callbackActive.get(name) === this._callbacks.get(name))
                this._callbackActive.set(name, this._callbackActive.get(name).slice());
        } else {
            // if we are removing a callback from any list that is executing right now
            // ensure we preserve these initial lists before modifications
            for (var _iterator = this._createForOfIteratorHelperLoose(this._callbackActive), _step; !(_step = _iterator()).done;) {
                var _step$value = _step.value
                    , key = _step$value[0]
                    , callbacks = _step$value[1];
                if (!this._callbacks.has(key))
                    continue;
                if (this._callbacks.get(key) !== callbacks)
                    continue;
                this._callbackActive.set(key, callbacks.slice());
            }
        }
        if (!name) {
            // remove all events
            this._callbacks.clear();
        } else if (!callback) {
            // remove all events of a specific name
            if (this._callbacks.has(name))
                this._callbacks.delete(name);
        } else {
            var events = this._callbacks.get(name);
            if (!events)
                return this;
            var count = events.length;
            // Made sure the the order doesn't change
            for (var i = events.length - 1; i >= 0; i--) {
                if (events[i].callback !== callback)
                    continue;

                if (scope && events[i].scope !== scope)
                    continue;

                events.splice(i, 1);
                --count;
            }
            events.length = count;
            events.length = count;
            if (events.length === 0)
                this._callbacks.delete(name);
        }
        return this;

    },
    _createForOfIteratorHelperLoose: function (o, allowArrayLike) {
        var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
        if (it)
            return (it = it.call(o)).next.bind(it);
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
            if (it)
                o = it;
            var i = 0;
            return function () {
                if (i >= o.length)
                    return {
                        done: true
                    };
                return {
                    done: false,
                    value: o[i++]
                };
            }
                ;
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
});




// Example for testing
/*
pc.app._callbacks["ViewportManager:onResize"].forEach((d, i) => {
    if (d.scope.entity.name === "Screen" && d.scope.entity.parent.name === "Pause") {
        console.log(i, d)
    }
});
*/

// WorldLight.js
var WorldLight = pc.createScript('worldLight');

WorldLight.attributes.add('lightEntities', { type: 'entity', array: true });

pc.extend(WorldLight.prototype, {
    initialize: function () {
        this.app.on('WorldLight:light', this.setLight, this);

        this.setDistance(PerspectiveView.instance.getRadius());
        this.app.on('PerspectiveView:onCameraChange', this.setDistance, this);
        this.on('destroy', this.onDestroy, this);
    },

    onDestroy: function () {
        this.app.off('WorldLight:light', this.setLight, this);
        this.app.off('PerspectiveView:onCameraChange', this.setDistance, this);
    },

    setLight: function (type = pc.SHADOWUPDATE_THISFRAME) {
        return
        this.lightEntities.forEach(entity => entity.light.shadowUpdateMode = type);
    },

    setDistance: function (radius) {
        this.lightEntities.forEach(entity => entity.light.shadowDistance = radius);
    },
});


// fps.js
// Just add this script to any object in the scene (usually Root) and it will 
// appear in the app as HTML overlay

if (typeof (document) !== "undefined") {
    /*! FPSMeter 0.3.1 - 9th May 2013 | https://github.com/Darsain/fpsmeter */
    (function (m, j) {
        function s(a, e) { for (var g in e) try { a.style[g] = e[g] } catch (j) { } return a } function H(a) { return null == a ? String(a) : "object" === typeof a || "function" === typeof a ? Object.prototype.toString.call(a).match(/\s([a-z]+)/i)[1].toLowerCase() || "object" : typeof a } function R(a, e) { if ("array" !== H(e)) return -1; if (e.indexOf) return e.indexOf(a); for (var g = 0, j = e.length; g < j; g++)if (e[g] === a) return g; return -1 } function I() {
            var a = arguments, e; for (e in a[1]) if (a[1].hasOwnProperty(e)) switch (H(a[1][e])) {
                case "object": a[0][e] =
                    I({}, a[0][e], a[1][e]); break; case "array": a[0][e] = a[1][e].slice(0); break; default: a[0][e] = a[1][e]
            }return 2 < a.length ? I.apply(null, [a[0]].concat(Array.prototype.slice.call(a, 2))) : a[0]
        } function N(a) { a = Math.round(255 * a).toString(16); return 1 === a.length ? "0" + a : a } function S(a, e, g, j) { if (a.addEventListener) a[j ? "removeEventListener" : "addEventListener"](e, g, !1); else if (a.attachEvent) a[j ? "detachEvent" : "attachEvent"]("on" + e, g) } function D(a, e) {
            function g(a, b, d, c) { return y[0 | a][Math.round(Math.min((b - d) / (c - d) * J, J))] }
            function r() { f.legend.fps !== q && (f.legend.fps = q, f.legend[T] = q ? "FPS" : "ms"); K = q ? b.fps : b.duration; f.count[T] = 999 < K ? "999+" : K.toFixed(99 < K ? 0 : d.decimals) } function m() {
                z = A(); L < z - d.threshold && (b.fps -= b.fps / Math.max(1, 60 * d.smoothing / d.interval), b.duration = 1E3 / b.fps); for (c = d.history; c--;)E[c] = 0 === c ? b.fps : E[c - 1], F[c] = 0 === c ? b.duration : F[c - 1]; r(); if (d.heat) {
                    if (w.length) for (c = w.length; c--;)w[c].el.style[h[w[c].name].heatOn] = q ? g(h[w[c].name].heatmap, b.fps, 0, d.maxFps) : g(h[w[c].name].heatmap, b.duration, d.threshold,
                        0); if (f.graph && h.column.heatOn) for (c = u.length; c--;)u[c].style[h.column.heatOn] = q ? g(h.column.heatmap, E[c], 0, d.maxFps) : g(h.column.heatmap, F[c], d.threshold, 0)
                } if (f.graph) for (p = 0; p < d.history; p++)u[p].style.height = (q ? E[p] ? Math.round(O / d.maxFps * Math.min(E[p], d.maxFps)) : 0 : F[p] ? Math.round(O / d.threshold * Math.min(F[p], d.threshold)) : 0) + "px"
            } function k() { 20 > d.interval ? (x = M(k), m()) : (x = setTimeout(k, d.interval), P = M(m)) } function G(a) {
                a = a || window.event; a.preventDefault ? (a.preventDefault(), a.stopPropagation()) : (a.returnValue =
                    !1, a.cancelBubble = !0); b.toggle()
            } function U() { d.toggleOn && S(f.container, d.toggleOn, G, 1); a.removeChild(f.container) } function V() {
                f.container && U(); h = D.theme[d.theme]; y = h.compiledHeatmaps || []; if (!y.length && h.heatmaps.length) {
                    for (p = 0; p < h.heatmaps.length; p++) {
                        y[p] = []; for (c = 0; c <= J; c++) {
                            var b = y[p], e = c, g; g = 0.33 / J * c; var j = h.heatmaps[p].saturation, m = h.heatmaps[p].lightness, n = void 0, k = void 0, l = void 0, t = l = void 0, v = n = k = void 0, v = void 0, l = 0.5 >= m ? m * (1 + j) : m + j - m * j; 0 === l ? g = "#000" : (t = 2 * m - l, k = (l - t) / l, g *= 6, n = Math.floor(g),
                                v = g - n, v *= l * k, 0 === n || 6 === n ? (n = l, k = t + v, l = t) : 1 === n ? (n = l - v, k = l, l = t) : 2 === n ? (n = t, k = l, l = t + v) : 3 === n ? (n = t, k = l - v) : 4 === n ? (n = t + v, k = t) : (n = l, k = t, l -= v), g = "#" + N(n) + N(k) + N(l)); b[e] = g
                        }
                    } h.compiledHeatmaps = y
                } f.container = s(document.createElement("div"), h.container); f.count = f.container.appendChild(s(document.createElement("div"), h.count)); f.legend = f.container.appendChild(s(document.createElement("div"), h.legend)); f.graph = d.graph ? f.container.appendChild(s(document.createElement("div"), h.graph)) : 0; w.length = 0; for (var q in f) f[q] &&
                    h[q].heatOn && w.push({ name: q, el: f[q] }); u.length = 0; if (f.graph) { f.graph.style.width = d.history * h.column.width + (d.history - 1) * h.column.spacing + "px"; for (c = 0; c < d.history; c++)u[c] = f.graph.appendChild(s(document.createElement("div"), h.column)), u[c].style.position = "absolute", u[c].style.bottom = 0, u[c].style.right = c * h.column.width + c * h.column.spacing + "px", u[c].style.width = h.column.width + "px", u[c].style.height = "0px" } s(f.container, d); r(); a.appendChild(f.container); f.graph && (O = f.graph.clientHeight); d.toggleOn && ("click" ===
                        d.toggleOn && (f.container.style.cursor = "pointer"), S(f.container, d.toggleOn, G))
            } "object" === H(a) && a.nodeType === j && (e = a, a = document.body); a || (a = document.body); var b = this, d = I({}, D.defaults, e || {}), f = {}, u = [], h, y, J = 100, w = [], W = 0, B = d.threshold, Q = 0, L = A() - B, z, E = [], F = [], x, P, q = "fps" === d.show, O, K, c, p; b.options = d; b.fps = 0; b.duration = 0; b.isPaused = 0; b.tickStart = function () { Q = A() }; b.tick = function () { z = A(); W = z - L; B += (W - B) / d.smoothing; b.fps = 1E3 / B; b.duration = Q < L ? B : z - Q; L = z }; b.pause = function () {
                x && (b.isPaused = 1, clearTimeout(x),
                    C(x), C(P), x = P = 0); return b
            }; b.resume = function () { x || (b.isPaused = 0, k()); return b }; b.set = function (a, c) { d[a] = c; q = "fps" === d.show; -1 !== R(a, X) && V(); -1 !== R(a, Y) && s(f.container, d); return b }; b.showDuration = function () { b.set("show", "ms"); return b }; b.showFps = function () { b.set("show", "fps"); return b }; b.toggle = function () { b.set("show", q ? "ms" : "fps"); return b }; b.hide = function () { b.pause(); f.container.style.display = "none"; return b }; b.show = function () { b.resume(); f.container.style.display = "block"; return b }; b.destroy = function () {
                b.pause();
                U(); b.tick = b.tickStart = function () { }
            }; V(); k()
        } var A, r = m.performance; A = r && (r.now || r.webkitNow) ? r[r.now ? "now" : "webkitNow"].bind(r) : function () { return +new Date }; for (var C = m.cancelAnimationFrame || m.cancelRequestAnimationFrame, M = m.requestAnimationFrame, r = ["moz", "webkit", "o"], G = 0, k = 0, Z = r.length; k < Z && !C; ++k)M = (C = m[r[k] + "CancelAnimationFrame"] || m[r[k] + "CancelRequestAnimationFrame"]) && m[r[k] + "RequestAnimationFrame"]; C || (M = function (a) {
            var e = A(), g = Math.max(0, 16 - (e - G)); G = e + g; return m.setTimeout(function () {
                a(e +
                    g)
            }, g)
        }, C = function (a) { clearTimeout(a) }); var T = "string" === H(document.createElement("div").textContent) ? "textContent" : "innerText"; D.extend = I; window.FPSMeter = D; D.defaults = { interval: 100, smoothing: 10, show: "fps", toggleOn: "click", decimals: 1, maxFps: 60, threshold: 100, position: "absolute", zIndex: 10, left: "5px", top: "5px", right: "auto", bottom: "auto", margin: "0 0 0 0", theme: "dark", heat: 0, graph: 0, history: 20 }; var X = ["toggleOn", "theme", "heat", "graph", "history"], Y = "position zIndex left top right bottom margin".split(" ")
    })(window); (function (m, j) {
        j.theme = {}; var s = j.theme.base = {
            heatmaps: [], container: { heatOn: null, heatmap: null, padding: "5px", minWidth: "95px", height: "30px", lineHeight: "30px", textAlign: "right", textShadow: "none" }, count: { heatOn: null, heatmap: null, position: "absolute", top: 0, right: 0, padding: "5px 10px", height: "30px", fontSize: "24px", fontFamily: "Consolas, Andale Mono, monospace", zIndex: 2 }, legend: {
                heatOn: null, heatmap: null, position: "absolute", top: 0, left: 0, padding: "5px 10px", height: "30px", fontSize: "12px", lineHeight: "32px", fontFamily: "sans-serif",
                textAlign: "left", zIndex: 2
            }, graph: { heatOn: null, heatmap: null, position: "relative", boxSizing: "padding-box", MozBoxSizing: "padding-box", height: "100%", zIndex: 1 }, column: { width: 4, spacing: 1, heatOn: null, heatmap: null }
        }; j.theme.dark = j.extend({}, s, { heatmaps: [{ saturation: 0.8, lightness: 0.8 }], container: { background: "#222", color: "#fff", border: "1px solid #1a1a1a", textShadow: "1px 1px 0 #222" }, count: { heatOn: "color" }, column: { background: "#3f3f3f" } }); j.theme.light = j.extend({}, s, {
            heatmaps: [{ saturation: 0.5, lightness: 0.5 }],
            container: { color: "#666", background: "#fff", textShadow: "1px 1px 0 rgba(255,255,255,.5), -1px -1px 0 rgba(255,255,255,.5)", boxShadow: "0 0 0 1px rgba(0,0,0,.1)" }, count: { heatOn: "color" }, column: { background: "#eaeaea" }
        }); j.theme.colorful = j.extend({}, s, { heatmaps: [{ saturation: 0.5, lightness: 0.6 }], container: { heatOn: "backgroundColor", background: "#888", color: "#fff", textShadow: "1px 1px 0 rgba(0,0,0,.2)", boxShadow: "0 0 0 1px rgba(0,0,0,.1)" }, column: { background: "#777", backgroundColor: "rgba(0,0,0,.2)" } }); j.theme.transparent =
            j.extend({}, s, { heatmaps: [{ saturation: 0.8, lightness: 0.5 }], container: { padding: 0, color: "#fff", textShadow: "1px 1px 0 rgba(0,0,0,.5)" }, count: { padding: "0 5px", height: "40px", lineHeight: "40px" }, legend: { padding: "0 5px", height: "40px", lineHeight: "42px" }, graph: { height: "40px" }, column: { width: 5, background: "#999", heatOn: "backgroundColor", opacity: 0.5 } })
    })(window, FPSMeter);
}

var Fps = pc.createScript('fps');

Fps.attributes.add('active', { type: 'boolean' });

Fps.prototype.initialize = function () {
    Fps.instance = this;

    this.fps = new FPSMeter({ heat: true, graph: true });

    this.state();

    this.on('attr:active', this.state, this);
};

Fps.prototype.state = function () {
    if (this.active) {
        this.fps.show();
    } else {
        this.fps.hide();
    }
};


// Called every frame, dt is time in seconds since last update
Fps.prototype.update = function (dt) {
    this.fps.tick();
};


// Debug.js
var Debug = pc.createScript('debug');

Debug.attributes.add('entities', { type: 'entity', array: true });
Debug.attributes.add('debug', { type: 'boolean', });

pc.extend(Debug.prototype, {
    postInitialize: function () {
        if (this.debug) {
            this.entities.forEach(entity => { entity.enabled = true; });
        } else {
            console.log("destroy")
            this.entities.forEach(entity => entity.destroy());
        }
    }
});


// DailyCoinScreen.js
var DailyCoinScreen = pc.createScript('dailyCoinScreen');

// initialize code called once per entity
DailyCoinScreen.prototype.initialize = function() {
    
};

// update code called every frame
DailyCoinScreen.prototype.update = function(dt) {
    
};

// swap method called for script hot-reloading
// inherit your script state here
// DailyCoinScreen.prototype.swap = function(old) { };

// to learn more about script anatomy, please read:
// http://developer.playcanvas.com/en/user-manual/scripting/

// PauseManager.js
/**
 * The pause manager handles when the game should be paused or not.
 * It will take the API into considoration when the game should be paused.
 * For example, when the game is blurred or when an ad is shown.
 * 
 * @extends pc.ScriptType
 */
class PauseManager extends pc.ScriptType {
    static addAttributes() {
        this.attributes.add('pauseWhenOutOfFocus', { type: 'boolean', default: true });
    }

    get gameTimeScale() { return this._gameTimeScale; }
    set gameTimeScale(value) { this._gameTimeScale = value; this._setTimeScale(); }

    get focusTimeScale() { return this._focusTimeScale; }
    set focusTimeScale(value) { this._focusTimeScale = value; this._setTimeScale(); }

    get adTimeScale() { return this._adTimeScale; }
    set adTimeScale(value) { this._adTimeScale = value; this._setTimeScale(); }

    initialize() {
        if (Singleton.instance.canCreateInstance(this)) {
            PauseManager.instance = this;
        }

        this.externalPause = Wrapper.instance.hasFeature('external_pause');

        this._gameTimeScale = 1;
        this._focusTimeScale = 1;
        this._adTimeScale = 1;

        this.state = PauseManager.STATES.RESUMED;

        window.famobi.onRequest("pauseGameplay", this.onPauseRequest.bind(this));
        window.famobi.onRequest("resumeGameplay", this.onResumeRequest.bind(this));

        if (!this.externalPause) {
            if (this.pauseWhenOutOfFocus) {
                window.onfocus = this.onFocus.bind(this);
                window.onblur = this.onBlur.bind(this);
            }
        }

        Wrapper.instance.setOnPauseRequested(this.onAdPauseRequested, this);
        Wrapper.instance.setOnResumeRequested(this.onAdResumeRequested, this);
    }

    onAdPauseRequested() { this.adTimeScale = 0; }
    onAdResumeRequested() {
        this.adTimeScale = 1;

        if (this._focusTimeScale === 0) {
            window.focus();
            if (this._focusTimeScale === 0) {
                this.focusTimeScale = 1;
            }
        }
    }

    onFocus() { this.focusTimeScale = 1; }
    onBlur() { this.focusTimeScale = 0; }
    onResumeRequest() { this.focusTimeScale = 1; }
    onPauseRequest() { this.focusTimeScale = 0; }

    _setTimeScale() {
        this.app.timeScale = this.gameTimeScale * this.focusTimeScale * this.adTimeScale;

        const newState = this.app.timeScale === 0 ? PauseManager.STATES.PAUSED : PauseManager.STATES.RESUMED;

        this.app.fire('PauseManager:valueChanged', this.app.timeScale, this.gameTimeScale, this.focusTimeScale, this.adTimeScale);

        if (newState !== this.state) {
            this.state = newState;

            switch (this.state) {
                case PauseManager.STATES.PAUSED:
                    this._pause();
                    break;
                case PauseManager.STATES.RESUMED:
                    this._resume();
                    break;
            }
        }
    }

    _pause() {
        this.app.fire('PauseManager:paused');
    }

    _resume() {
        this.app.fire('PauseManager:resumed');
    }

    // ------------------------------------------------
    // PUBLIC METHODS
    // ------------------------------------------------

    /**
     * Pause the game
     */
    pause() { this.gameTimeScale = 0; }

    /**
     * Resume the game
     */
    resume() { this.gameTimeScale = 1; }

    /**
     * Able to set your own time scale.
     */
    setTimeScale(value) { this.gameTimeScale = value; }
}

pc.registerScript(PauseManager, 'pauseManager');
PauseManager.addAttributes();

PauseManager.STATES = Object.freeze({
    PAUSED: 'paused',
    RESUMED: 'resumed',
});



// MonkeyGames.js
class MonkeyGames extends pc.ScriptType {
    static addAttributes() {
        this.attributes.add('html', { type: 'asset', assetType: 'html', title: 'HTML Asset' });
        this.attributes.add('css', { type: 'asset', assetType: 'css', title: 'HTML Asset' });
    }

    get volume() { return this._volume; }
    set volume(value) { this._volume = value; this.changeVolume(); }

    initialize() {
        MonkeyGames.instance = this;
        this._volume = 1;

        this.createGUI();
    }

    createGUI() {
        var gui = new dat.GUI({ name: this.name, closed: this.closed });

        var folder = gui.addFolder('FamobiAPI');

        folder.add(MonkeyGames.instance, 'requestPause').name("Pause");
        folder.add(MonkeyGames.instance, 'requestResume').name("Resume");
        folder.add(MonkeyGames.instance, 'disableAudio').name("Disable Audio");
        folder.add(MonkeyGames.instance, 'enableAudio').name("Enable Audio");
        folder.add(MonkeyGames.instance, 'disableMusic').name("Disable Music");
        folder.add(MonkeyGames.instance, 'enableMusic').name("Enable Music");
        folder.add(MonkeyGames.instance, 'volume', 0, 1, 0.1).name("Change Volume");
        folder.add(MonkeyGames.instance, 'restartGame').name("Restart Game");
    }

    requestPause() {
        this.app.fire('Famobi:pauseGameplay');
    }

    requestResume() {
        this.app.fire('Famobi:resumeGameplay');
    }

    disableAudio() {
        this.app.fire('Famobi:disableAudio');
    }

    enableAudio() {
        this.app.fire('Famobi:enableAudio');
    }

    disableMusic() {
        this.app.fire('Famobi:disableMusic');
    }

    enableMusic() {
        this.app.fire('Famobi:enableMusic');
    }

    changeVolume() {
        this.app.fire('Famobi:changeVolume', this._volume);
    }

    restartGame() {
        this.app.fire('Famobi:restartGame');
    }
}

pc.registerScript(MonkeyGames, 'monkeyGames');


// FinalImageScreen.js
var FinalImageScreen = pc.createScript('finalImageScreen');

FinalImageScreen.attributes.add('background', { type: 'entity' });
FinalImageScreen.attributes.add('overlay', { type: 'entity' });
FinalImageScreen.attributes.add('picture', { type: 'entity' });

FinalImageScreen.attributes.add('image', { type: 'entity' });

FinalImageScreen.attributes.add('closeButton', { type: 'entity' });
FinalImageScreen.attributes.add('closeButtonGroup', { type: 'entity' });
FinalImageScreen.attributes.add('curve', { type: 'curve', curves: ["x", "y", "z"] });
FinalImageScreen.attributes.add('curveScale', { type: 'curve' });

FinalImageScreen.attributes.add('target', { type: 'entity' });
FinalImageScreen.attributes.add('duration', { type: 'number', default: 2 });

FinalImageScreen.attributes.add('assets', { type: 'asset', array: true });

pc.extend(FinalImageScreen.prototype, {
    initialize: function () {
        this.closeButton.script.elementInput.on('click', this.onClose, this);
        this.background.script.elementInput.on('click', this.onClick, this);

        this.cornerAngle = Math.atan(this.picture.element.height / this.picture.element.width);
        this.pictureAngle = -this.picture.getLocalEulerAngles().z * Math.PI / 180;

        this.diagonalLength = Math.sqrt(this.picture.element.width * this.picture.element.width + this.picture.element.height * this.picture.element.height)

        this.defaultWidth = this.diagonalLength * Math.cos(this.cornerAngle - this.pictureAngle);
        this.defaultHeight = this.diagonalLength * Math.sin(this.cornerAngle + this.pictureAngle);
    },

    postInitialize: function () {
        this.onResize(ViewportManager.instance.getOrientation(), ViewportManager.instance.width, ViewportManager.instance.height);
        this.app.on('ViewportManager:onResize', this.onResize, this);
    },

    update: function (dt) {
        if (!this.tweening) {
            return;
        }

        this.time += dt;

        const ratio = this.time / this.duration;

        const values = this.curve.value(ratio);
        const valueScale = this.curveScale.value(ratio);

        const targetPosition = this.target.getPosition();

        this.picture.setPosition(values[0] * targetPosition.x, values[1] * targetPosition.y, values[2] * targetPosition.z);
        this.picture.setLocalScale(valueScale * this.scale, valueScale * this.scale, valueScale * this.scale);

        if (this.time >= this.duration) {
            this.tweening = false;
            this.fire('complete');
        }
    },

    calculateWidthAndHeight() {
        this.picture.setLocalEulerAngles(0, 0, this.rotation);
        this.pictureAngle = -this.picture.getLocalEulerAngles().z * Math.PI / 180;

        this.defaultWidth = this.diagonalLength * Math.cos(this.cornerAngle - this.pictureAngle);
        this.defaultHeight = this.diagonalLength * Math.sin(this.cornerAngle + this.pictureAngle);

        this.onResize();
    },

    onResize: function (orientation, width = ViewportManager.instance.width, height = ViewportManager.instance.height) {
        const reference = UIManager.instance.getReferenceResolution();

        this.maxWidth = reference.x * width / height;
        this.maxHeight = reference.y;

        const scaleWidth = this.maxWidth / this.defaultWidth;
        const scaleHeight = this.maxHeight / this.defaultHeight;

        this.scale = Math.min(scaleWidth, scaleHeight);

        this.picture.setLocalScale(this.scale, this.scale, this.scale);
    },

    onUIEntityOpen: function (properties = {}) {
        this.fromBook = properties.fromBook;
        this.rotation = typeof properties.rotation === 'number' ? properties.rotation : -10;
        this.orientation = ViewportManager.instance.getOrientation();
        this.calculateWidthAndHeight();

        this.tweening = false;
        this.loaded = false;
        this.loadAssets();

        if (!this.fromBook) {
            this.unlockedTween();
        } else {
            this.showTween();
        }
    },

    unlockedTween() {
        this.closeButtonGroup.enabled = false;

        this.clicked = false;
        pc.timer.add(5, this.ableToSkip, this);

        this.background.element.opacity = 0;
        this.overlay.enabled = true;
        this.overlay.element.opacity = 0;
        this.picture.element.opacity = 0;
        this.image.element.opacity = 0;
        const overlayTween = this.tweenOpacity(this.overlay, 1, 1).start();
        this.picture.setLocalPosition(pc.Vec3.ZERO);

        overlayTween.on('complete', () => {
            if (this.loaded) {
                this.showPicture();
            } else {
                this.app.fire('UIManager:showUI', 'LoadingScreen');
                this.once('loaded', this.showPicture, this);
            }
        });
    },

    showTween() {
        this.overlay.element.opacity = 0;
        this.closeButtonGroup.enabled = false;
        this.background.element.opacity = 0.5;
        this.closeButtonGroup.enabled = true;
        this.closeButtonGroup.script.MoveUITween.doOpenAnimation();
        this.picture.setLocalPosition(this.orientation === orientationEnum.LANDSCAPE ? FinalImageScreen.LANDSCAPE_POSITION : FinalImageScreen.PORTRAIT_POSITION);
        this.picture.tween(this.picture.getLocalPosition())
            .to(pc.Vec3.ZERO, 1, pc.BackOut)
            .start();
    },

    hideTween() {
        this.picture.tween(this.picture.getLocalPosition())
            .to(this.orientation === orientationEnum.LANDSCAPE ? FinalImageScreen.LANDSCAPE_POSITION : FinalImageScreen.PORTRAIT_POSITION, 1, pc.BackIn)
            .start()
            .on('complete', () => {
                this.app.fire('FinalImageScreen:hidden');
                this.fire('complete');

            }, this);
    },

    showPicture: function () {
        this.picture.element.opacity = 1;
        this.image.element.opacity = 1;

        this.tweenOpacity(this.overlay, 0, 1, pc.Linear, 1)
            .start()
            .on('complete', () => this.overlay.enabled = false);

        pc.timer.add(4, () => {
            this.closeButtonGroup.enabled = true;
            this.closeButtonGroup.script.MoveUITween.doOpenAnimation();
        });
    },

    onUIEntityClose: function () {

        return new Promise(resolve => {
            this.once('complete', resolve);
        });
    },

    onUIEntityCloseFinish: function () {
        this.closing = false;

        if (!this.fromBook) {
            this.app.fire('FinalImageScreen:closed');
        }
        // this.assets.forEach(asset => asset.unload());
    },

    onClick: function () {
        if (this.clicked) {
            return;
        }

        this.clicked = true;

        this.app.fire('UIManager:hideUI', this.entity.script.uiEntity.name);
    },

    ableToSkip: function () {
        this.background.element.useInput = true;
    },

    tweenOpacity: function (entity, opacity, duration = 1, easing = pc.Linear, delay = 0) {
        return entity.tween(entity.element).to({ opacity: opacity }, duration, easing, delay)
    },

    loadAssets: function () {
        LazyLoader.instance.lazyLoadParallel(this.assets, this.onLoad, this);
    },

    onLoad: function () {
        this.loaded = true;

        this.fire('loaded');
    },

    onClose: function () {
        if (this.closing) {
            return;
        }

        this.closing = true;
        this.app.fire('UIManager:hideUI', 'finalImage');

        if (!this.fromBook) {
            this.app.fire('UIManager:showUI', 'Garden');

            this.tweening = true;
            this.time = 0;
        } else {
            this.hideTween();
        }
    },
});

FinalImageScreen.PORTRAIT_POSITION = new pc.Vec3(0, -2000, 0);
FinalImageScreen.LANDSCAPE_POSITION = new pc.Vec3(2000, 0, 0);


// dat.gui.min.js
// FinalImage.js
class FinalImage extends pc.ScriptType {
    static addAttributes() {
        this.attributes.add('image', { type: 'entity' });
    }

    initialize() {
        this.app.on('FinalImageScreen:hidden', this.showImage, this);
        this.app.on('ViewportManager:onResize', this.onResize, this);

        this.hidden = false;

        this.onResize();
        this.entity.script.elementInput.on(inputEvents.CLICK, this.onClick, this);
    }

    postInitialize() {
        this.entity.enabled = false;

        this.checkImageHasLoaded();
    }

    checkImageHasLoaded() {
        const assetId = this.image.element.spriteAsset;

        let asset = this.app.assets.get(assetId);

        if (!(asset instanceof pc.Asset)) {
            console.log("no asset found");
        }

        asset = this.app.assets.get(asset.data.textureAtlasAsset);

        asset.ready(this.popup, this);
    }

    popup() {
        this.entity.enabled = true;
        this.notReady = true;
        this.entity.setLocalPosition(this.getPosition());
        this.notReady = false;
        this.showImage();
    }

    onClick() {
        if (this.hidden) {
            return;
        }

        this.hidden = true;

        this.tween = this.entity
            .tween(this.entity.getLocalPosition())
            .to(this.getPosition(), 1, pc.BackIn)
            .start();

        this.tween.on('complete', this.onComplete, this);
    }

    showImage() {
        this.hidden = false;

        this.tween = this.entity.tween(this.entity.getLocalPosition())
            .to(this.getPosition(), 1, pc.BackOut)
            .start();

    }

    onResize(orientation = ViewportManager.instance.getOrientation(), width = ViewportManager.instance.width) {
        var yScale = UIManager.instance.getReferenceResolution().y / ViewportManager.instance.height;

        FinalImage.LANDSCAPE_TRANSFORM.hide.position.x = width * yScale / 2 + 600;
        FinalImageScreen.LANDSCAPE_POSITION.x = width * yScale / 2 + 1300;

        this.orientation = orientation;

        this.entity.setLocalPosition(this.getPosition());
        this.entity.setLocalEulerAngles(this.getRotation());

        if (this.tween) {
            this.tween.stop();
            delete this.tween;
        }
    }

    getPosition() {
        if (this.notReady) {
            switch (this.orientation) {
                case orientationEnum.LANDSCAPE:
                    return FinalImage.LANDSCAPE_TRANSFORM.popup.position;
                case orientationEnum.PORTRAIT:
                    return FinalImage.PORTRAIT_TRANSFORM.popup.position;
            }
        }

        if (this.hidden) {
            switch (this.orientation) {
                case orientationEnum.LANDSCAPE:
                    return FinalImage.LANDSCAPE_TRANSFORM.hide.position;
                case orientationEnum.PORTRAIT:
                    return FinalImage.PORTRAIT_TRANSFORM.hide.position;
            }
        } else {
            switch (this.orientation) {
                case orientationEnum.LANDSCAPE:
                    return FinalImage.LANDSCAPE_TRANSFORM.show.position;
                case orientationEnum.PORTRAIT:
                    return FinalImage.PORTRAIT_TRANSFORM.show.position;
            }
        }

        console.warn("nothing found", this.orientation, this.hidden, this.notReady)

        return pc.Vec3.ZERO;
    }

    getRotation() {
        if (this.hidden) {
            switch (this.orientation) {
                case orientationEnum.LANDSCAPE:
                    return FinalImage.LANDSCAPE_TRANSFORM.hide.rotation;
                case orientationEnum.PORTRAIT:
                    return FinalImage.PORTRAIT_TRANSFORM.hide.rotation;
            }
        } else {
            switch (this.orientation) {
                case orientationEnum.LANDSCAPE:
                    return FinalImage.LANDSCAPE_TRANSFORM.show.rotation;
                case orientationEnum.PORTRAIT:
                    return FinalImage.PORTRAIT_TRANSFORM.show.rotation;
            }
        }

        console.log("nothing found", this.orientation, this.hidden)

        return pc.Vec3.ZERO;
    }


    onComplete() {
        this.app.fire('UIManager:showUI', 'finalImage', { fromBook: true, rotation: 0 });
    }
}

pc.registerScript(FinalImage, 'finalImage');
FinalImage.addAttributes();
FinalImage.LANDSCAPE_TRANSFORM = {
    show: {
        position: new pc.Vec3(280, 0, 0),
        rotation: new pc.Vec3(0, 0, -10)
    },
    hide: {
        position: new pc.Vec3(2000, -400, 0),
        rotation: new pc.Vec3(0, 0, -10)
    },
    popup: {
        position: new pc.Vec3(80, 0, 0),
        rotation: new pc.Vec3(0, 0, -10)
    }
};

FinalImage.PORTRAIT_TRANSFORM = {
    show: {
        position: new pc.Vec3(400, 0, 0),
        rotation: new pc.Vec3(0, 0, 80)
    },
    hide: {
        position: new pc.Vec3(2000, 0, 0),
        rotation: new pc.Vec3(0, 0, 80)
    },
    popup: {
        position: new pc.Vec3(200, 0, 0),
        rotation: new pc.Vec3(0, 0, -10)
    }
};


// GameAnalytics.js
// GameAnalyticsAPI.js
// MeshInstance.js
const _tempBoneAabb = new pc.BoundingBox();
const _tmpAabb = new pc.BoundingBox();

Object.defineProperty(pc.MeshInstance.prototype, "aabb", {
    get: function () {
        // use specified world space aabb
        if (!this._updateAabb) {
            return this._aabb;
        }

        // callback function returning world space aabb
        if (this._updateAabbFunc) {
            return this._updateAabbFunc(this._aabb);
        }

        // use local space override aabb if specified
        let localAabb = this._customAabb;
        let toWorldSpace = !!localAabb;

        // otherwise evaluate local aabb
        if (!localAabb) {

            localAabb = _tmpAabb;

            if (this.skinInstance) {

                // Initialize local bone AABBs if needed
                if (!this.mesh.boneAabb) {
                    const morphTargets = this._morphInstance ? this._morphInstance.morph._targets : null;
                    this.mesh._initBoneAabbs(morphTargets);
                }

                // evaluate local space bounds based on all active bones
                const boneUsed = this.mesh.boneUsed;
                let first = true;

                for (let i = 0; i < this.mesh.boneAabb.length; i++) {
                    if (boneUsed[i]) {

                        // transform bone AABB by bone matrix
                        _tempBoneAabb.setFromTransformedAabb(this.mesh.boneAabb[i], this.skinInstance.matrices[i]);

                        // add them up
                        if (first) {
                            first = false;
                            localAabb.center.copy(_tempBoneAabb.center);
                            localAabb.halfExtents.copy(_tempBoneAabb.halfExtents);
                        } else {
                            localAabb.add(_tempBoneAabb);
                        }
                    }
                }

                toWorldSpace = true;

            } else if (this.node._aabbVer !== this._aabbVer || this.mesh && this.mesh._aabbVer !== this._aabbMeshVer) {

                // local space bounding box - either from mesh or empty
                if (this.mesh) {
                    localAabb.center.copy(this.mesh.aabb.center);
                    localAabb.halfExtents.copy(this.mesh.aabb.halfExtents);
                } else {
                    localAabb.center.set(0, 0, 0);
                    localAabb.halfExtents.set(0, 0, 0);
                }

                // update local space bounding box by morph targets
                if (this.mesh && this.mesh.morph) {
                    const morphAabb = this.mesh.morph.aabb;
                    localAabb._expand(morphAabb.getMin(), morphAabb.getMax());
                }

                toWorldSpace = true;
                this._aabbVer = this.node._aabbVer;
                this._aabbMeshVer = this.mesh._aabbVer;
            }
        }

        // store world space bounding box
        if (toWorldSpace) {
            this._aabb.setFromTransformedAabb(localAabb, this.node.getWorldTransform());
        }

        return this._aabb;

    }
});


// SoundInstance.js
pc.extend(pc.SoundInstance.prototype, {
    _onEnded() {
        // the callback is not fired synchronously
        // so only decrement _suspendEndEvent when the
        // callback is fired
        if (this._suspendEndEvent > 0) {
            this._suspendEndEvent--;
            return;
        }

        if (this.loop) {
            return;
        }

        this.fire('end');

        if (this._onEndCallback)
            this._onEndCallback(this);

        this.stop();
    }
})

